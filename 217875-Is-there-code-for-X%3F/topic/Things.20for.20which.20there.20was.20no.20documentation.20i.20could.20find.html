---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html">Things for which there was no documentation i could find</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="257203859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257203859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257203859">(Oct 12 2021 at 13:38)</a>:</h4>
<p>I was trying to write a program in the latest version of lean 3, and here are certain things I couldn’t find documentation for, causing a bunch of errors.<br>
-creating and casting vectors as lists<br>
-casting option a’s as a‘s<br>
-inhabiting a predicate as the input to a function, such as list.nth_le, that calls for it<br>
-taking apart ordered pairs<br>
-using list.foldr<br>
-syntax for lambdas giving something of type a -&gt; b rather than \Pi (x:a) : b<br>
-syntax for let expressions<br>
-syntax for quantifiers<br>
-a function to do the same thing to a list of lists each the same length as is done to a matrix when it is transposed<br>
-a higher order function to apply a given function an arbitrary number of times<br>
-syntax for declaring refinement types and creating elements thereof<br>
-expressing and proving worst case asymptotic runtimes for a program written in the purely functional language, according to the tm2 model(this is part of my ultimate goal)</p>



<a name="257205653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257205653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257205653">(Oct 12 2021 at 13:49)</a>:</h4>
<blockquote>
<p>-creating and casting vectors as lists</p>
</blockquote>
<p>Create a vector with <a href="https://leanprover-community.github.io/mathlib_docs/find/vector.nil">docs#vector.nil</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/vector.cons">docs#vector.cons</a>, convert it to a list with <code>vec.1</code></p>
<blockquote>
<p>-casting option a’s as a‘s</p>
</blockquote>
<p>Can't do it, that's unsound. But <a href="https://leanprover-community.github.io/mathlib_docs/find/option.get">docs#option.get</a> will get the value if it is not none, and <a href="https://leanprover-community.github.io/mathlib_docs/find/option.iget">docs#option.iget</a> will get the value or a default value of the type</p>
<blockquote>
<p>-inhabiting a predicate as the input to a function, such as list.nth_le, that calls for it</p>
</blockquote>
<p>The easiest way is <code>dec_trivial</code>, although it doesn't always apply. In general, well it's a proof goal</p>
<blockquote>
<p>-taking apart ordered pairs</p>
</blockquote>
<p>You can use <code>let (a, b) := pair in ...</code> or <code>pair.1</code> and <code>pair.2</code> (which are short for <a href="https://leanprover-community.github.io/mathlib_docs/find/prod.fst">docs#prod.fst</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/prod.snd">docs#prod.snd</a>)</p>
<blockquote>
<p>-using list.foldr</p>
</blockquote>
<p>It folds a function from right to left, i.e. <code>foldr f z [1, 2, 3] = f 1 (f 2 (f 3 z))</code></p>
<blockquote>
<p>-syntax for lambdas giving something of type a -&gt; b rather than \Pi (x:a) : b</p>
</blockquote>
<p><code>a -&gt; b</code> is the same as <code>\Pi (x:a) : b</code>, and there is only one lambda</p>
<blockquote>
<p>-syntax for let expressions</p>
</blockquote>
<p><code>let x : type := value in expr</code></p>
<blockquote>
<p>-syntax for quantifiers</p>
</blockquote>
<p><code>\forall x : type, prop</code>, <code>\exists x : type, prop</code></p>
<blockquote>
<p>-a function to do the same thing to a list of lists each the same length as is done to a matrix when it is transposed</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.transpose">docs#list.transpose</a></p>
<blockquote>
<p>-a higher order function to apply a given function an arbitrary number of times</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/nat.iterate">docs#nat.iterate</a></p>
<blockquote>
<p>-syntax for declaring refinement types and creating elements thereof</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/subtype">docs#subtype</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype.mk">docs#subtype.mk</a>. The syntax is <code>{x // p x}</code> for the type, <code>⟨x, h⟩</code> for creating an element of the type, and <code>p.1</code> and <code>p.2</code> for extracting the components</p>
<blockquote>
<p>-expressing and proving worst case asymptotic runtimes for a program written in the purely functional language, according to the tm2 model(this is part of my ultimate goal)</p>
</blockquote>
<p>It's not possible to prove runtime bounds on programs written in pure lean, because runtime is not preserved by lean equality. But for functions which are deeply embedded i.e. in the TM2 model it is possible. Unfortunately the infrastructure isn't there yet</p>



<a name="257224306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257224306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257224306">(Oct 12 2021 at 15:44)</a>:</h4>
<p>dec_trivial isn’t working.<br>
 vec.l isn’t working. <br>
Prod.and and <a href="http://prod.fast">prod.fast</a> works in some places, but where it doesn’t, neither does pair.1 and pair.2 . <br>
I have a universal quantifier that looks like as follows, where apparently d is an unknown identifier:<br>
\forall a, b, c, d : \nat, &lt;pred&gt; <br>
Is it in fact valid to use the \in symbol to check for the presence of a given value in a list?<br>
Is there a function to find where it is afterward?<br>
When using foldr, and the function I’m using is &amp;&amp; or +(nat), how do i do that?<br>
And, in some places lean seems to expect a (Type: Type 1) rather than an element of the type i thought it should. Why?</p>



<a name="257227797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257227797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257227797">(Oct 12 2021 at 16:04)</a>:</h4>
<p>*thats prod.snd and prod.fst</p>



<a name="257228808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257228808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257228808">(Oct 12 2021 at 16:11)</a>:</h4>
<p>It's hard to help you without seeing your code. Would you mind providing a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="257228933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257228933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257228933">(Oct 12 2021 at 16:12)</a>:</h4>
<p>I think that instead of asking 100 questions it might be easier to ask fewer questions and back them all up with a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> . Nobody can debug "dec_trivial isn't working" with no further information -- it works for me</p>



<a name="257230802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257230802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257230802">(Oct 12 2021 at 16:23)</a>:</h4>
<p>this is the nearly first 250 of nearly 500  lines i have written. not sure if it counts as an mwe, for it doesnt in fact work. the rest in the next comment:</p>
<p>import data.list<br>
import data.vector.basic<br>
import <a href="http://data.prod">data.prod</a><br>
open classical</p>
<p>variables a b c: Type</p>
<p>structure bitnode := <br>
  mk :: (value : bool)<br>
  (indices : list (ℕ × ℕ)) --these pointers indicate what it is connected to<br>
  (isconstant : bool)<br>
  (considered : bool)</p>
<p>structure gatenode :=<br>
  mk :: (valence : ℕ)<br>
  (possib : list ( vector bool valence))--i dont know how to create vectors or cast them as lists<br>
  (state : bool × (vector (bool) valence)) --the fst of this indicates that the front of consideration has passed the node<br>
  (indices : vector ℕ valence)</p>
<p>def reversible (a : gatenode) : Prop :=<br>
  (∀ b c d : ℕ, (b &lt; a.possib.length → c &lt; a.possib.length → d &lt; a.valence<br>
    → (<br>
          --the entry is fully determined by all but one bit. represented in haskell like so:<br>
      --(<br>
                --remove_nth <br>
                --((a.possib))!!b  d<br>
                --== <br>
                --remove_nth<br>
                --( (a.possib))!!c  d<br>
            --)<br>
            --&lt;-&gt;<br>
            (<br>
                (((a.possib))!!b)!!d<br>
                == <br>
                ((a.possib))!!c)!!d<br>
            )<br>
      )</p>
<div class="codehilite"><pre><span></span><code>)
</code></pre></div>

<p>)<br>
  )<br>
--the types of gates: not, and 3-unique, which is complete<br>
----an AND gate can be constructed as follows:<br>
            -- bits 1-8. inputs to bit 3,7. output bit 5. 3unique(1,2,3), 3unique(4,5,6), NOT(7,8), 3unique(1,4,7), 3unique(2,5,8), NOT(3,6)<br>
            -- the OR gate can be constructed the same way, with the output put through a NOT, and the inputs at 6,8.<br>
            --therefore 3-unique is functionally complete.<br>
def mknot (c: vector ℕ 2) : gatenode :=<br>
  {valence := 2, possib := [vector.cons ff (vector.cons tt vector.nil),vector.cons tt (vector.cons ff vector.nil)],<br>
  state := (ff,vector.cons ff (vector.cons tt vector.nil)), indices := c}</p>
<p>def mk3unique (c: vector ℕ 3) : gatenode :=<br>
{valence := 3, possib := [vector.cons ff(vector.cons ff (vector.cons tt vector.nil)),<br>
vector.cons ff(vector.cons tt(vector.cons ff vector.nil)),<br>
vector.cons tt(vector.cons ff(vector.cons ff vector.nil))],<br>
  state := (ff,(vector.cons ff(vector.cons ff(vector.cons tt vector.nil)))), indices := c}</p>
<p>structure satnet :=  --i use an undirected graph representation of a sat instance, <br>
                     --implemented as lists with indices as pointers<br>
mk:: (bts : list bitnode)(gts : list gatenode)<br>
(nextbits : list ℕ)(nextgates : list ℕ)(table : list ℕ × list (list bool))<br>
(tablesequence: list (list ℕ × list (list bool)))</p>
<p>--all indices must be within range.<br>
--the corresponding function is implemented in haskell like so:</p>
<p>--vetnet :: satnet -&gt; bool<br>
--vetnet a =  <br>
    --fold &amp;&amp; map (\x-&gt;(fold &amp;&amp; map (\y-&gt;(bts a !!(indices((gts a) !! (fst y))!! (snd y))== y))(indices x))) (bts a) <br>
    --&amp;&amp; <br>
    --fold &amp;&amp; map (\x-&gt;(fold &amp;&amp; map (\y-&gt;(fold || map (\z-&gt;(((gts a)!! (fst z)) == x &amp;&amp; (indices((gts b)!! (fst z))!! <br>
  --(snd z))== y)) (indices y)!! y )) indices x))(gts a)  </p>
<p>def solv1 (s : satnet) :satnet := --start by, if possible, considering the bits that are constant<br>
let cond:Prop := (--should be a true prop if there are no nodes satisfying the lambda expression<br>
    list.length <br>
    (<br>
      list.filter <br>
      (λx,(<br>
         ((bitnode.isconstant x) = tt)<br>
      ))<br>
      s.bts<br>
    ) = 0<br>
  ) ,<br>
  set:list ℕ  := <a href="http://list.map">list.map</a> prod.fst  <br>
  (list.filter                      <br>
  (<br>
    (λx,( <br>
       ((bitnode.isconstant x) = tt) <br>
    )) ∘ prod.snd<br>
  ) <br>
  (<br>
    list.zip <br>
    (<br>
      list.range <br>
      (<br>
        list.length s.bts<br>
      )<br>
    )<br>
    s.bts<br>
  )) in<br>
{bts := s.bts,<br>
gts := s.gts,<br>
  nextbits := <br>
  if cond <br>
  then [0] <br>
  else set,<br>
  nextgates := s.nextgates,<br>
  table := s.table, <br>
  tablesequence:= []<br>
  }</p>
<p>def solv2 (s: satnet) : satnet := --get the first gate and table on the list<br>
let set:list ℕ := list.erase_dup  --actually leaves in the last copy of the set of duplicates, but is nonetheless consistent<br>
  ( <a href="http://list.map">list.map</a><br>
    (<br>
      list.foldr <br>
      (<br>
        list.append <br>
        (<br>
<a href="http://list.map">list.map</a> prod.fst ∘ bitnode.indices <br>
          (<br>
            list.filter (λx,( ¬ (bitnode.considered x) = tt))<br>
            (<br>
<a href="http://list.map">list.map</a> <br>
              (λx,(<br>
                list.nth_le s.bts x (dec_trivial)<br>
              ))<br>
              s.nextbits<br>
            )<br>
          )<br>
        )<br>
      )<br>
    )<br>
  )<br>
  in<br>
{ bts := s.bts, <br>
gts := s.gts, <br>
nextbits := s.nextbits, <br>
nextgates:= <br>
  if list.length s.nextgates = 0 then if list.length set = 0 then [0] else [list.head set] else s.nextgates,<br>
  table := if list.length s.nextgates = 0 then if list.length set = 0 then <br>
   (vec.l gatenode.indices (list.nth_le  s.gts (list.head set) dec_trivial ),<br>
<a href="http://list.map">list.map</a> vec.l (gatenode.possib (list.nth_le s.gts (list.head set) dec_trivial) ))<br>
  else (vec.l gatenode.indices (list.nth_le s.gts (list.head set) dec_trivial),<br>
<a href="http://list.map">list.map</a> vec.l (gatenode.possib (list.nth_le s.gts (list.head set) dec_trivial))) else s.table,</p>
<p>tablesequence := if list.length s.nextgates = 0 <br>
  then if list.length set = 0 <br>
  then [(vec.l (gatenode.indices (list.head s.gts)), <a href="http://list.map">list.map</a> vec.l (gatenode.possib (list.head s.gts)))] <br>
  else [(vec.l (gatenode.indices (list.nth_le s.gts (list.head set) dec_trivial)),<br>
<a href="http://list.map">list.map</a> vec.l (gatenode.possib (list.nth_le s.gts (list.head set) dec_trivial)))] <br>
  else s.tablesequence<br>
}</p>
<p>def solv3 (s:satnet) : satnet :=  --remove those bits that the front of consideration has passed from nextbits<br>
{<br>
  bts := s.bts, gts := s.gts, nextbits := <br>
  list.filter <br>
  (λy,(<br>
     ((<br>
      list.foldr <br>
      (λz,λw,(z &amp;&amp; w))<br>
      (<a href="http://list.map">list.map</a> <br>
        (λx:ℕ,(<br>
          pair.1  --im not sure what im doing wrong when it comes to taking ordered pairs apart,<br>
                    -- as that seems to be the source of most of the errors in the file0<br>
          gatenode.state <br>
          (list.nth<br>
          s.gts<br>
          x<br>
        ))<br>
          (<br>
<a href="http://list.map">list.map</a> <br>
            prod.fst <br>
            (<br>
              bitnode.indices <br>
              y<br>
            )<br>
          ) = tt<br>
        )<br>
      )<br>
    ))<br>
  ))<br>
  (list.erase_dup<br>
  (<br>
    list.foldr <br>
    (<br>
      list.append <br>
      (<br>
<a href="http://list.map">list.map</a> (λx:gatenode,(vec.l gatenode.indices x)) <br>
        (<br>
          list.filter <br>
          (λx,( ¬ (<br>
            prod.fst (gatenode.state x)<br>
          ) = tt)) <br>
          (<br>
<a href="http://list.map">list.map</a> --how to turn an option a to an a?<br>
            (λx,(<br>
              list.nth_le s.gts x dec_trivial<br>
            ))<br>
            s.nextbits<br>
          )<br>
        )<br>
      )<br>
    )<br>
  ))<br>
  , nextgates := s.nextgates,<br>
  table := s.table,<br>
  tablesequence := s.tablesequence<br>
}</p>
<p>def size (l: list (list a)) : ℕ :=<br>
 (list.foldr (λx,λy,(nat.add x y)) (<a href="http://list.map">list.map</a> list.length l)) </p>
<p>def tables (s:satnet)(g: ℕ ) : list ℕ × list (list bool) :=  --make a table listing all the ways that nextbits could be, <br>
                                                              --given the last table in s.tablesequence and the gate at index g<br>
let set: list ℕ  := <br>
list.erase_dup (list.append s.nextbits (vec.l gatenode.indices (list.nth_le s.gts g dec_trivial)) <br>
in <br>
  (set,(<br>
    --implement like so:<br>
    --intersect set with that of nth tablesequence length - 1<br>
    let <br>
    --the states that are compatible<br>
    subset : list list bool := <br>
    list.filter (λx,(        --why is d unknown?<br>
      ∀ a, b, c, d : ℕ, a &lt; (list.length s.bts) → b &lt; gatenode.valence (list.nth_le s.gts g dec_trivial) → c &lt; list.length prod.fst <br>
        (list.nth s.tablesequence (nat.sub (list.length s.tablesequence) 1))<br>
         → list.nth_le (gatenode.indices list.nth s.gts) b dec_trivial =  list.nth_le (prod.fst <br>
         (list.nth_le s.tablesequence (nat.sub (list.length s.tablesequence) 1) dec_trivial)) c dec_trivial<br>
         → d &lt; list.length (prod.snd <br>
         (list.nth_le s.tablesequence (nat.sub (list.length s.tablesequence) 1) dec_trivial)) <br>
         → ¬ list.nth_le (list.nth_le (prod.snd <br>
         (list.nth s.tablesequence (nat.sub (list.length s.tablesequence) 1))) c dec_trivial) d dec_trivial = vector.nth_le x b dec_trivial<br>
        )</p>



<a name="257230983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257230983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257230983">(Oct 12 2021 at 16:24)</a>:</h4>
<div class="codehilite"><pre><span></span><code>
</code></pre></div>

<p>and here is the rest:</p>
<p>) (gatenode.possib (list.nth s.gts g)),<br>
    expset : list list bool := list.foldr λz,(list.concat z) (<a href="http://list.map">list.map</a> λx,( <a href="http://list.map">list.map</a> λy,(list.append x y))  <br>
    (prod.snd (list.nth s.tablesequence (nat.sub (list.length s.tablesequence) 1))) (subset))<br>
    in list.erase_dup (<br>
      list.transpose --by transpose, i mean like matrix transposition<br>
      (<br>
<a href="http://list.map">list.map</a> prod.snd <br>
        (<br>
          list.erase_dup <br>
          ( list.filter (λx,( (list.fst x ∈ (set))))<br>
            list.zip <br>
            ( list.append<br>
              prod.fst <br>
              (<br>
                list.nth s.tablesequence <br>
                (<br>
                  nat.sub <br>
                  (<br>
                    list.length s.tablesequence<br>
                  ) <br>
                  1<br>
                )<br>
              ) <br>
              (gatenode.indices (list.nth s.gts g))<br>
            ) <br>
            list.transpose <br>
            (<br>
              list.erase_dup expset<br>
            )<br>
          )<br>
        )<br>
      )<br>
    )<br>
  ))</p>
<p>def solv4 (s:satnet) : satnet := --construct the smallest table for any choice in how the front of consideration is to advance<br>
{bts := s.bts,<br>
 gts := s.gts,<br>
 nextbits := s.nextbits,<br>
  nextgates := list.concat <br>
  s.nextgates <br>
  (<br>
    list.argmin <br>
    (<br>
     size (prod.snd<br>
      (λx,(tables s x)))<br>
    ) <br>
    (<br>
      list.filter <br>
      (λx,(¬ ((prod.fst (gatenode.state (list.nth_le s.gts x dec_trivial))= tt) ∨  x ∈ s.nextgates))) <br>
      (list.range (list.length s.gts))<br>
    )<br>
  ),                                      <br>
   table := list.argmin λx,(size (prod.snd x)) (<a href="http://list.map">list.map</a> (λx,(tables s x)) (list.range (list.length s.gts))), <br>
  --the one thing i'm not sure on, <br>
  --the maximum number of entries in this table, if im correct,<br>
  -- grows no faster than the number of gates <br>
  --sketch:<br>
  --initially, the front of consideration is fully determined until it reaches the edge of a bubble<br>
  -- a bubble is here defined as a subset of the satnet s where determination on the outside has no bearing on the inside, though not necessarily vice versa<br>
  --the edge of a bubble is formed by one ore more cycles of gates connected to bits on the inside, and each one has a single line outwards<br>
  --for each cycle, there are at most two distinct states the whole cycle can be in<br>
  -- the most efficient traversal through that is to consider the consequences of one cycle at a time, <br>
  --as that keeps the number of entries below some constant<br>
  --it will take an automated proof search to prove that this is always possible</p>
<p>--though i do know that it is definitely subexponential,<br>
  -- at most 2^(sqrt(n))<br>
  --sketch:<br>
  --the width of the front of consideration grows linearly and then shrinks linearly<br>
  -- from one gate to its maximum than back down to just one again<br>
  --for the maximum to be the absolute worst case, the system must approximate a square with the disjoint subsets that the front passes through in layers<br>
  --the maximum width then is sqrt(2n)<br>
  --the maximum number of states that can take on is O(2^(sqrt(2n)))<br>
  --qed, therefore the exponential time hypothesis is false<br>
  tablesequence := s.tablesequence<br>
}</p>
<p>def solv5 (s:satnet) : satnet :=   --place the new table in the squence<br>
{bts := s.bts, <br>
gts := s.gts, <br>
nextbits := s.nextbits,<br>
nextgates := s.nextgates,<br>
table := s.table,<br>
tablesequence := list.concat s.tablesequence s.table<br>
}</p>
<p>--say that the bitnodes and gatenodes that the front of consideration has passed are considered<br>
def reconsider (s:satnet)(b:ℕ ) : bitnode :=<br>
  {<br>
    value := bitnode.value (list.nth_le s.bts b dec_trivial),<br>
    indices := bitnode.indices (list.nth_le s.bts b dec_trivial),<br>
    isconstant := bitnode.isconstant (list.nth_le s.bts b dec_trivial),<br>
    considered := <br>
    if <br>
    list.foldr <br>
    (λz,λw,(z &amp;&amp; w)) <br>
    (<a href="http://list.map">list.map</a> <br>
    (λx,(<br>
     prod.fst x ∈ s.nextgates <br>
    )) <br>
    (<br>
      bitnode.indices <br>
      (list.nth_le s.bts b dec_trivial)<br>
    ) )<br>
    then <br>
    tt <br>
    else <br>
    bitnode.considered <br>
    (list.nth_le s.bts b dec_trivial)<br>
  }</p>
<p>def solv6 (s:satnet) : satnet := <br>
{bts := <a href="http://list.map">list.map</a> (λx,(reconsider s x)) (list.range (list.length s.bts)),<br>
gts := s.gts,<br>
nextbits := s.nextbits,<br>
nextgates := s.nextgates,<br>
table := s.table,<br>
tablesequence := s.tablesequence<br>
}</p>
<p>def greconsider (s:satnet)(g:ℕ )(c:bool) : gatenode :=<br>
{valence := gatenode.valence (list.nth_le s.gts g dec_trivial),<br>
possib := gatenode.possib (list.nth_le s.gts g dec_trivial),<br>
indices := gatenode.indices (list.nth_le s.gts g dec_trivial),<br>
state := <br>
(<br>
  (<br>
    if <br>
    c <br>
    then <br>
    tt <br>
    else <br>
    (<br>
      prod.fst <br>
      (gatenode.state (list.nth_le s.gts g dec_trivial))<br>
    )<br>
  ), <br>
  (<br>
    prod.snd <br>
    (gatenode.state (list.nth_le s.gts g dec_trivial))<br>
  )<br>
)<br>
}</p>
<p>def solv7 (s:satnet) : satnet :=<br>
let set:list ℕ  := list.filter<br>
(λy,(<br>
  ((<br>
    list.foldr <br>
    (λz,λw,(z &amp;&amp; w)) <br>
    (<a href="http://list.map">list.map</a><br>
      (λx,(<br>
        bitnode.considered x<br>
      ) = tt) <br>
      (vec.l (gatenode.indices (list.nth_le s.gts y dec_trivial)))<br>
    )<br>
  ) )<br>
))<br>
(<br>
  list.range<br>
  (list.length s.gts)<br>
)<br>
in<br>
{bts := s.bts, <br>
gts := <a href="http://list.map">list.map</a> (λx,(greconsider s x (x ∈ set))) (list.range (list.length s.gts))<br>
,nextbits := s.nextbits,<br>
nextgates := list.filter (λx,(¬ (x ∈ set))) s.nextgates,<br>
table := s.table,<br>
tablesequence := s.tablesequence<br>
}</p>
<p>def solvcycle : satnet -&gt; satnet := --the cycle starts in solv3.<br>
 solv7 ∘ solv6 ∘ solv5 ∘ solv4 ∘ solv3 </p>
<p>def solvcert (s:satnet ): satnet := --this is the information required to 'certify' satisfiability without a witness<br>
(nat.iterate  solvcycle (nat.sub (list.length s.gts) 1)) ((solv2 ∘ solv1) s)</p>
<p>def solvdecide (s:satnet): bool := list.length (prod.snd (satnet.table (solvcert s))) &gt; 0  --this 'solves the decision problem'</p>
<p>def solvretract1 (s:satnet) : satnet :=    --pick an entry, possibly random, in the last table and commit to it<br>
-- choose a nat in 0..length (snd (last table), maybe randomly<br>
let choicen : ℕ :=<br>
random  (0, list.length prod.snd s.table)<br>
in<br>
{bts :=<br>
--set the value of each bitnode to that in the entry corresponding to the number previously chosen<br>
<a href="http://list.map">list.map</a> <br>
(λx:ℕ,<br>
{value := if x ∈ prod.fst s.table <br>
then list.nth_le (list.nth_le (prod.snd s.table) choicen dec_trivial) (list.indexof x (prod.fst s.table)) dec_trivial --surely there is a function that does this<br>
else bitnode.value (list.nth_le s.bts x dec_trivial),<br>
indices := bitnode.indices (list.nth_le s.bts x dec_trivial),<br>
isconstant:= bitnode.isconstant (list.nth_le s.bts x dec_trivial),<br>
considered := bitnode.considered (list.nth_le s.bts x dec_trivial)}) <br>
(list.range (list.length s.bts)),</p>
<p>gts := --same here<br>
 --placeholder<br>
 s.gts<br>
-- if all the bits connected to a gate are in the last table then set the state to the values in the table entry</p>
<p>,<br>
nextbits := s.nextbits, nextgates := s.nextgates,<br>
table := (prod.fst s.table, list.nth_le (pair.2 s.table) choicen dec_trivial),<br>
tablesequence := s.tablesequence<br>
}</p>
<p>def solvretract2 (s:satnet ) : satnet :=  -- remove the entries incompatible with the table from which we are puuling back<br>
{bts := s.bts,<br>
gts := s.gts,<br>
nextbits := s.nextbits,<br>
nextgates := s.nextgates,<br>
table := s.table,<br>
tablesequence := <br>
  (<br>
    list.concat <br>
    (list.remove_nth (s.tablesequence) <br>
    ( nat.sub (list.length (s.tablesequence)) 1)),<br>
    list.filter<br>
    (<br>
      λx,(<br>
         (<br>
          ∀ b, c, d : ℕ , <br>
          b &lt; list.length (prod.fst s.table) <br>
          → c &lt; list.length x<br>
          →  list.nth x c = d<br>
          → list.nth_le (prod.fst s.table) b dec_trivial = d <br>
          → list.nth_le (prod.snd s.table) b dec_trivial = list.nth_le x c dec_trivial<br>
        )<br>
      )<br>
    ) <br>
    (list.nth_le s.tablesequence (nat.sub (list.length s.tablesequence) 1) dec_trivial)<br>
  )<br>
}</p>
<p>def solvretract3 (s:satnet) : satnet := --pop the last table in the sequence off<br>
{bts := s.bts,<br>
gts := s.gts,<br>
nextbits := s.nextbits,<br>
nextgates := s.nextgates,<br>
table := list.nth_le s.tablesequence ( nat.sub (list.length s.tablesequence) 1) dec_trivial,<br>
tablesequence := list.remove_nth s.tablesequence (nat.sub (list.length s.tablesequence) 1)}</p>
<p>def solvwitness (s:satnet): satnet := --this solves the 'function problem'<br>
(nat.iterate (λx,(solvretract3 (solvretract2 ( solvretract1 x))))(list.length s.gts) ) ((solvcert) s)</p>



<a name="257231336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257231336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257231336">(Oct 12 2021 at 16:27)</a>:</h4>
<p>Use <a href="https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks">#backticks</a> so that the formatting will be preserved (you can edit your messages).</p>



<a name="257232857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257232857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257232857">(Oct 12 2021 at 16:36)</a>:</h4>
<p>trying it again:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list</span>
<span class="kn">import</span> <span class="n">data.vector.basic</span>
<span class="kn">import</span> <span class="n">data.prod</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span><span class="o">:</span> <span class="kt">Type</span>



<span class="kd">structure</span> <span class="n">bitnode</span> <span class="o">:=</span>
  <span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
  <span class="o">(</span><span class="n">indices</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">))</span> <span class="c1">--these pointers indicate what it is connected to</span>
  <span class="o">(</span><span class="n">isconstant</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
  <span class="o">(</span><span class="n">considered</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">gatenode</span> <span class="o">:=</span>
  <span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">valence</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">possib</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span> <span class="n">vector</span> <span class="n">bool</span> <span class="n">valence</span><span class="o">))</span>
  <span class="o">(</span><span class="n">state</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">×</span> <span class="o">(</span><span class="n">vector</span> <span class="o">(</span><span class="n">bool</span><span class="o">)</span> <span class="n">valence</span><span class="o">))</span> <span class="c1">--the fst of this indicates that the front of consideration has passed the node</span>
  <span class="o">(</span><span class="n">indices</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">ℕ</span> <span class="n">valence</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">reversible</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">gatenode</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a.possib.length</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">a.possib.length</span> <span class="bp">→</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="n">a.valence</span>
    <span class="bp">→</span> <span class="o">(</span>
          <span class="c1">--the entry is fully determined by all but one bit. represented in haskell like so:</span>
      <span class="c1">--(</span>
                <span class="c1">--remove_nth</span>
                <span class="c1">--((a.possib))!!b  d</span>
                <span class="c1">--==</span>
                <span class="c1">--remove_nth</span>
                <span class="c1">--( (a.possib))!!c  d</span>
            <span class="c1">--)</span>
            <span class="c1">--&lt;-&gt;</span>
            <span class="o">(</span>
                <span class="o">(((</span><span class="n">a.possib</span><span class="o">))</span><span class="bp">!!</span><span class="n">b</span><span class="o">)</span><span class="bp">!!</span><span class="n">d</span>
                <span class="bp">==</span>
                <span class="o">((</span><span class="n">a.possib</span><span class="o">))</span><span class="bp">!!</span><span class="n">c</span><span class="o">)</span><span class="bp">!!</span><span class="n">d</span>
            <span class="o">)</span>
      <span class="o">)</span>

    <span class="o">)</span>
   <span class="o">)</span>
  <span class="o">)</span>
<span class="c1">--the types of gates: not, and 3-unique, which is complete</span>
<span class="c1">----an AND gate can be constructed as follows:</span>
            <span class="c1">-- bits 1-8. inputs to bit 3,7. output bit 5. 3unique(1,2,3), 3unique(4,5,6), NOT(7,8), 3unique(1,4,7), 3unique(2,5,8), NOT(3,6)</span>
            <span class="c1">-- the OR gate can be constructed the same way, with the output put through a NOT, and the inputs at 6,8.</span>
            <span class="c1">--therefore 3-unique is functionally complete.</span>
<span class="kd">def</span> <span class="n">mknot</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="n">vector</span> <span class="n">ℕ</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">gatenode</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">valence</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">possib</span> <span class="o">:=</span> <span class="o">[</span><span class="n">vector.cons</span> <span class="n">ff</span> <span class="o">(</span><span class="n">vector.cons</span> <span class="n">tt</span> <span class="n">vector.nil</span><span class="o">),</span><span class="n">vector.cons</span> <span class="n">tt</span> <span class="o">(</span><span class="n">vector.cons</span> <span class="n">ff</span> <span class="n">vector.nil</span><span class="o">)],</span>
  <span class="n">state</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span><span class="n">vector.cons</span> <span class="n">ff</span> <span class="o">(</span><span class="n">vector.cons</span> <span class="n">tt</span> <span class="n">vector.nil</span><span class="o">)),</span> <span class="n">indices</span> <span class="o">:=</span> <span class="n">c</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">mk3unique</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="n">vector</span> <span class="n">ℕ</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:</span> <span class="n">gatenode</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">valence</span> <span class="o">:=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">possib</span> <span class="o">:=</span> <span class="o">[</span><span class="n">vector.cons</span> <span class="n">ff</span><span class="o">(</span><span class="n">vector.cons</span> <span class="n">ff</span> <span class="o">(</span><span class="n">vector.cons</span> <span class="n">tt</span> <span class="n">vector.nil</span><span class="o">)),</span>
<span class="n">vector.cons</span> <span class="n">ff</span><span class="o">(</span><span class="n">vector.cons</span> <span class="n">tt</span><span class="o">(</span><span class="n">vector.cons</span> <span class="n">ff</span> <span class="n">vector.nil</span><span class="o">)),</span>
<span class="n">vector.cons</span> <span class="n">tt</span><span class="o">(</span><span class="n">vector.cons</span> <span class="n">ff</span><span class="o">(</span><span class="n">vector.cons</span> <span class="n">ff</span> <span class="n">vector.nil</span><span class="o">))],</span>
  <span class="n">state</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ff</span><span class="o">,(</span><span class="n">vector.cons</span> <span class="n">ff</span><span class="o">(</span><span class="n">vector.cons</span> <span class="n">ff</span><span class="o">(</span><span class="n">vector.cons</span> <span class="n">tt</span> <span class="n">vector.nil</span><span class="o">)))),</span> <span class="n">indices</span> <span class="o">:=</span> <span class="n">c</span><span class="o">}</span>

<span class="kd">structure</span> <span class="n">satnet</span> <span class="o">:=</span>  <span class="c1">--i use an undirected graph representation of a sat instance,</span>
                     <span class="c1">--implemented as lists with indices as pointers</span>
<span class="n">mk</span><span class="o">::</span> <span class="o">(</span><span class="n">bts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bitnode</span><span class="o">)(</span><span class="n">gts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">gatenode</span><span class="o">)</span>
<span class="o">(</span><span class="n">nextbits</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)(</span><span class="n">nextgates</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)(</span><span class="n">table</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">))</span>
<span class="o">(</span><span class="n">tablesequence</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)))</span>

<span class="c1">--all indices must be within range.</span>
<span class="c1">--the corresponding function is implemented in haskell like so:</span>

<span class="c1">--vetnet :: satnet -&gt; bool</span>
<span class="c1">--vetnet a =</span>
    <span class="c1">--fold &amp;&amp; map (\x-&gt;(fold &amp;&amp; map (\y-&gt;(bts a !!(indices((gts a) !! (fst y))!! (snd y))== y))(indices x))) (bts a)</span>
    <span class="c1">--&amp;&amp;</span>
    <span class="c1">--fold &amp;&amp; map (\x-&gt;(fold &amp;&amp; map (\y-&gt;(fold || map (\z-&gt;(((gts a)!! (fst z)) == x &amp;&amp; (indices((gts b)!! (fst z))!!</span>
  <span class="c1">--(snd z))== y)) (indices y)!! y )) indices x))(gts a)</span>


<span class="kd">def</span> <span class="n">solv1</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">satnet</span><span class="o">)</span> <span class="o">:</span><span class="n">satnet</span> <span class="o">:=</span> <span class="c1">--start by, if possible, considering the bits that are constant</span>
<span class="k">let</span> <span class="n">cond</span><span class="o">:</span><span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span>
    <span class="n">list.length</span>
    <span class="o">(</span>
      <span class="n">list.filter</span>
      <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span>
         <span class="o">((</span><span class="n">bitnode.isconstant</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">)</span>
      <span class="o">))</span>
      <span class="n">s.bts</span>
    <span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span>
  <span class="o">)</span> <span class="o">,</span>
  <span class="n">set</span><span class="o">:</span><span class="n">list</span> <span class="n">ℕ</span>  <span class="o">:=</span> <span class="n">list.map</span> <span class="n">prod.fst</span>
  <span class="o">(</span><span class="n">list.filter</span>
  <span class="o">(</span>
    <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span>
       <span class="o">((</span><span class="n">bitnode.isconstant</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">)</span>
    <span class="o">))</span> <span class="bp">∘</span> <span class="n">prod.snd</span>
  <span class="o">)</span>
  <span class="o">(</span>
    <span class="n">list.zip</span>
    <span class="o">(</span>
      <span class="n">list.range</span>
      <span class="o">(</span>
        <span class="n">list.length</span> <span class="n">s.bts</span>
      <span class="o">)</span>
    <span class="o">)</span>
    <span class="n">s.bts</span>
  <span class="o">))</span> <span class="k">in</span>
<span class="o">{</span><span class="n">bts</span> <span class="o">:=</span> <span class="n">s.bts</span><span class="o">,</span>
<span class="n">gts</span> <span class="o">:=</span> <span class="n">s.gts</span><span class="o">,</span>
  <span class="n">nextbits</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">cond</span>
  <span class="k">then</span> <span class="o">[</span><span class="mi">0</span><span class="o">]</span>
  <span class="k">else</span> <span class="n">set</span><span class="o">,</span>
  <span class="n">nextgates</span> <span class="o">:=</span> <span class="n">s.nextgates</span><span class="o">,</span>
  <span class="n">table</span> <span class="o">:=</span> <span class="n">s.table</span><span class="o">,</span>
  <span class="n">tablesequence</span><span class="o">:=</span> <span class="o">[]</span>
  <span class="o">}</span>

<span class="kd">def</span> <span class="n">solv2</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">satnet</span><span class="o">)</span> <span class="o">:</span> <span class="n">satnet</span> <span class="o">:=</span> <span class="c1">--get the first gate and table on the list</span>
<span class="k">let</span> <span class="n">set</span><span class="o">:</span><span class="n">list</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">list.erase_dup</span>  <span class="c1">--actually leaves in the last copy of the set of duplicates, but is nonetheless consistent</span>
  <span class="o">(</span> <span class="n">list.map</span>
    <span class="o">(</span>
      <span class="n">list.foldr</span>
      <span class="o">(</span>
        <span class="n">list.append</span>
        <span class="o">(</span>
          <span class="n">list.map</span> <span class="n">prod.fst</span> <span class="bp">∘</span> <span class="n">bitnode.indices</span>
          <span class="o">(</span>
            <span class="n">list.filter</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">bitnode.considered</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">))</span>
            <span class="o">(</span>
              <span class="n">list.map</span>
              <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span>
                <span class="n">list.nth_le</span> <span class="n">s.bts</span> <span class="n">x</span> <span class="o">(</span><span class="n">dec_trivial</span><span class="o">)</span>
              <span class="o">))</span>
              <span class="n">s.nextbits</span>
            <span class="o">)</span>
          <span class="o">)</span>
        <span class="o">)</span>
      <span class="o">)</span>
    <span class="o">)</span>
  <span class="o">)</span>
  <span class="k">in</span>
<span class="o">{</span> <span class="n">bts</span> <span class="o">:=</span> <span class="n">s.bts</span><span class="o">,</span>
<span class="n">gts</span> <span class="o">:=</span> <span class="n">s.gts</span><span class="o">,</span>
<span class="n">nextbits</span> <span class="o">:=</span> <span class="n">s.nextbits</span><span class="o">,</span>
<span class="n">nextgates</span><span class="o">:=</span>
  <span class="k">if</span> <span class="n">list.length</span> <span class="n">s.nextgates</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="k">if</span> <span class="n">list.length</span> <span class="n">set</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="k">else</span> <span class="o">[</span><span class="n">list.head</span> <span class="n">set</span><span class="o">]</span> <span class="k">else</span> <span class="n">s.nextgates</span><span class="o">,</span>
  <span class="n">table</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">list.length</span> <span class="n">s.nextgates</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="k">if</span> <span class="n">list.length</span> <span class="n">set</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span>
   <span class="o">(</span><span class="n">vec.l</span> <span class="n">gatenode.indices</span> <span class="o">(</span><span class="n">list.nth_le</span>  <span class="n">s.gts</span> <span class="o">(</span><span class="n">list.head</span> <span class="n">set</span><span class="o">)</span> <span class="n">dec_trivial</span> <span class="o">),</span>
  <span class="n">list.map</span> <span class="n">vec.l</span> <span class="o">(</span><span class="n">gatenode.possib</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="o">(</span><span class="n">list.head</span> <span class="n">set</span><span class="o">)</span> <span class="n">dec_trivial</span><span class="o">)</span> <span class="o">))</span>
  <span class="k">else</span> <span class="o">(</span><span class="n">vec.l</span> <span class="n">gatenode.indices</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="o">(</span><span class="n">list.head</span> <span class="n">set</span><span class="o">)</span> <span class="n">dec_trivial</span><span class="o">),</span>
  <span class="n">list.map</span> <span class="n">vec.l</span> <span class="o">(</span><span class="n">gatenode.possib</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="o">(</span><span class="n">list.head</span> <span class="n">set</span><span class="o">)</span> <span class="n">dec_trivial</span><span class="o">)))</span> <span class="k">else</span> <span class="n">s.table</span><span class="o">,</span>

  <span class="n">tablesequence</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">list.length</span> <span class="n">s.nextgates</span> <span class="bp">=</span> <span class="mi">0</span>
  <span class="k">then</span> <span class="k">if</span> <span class="n">list.length</span> <span class="n">set</span> <span class="bp">=</span> <span class="mi">0</span>
  <span class="k">then</span> <span class="o">[(</span><span class="n">vec.l</span> <span class="o">(</span><span class="n">gatenode.indices</span> <span class="o">(</span><span class="n">list.head</span> <span class="n">s.gts</span><span class="o">)),</span> <span class="n">list.map</span> <span class="n">vec.l</span> <span class="o">(</span><span class="n">gatenode.possib</span> <span class="o">(</span><span class="n">list.head</span> <span class="n">s.gts</span><span class="o">)))]</span>
  <span class="k">else</span> <span class="o">[(</span><span class="n">vec.l</span> <span class="o">(</span><span class="n">gatenode.indices</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="o">(</span><span class="n">list.head</span> <span class="n">set</span><span class="o">)</span> <span class="n">dec_trivial</span><span class="o">)),</span>
  <span class="n">list.map</span> <span class="n">vec.l</span> <span class="o">(</span><span class="n">gatenode.possib</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="o">(</span><span class="n">list.head</span> <span class="n">set</span><span class="o">)</span> <span class="n">dec_trivial</span><span class="o">)))]</span>
  <span class="k">else</span> <span class="n">s.tablesequence</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">solv3</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">)</span> <span class="o">:</span> <span class="n">satnet</span> <span class="o">:=</span>  <span class="c1">--remove those bits that the front of consideration has passed from nextbits</span>
<span class="o">{</span>
  <span class="n">bts</span> <span class="o">:=</span> <span class="n">s.bts</span><span class="o">,</span> <span class="n">gts</span> <span class="o">:=</span> <span class="n">s.gts</span><span class="o">,</span> <span class="n">nextbits</span> <span class="o">:=</span>
  <span class="n">list.filter</span>
  <span class="o">(</span><span class="bp">λ</span><span class="n">y</span><span class="o">,(</span>
     <span class="o">((</span>
      <span class="n">list.foldr</span>
      <span class="o">(</span><span class="bp">λ</span><span class="n">z</span><span class="o">,</span><span class="bp">λ</span><span class="n">w</span><span class="o">,(</span><span class="n">z</span> <span class="bp">&amp;&amp;</span> <span class="n">w</span><span class="o">))</span>
      <span class="o">(</span><span class="n">list.map</span>
        <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">:</span><span class="n">ℕ</span><span class="o">,(</span>
          <span class="n">pair.1</span>
          <span class="n">gatenode.state</span>
          <span class="o">(</span><span class="n">list.nth</span>
          <span class="n">s.gts</span>
          <span class="n">x</span>
        <span class="o">))</span>
          <span class="o">(</span>
            <span class="n">list.map</span>
            <span class="n">prod.fst</span>
            <span class="o">(</span>
              <span class="n">bitnode.indices</span>
              <span class="n">y</span>
            <span class="o">)</span>
          <span class="o">)</span> <span class="bp">=</span> <span class="n">tt</span>
        <span class="o">)</span>
      <span class="o">)</span>
    <span class="o">))</span>
  <span class="o">))</span>
  <span class="o">(</span><span class="n">list.erase_dup</span>
  <span class="o">(</span>
    <span class="n">list.foldr</span>
    <span class="o">(</span>
      <span class="n">list.append</span>
      <span class="o">(</span>
        <span class="n">list.map</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">:</span><span class="n">gatenode</span><span class="o">,(</span><span class="n">vec.l</span> <span class="n">gatenode.indices</span> <span class="n">x</span><span class="o">))</span>
        <span class="o">(</span>
          <span class="n">list.filter</span>
          <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span> <span class="bp">¬</span> <span class="o">(</span>
            <span class="n">prod.fst</span> <span class="o">(</span><span class="n">gatenode.state</span> <span class="n">x</span><span class="o">)</span>
          <span class="o">)</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">))</span>
          <span class="o">(</span>
            <span class="n">list.map</span>
            <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span>
              <span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="n">x</span> <span class="n">dec_trivial</span>
            <span class="o">))</span>
            <span class="n">s.nextbits</span>
          <span class="o">)</span>
        <span class="o">)</span>
      <span class="o">)</span>
    <span class="o">)</span>
  <span class="o">))</span>
  <span class="o">,</span> <span class="n">nextgates</span> <span class="o">:=</span> <span class="n">s.nextgates</span><span class="o">,</span>
  <span class="n">table</span> <span class="o">:=</span> <span class="n">s.table</span><span class="o">,</span>
  <span class="n">tablesequence</span> <span class="o">:=</span> <span class="n">s.tablesequence</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">size</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">list.foldr</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span><span class="bp">λ</span><span class="n">y</span><span class="o">,(</span><span class="n">nat.add</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span> <span class="o">(</span><span class="n">list.map</span> <span class="n">list.length</span> <span class="n">l</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">tables</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">)(</span><span class="n">g</span><span class="o">:</span> <span class="n">ℕ</span> <span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>  <span class="c1">--make a table listing all the ways that nextbits could be,</span>
                                                              <span class="c1">--given the last table in s.tablesequence and the gate at index g</span>
<span class="k">let</span> <span class="n">set</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span>  <span class="o">:=</span>
<span class="n">list.erase_dup</span> <span class="o">(</span><span class="n">list.append</span> <span class="n">s.nextbits</span> <span class="o">(</span><span class="n">vec.l</span> <span class="n">gatenode.indices</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="n">g</span> <span class="n">dec_trivial</span><span class="o">))</span>
<span class="k">in</span>
  <span class="o">(</span><span class="n">set</span><span class="o">,(</span>
    <span class="c1">--implement like so:</span>
    <span class="c1">--intersect set with that of nth tablesequence length - 1</span>
    <span class="k">let</span>
    <span class="c1">--the states that are compatible</span>
    <span class="n">subset</span> <span class="o">:</span> <span class="n">list</span> <span class="n">list</span> <span class="n">bool</span> <span class="o">:=</span>
    <span class="n">list.filter</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span>        <span class="c1">--why is d unknown?</span>
      <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.bts</span><span class="o">)</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">gatenode.valence</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="n">g</span> <span class="n">dec_trivial</span><span class="o">)</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">list.length</span> <span class="n">prod.fst</span>
        <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.tablesequence</span> <span class="o">(</span><span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="mi">1</span><span class="o">))</span>
         <span class="bp">→</span> <span class="n">list.nth_le</span> <span class="o">(</span><span class="n">gatenode.indices</span> <span class="n">list.nth</span> <span class="n">s.gts</span><span class="o">)</span> <span class="n">b</span> <span class="n">dec_trivial</span> <span class="bp">=</span>  <span class="n">list.nth_le</span> <span class="o">(</span><span class="n">prod.fst</span>
         <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.tablesequence</span> <span class="o">(</span><span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="n">dec_trivial</span><span class="o">))</span> <span class="n">c</span> <span class="n">dec_trivial</span>
         <span class="bp">→</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="n">list.length</span> <span class="o">(</span><span class="n">prod.snd</span>
         <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.tablesequence</span> <span class="o">(</span><span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="n">dec_trivial</span><span class="o">))</span>
         <span class="bp">→</span> <span class="bp">¬</span> <span class="n">list.nth_le</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="o">(</span><span class="n">prod.snd</span>
         <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.tablesequence</span> <span class="o">(</span><span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="mi">1</span><span class="o">)))</span> <span class="n">c</span> <span class="n">dec_trivial</span><span class="o">)</span> <span class="n">d</span> <span class="n">dec_trivial</span> <span class="bp">=</span> <span class="n">vector.nth_le</span> <span class="n">x</span> <span class="n">b</span> <span class="n">dec_trivial</span>
        <span class="o">)</span>

    <span class="o">)</span> <span class="o">(</span><span class="n">gatenode.possib</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.gts</span> <span class="n">g</span><span class="o">)),</span>
    <span class="n">expset</span> <span class="o">:</span> <span class="n">list</span> <span class="n">list</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">list.foldr</span> <span class="bp">λ</span><span class="n">z</span><span class="o">,(</span><span class="n">list.concat</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">list.map</span> <span class="bp">λ</span><span class="n">x</span><span class="o">,(</span> <span class="n">list.map</span> <span class="bp">λ</span><span class="n">y</span><span class="o">,(</span><span class="n">list.append</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span>
    <span class="o">(</span><span class="n">prod.snd</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.tablesequence</span> <span class="o">(</span><span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">subset</span><span class="o">))</span>
    <span class="k">in</span> <span class="n">list.erase_dup</span> <span class="o">(</span>
      <span class="n">list.transpose</span>
      <span class="o">(</span>
        <span class="n">list.map</span> <span class="n">prod.snd</span>
        <span class="o">(</span>
          <span class="n">list.erase_dup</span>
          <span class="o">(</span> <span class="n">list.filter</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span> <span class="o">(</span><span class="n">list.fst</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">set</span><span class="o">))))</span>
            <span class="n">list.zip</span>
            <span class="o">(</span> <span class="n">list.append</span>
              <span class="n">prod.fst</span>
              <span class="o">(</span>
                <span class="n">list.nth</span> <span class="n">s.tablesequence</span>
                <span class="o">(</span>
                  <span class="n">nat.sub</span>
                  <span class="o">(</span>
                    <span class="n">list.length</span> <span class="n">s.tablesequence</span>
                  <span class="o">)</span>
                  <span class="mi">1</span>
                <span class="o">)</span>
              <span class="o">)</span>
              <span class="o">(</span><span class="n">gatenode.indices</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.gts</span> <span class="n">g</span><span class="o">))</span>
            <span class="o">)</span>
            <span class="n">list.transpose</span>
            <span class="o">(</span>
              <span class="n">list.erase_dup</span> <span class="n">expset</span>
            <span class="o">)</span>
          <span class="o">)</span>
        <span class="o">)</span>
      <span class="o">)</span>
    <span class="o">)</span>
  <span class="o">))</span>
</code></pre></div>



<a name="257233060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257233060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257233060">(Oct 12 2021 at 16:37)</a>:</h4>
<p>respond to this comment please.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">solv4</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">)</span> <span class="o">:</span> <span class="n">satnet</span> <span class="o">:=</span> <span class="c1">--construct the smallest table for any choice in how the front of consideration is to advance</span>
<span class="o">{</span><span class="n">bts</span> <span class="o">:=</span> <span class="n">s.bts</span><span class="o">,</span>
 <span class="n">gts</span> <span class="o">:=</span> <span class="n">s.gts</span><span class="o">,</span>
 <span class="n">nextbits</span> <span class="o">:=</span> <span class="n">s.nextbits</span><span class="o">,</span>
  <span class="n">nextgates</span> <span class="o">:=</span> <span class="n">list.concat</span>
  <span class="n">s.nextgates</span>
  <span class="o">(</span>
    <span class="n">list.argmin</span>
    <span class="o">(</span>
     <span class="n">size</span> <span class="o">(</span><span class="n">prod.snd</span>
      <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span><span class="n">tables</span> <span class="n">s</span> <span class="n">x</span><span class="o">)))</span>
    <span class="o">)</span>
    <span class="o">(</span>
      <span class="n">list.filter</span>
      <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span><span class="bp">¬</span> <span class="o">((</span><span class="n">prod.fst</span> <span class="o">(</span><span class="n">gatenode.state</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="n">x</span> <span class="n">dec_trivial</span><span class="o">))</span><span class="bp">=</span> <span class="n">tt</span><span class="o">)</span> <span class="bp">∨</span>  <span class="n">x</span> <span class="bp">∈</span> <span class="n">s.nextgates</span><span class="o">)))</span>
      <span class="o">(</span><span class="n">list.range</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.gts</span><span class="o">))</span>
    <span class="o">)</span>
  <span class="o">),</span>
   <span class="n">table</span> <span class="o">:=</span> <span class="n">list.argmin</span> <span class="bp">λ</span><span class="n">x</span><span class="o">,(</span><span class="n">size</span> <span class="o">(</span><span class="n">prod.snd</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">list.map</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span><span class="n">tables</span> <span class="n">s</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">list.range</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.gts</span><span class="o">))),</span>
  <span class="c1">--the one thing i'm not sure on,</span>
  <span class="c1">--the maximum number of entries in this table, if im correct,</span>
  <span class="c1">-- grows no faster than the number of gates</span>
  <span class="c1">--sketch:</span>
  <span class="c1">--initially, the front of consideration is fully determined until it reaches the edge of a bubble</span>
  <span class="c1">-- a bubble is here defined as a subset of the satnet s where determination on the outside has no bearing on the inside, though not necessarily vice versa</span>
  <span class="c1">--the edge of a bubble is formed by one ore more cycles of gates connected to bits on the inside, and each one has a single line outwards</span>
  <span class="c1">--for each cycle, there are at most two distinct states the whole cycle can be in</span>
  <span class="c1">-- the most efficient traversal through that is to consider the consequences of one cycle at a time,</span>
  <span class="c1">--as that keeps the number of entries below some constant</span>
  <span class="c1">--it will take an automated proof search to prove that this is always possible</span>

  <span class="c1">--though i do know that it is definitely subexponential,</span>
  <span class="c1">-- at most 2^(sqrt(n))</span>
  <span class="c1">--sketch:</span>
  <span class="c1">--the width of the front of consideration grows linearly and then shrinks linearly</span>
  <span class="c1">-- from one gate to its maximum than back down to just one again</span>
  <span class="c1">--for the maximum to be the absolute worst case, the system must approximate a square with the disjoint subsets that the front passes through in layers</span>
  <span class="c1">--the maximum width then is sqrt(2n)</span>
  <span class="c1">--the maximum number of states that can take on is O(2^(sqrt(2n)))</span>
  <span class="c1">--qed, therefore the exponential time hypothesis is false</span>
  <span class="n">tablesequence</span> <span class="o">:=</span> <span class="n">s.tablesequence</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">solv5</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">)</span> <span class="o">:</span> <span class="n">satnet</span> <span class="o">:=</span>   <span class="c1">--place the new table in the squence</span>
<span class="o">{</span><span class="n">bts</span> <span class="o">:=</span> <span class="n">s.bts</span><span class="o">,</span>
<span class="n">gts</span> <span class="o">:=</span> <span class="n">s.gts</span><span class="o">,</span>
<span class="n">nextbits</span> <span class="o">:=</span> <span class="n">s.nextbits</span><span class="o">,</span>
<span class="n">nextgates</span> <span class="o">:=</span> <span class="n">s.nextgates</span><span class="o">,</span>
<span class="n">table</span> <span class="o">:=</span> <span class="n">s.table</span><span class="o">,</span>
<span class="n">tablesequence</span> <span class="o">:=</span> <span class="n">list.concat</span> <span class="n">s.tablesequence</span> <span class="n">s.table</span>
<span class="o">}</span>

<span class="c1">--say that the bitnodes and gatenodes that the front of consideration has passed are considered</span>
<span class="kd">def</span> <span class="n">reconsider</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">)(</span><span class="n">b</span><span class="o">:</span><span class="n">ℕ</span> <span class="o">)</span> <span class="o">:</span> <span class="n">bitnode</span> <span class="o">:=</span>
  <span class="o">{</span>
    <span class="n">value</span> <span class="o">:=</span> <span class="n">bitnode.value</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.bts</span> <span class="n">b</span> <span class="n">dec_trivial</span><span class="o">),</span>
    <span class="n">indices</span> <span class="o">:=</span> <span class="n">bitnode.indices</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.bts</span> <span class="n">b</span> <span class="n">dec_trivial</span><span class="o">),</span>
    <span class="n">isconstant</span> <span class="o">:=</span> <span class="n">bitnode.isconstant</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.bts</span> <span class="n">b</span> <span class="n">dec_trivial</span><span class="o">),</span>
    <span class="n">considered</span> <span class="o">:=</span>
    <span class="k">if</span>
    <span class="n">list.foldr</span>
    <span class="o">(</span><span class="bp">λ</span><span class="n">z</span><span class="o">,</span><span class="bp">λ</span><span class="n">w</span><span class="o">,(</span><span class="n">z</span> <span class="bp">&amp;&amp;</span> <span class="n">w</span><span class="o">))</span>
    <span class="o">(</span><span class="n">list.map</span>
    <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span>
     <span class="n">prod.fst</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s.nextgates</span>
    <span class="o">))</span>
    <span class="o">(</span>
      <span class="n">bitnode.indices</span>
      <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.bts</span> <span class="n">b</span> <span class="n">dec_trivial</span><span class="o">)</span>
    <span class="o">)</span> <span class="o">)</span>
    <span class="k">then</span>
    <span class="n">tt</span>
    <span class="k">else</span>
    <span class="n">bitnode.considered</span>
    <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.bts</span> <span class="n">b</span> <span class="n">dec_trivial</span><span class="o">)</span>
  <span class="o">}</span>

<span class="kd">def</span> <span class="n">solv6</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">)</span> <span class="o">:</span> <span class="n">satnet</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">bts</span> <span class="o">:=</span> <span class="n">list.map</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span><span class="n">reconsider</span> <span class="n">s</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">list.range</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.bts</span><span class="o">)),</span>
<span class="n">gts</span> <span class="o">:=</span> <span class="n">s.gts</span><span class="o">,</span>
<span class="n">nextbits</span> <span class="o">:=</span> <span class="n">s.nextbits</span><span class="o">,</span>
<span class="n">nextgates</span> <span class="o">:=</span> <span class="n">s.nextgates</span><span class="o">,</span>
<span class="n">table</span> <span class="o">:=</span> <span class="n">s.table</span><span class="o">,</span>
<span class="n">tablesequence</span> <span class="o">:=</span> <span class="n">s.tablesequence</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">greconsider</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">)(</span><span class="n">g</span><span class="o">:</span><span class="n">ℕ</span> <span class="o">)(</span><span class="n">c</span><span class="o">:</span><span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">gatenode</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">valence</span> <span class="o">:=</span> <span class="n">gatenode.valence</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="n">g</span> <span class="n">dec_trivial</span><span class="o">),</span>
<span class="n">possib</span> <span class="o">:=</span> <span class="n">gatenode.possib</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="n">g</span> <span class="n">dec_trivial</span><span class="o">),</span>
<span class="n">indices</span> <span class="o">:=</span> <span class="n">gatenode.indices</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="n">g</span> <span class="n">dec_trivial</span><span class="o">),</span>
<span class="n">state</span> <span class="o">:=</span>
<span class="o">(</span>
  <span class="o">(</span>
    <span class="k">if</span>
    <span class="n">c</span>
    <span class="k">then</span>
    <span class="n">tt</span>
    <span class="k">else</span>
    <span class="o">(</span>
      <span class="n">prod.fst</span>
      <span class="o">(</span><span class="n">gatenode.state</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="n">g</span> <span class="n">dec_trivial</span><span class="o">))</span>
    <span class="o">)</span>
  <span class="o">),</span>
  <span class="o">(</span>
    <span class="n">prod.snd</span>
    <span class="o">(</span><span class="n">gatenode.state</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="n">g</span> <span class="n">dec_trivial</span><span class="o">))</span>
  <span class="o">)</span>
<span class="o">)</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">solv7</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">)</span> <span class="o">:</span> <span class="n">satnet</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">set</span><span class="o">:</span><span class="n">list</span> <span class="n">ℕ</span>  <span class="o">:=</span> <span class="n">list.filter</span>
<span class="o">(</span><span class="bp">λ</span><span class="n">y</span><span class="o">,(</span>
  <span class="o">((</span>
    <span class="n">list.foldr</span>
    <span class="o">(</span><span class="bp">λ</span><span class="n">z</span><span class="o">,</span><span class="bp">λ</span><span class="n">w</span><span class="o">,(</span><span class="n">z</span> <span class="bp">&amp;&amp;</span> <span class="n">w</span><span class="o">))</span>
    <span class="o">(</span><span class="n">list.map</span>
      <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span>
        <span class="n">bitnode.considered</span> <span class="n">x</span>
      <span class="o">)</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">)</span>
      <span class="o">(</span><span class="n">vec.l</span> <span class="o">(</span><span class="n">gatenode.indices</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.gts</span> <span class="n">y</span> <span class="n">dec_trivial</span><span class="o">)))</span>
    <span class="o">)</span>
  <span class="o">)</span> <span class="o">)</span>
<span class="o">))</span>
<span class="o">(</span>
  <span class="n">list.range</span>
  <span class="o">(</span><span class="n">list.length</span> <span class="n">s.gts</span><span class="o">)</span>
<span class="o">)</span>
<span class="k">in</span>
<span class="o">{</span><span class="n">bts</span> <span class="o">:=</span> <span class="n">s.bts</span><span class="o">,</span>
<span class="n">gts</span> <span class="o">:=</span> <span class="n">list.map</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span><span class="n">greconsider</span> <span class="n">s</span> <span class="n">x</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">set</span><span class="o">)))</span> <span class="o">(</span><span class="n">list.range</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.gts</span><span class="o">))</span>
<span class="o">,</span><span class="n">nextbits</span> <span class="o">:=</span> <span class="n">s.nextbits</span><span class="o">,</span>
<span class="n">nextgates</span> <span class="o">:=</span> <span class="n">list.filter</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">set</span><span class="o">)))</span> <span class="n">s.nextgates</span><span class="o">,</span>
<span class="n">table</span> <span class="o">:=</span> <span class="n">s.table</span><span class="o">,</span>
<span class="n">tablesequence</span> <span class="o">:=</span> <span class="n">s.tablesequence</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">solvcycle</span> <span class="o">:</span> <span class="n">satnet</span> <span class="bp">-&gt;</span> <span class="n">satnet</span> <span class="o">:=</span> <span class="c1">--the cycle starts in solv3.</span>
 <span class="n">solv7</span> <span class="bp">∘</span> <span class="n">solv6</span> <span class="bp">∘</span> <span class="n">solv5</span> <span class="bp">∘</span> <span class="n">solv4</span> <span class="bp">∘</span> <span class="n">solv3</span>


<span class="kd">def</span> <span class="n">solvcert</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span> <span class="o">):</span> <span class="n">satnet</span> <span class="o">:=</span> <span class="c1">--this is the information required to 'certify' satisfiability without a witness</span>
<span class="o">(</span><span class="n">nat.iterate</span>  <span class="n">solvcycle</span> <span class="o">(</span><span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.gts</span><span class="o">)</span> <span class="mi">1</span><span class="o">))</span> <span class="o">((</span><span class="n">solv2</span> <span class="bp">∘</span> <span class="n">solv1</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">solvdecide</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">):</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">list.length</span> <span class="o">(</span><span class="n">prod.snd</span> <span class="o">(</span><span class="n">satnet.table</span> <span class="o">(</span><span class="n">solvcert</span> <span class="n">s</span><span class="o">)))</span> <span class="bp">&gt;</span> <span class="mi">0</span>  <span class="c1">--this 'solves the decision problem'</span>

<span class="kd">def</span> <span class="n">solvretract1</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">)</span> <span class="o">:</span> <span class="n">satnet</span> <span class="o">:=</span>    <span class="c1">--pick an entry, possibly random, in the last table and commit to it</span>
<span class="c1">-- choose a nat in 0..length (snd (last table), maybe randomly</span>
<span class="k">let</span> <span class="n">choicen</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">random</span>  <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">list.length</span> <span class="n">prod.snd</span> <span class="n">s.table</span><span class="o">)</span>
<span class="k">in</span>
<span class="o">{</span><span class="n">bts</span> <span class="o">:=</span>
<span class="c1">--set the value of each bitnode to that in the entry corresponding to the number previously chosen</span>
<span class="n">list.map</span>
<span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">:</span><span class="n">ℕ</span><span class="o">,</span>
<span class="o">{</span><span class="n">value</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">prod.fst</span> <span class="n">s.table</span>
<span class="k">then</span> <span class="n">list.nth_le</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="o">(</span><span class="n">prod.snd</span> <span class="n">s.table</span><span class="o">)</span> <span class="n">choicen</span> <span class="n">dec_trivial</span><span class="o">)</span> <span class="o">(</span><span class="n">list.indexof</span> <span class="n">x</span> <span class="o">(</span><span class="n">prod.fst</span> <span class="n">s.table</span><span class="o">))</span> <span class="n">dec_trivial</span> <span class="c1">--surely there is a function that does this</span>
<span class="k">else</span> <span class="n">bitnode.value</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.bts</span> <span class="n">x</span> <span class="n">dec_trivial</span><span class="o">),</span>
<span class="n">indices</span> <span class="o">:=</span> <span class="n">bitnode.indices</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.bts</span> <span class="n">x</span> <span class="n">dec_trivial</span><span class="o">),</span>
<span class="n">isconstant</span><span class="o">:=</span> <span class="n">bitnode.isconstant</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.bts</span> <span class="n">x</span> <span class="n">dec_trivial</span><span class="o">),</span>
<span class="n">considered</span> <span class="o">:=</span> <span class="n">bitnode.considered</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.bts</span> <span class="n">x</span> <span class="n">dec_trivial</span><span class="o">)})</span>
<span class="o">(</span><span class="n">list.range</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.bts</span><span class="o">)),</span>

 <span class="n">gts</span> <span class="o">:=</span> <span class="c1">--same here</span>
 <span class="c1">--placeholder</span>
 <span class="n">s.gts</span>
<span class="c1">-- if all the bits connected to a gate are in the last table then set the state to the values in the table entry</span>

<span class="o">,</span>
<span class="n">nextbits</span> <span class="o">:=</span> <span class="n">s.nextbits</span><span class="o">,</span> <span class="n">nextgates</span> <span class="o">:=</span> <span class="n">s.nextgates</span><span class="o">,</span>
<span class="n">table</span> <span class="o">:=</span> <span class="o">(</span><span class="n">prod.fst</span> <span class="n">s.table</span><span class="o">,</span> <span class="n">list.nth_le</span> <span class="o">(</span><span class="n">pair.2</span> <span class="n">s.table</span><span class="o">)</span> <span class="n">choicen</span> <span class="n">dec_trivial</span><span class="o">),</span>
<span class="n">tablesequence</span> <span class="o">:=</span> <span class="n">s.tablesequence</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">solvretract2</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span> <span class="o">)</span> <span class="o">:</span> <span class="n">satnet</span> <span class="o">:=</span>  <span class="c1">-- remove the entries incompatible with the table from which we are puuling back</span>
<span class="o">{</span><span class="n">bts</span> <span class="o">:=</span> <span class="n">s.bts</span><span class="o">,</span>
<span class="n">gts</span> <span class="o">:=</span> <span class="n">s.gts</span><span class="o">,</span>
<span class="n">nextbits</span> <span class="o">:=</span> <span class="n">s.nextbits</span><span class="o">,</span>
<span class="n">nextgates</span> <span class="o">:=</span> <span class="n">s.nextgates</span><span class="o">,</span>
<span class="n">table</span> <span class="o">:=</span> <span class="n">s.table</span><span class="o">,</span>
<span class="n">tablesequence</span> <span class="o">:=</span>
  <span class="o">(</span>
    <span class="n">list.concat</span>
    <span class="o">(</span><span class="n">list.remove_nth</span> <span class="o">(</span><span class="n">s.tablesequence</span><span class="o">)</span>
    <span class="o">(</span> <span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="o">(</span><span class="n">s.tablesequence</span><span class="o">))</span> <span class="mi">1</span><span class="o">)),</span>
    <span class="n">list.filter</span>
    <span class="o">(</span>
      <span class="bp">λ</span><span class="n">x</span><span class="o">,(</span>
         <span class="o">(</span>
          <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">,</span>
          <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">list.length</span> <span class="o">(</span><span class="n">prod.fst</span> <span class="n">s.table</span><span class="o">)</span>
          <span class="bp">→</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">list.length</span> <span class="n">x</span>
          <span class="bp">→</span>  <span class="n">list.nth</span> <span class="n">x</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">d</span>
          <span class="bp">→</span> <span class="n">list.nth_le</span> <span class="o">(</span><span class="n">prod.fst</span> <span class="n">s.table</span><span class="o">)</span> <span class="n">b</span> <span class="n">dec_trivial</span> <span class="bp">=</span> <span class="n">d</span>
          <span class="bp">→</span> <span class="n">list.nth_le</span> <span class="o">(</span><span class="n">prod.snd</span> <span class="n">s.table</span><span class="o">)</span> <span class="n">b</span> <span class="n">dec_trivial</span> <span class="bp">=</span> <span class="n">list.nth_le</span> <span class="n">x</span> <span class="n">c</span> <span class="n">dec_trivial</span>
        <span class="o">)</span>
      <span class="o">)</span>
    <span class="o">)</span>
    <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">s.tablesequence</span> <span class="o">(</span><span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="n">dec_trivial</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">solvretract3</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">)</span> <span class="o">:</span> <span class="n">satnet</span> <span class="o">:=</span> <span class="c1">--pop the last table in the sequence off</span>
<span class="o">{</span><span class="n">bts</span> <span class="o">:=</span> <span class="n">s.bts</span><span class="o">,</span>
<span class="n">gts</span> <span class="o">:=</span> <span class="n">s.gts</span><span class="o">,</span>
<span class="n">nextbits</span> <span class="o">:=</span> <span class="n">s.nextbits</span><span class="o">,</span>
<span class="n">nextgates</span> <span class="o">:=</span> <span class="n">s.nextgates</span><span class="o">,</span>
<span class="n">table</span> <span class="o">:=</span> <span class="n">list.nth_le</span> <span class="n">s.tablesequence</span> <span class="o">(</span> <span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="n">dec_trivial</span><span class="o">,</span>
<span class="n">tablesequence</span> <span class="o">:=</span> <span class="n">list.remove_nth</span> <span class="n">s.tablesequence</span> <span class="o">(</span><span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="mi">1</span><span class="o">)}</span>

<span class="kd">def</span> <span class="n">solvwitness</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">):</span> <span class="n">satnet</span> <span class="o">:=</span> <span class="c1">--this solves the 'function problem'</span>
<span class="o">(</span><span class="n">nat.iterate</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span><span class="n">solvretract3</span> <span class="o">(</span><span class="n">solvretract2</span> <span class="o">(</span> <span class="n">solvretract1</span> <span class="n">x</span><span class="o">))))(</span><span class="n">list.length</span> <span class="n">s.gts</span><span class="o">)</span> <span class="o">)</span> <span class="o">((</span><span class="n">solvcert</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span>
</code></pre></div>



<a name="257238402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257238402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257238402">(Oct 12 2021 at 17:12)</a>:</h4>
<p>This is not a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>. The interpretation of "working" here is "it demonstrates the issue you are having trouble with", i.e. it fails in the expected way. But "minimal" is also important. Remove all definitions that are not relevant to the error, by stubbing things out (put <code>sorry</code> anywhere you can). And if you comment your code, make sure the comments are relevant to the error, especially if there are multiple lean errors in the document</p>



<a name="257240853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257240853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257240853">(Oct 12 2021 at 17:28)</a>:</h4>
<p>I said <code>vec.1</code> not <code>vec.l</code> by the way</p>



<a name="257240930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257240930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257240930">(Oct 12 2021 at 17:29)</a>:</h4>
<p>and <code>vec</code> is supposed to be the variable of type <code>vector</code> that you have</p>



<a name="257240971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257240971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257240971">(Oct 12 2021 at 17:29)</a>:</h4>
<p>the underlying function is <code>subtype.val</code></p>



<a name="257241144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257241144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257241144">(Oct 12 2021 at 17:30)</a>:</h4>
<p>I should also note that in lean we generally avoid point-free programming; things like dot-notation don't work in point-free style and the composition operator can interfere with proofs</p>



<a name="257242526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257242526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257242526">(Oct 12 2021 at 17:39)</a>:</h4>
<p>Here's a leanified version of your file through <code>solv1</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list</span>
<span class="kn">import</span> <span class="n">data.vector.basic</span>
<span class="kn">import</span> <span class="n">data.prod</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">bitnode</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="o">(</span><span class="n">indices</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">))</span>
<span class="o">(</span><span class="n">isconstant</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="o">(</span><span class="n">considered</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">gatenode</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">valence</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">possib</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">vector</span> <span class="n">bool</span> <span class="n">valence</span><span class="o">))</span>
<span class="o">(</span><span class="n">state</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">×</span> <span class="n">vector</span> <span class="n">bool</span> <span class="n">valence</span><span class="o">)</span>
<span class="o">(</span><span class="n">indices</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">ℕ</span> <span class="n">valence</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">reversible</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">gatenode</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">∈</span> <span class="n">a.possib</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">a.valence</span><span class="o">,</span>
  <span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="n">vector</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">remove_nth</span> <span class="n">i</span> <span class="bp">=</span> <span class="o">(</span><span class="n">w</span><span class="o">:</span><span class="n">vector</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">remove_nth</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">w</span>

<span class="kd">def</span> <span class="n">mknot</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="n">vector</span> <span class="n">ℕ</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">gatenode</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">valence</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span>
  <span class="n">possib</span> <span class="o">:=</span> <span class="o">[</span><span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">vector.nil</span><span class="o">,</span> <span class="n">tt</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">vector.nil</span><span class="o">],</span>
  <span class="n">state</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span> <span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">tt</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">vector.nil</span><span class="o">),</span>
  <span class="n">indices</span> <span class="o">:=</span> <span class="n">c</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">mk3unique</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="n">vector</span> <span class="n">ℕ</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:</span> <span class="n">gatenode</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">valence</span> <span class="o">:=</span> <span class="mi">3</span><span class="o">,</span>
  <span class="n">possib</span> <span class="o">:=</span> <span class="o">[</span>
    <span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">tt</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">vector.nil</span><span class="o">,</span>
    <span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">tt</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">vector.nil</span><span class="o">,</span>
    <span class="n">tt</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">vector.nil</span>
  <span class="o">],</span>
  <span class="n">state</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span> <span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span>  <span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span>  <span class="n">tt</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">vector.nil</span><span class="o">),</span>
  <span class="n">indices</span> <span class="o">:=</span> <span class="n">c</span> <span class="o">}</span>

<span class="kd">structure</span> <span class="n">satnet</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bitnode</span><span class="o">)</span> <span class="o">(</span><span class="n">gts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">gatenode</span><span class="o">)</span>
<span class="o">(</span><span class="n">nextbits</span> <span class="n">nextgates</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">table</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">))</span>
<span class="o">(</span><span class="n">tablesequence</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)))</span>

<span class="kd">def</span> <span class="n">solv1</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">satnet</span><span class="o">)</span> <span class="o">:</span> <span class="n">satnet</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">bts</span> <span class="o">:=</span> <span class="n">s.bts</span><span class="o">,</span>
  <span class="n">gts</span> <span class="o">:=</span> <span class="n">s.gts</span><span class="o">,</span>
  <span class="n">nextbits</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">s.bts.any</span> <span class="n">bitnode.isconstant</span> <span class="k">then</span>
      <span class="o">(</span><span class="n">s.bts.enum.filter</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">:</span><span class="n">_</span><span class="bp">×</span><span class="n">bitnode</span><span class="o">,</span> <span class="n">x.2.isconstant</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span> <span class="n">prod.fst</span>
    <span class="k">else</span> <span class="o">[</span><span class="mi">0</span><span class="o">],</span>
  <span class="n">nextgates</span> <span class="o">:=</span> <span class="n">s.nextgates</span><span class="o">,</span>
  <span class="n">table</span> <span class="o">:=</span> <span class="n">s.table</span><span class="o">,</span>
  <span class="n">tablesequence</span> <span class="o">:=</span> <span class="o">[]</span> <span class="o">}</span>
</code></pre></div>



<a name="257243456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257243456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257243456">(Oct 12 2021 at 17:45)</a>:</h4>
<p>I don't know how to make sense of the definition of <code>set</code> in <code>solv2</code>; the <code>list.map</code> and <code>list.foldr</code> calls don't have enough arguments</p>



<a name="257243724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257243724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257243724">(Oct 12 2021 at 17:47)</a>:</h4>
<p>you should definitely break this down into bite sized pieces and ask questions one at a time</p>



<a name="257244905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257244905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257244905">(Oct 12 2021 at 17:55)</a>:</h4>
<p>i changed the set to this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">set</span><span class="o">:</span><span class="n">list</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">list.erase_dup</span>
  <span class="o">(</span> <span class="n">list.foldr</span> <span class="n">list.append</span> <span class="o">(</span>
          <span class="n">list.map</span> <span class="n">prod.fst</span> <span class="bp">∘</span> <span class="n">bitnode.indices</span>
          <span class="o">(</span>
            <span class="n">list.filter</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">bitnode.considered</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">))</span>
            <span class="o">(</span>
              <span class="n">list.map</span>
              <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span>
                <span class="n">list.nth_le</span> <span class="n">s.bts</span> <span class="n">x</span> <span class="o">(</span><span class="n">dec_trivial</span><span class="o">)</span>
              <span class="o">))</span>
              <span class="n">s.nextbits</span>
            <span class="o">)</span>
          <span class="o">)</span>
        <span class="o">)</span>
    <span class="o">)</span>
</code></pre></div>



<a name="257245075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257245075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257245075">(Oct 12 2021 at 17:56)</a>:</h4>
<p>subtype.val is the underlying function of what?</p>



<a name="257245112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257245112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257245112">(Oct 12 2021 at 17:56)</a>:</h4>
<p>If I replace the <code>dec_trivial</code> with <code>sorry</code> it still does not type check, <code>bitnode.indices</code> doesn't have the right type</p>



<a name="257245209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257245209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257245209">(Oct 12 2021 at 17:57)</a>:</h4>
<p>do you want it to be <code>list.map (prod.fst ∘ bitnode.indices) ...</code>?</p>



<a name="257245228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257245228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257245228">(Oct 12 2021 at 17:57)</a>:</h4>
<p>that also doesn't work</p>



<a name="257245325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257245325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257245325">(Oct 12 2021 at 17:58)</a>:</h4>
<p>Can you say in words what you are trying to express?</p>



<a name="257245584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257245584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257245584">(Oct 12 2021 at 17:59)</a>:</h4>
<p>the pointers to the gatenodes that are connected to the bitnodes that nextbits points to.</p>



<a name="257245587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257245587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257245587">(Oct 12 2021 at 17:59)</a>:</h4>
<p>and the <code>foldr</code> is still missing an argument; it takes 3 arguments, the function to fold, the initial value and the list. You have no initial value</p>



<a name="257245805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257245805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257245805">(Oct 12 2021 at 18:00)</a>:</h4>
<p>what does points to mean here?</p>



<a name="257245914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257245914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257245914">(Oct 12 2021 at 18:01)</a>:</h4>
<p>what should happen if <code>s.nextbits</code> contains an index out of range of <code>s.bts</code>?</p>



<a name="257246042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257246042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257246042">(Oct 12 2021 at 18:02)</a>:</h4>
<p>one easy thing to do is filter those indices out, so you get <code>s.nextbits.filter_map (list.nth s.bts)</code></p>



<a name="257246056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257246056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257246056">(Oct 12 2021 at 18:02)</a>:</h4>
<p>the starting value is []</p>



<a name="257246229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257246229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257246229">(Oct 12 2021 at 18:03)</a>:</h4>
<p>the pointers are the indexes in the corresponding list where the connected node is at</p>



<a name="257246279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257246279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257246279">(Oct 12 2021 at 18:04)</a>:</h4>
<p>still not sure where you want to go with that <code>list.map prod.fst ∘ bitnode.indices</code> part</p>



<a name="257246458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257246458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257246458">(Oct 12 2021 at 18:04)</a>:</h4>
<p>if a function like vetnet is used as a refinement to satnet, the indices should not be out of range.</p>



<a name="257246497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257246497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257246497">(Oct 12 2021 at 18:05)</a>:</h4>
<p>So <code>s.nextbits.filter_map (list.nth s.bts)</code> is the collection of bitnodes pointed to by nextbits. where do <code>considered</code> and <code>indices</code> come up?</p>



<a name="257246558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257246558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257246558">(Oct 12 2021 at 18:05)</a>:</h4>
<p>Sure, but the types don't say that so you have to decide what to do anyway</p>



<a name="257246674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257246674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257246674">(Oct 12 2021 at 18:06)</a>:</h4>
<p><code>filter_map</code> is an easy way to dodge the issue with <code>nth_le</code></p>



<a name="257246737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257246737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257246737">(Oct 12 2021 at 18:06)</a>:</h4>
<p>Alternatively, you can give an instance of <code>inhabited bitset</code> and then you can use <code>list.inth</code></p>



<a name="257246989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257246989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257246989">(Oct 12 2021 at 18:08)</a>:</h4>
<p>the second of the ordered pairs that bitnode.indices uses connects to a particular line of a gatenode</p>



<a name="257247314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257247314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257247314">(Oct 12 2021 at 18:10)</a>:</h4>
<p>aha, I think you want this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">set</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="o">:=</span>
  <span class="o">(((</span><span class="n">s.nextbits.filter_map</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.bts</span><span class="o">))</span>
    <span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">bitnode.considered</span> <span class="n">x</span><span class="o">))</span>
    <span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">:</span><span class="n">bitnode</span><span class="o">,</span> <span class="n">x.indices.map</span> <span class="n">prod.fst</span><span class="o">))</span>
    <span class="bp">.</span><span class="n">erase_dup</span>
</code></pre></div>



<a name="257247366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257247366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257247366">(Oct 12 2021 at 18:10)</a>:</h4>
<p>i prefer to use filter_map</p>



<a name="257247627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257247627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257247627">(Oct 12 2021 at 18:12)</a>:</h4>
<p>Here's a way to write it monadically:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">set</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">list.erase_dup</span> <span class="bp">$</span> <span class="k">do</span>
  <span class="n">n</span> <span class="bp">←</span> <span class="n">s.nextbits</span><span class="o">,</span>
  <span class="n">x</span> <span class="bp">←</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.bts</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">to_list</span><span class="o">,</span>
  <span class="n">guard</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">bitnode.considered</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">i</span> <span class="bp">←</span> <span class="n">x.indices</span><span class="o">,</span>
  <span class="n">pure</span> <span class="n">i.1</span>
</code></pre></div>



<a name="257247658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257247658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257247658">(Oct 12 2021 at 18:13)</a>:</h4>
<p>does it matter?</p>



<a name="257247680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257247680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257247680">(Oct 12 2021 at 18:13)</a>:</h4>
<p>what do you mean?</p>



<a name="257247703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257247703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257247703">(Oct 12 2021 at 18:13)</a>:</h4>
<p>It's a matter of taste</p>



<a name="257247805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257247805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257247805">(Oct 12 2021 at 18:14)</a>:</h4>
<p>what would inform the choice to instead use the monadic version?</p>



<a name="257247844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257247844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257247844">(Oct 12 2021 at 18:14)</a>:</h4>
<p>it's a bit easier to write and maintain</p>



<a name="257247888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257247888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257247888">(Oct 12 2021 at 18:14)</a>:</h4>
<p>easier to understand?</p>



<a name="257248126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257248126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257248126">(Oct 12 2021 at 18:16)</a>:</h4>
<p>Both of the last two versions I wrote are okay for understanding, but normally you wouldn't be writing all these lists explicitly and instead you would describe things more declaratively, by describing the property that should hold about the values and letting lean figure out how to compute it</p>



<a name="257248245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257248245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257248245">(Oct 12 2021 at 18:17)</a>:</h4>
<p>it still looks too much like haskell code atm</p>



<a name="257248291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257248291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257248291">(Oct 12 2021 at 18:17)</a>:</h4>
<p>anyway i used the former</p>



<a name="257248513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257248513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257248513">(Oct 12 2021 at 18:19)</a>:</h4>
<p>what looks too much like haskell?</p>



<a name="257248631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257248631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257248631">(Oct 12 2021 at 18:20)</a>:</h4>
<p>Maybe it might help to start at the beginning, with the problem modeling. What are <code>bitnode</code> and <code>gatenode</code>, and how do the fields accomplish what they need to do?</p>



<a name="257248745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257248745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257248745">(Oct 12 2021 at 18:20)</a>:</h4>
<p>I suspect there are a number of missing propositional fields</p>



<a name="257249342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257249342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257249342">(Oct 12 2021 at 18:24)</a>:</h4>
<p>Where does this idea of having all those lines with only parentheses come from?</p>



<a name="257249705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257249705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257249705">(Oct 12 2021 at 18:26)</a>:</h4>
<p>the entire network is composed of nodes representing bits and logic gates. a bit can be connected to the lines of any number of gates, while each line of a gate can only be connected to one bit. possib is an exhaustive enumeration of the ways the bits a gate is connected to can take on values.  the algorithm that i was going for moves a front of consideration across the network, and bitnode.considered and gatenode.state.fst indicate that the node has been passed by.</p>



<a name="257249817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257249817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257249817">(Oct 12 2021 at 18:27)</a>:</h4>
<p>that sounds like <code>bitnode.considered</code> should not be a part of <code>bitnode</code> then</p>



<a name="257249891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257249891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257249891">(Oct 12 2021 at 18:28)</a>:</h4>
<p>What is the data required to define a network?</p>



<a name="257249963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257249963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257249963">(Oct 12 2021 at 18:28)</a>:</h4>
<p>What is the input and output of the algorithm?</p>



<a name="257249982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257249982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257249982">(Oct 12 2021 at 18:29)</a>:</h4>
<p>all the perentheses are necessary to tell what branch of the function graph you are looking at. it also help lean call on the antire value rather than the function that produced it.</p>



<a name="257250087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257250087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257250087">(Oct 12 2021 at 18:29)</a>:</h4>
<p>I think patrick is referring to the formatting of the parentheses, not their presence</p>



<a name="257250108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257250108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257250108">(Oct 12 2021 at 18:29)</a>:</h4>
<p>bitnode.considered is required for efficiency.</p>



<a name="257250169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257250169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257250169">(Oct 12 2021 at 18:30)</a>:</h4>
<p>efficiency in what sense?</p>



<a name="257250240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257250240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257250240">(Oct 12 2021 at 18:30)</a>:</h4>
<p>the formatting helps me personally to read what is there.</p>



<a name="257250267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257250267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257250267">(Oct 12 2021 at 18:30)</a>:</h4>
<p>I mean to say that your <code>considered</code> data should be separate from the network, since it's not part of the input</p>



<a name="257250339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257250339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257250339">(Oct 12 2021 at 18:31)</a>:</h4>
<p>it is linked to the bitnode by necessity.</p>



<a name="257250372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257250372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257250372">(Oct 12 2021 at 18:31)</a>:</h4>
<p>it can be layered over the bitnode just as well, thanks to dependent types</p>



<a name="257250600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257250600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257250600">(Oct 12 2021 at 18:33)</a>:</h4>
<p>but maybe that's getting ahead of ourselves. What are the other fields in <code>bitnode</code>? What do you mean by a "bit"? Is this like an internal wire in a logic gate diagram, or an external wire?</p>



<a name="257250666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257250666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257250666">(Oct 12 2021 at 18:34)</a>:</h4>
<p>the former.</p>



<a name="257250869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257250869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257250869">(Oct 12 2021 at 18:35)</a>:</h4>
<p>It seems like the network (the graph) should be separate from the space of states of the network (assignments of {0, 1} to the wires), but the current form doesn't seem to make a distinction</p>



<a name="257250982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257250982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257250982">(Oct 12 2021 at 18:36)</a>:</h4>
<p>why?</p>



<a name="257251320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257251320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257251320">(Oct 12 2021 at 18:38)</a>:</h4>
<p>Otherwise you can't talk about properties of networks, only properties of states. For example an unstable network (i.e. one with no valid assignment) can't be expressed</p>



<a name="257251400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257251400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257251400">(Oct 12 2021 at 18:39)</a>:</h4>
<p>Same as how formulas and assignments are distinguished in SAT</p>



<a name="257251898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257251898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257251898">(Oct 12 2021 at 18:42)</a>:</h4>
<p>an example, please.</p>



<a name="257252238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257252238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257252238">(Oct 12 2021 at 18:44)</a>:</h4>
<p>the way satnet is formulated, one does not necessarily have an output.</p>



<a name="257252895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257252895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257252895">(Oct 12 2021 at 18:49)</a>:</h4>
<p>I'm thinking of something like this for defining a network:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">network</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bits</span> <span class="n">gates</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">valence</span> <span class="o">:</span> <span class="n">gates</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">valuation</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">gates</span><span class="o">,</span> <span class="n">vector</span> <span class="n">bool</span> <span class="o">(</span><span class="n">valence</span> <span class="n">g</span><span class="o">)</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span>
<span class="o">(</span><span class="n">input</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">gates</span><span class="o">,</span> <span class="n">vector</span> <span class="n">bits</span> <span class="o">(</span><span class="n">valence</span> <span class="n">g</span><span class="o">))</span>
<span class="o">(</span><span class="n">output</span> <span class="o">:</span> <span class="n">gates</span> <span class="bp">→</span> <span class="n">bits</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">mknot</span> <span class="o">:</span> <span class="n">network</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">bits</span> <span class="o">:=</span> <span class="n">bool</span><span class="o">,</span>
  <span class="n">gates</span> <span class="o">:=</span> <span class="n">unit</span><span class="o">,</span>
  <span class="n">valence</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">valuation</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">v</span><span class="o">,</span> <span class="n">bnot</span> <span class="o">(</span><span class="n">v.get</span> <span class="mi">0</span><span class="o">),</span>
  <span class="n">input</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">ff</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">vector.nil</span><span class="o">,</span>
  <span class="n">output</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">}</span>
</code></pre></div>



<a name="257253418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257253418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257253418">(Oct 12 2021 at 18:53)</a>:</h4>
<p>if there were equivalent functions (to all the ones being used) that can operate on those fields, then that would work.</p>



<a name="257253545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257253545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257253545">(Oct 12 2021 at 18:53)</a>:</h4>
<p>And an assignment would look like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">assignment</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">network</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">n.bits</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span>
<span class="o">(</span><span class="n">valid</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="n">b</span><span class="o">,</span> <span class="n">n.output</span> <span class="n">g</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">n.valuation</span> <span class="n">g</span> <span class="o">((</span><span class="n">n.input</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">value</span><span class="o">)</span> <span class="bp">=</span> <span class="n">value</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>



<a name="257253713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257253713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257253713">(Oct 12 2021 at 18:55)</a>:</h4>
<p>but the reason i use lists is that such an implementation lends itself to optimization.</p>



<a name="257253964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257253964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257253964">(Oct 12 2021 at 18:56)</a>:</h4>
<p>This is for the abstract theory, where the lists get in the way. Once you have proofs about the abstract theory, the algorithm can be a refinement of it using lists and working in a special case where everything is finite and decidable</p>



<a name="257254092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257254092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257254092">(Oct 12 2021 at 18:57)</a>:</h4>
<p>fine.</p>



<a name="257254103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257254103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257254103">(Oct 12 2021 at 18:57)</a>:</h4>
<p>In fact, you will find that <code>vector</code> is not used much in mathlib, and there is some syntax sugar for <code>fin n -&gt; A</code> style lists</p>



<a name="257254202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257254202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257254202">(Oct 12 2021 at 18:58)</a>:</h4>
<p>I think it is in <code>data.matrix.notation</code>, you can write <code>![a, b, c]</code> to get a <code>fin 3 -&gt; A</code></p>



<a name="257254368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257254368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257254368">(Oct 12 2021 at 18:59)</a>:</h4>
<p>the reason i used vector was so that certain lists would have the same length.</p>



<a name="257254555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257254555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257254555">(Oct 12 2021 at 19:00)</a>:</h4>
<p>It looks like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.matrix.notation</span>

<span class="kd">structure</span> <span class="n">network</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bits</span> <span class="n">gates</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">valence</span> <span class="o">:</span> <span class="n">gates</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">valuation</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">gates</span><span class="o">,</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">valence</span> <span class="n">g</span><span class="o">)</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span>
<span class="o">(</span><span class="n">input</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">gates</span><span class="o">,</span> <span class="n">fin</span> <span class="o">(</span><span class="n">valence</span> <span class="n">g</span><span class="o">)</span> <span class="bp">→</span> <span class="n">bits</span><span class="o">)</span>
<span class="o">(</span><span class="n">output</span> <span class="o">:</span> <span class="n">gates</span> <span class="bp">→</span> <span class="n">bits</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">mknot</span> <span class="o">:</span> <span class="n">network</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">bits</span> <span class="o">:=</span> <span class="n">bool</span><span class="o">,</span>
  <span class="n">gates</span> <span class="o">:=</span> <span class="n">unit</span><span class="o">,</span>
  <span class="n">valence</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">valuation</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">v</span><span class="o">,</span> <span class="n">bnot</span> <span class="o">(</span><span class="n">v</span> <span class="mi">0</span><span class="o">),</span>
  <span class="n">input</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="bp">!</span><span class="o">[</span><span class="n">ff</span><span class="o">],</span>
  <span class="n">output</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">}</span>

<span class="kd">structure</span> <span class="n">assignment</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">network</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">n.bits</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span>
<span class="o">(</span><span class="n">valid</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="n">b</span><span class="o">,</span> <span class="n">n.output</span> <span class="n">g</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">n.valuation</span> <span class="n">g</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">value</span> <span class="o">(</span><span class="n">n.input</span> <span class="n">g</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span> <span class="n">value</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>



<a name="257254617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257254617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257254617">(Oct 12 2021 at 19:00)</a>:</h4>
<p><code>fin n -&gt; A</code> is also fixed length lists, but you can compose them easier than lists, just using function composition</p>



<a name="257254762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257254762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257254762">(Oct 12 2021 at 19:01)</a>:</h4>
<p>what is fin n?</p>



<a name="257254849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257254849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257254849">(Oct 12 2021 at 19:02)</a>:</h4>
<p>it is the set of natural numbers less than <code>n</code></p>



<a name="257254912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257254912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257254912">(Oct 12 2021 at 19:02)</a>:</h4>
<p>it's the canonical type with <code>n</code> elements</p>



<a name="257255016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257255016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257255016">(Oct 12 2021 at 19:03)</a>:</h4>
<p>ok</p>



<a name="257255076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257255076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257255076">(Oct 12 2021 at 19:03)</a>:</h4>
<p>What is <code>satnet</code> supposed to be?</p>



<a name="257255412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257255412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257255412">(Oct 12 2021 at 19:06)</a>:</h4>
<p>'satnet' is the type of a network of bitnodes and gatenodes. the name is due to the fact that any SAT instance can be used to build one.</p>



<a name="257255565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257255565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257255565">(Oct 12 2021 at 19:06)</a>:</h4>
<p>*and vice versa</p>



<a name="257258348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257258348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257258348">(Oct 12 2021 at 19:26)</a>:</h4>
<p>Here's a network which contains every SAT network as a sub-DAG:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">SAT</span>
<span class="kn">section</span>
<span class="kd">parameters</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">true</span> <span class="o">:</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">and</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">not</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>

<span class="kd">inductive</span> <span class="n">gate</span>
<span class="bp">|</span> <span class="n">true</span> <span class="o">:</span> <span class="n">gate</span>
<span class="bp">|</span> <span class="n">and</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">gate</span>
<span class="bp">|</span> <span class="n">not</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">gate</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">valence</span> <span class="o">:</span> <span class="n">gate</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">gate.true</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">gate.and</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">gate.not</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">valuation</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">gate</span><span class="o">,</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">valence</span> <span class="n">g</span><span class="o">)</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">gate.true</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">gate.and</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span> <span class="mi">0</span> <span class="bp">&amp;&amp;</span> <span class="n">v</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">gate.not</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="n">fin</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bnot</span> <span class="o">(</span><span class="n">v</span> <span class="mi">0</span><span class="o">)</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">input</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">gate</span><span class="o">,</span> <span class="n">fin</span> <span class="o">(</span><span class="n">valence</span> <span class="n">g</span><span class="o">)</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">gate.true</span> <span class="o">:=</span> <span class="bp">!</span><span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">gate.and</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">!</span><span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">gate.not</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">!</span><span class="o">[</span><span class="n">a</span><span class="o">]</span>

<span class="kd">inductive</span> <span class="n">output</span> <span class="o">:</span> <span class="n">gate</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">true</span> <span class="o">:</span> <span class="n">output</span> <span class="n">gate.true</span> <span class="n">formula.true</span>
<span class="bp">|</span> <span class="n">and</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">output</span> <span class="o">(</span><span class="n">gate.and</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">formula.and</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">not</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">output</span> <span class="o">(</span><span class="n">gate.not</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">formula.not</span> <span class="n">a</span><span class="o">)</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">network</span> <span class="o">:</span> <span class="n">network</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">bits</span> <span class="o">:=</span> <span class="n">formula</span><span class="o">,</span>
  <span class="n">gates</span> <span class="o">:=</span> <span class="n">gate</span><span class="o">,</span>
  <span class="n">valence</span> <span class="o">:=</span> <span class="n">valence</span><span class="o">,</span>
  <span class="n">valuation</span> <span class="o">:=</span> <span class="n">valuation</span><span class="o">,</span>
  <span class="n">input</span> <span class="o">:=</span> <span class="n">input</span><span class="o">,</span>
  <span class="n">output</span> <span class="o">:=</span> <span class="n">output</span> <span class="o">}</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">eval</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">formula.var</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">v</span>
<span class="bp">|</span> <span class="n">formula.true</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">formula.and</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eval</span> <span class="n">a</span> <span class="bp">&amp;&amp;</span> <span class="n">eval</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">formula.not</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bnot</span> <span class="o">(</span><span class="n">eval</span> <span class="n">a</span><span class="o">)</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">assignment</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">assignment</span> <span class="n">network</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">value</span> <span class="o">:=</span> <span class="n">eval</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">valid</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">b</span> <span class="n">out</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">out</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">end</span>
<span class="kd">end</span> <span class="n">SAT</span>
</code></pre></div>



<a name="257259472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257259472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257259472">(Oct 12 2021 at 19:34)</a>:</h4>
<p>what purpose does this serve?</p>



<a name="257263261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257263261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257263261">(Oct 12 2021 at 20:01)</a>:</h4>
<p>it might help to know what the algorithm does. <br>
what is does is construct a sequence of truth tables,  related to subsets of the gates, such that<br>
each subset and the next intersects<br>
each subset contains one gate that all the previous ones did not<br>
each table is maximal for the set it represents and compatible with the previous one, while the choice of which gate is used minimizes the size of the table <br>
and all the subsets together cover the entire network. <br>
this process generates the information to certify satisfiability<br>
then an entry in the last table is chosen, then in each previous one an entry compatible with the successive table is also chosen.<br>
this is how a particular solution is generated.</p>



<a name="257270633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Things%20for%20which%20there%20was%20no%20documentation%20i%20could%20find/near/257270633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Things.20for.20which.20there.20was.20no.20documentation.20i.20could.20find.html#257270633">(Oct 12 2021 at 20:54)</a>:</h4>
<p>the lack of directionality specifically allows for information to traverse the network in all directions, so each gate is like 'if the lines are not in an allowed state then the network's valuations are invalid'</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
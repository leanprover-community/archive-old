---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html">disjoint_nhds_finite_of_t2</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="219576517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219576517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219576517">(Dec 11 2020 at 08:33)</a>:</h4>
<p>Dear All,</p>
<p>is there a lemma extending the "T_2 property" of a topological space from two points to a <code>finset</code>?  I am thinking of something along the lines of the lemma below, but any essentially equivalent formulation would likely work!</p>
<p>Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.separation</span>
<span class="kn">import</span> <span class="n">data.finsupp</span>

<span class="c1">--instance (X : Type*) : has_zero (set X) := ⟨(∅ : set X)⟩</span>
<span class="c1">-- Lean complains:</span>
<span class="c1">-- invalid definition, a declaration named 'set.has_zero' has already been declared</span>

<span class="kd">lemma</span> <span class="n">disjoint_nhds_finset_of_t2</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">U</span> <span class="o">:</span> <span class="bp">@</span><span class="n">finsupp</span> <span class="n">X</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">⟨</span><span class="bp">∅</span><span class="o">⟩,</span>  <span class="c1">-- awkward: I think that this instance should be there...</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="o">(</span><span class="n">U</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">nhds</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">disjoint</span> <span class="o">(</span><span class="n">U</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="c">/-</span><span class="cm"> -- proof likely starting with</span>
<span class="cm">  generalize' hd : s.card = d,</span>
<span class="cm">  refine finset.induction_on s _ _,</span>
<span class="cm">-/</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219579745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219579745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219579745">(Dec 11 2020 at 09:10)</a>:</h4>
<p>Related to the above: is it possible define a function <code>f : X → X → set X × set X</code> with the property that, if <code>x ≠ y</code>, then <code>f x y = (U, V)</code> with <code>U</code> and <code>V</code> disjoint neighbourhoods of <code>x</code> and <code>y</code>?  In the sample below, <code>cases</code> complains:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">induction</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">recursor</span> <span class="bp">'</span><span class="n">Exists.dcases_on'</span> <span class="n">can</span> <span class="n">only</span> <span class="n">eliminate</span> <span class="n">into</span> <span class="kt">Prop</span>
</code></pre></div>
<p>I take this to mean that <code>cases</code> can only return stuff of Type <code>Prop</code>, but in this case would have to return something of Type <code>set X</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">disjoint_opens_pairs_of_t2</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">xy</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">set.univ</span><span class="o">,</span> <span class="n">set.univ</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="n">cases</span> <span class="n">t2_space.t2</span> <span class="n">x</span> <span class="n">y</span> <span class="n">xy</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219580072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219580072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219580072">(Dec 11 2020 at 09:13)</a>:</h4>
<p>(I realize that, depending on how <code>t2_space</code> is implemented, this might require the axiom of choice: I am happy to assume it!)</p>



<a name="219580538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219580538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219580538">(Dec 11 2020 at 09:19)</a>:</h4>
<p>yes, it is possible. Start by proving <code>\forall x y, \exists (UV : set X × set X), &lt;disjoint yada yada&gt;</code></p>



<a name="219580558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219580558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219580558">(Dec 11 2020 at 09:19)</a>:</h4>
<p>and then use <code>classical.some</code> on this proof to get the function</p>



<a name="219580684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219580684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219580684">(Dec 11 2020 at 09:20)</a>:</h4>
<p>Thanks for the suggestion: I will try!</p>



<a name="219580844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219580844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219580844">(Dec 11 2020 at 09:22)</a>:</h4>
<p>oh, actually I see there is a case disjunction, so I guess you want the proof to be <code>\forall x y, x != y -&gt; \exists (UV : set X × set X), &lt;disjoint yada yada&gt;</code>, and then the function is <code>\lam x y, if h : x = y then (univ, univ) else classical.some (proof x y h)</code></p>



<a name="219581465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219581465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219581465">(Dec 11 2020 at 09:29)</a>:</h4>
<p>The definition of <code>t2_space</code> seems to be exactly what I should prove, right?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">t2_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t2</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="bp">∃</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">u</span> <span class="bp">∧</span> <span class="n">is_open</span> <span class="n">v</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">u</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">v</span> <span class="bp">∧</span> <span class="n">u</span> <span class="bp">∩</span> <span class="n">v</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">)</span>
</code></pre></div>



<a name="219582901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219582901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219582901">(Dec 11 2020 at 09:46)</a>:</h4>
<p>Thank you, Mario!  The code below compiles and I think that it does what I want!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">pre_choice_opens</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">set</span> <span class="n">X</span><span class="o">),</span>
  <span class="n">is_open</span> <span class="n">U.1</span> <span class="bp">∧</span> <span class="n">is_open</span> <span class="n">U.2</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">U.1</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">U.2</span> <span class="bp">∧</span> <span class="n">U.1</span> <span class="bp">∩</span> <span class="n">U.2</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">xy</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="o">(</span><span class="n">t2_separation</span> <span class="n">xy</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span> <span class="n">Z</span><span class="o">⟩,</span>
  <span class="n">refine</span> <span class="o">⟨(</span><span class="n">U</span><span class="o">,</span> <span class="n">V</span><span class="o">),</span> <span class="n">Z</span><span class="o">⟩,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">t2_choice</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="o">(</span><span class="n">set.univ</span><span class="o">,</span> <span class="n">set.univ</span><span class="o">)</span> <span class="k">else</span> <span class="n">classical.some</span> <span class="o">(</span><span class="n">pre_choice_opens</span> <span class="n">X</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">t2_choice</span>
  <span class="c1">--  t2_choice : Π (X : Type u_2) [_inst_4 : topological_space X] [_inst_5 : t2_space X], X → X → set X × set X</span>
</code></pre></div>



<a name="219583068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219583068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219583068">(Dec 11 2020 at 09:48)</a>:</h4>
<p>I suggest actually making two definitions, for the two sets, and then three lemmas about the properties of the two sets (all unpacked from the <code>pre_choice_opens</code> proof)</p>



<a name="219583132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219583132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219583132">(Dec 11 2020 at 09:49)</a>:</h4>
<p>I think that I am misunderstanding: the two sets need to be disjoint: how can I define them separately?</p>



<a name="219589968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219589968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219589968">(Dec 11 2020 at 10:56)</a>:</h4>
<p>Mario, this kind of trick is really difficult for beginners (or even intermediate users like Damiano).</p>



<a name="219590035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219590035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219590035">(Dec 11 2020 at 10:57)</a>:</h4>
<p>Damanio, here are the definitions and statements. You need to understand <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.some">docs#classical.some</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.some_spec">docs#classical.some_spec</a>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.separation</span>
<span class="kd">noncomputable theory</span>

<span class="kn">open</span> <span class="n">topological_space</span> <span class="n">set</span> <span class="n">classical</span>

<span class="n">open_locale</span> <span class="n">classical</span>


<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">X</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">t2_open₁</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">univ</span> <span class="k">else</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">t2_separation</span> <span class="n">h</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">t2_open₂</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">univ</span> <span class="k">else</span> <span class="o">(</span><span class="n">some</span> <span class="bp">$</span> <span class="n">some_spec</span> <span class="bp">$</span> <span class="n">t2_separation</span> <span class="n">h</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">mem_t2_open₁</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t2_open₁</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">lemma</span> <span class="n">mem_t2_open₂</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">t2_open₂</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">lemma</span> <span class="n">disjoint_t2_open₁_t2_open₂</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">t2_open₁</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∩</span> <span class="n">t2_open₂</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="219590095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219590095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219590095">(Dec 11 2020 at 10:58)</a>:</h4>
<p>And it misses two lemmas saying both sets are open.</p>



<a name="219590142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219590142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219590142">(Dec 11 2020 at 10:58)</a>:</h4>
<p>I can give you the proofs if you get stuck, but this is an important exercise.</p>



<a name="219590327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219590327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219590327">(Dec 11 2020 at 11:00)</a>:</h4>
<p>The missing statements are</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_open_t2_open₁</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">t2_open₁</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">lemma</span> <span class="n">is_open_t2_open₂</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">t2_open₂</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="219590343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219590343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219590343">(Dec 11 2020 at 11:01)</a>:</h4>
<p>Let me give it a try!  Thanks!</p>



<a name="219590352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219590352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219590352">(Dec 11 2020 at 11:01)</a>:</h4>
<p>Note that all proofs are two to four lines long.</p>



<a name="219590658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219590658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219590658">(Dec 11 2020 at 11:02)</a>:</h4>
<p>Note also where is the "precondition" <code>x ≠ y</code>. You don't need it to talk about the open sets, and you don't need it in 4 lemmas out of 5.</p>



<a name="219590748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219590748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219590748">(Dec 11 2020 at 11:02)</a>:</h4>
<p>That's the key: you don't want to pass around proofs to talk about objects only when proving the crucial property.</p>



<a name="219590904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219590904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219590904">(Dec 11 2020 at 11:03)</a>:</h4>
<p>Ok, this concept is slowly creeping its way in me, although it is not easy for me to spot where I am making this error...</p>



<a name="219591318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219591318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219591318">(Dec 11 2020 at 11:05)</a>:</h4>
<p>I know it feels weird but only because you're usually lying to yourself. When you write computations on paper, it's not true that for each division you write a proof next to the division symbol. So you're doing the same thing as we do here: write first, apologize later.</p>



<a name="219591740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219591740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219591740">(Dec 11 2020 at 11:09)</a>:</h4>
<p>Note also the trick that junk values (this is how we call values returned when the precondition is not met) are not random, although Kevin loves to joke about returning 37. They are carefully chosen to maximize the number of lemmas that are unconditionnaly true. For instance here, returning the empty set would be a bad choice because <code>mem_t2_open₁</code> would need the precondition. Again we don't really care those lemmas are true in junk cases, but it does save some typing when applying them.</p>



<a name="219594293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219594293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219594293">(Dec 11 2020 at 11:32)</a>:</h4>
<p>This is my attempt with the first of the lemmas above: I am not even sure if I made progress or not...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mem_t2_open₁</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t2_open₁</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">t2_open₁</span><span class="o">,</span>
  <span class="n">split_ifs</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mem_univ</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="n">F</span> <span class="o">:=</span> <span class="o">(</span><span class="n">t2_separation</span> <span class="n">h</span><span class="o">),</span>
<span class="c1">--  obtain ⟨U, V, oU, oV, xU, yV, UV⟩ := (t2_separation h),</span>
  <span class="n">rw</span> <span class="n">mem_def</span><span class="o">,</span>
</code></pre></div>
<p>For me, the <code>some</code> is a wall that I cannot climb...</p>



<a name="219594370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219594370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219594370">(Dec 11 2020 at 11:33)</a>:</h4>
<p>I did identify the <code>_</code> in the underscore as <code>F</code>, though!  This is the only use that I have for the <code>obtain</code> line...</p>



<a name="219594371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219594371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219594371">(Dec 11 2020 at 11:33)</a>:</h4>
<p>Whenever you see a <code>some</code>, use <code>some_spec</code> with the same hypothesis given to <code>some</code></p>



<a name="219594385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219594385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219594385">(Dec 11 2020 at 11:33)</a>:</h4>
<p>Ah, I will try!  Thanks!</p>



<a name="219596882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219596882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219596882">(Dec 11 2020 at 12:00)</a>:</h4>
<p>This is a proof of the first lemma!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mem_t2_open₁</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t2_open₁</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">t2_open₁</span><span class="o">,</span>
  <span class="n">split_ifs</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mem_univ</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="o">(</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">t2_separation</span> <span class="n">h</span><span class="o">))</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">D</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">D</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Any comments are very welcome!  Especially since I do not really understand this proof (or rather, what it is that I am supposed to prove)!</p>



<a name="219596959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219596959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219596959">(Dec 11 2020 at 12:01)</a>:</h4>
<p>That's right. You can probably write it as something like <code>(some_spec (t2_separation h)).snd.2.2.1</code></p>



<a name="219597054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219597054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219597054">(Dec 11 2020 at 12:02)</a>:</h4>
<p>Basically, <code>some_spec (t2_separation h)</code> is a theorem that says <code>some (t2_separation h)</code> satisfies the property in the existential of <code>t2_separation h</code></p>



<a name="219597216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219597216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219597216">(Dec 11 2020 at 12:04)</a>:</h4>
<p>in this case, <code>some (t2_separation h)</code> is <code>t2_open₁ x y</code>, so <code>some_spec (t2_separation h)</code> says that <code>∃v : set α, is_open (t2_open₁ x y) ∧ is_open v ∧ x ∈ t2_open₁ x y ∧ y ∈ v ∧ t2_open₁ x y ∩ v = ∅)</code></p>



<a name="219597430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219597430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219597430">(Dec 11 2020 at 12:06)</a>:</h4>
<p>Ok, so it is giving a name to the "variable" open set that contains x and [properties involving y], without referring to y.  Is this a correct way of thinking about this?</p>



<a name="219597499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219597499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219597499">(Dec 11 2020 at 12:07)</a>:</h4>
<p>I find it a bit easier to understand if there is only one existential; Patrick's version uses <code>some</code> twice on the two existentials. If you use <code>some</code> on your <code>pre_choice_opens</code> proof instead of <code>t2_separation h</code> directly, the property you get out is something like <code>is_open (foo x y).1 ∧ is_open (foo x y).2 ∧ x ∈ (foo x y).1 ∧ y ∈ (foo x y).2 ∧ (foo x y).1 ∩ (foo x y).2 = ∅)</code>, where <code>foo x y</code> is a definition abbreviating <code>some (pre_choice_opens x y h)</code>. If you then define <code>t2_open₁ x y := (foo x y).1</code> and <code>t2_open₂ x y := (foo x y).2</code>, then you can simply observe that this is a conjunction of all the lemmas you want</p>



<a name="219597828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219597828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219597828">(Dec 11 2020 at 12:11)</a>:</h4>
<p>I think that the "nested" <code>some</code>s are now what I am trying to undo in the second lemma.  I will try to fill in the proofs with both approaches: I may learn <code>some</code>thing</p>



<a name="219600884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219600884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219600884">(Dec 11 2020 at 12:43)</a>:</h4>
<p>It took me a while, but here is a proof of lemma 2:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mem_t2_open₂</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">t2_open₂</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">t2_open₂</span><span class="o">,</span>
  <span class="n">split_ifs</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mem_univ</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">some_spec</span> <span class="o">(</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">t2_separation</span> <span class="n">h</span><span class="o">))</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">D</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">D</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219602553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219602553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219602553">(Dec 11 2020 at 13:01)</a>:</h4>
<p>The fact there are two existentials is indeed a bit unfortunate for a first exercise in using these ideas. The reason I did that is the existing lemma <code>t2_separation</code> is stated like that.</p>



<a name="219602727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219602727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219602727">(Dec 11 2020 at 13:02)</a>:</h4>
<p>My proofs were:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mem_t2_open₁</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t2_open₁</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">t2_open₁</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">some_spec</span> <span class="o">(</span><span class="n">t2_separation</span> <span class="n">h</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">op₁</span><span class="o">,</span> <span class="n">op₂</span><span class="o">,</span> <span class="n">x_in</span><span class="o">,</span> <span class="n">y_in</span><span class="o">,</span> <span class="n">hinter</span><span class="o">⟩,</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">t2_open₁</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span> <span class="n">using</span> <span class="n">T</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">mem_t2_open₂</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">t2_open₂</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">t2_open₂</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">some_spec</span> <span class="o">(</span><span class="n">some_spec</span> <span class="bp">$</span> <span class="n">t2_separation</span> <span class="n">h</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="bp">-</span><span class="o">,</span> <span class="bp">-</span><span class="o">,</span> <span class="bp">-</span><span class="o">,</span> <span class="n">y_in</span><span class="o">,</span> <span class="bp">-</span><span class="o">⟩,</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">t2_open₂</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span> <span class="n">using</span> <span class="n">y_in</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>In the first proof I named every pieces in the <code>rcases</code> for clarity, and in the second lemma I illustrate how to throw away unneeded pieces.</p>



<a name="219602982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219602982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219602982">(Dec 11 2020 at 13:05)</a>:</h4>
<p>Thanks for your proofs!  I also had all the terms in the <code>rcases ... ⟨_, _, _, D, _⟩</code> labeled, but then I dropped them, for obscurity!</p>



<a name="219603077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603077">(Dec 11 2020 at 13:06)</a>:</h4>
<p>Underscores do not drop them, it gives them awful names. Dashes drop them.</p>



<a name="219603130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603130">(Dec 11 2020 at 13:06)</a>:</h4>
<p>here is a proof of the next lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">disjoint_t2_open₁_t2_open₂</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">t2_open₁</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∩</span> <span class="n">t2_open₂</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">t2_open₂</span><span class="o">,</span>
  <span class="n">split_ifs</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span> <span class="n">h_1</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">unfold</span> <span class="n">t2_open₁</span><span class="o">,</span>
    <span class="n">split_ifs</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">some_spec</span> <span class="o">(</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">t2_separation</span> <span class="n">h</span><span class="o">))</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">E</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">E</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219603222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603222">(Dec 11 2020 at 13:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/disjoint_nhds_finite_of_t2/near/219603077">said</a>:</p>
<blockquote>
<p>Underscores do not drop them, it gives them awful names. Dashes drop them.</p>
</blockquote>
<p>Ah, I learned that</p>
<ol>
<li>I should pay more attention to the difference between <code>-</code> and <code>_</code>;</li>
<li>there <em>is</em> a difference between them!</li>
</ol>



<a name="219603298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603298">(Dec 11 2020 at 13:08)</a>:</h4>
<p>Ok, now try to prove that next lemma in two lines (one <code>rcases</code> and one more line).</p>



<a name="219603300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603300">(Dec 11 2020 at 13:08)</a>:</h4>
<p>Seeing your proofs, I could probably avoid <code>unfold</code>ing and separate the cases presciently...</p>



<a name="219603332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603332">(Dec 11 2020 at 13:08)</a>:</h4>
<p>I mean <code>disjoint_t2_open₁_t2_open₂</code></p>



<a name="219603383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603383">(Dec 11 2020 at 13:09)</a>:</h4>
<p>Yes, it is the next one in your/my list!</p>
<p>Except it is almost lunch time: I might do it in a bit!</p>
<p>Thanks for the exercises and the help!</p>



<a name="219603551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603551">(Dec 11 2020 at 13:10)</a>:</h4>
<p>No, it's what you called the next one, but you just pasted a proof that is 8 lines long.</p>



<a name="219603573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603573">(Dec 11 2020 at 13:10)</a>:</h4>
<p>I say make it 2 lines long now.</p>



<a name="219603583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603583">(Dec 11 2020 at 13:10)</a>:</h4>
<p>Ah, ok!</p>



<a name="219603622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603622">(Dec 11 2020 at 13:11)</a>:</h4>
<p>(sorry, I was still processing the <code>_</code> and <code>-</code>)</p>



<a name="219603762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603762">(Dec 11 2020 at 13:12)</a>:</h4>
<p>Actually you can make it one line long (without cheating by putting two tactics on the same line) if you go to 106 columns.</p>



<a name="219603875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603875">(Dec 11 2020 at 13:13)</a>:</h4>
<p>Oh, I can bring it down to 89 columns, but this is borderline obfuscation.</p>



<a name="219603957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219603957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219603957">(Dec 11 2020 at 13:14)</a>:</h4>
<p>I should really work now instead of playing with Lean.</p>



<a name="219604704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219604704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219604704">(Dec 11 2020 at 13:20)</a>:</h4>
<p>Admittedly, all this is trivial after seeing the definition of T2, so obfuscation is allowed:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_open_t2_open₂</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">t2_open₂</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">classical.em</span> <span class="bp">$</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">t2_open₂</span><span class="o">,</span> <span class="n">h</span><span class="o">])</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">t2_open₂</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span> <span class="n">using</span> <span class="o">(</span><span class="n">some_spec</span> <span class="bp">$</span> <span class="n">some_spec</span> <span class="bp">$</span> <span class="n">t2_separation</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>Ok, I'll go to work.</p>



<a name="219605557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219605557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219605557">(Dec 11 2020 at 13:29)</a>:</h4>
<p>I'll need time to process these two lines: for the moment, I will absorb the satisfaction that I could find <em>one</em> proof!</p>



<a name="219634141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219634141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219634141">(Dec 11 2020 at 17:21)</a>:</h4>
<p>I feel at the same time proud and ashamed: I managed to prove the statement about disjoint <code>finset</code>s having disjoint neighbourhoods... but not using <code>some</code>s...  sorry!  Below is the argument, in case people are interested!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.separation</span>
<span class="kd">noncomputable theory</span>

<span class="kn">open</span> <span class="n">topological_space</span> <span class="n">set</span> <span class="n">finset</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">lemma</span> <span class="n">finset_disjoint_point_opens_of_t2</span>
  <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">s</span> <span class="bp">→</span>
    <span class="bp">∃</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">),</span> <span class="o">(</span><span class="n">is_open</span> <span class="n">U</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">is_open</span> <span class="n">V</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">U</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">V</span> <span class="bp">∧</span> <span class="n">disjoint</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">generalize'</span> <span class="n">hd</span> <span class="o">:</span> <span class="n">s.card</span> <span class="bp">=</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">finset.induction_on</span> <span class="n">s</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">∅</span><span class="o">,</span> <span class="n">set.univ</span><span class="o">,</span> <span class="n">is_open_empty</span><span class="o">,</span> <span class="n">is_open_univ</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">set.mem_univ</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">set.disjoint_univ.mpr</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">rintros</span> <span class="n">a</span> <span class="n">t</span> <span class="n">ta</span> <span class="n">xxt</span> <span class="n">x</span> <span class="n">xt</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span> <span class="n">oU</span><span class="o">,</span> <span class="n">oV</span><span class="o">,</span> <span class="n">xU</span><span class="o">,</span> <span class="n">aV</span><span class="o">,</span> <span class="n">UV</span><span class="o">⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">t2_separation</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">x</span> <span class="n">a</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">t</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">xt</span> <span class="o">(</span><span class="n">mem_insert_of_mem</span> <span class="n">j</span><span class="o">),</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">Ui</span><span class="o">,</span> <span class="n">Vi</span><span class="o">,</span> <span class="n">oUi</span><span class="o">,</span> <span class="n">oVi</span><span class="o">,</span> <span class="n">xUi</span><span class="o">,</span> <span class="n">aVi</span><span class="o">,</span> <span class="n">UVi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">xxt</span> <span class="n">x</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">V</span> <span class="bp">∪</span> <span class="n">Ui</span><span class="o">,</span> <span class="n">U</span> <span class="bp">∩</span> <span class="n">Vi</span><span class="o">,</span> <span class="n">is_open_union</span> <span class="n">oV</span> <span class="n">oUi</span><span class="o">,</span> <span class="n">is_open_inter</span> <span class="n">oU</span> <span class="n">oVi</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">xU</span><span class="o">,</span> <span class="n">aVi</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">f</span> <span class="n">fi</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">fa</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">a</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">fa</span><span class="o">,</span> <span class="n">exact</span> <span class="n">set.mem_union_left</span> <span class="n">_</span> <span class="n">aV</span> <span class="o">},</span>
    <span class="n">apply</span> <span class="n">set.mem_union_right</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">xUi</span> <span class="n">f</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">mem_of_mem_insert_of_ne</span> <span class="n">fi</span> <span class="n">fa</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">disjoint.union_left</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.disjoint_of_subset_right</span> <span class="o">(</span><span class="n">set.inter_subset_right</span> <span class="n">U</span> <span class="n">Vi</span><span class="o">)</span> <span class="n">UVi</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="bp">@</span><span class="n">set.disjoint_of_subset_right</span> <span class="n">_</span> <span class="n">V</span> <span class="o">(</span><span class="n">U</span> <span class="bp">∩</span> <span class="n">Vi</span><span class="o">)</span> <span class="n">U</span> <span class="o">(</span><span class="n">set.inter_subset_left</span> <span class="n">U</span> <span class="n">Vi</span><span class="o">),</span>
      <span class="n">rw</span> <span class="n">set.inter_comm</span> <span class="n">at</span> <span class="n">UV</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">set.disjoint_iff_inter_eq_empty.mpr</span> <span class="n">UV</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">symmetry</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">ne_of_mem_of_not_mem</span> <span class="o">(</span><span class="n">mem_insert_self</span> <span class="n">a</span> <span class="n">t</span><span class="o">)</span> <span class="n">xt</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">finset_disjoint_finset_opens_of_t2</span>
  <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">disjoint</span> <span class="n">s</span> <span class="n">t</span> <span class="bp">→</span>
  <span class="bp">∃</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">),</span> <span class="o">(</span><span class="n">is_open</span> <span class="n">U</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">is_open</span> <span class="n">V</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">U</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">V</span><span class="o">)</span>
  <span class="bp">∧</span> <span class="n">disjoint</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">generalize'</span> <span class="n">hd</span> <span class="o">:</span> <span class="n">t.card</span> <span class="bp">=</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">finset.induction_on</span> <span class="n">t</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">f</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">set.univ</span><span class="o">,</span> <span class="bp">∅</span><span class="o">,</span> <span class="n">is_open_univ</span><span class="o">,</span> <span class="n">is_open_empty</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">set.mem_univ</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">set.univ_disjoint.mpr</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">S</span> <span class="n">xS</span> <span class="n">hi</span> <span class="n">sxS</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span> <span class="n">oU</span><span class="o">,</span> <span class="n">oV</span><span class="o">,</span> <span class="n">xU</span><span class="o">,</span> <span class="n">yV</span><span class="o">,</span> <span class="n">UV</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hi</span> <span class="o">(</span><span class="n">finset.disjoint_of_subset_right</span> <span class="o">(</span><span class="n">subset_insert</span> <span class="n">x</span> <span class="n">S</span><span class="o">)</span> <span class="n">sxS</span><span class="o">),</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">Ui</span><span class="o">,</span> <span class="n">Vi</span><span class="o">,</span> <span class="n">oUi</span><span class="o">,</span> <span class="n">oVi</span><span class="o">,</span> <span class="n">xUi</span><span class="o">,</span> <span class="n">aVi</span><span class="o">,</span> <span class="n">UiVi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">finset_disjoint_point_opens_of_t2</span> <span class="n">s</span> <span class="n">x</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">U</span> <span class="bp">∩</span> <span class="n">Ui</span><span class="o">,</span> <span class="n">V</span> <span class="bp">∪</span> <span class="n">Vi</span><span class="o">,</span> <span class="n">is_open_inter</span> <span class="n">oU</span> <span class="n">oUi</span><span class="o">,</span> <span class="n">is_open_union</span> <span class="n">oV</span> <span class="n">oVi</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="o">{</span> <span class="n">refine</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">as</span><span class="o">,</span> <span class="o">⟨</span><span class="n">xU</span> <span class="n">a</span> <span class="n">as</span><span class="o">,</span> <span class="n">xUi</span> <span class="n">a</span> <span class="n">as</span><span class="o">⟩</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">intros</span> <span class="n">f</span> <span class="n">fi</span><span class="o">,</span>
        <span class="n">by_cases</span> <span class="n">fx</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">subst</span> <span class="n">fx</span><span class="o">,</span> <span class="n">apply</span> <span class="n">set.mem_union_right</span> <span class="n">_</span> <span class="n">aVi</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">exact</span> <span class="n">Vi.mem_union_left</span> <span class="o">(</span><span class="n">yV</span> <span class="n">f</span> <span class="o">(</span><span class="n">mem_of_mem_insert_of_ne</span> <span class="n">fi</span> <span class="n">fx</span><span class="o">))</span> <span class="o">}</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">apply</span> <span class="n">disjoint.union_right</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">exact</span> <span class="n">set.disjoint_of_subset_left</span> <span class="o">(</span><span class="n">set.inter_subset_left</span> <span class="n">U</span> <span class="n">Ui</span><span class="o">)</span> <span class="n">UV</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">exact</span> <span class="n">set.disjoint_of_subset_left</span> <span class="o">(</span><span class="n">set.inter_subset_right</span> <span class="n">U</span> <span class="n">Ui</span><span class="o">)</span> <span class="n">UiVi</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">disjoint_insert_right.mp</span> <span class="n">sxS</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219651382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219651382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219651382">(Dec 11 2020 at 19:32)</a>:</h4>
<p>.</p>



<a name="219691963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219691963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219691963">(Dec 12 2020 at 05:45)</a>:</h4>
<p>In case this is not already in mathlib and people think that this is a useful addition, I can make a PR with this proof!<br>
<span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="219692149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219692149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219692149">(Dec 12 2020 at 05:51)</a>:</h4>
<p>I guess there's al ultrafilter-centric analogue of this statement too... (analogous to <a href="https://leanprover-community.github.io/mathlib_docs/find/t2_iff_ultrafilter">docs#t2_iff_ultrafilter</a> )</p>



<a name="219692215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219692215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219692215">(Dec 12 2020 at 05:53)</a>:</h4>
<p>I did not learn about ultrafilters yet: I will make this PR and see if there is interest in more!</p>



<a name="219692283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219692283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219692283">(Dec 12 2020 at 05:54)</a>:</h4>
<p>But maybe it's not that interesting... I guess it would say, approximately, that given any two disjoint finite sets <code>S</code> and <code>T</code>, any ultrafilter which converges to a point in <code>S</code> cannot converge to any point in <code>T</code>.</p>



<a name="219692354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219692354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219692354">(Dec 12 2020 at 05:56)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> I didn't like ultrafilters at first, but then I realized that one should think of them like algebraic geometers think of valuation rings, and now I love them!</p>



<a name="219692373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219692373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219692373">(Dec 12 2020 at 05:57)</a>:</h4>
<p>Ah, as I am not familiar with filters/ultrafilters, I unconsciously try to avoid them.  Your comment makes me want to dive into them, though!  Thanks!</p>



<a name="219692586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219692586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219692586">(Dec 12 2020 at 06:03)</a>:</h4>
<p>(The analogy breaks down after a while, but it's a good approximation <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> )</p>



<a name="219693597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219693597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219693597">(Dec 12 2020 at 06:33)</a>:</h4>
<p>Done!<br>
<a href="https://github.com/leanprover-community/mathlib/issues/5332">#5332</a></p>
<p>Let's see if Lean also likes it!</p>



<a name="219721782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219721782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219721782">(Dec 12 2020 at 18:50)</a>:</h4>
<p>The code below proves the same existence of disjoint open sets containing disjoint finsets.  It is slightly longer than the other proof, however it seems more streamlined: should I update the previous PR or, by proof-irrelevance, the shorter the proof, the better?</p>
<p>Here, short is only measured in terms of lines, not of anything more objective.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.separation</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kd">lemma</span> <span class="n">finset_ind_card_empty</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">},</span> <span class="n">P</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">basea0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span><span class="o">},</span> <span class="n">P</span> <span class="n">a</span> <span class="bp">∅</span><span class="o">)</span>
  <span class="o">(</span><span class="n">base11</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">},</span> <span class="n">P</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span><span class="o">})</span>
  <span class="o">(</span><span class="n">indu</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">P</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∪</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">finset.induction_on</span> <span class="n">b</span> <span class="n">basea0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">s</span> <span class="n">xs</span> <span class="n">hi</span><span class="o">,</span> <span class="n">symm</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">finset.insert_eq</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">indu</span> <span class="n">_</span> <span class="o">(</span><span class="n">symm</span> <span class="n">hi</span><span class="o">),</span>
  <span class="n">refine</span> <span class="n">finset.induction_on</span> <span class="n">a</span> <span class="n">basea0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">t</span> <span class="n">ta</span> <span class="n">hi</span><span class="o">,</span> <span class="n">symm</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">finset.insert_eq</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">indu</span> <span class="n">base11</span> <span class="o">(</span><span class="n">symm</span> <span class="n">hi</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">dis</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="n">disjoint</span> <span class="n">s</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">is_open</span> <span class="n">U</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">is_open</span> <span class="n">V</span> <span class="bp">∧</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">U</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">V</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">disjoint</span> <span class="n">U</span> <span class="n">V</span>

<span class="kd">lemma</span> <span class="n">dis_symm</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">dis</span> <span class="n">s</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">dis</span> <span class="n">t</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
 <span class="n">intros</span> <span class="n">h1</span> <span class="n">d</span><span class="o">,</span>
 <span class="n">unfold</span> <span class="n">dis</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
 <span class="n">obtain</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span> <span class="n">oU</span><span class="o">,</span> <span class="n">oV</span><span class="o">,</span> <span class="n">aU</span><span class="o">,</span> <span class="n">bV</span><span class="o">,</span> <span class="n">UV</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h1</span> <span class="o">(</span><span class="n">disjoint.symm</span> <span class="n">d</span><span class="o">),</span>
 <span class="n">exact</span> <span class="o">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">oV</span><span class="o">,</span> <span class="n">oU</span><span class="o">,</span> <span class="n">bV</span><span class="o">,</span> <span class="n">aU</span><span class="o">,</span> <span class="n">disjoint.symm</span> <span class="n">UV</span><span class="o">⟩</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">dis_basea0</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">},</span> <span class="n">dis</span> <span class="n">a</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">d</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">is_open_univ</span><span class="o">,</span> <span class="n">is_open_empty</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span> <span class="n">mem_univ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">disjoint_empty</span> <span class="n">_</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">dis_base11</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">dis</span> <span class="o">({</span><span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">forall_eq</span><span class="o">,</span> <span class="n">finset.mem_singleton</span><span class="o">,</span> <span class="n">disjoint_iff_inter_eq_empty</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">t2_separation</span> <span class="o">(</span><span class="n">finset.not_mem_singleton.mp</span> <span class="o">(</span><span class="n">finset.disjoint_singleton.mp</span> <span class="o">(</span><span class="n">disjoint.comm.mp</span> <span class="n">d</span><span class="o">))),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">dis_indu</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">},</span> <span class="n">dis</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">dis</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">dis</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∪</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">ac</span> <span class="n">bc</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">U1</span><span class="o">,</span> <span class="n">V1</span><span class="o">,</span> <span class="n">oU1</span><span class="o">,</span> <span class="n">oV1</span><span class="o">,</span> <span class="n">aU1</span><span class="o">,</span> <span class="n">bV1</span><span class="o">,</span> <span class="n">UV1</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ac</span> <span class="o">(</span><span class="n">finset.disjoint_of_subset_left</span> <span class="o">(</span><span class="n">finset.subset_union_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">d</span><span class="o">),</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">U2</span><span class="o">,</span> <span class="n">V2</span><span class="o">,</span> <span class="n">oU2</span><span class="o">,</span> <span class="n">oV2</span><span class="o">,</span> <span class="n">aU2</span><span class="o">,</span> <span class="n">bV2</span><span class="o">,</span> <span class="n">UV2</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">bc</span> <span class="o">(</span><span class="n">finset.disjoint_of_subset_left</span> <span class="o">(</span><span class="n">finset.subset_union_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">d</span><span class="o">),</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">U1</span> <span class="bp">∪</span> <span class="n">U2</span><span class="o">,</span> <span class="n">V1</span> <span class="bp">∩</span> <span class="n">V2</span><span class="o">,</span> <span class="n">is_open_union</span> <span class="n">oU1</span> <span class="n">oU2</span><span class="o">,</span> <span class="n">is_open_inter</span> <span class="n">oV1</span> <span class="n">oV2</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">xab</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">xc</span><span class="o">,</span> <span class="o">⟨</span><span class="n">bV1</span> <span class="n">_</span> <span class="n">xc</span><span class="o">,</span> <span class="n">bV2</span> <span class="n">_</span> <span class="n">xc</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">finset.mem_union.mp</span> <span class="n">xab</span> <span class="k">with</span> <span class="n">h</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">mem_union_left</span> <span class="n">U2</span> <span class="o">(</span><span class="n">aU1</span> <span class="n">x</span> <span class="n">h</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">mem_union_right</span> <span class="n">U1</span> <span class="o">(</span><span class="n">aU2</span> <span class="n">x</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">disjoint_union_left.mpr</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">disjoint_of_subset_right</span> <span class="o">(</span><span class="n">inter_subset_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">UV1</span><span class="o">,</span> <span class="n">disjoint_of_subset_right</span> <span class="o">(</span><span class="n">inter_subset_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">UV2</span><span class="o">⟩</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">disjoint_finset_t2</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="n">dis</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">finset_ind_card_empty</span> <span class="n">dis</span> <span class="n">dis_symm</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">dis_basea0</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">dis_base11</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">dis_indu</span><span class="o">)</span>
</code></pre></div>



<a name="219722018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219722018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219722018">(Dec 12 2020 at 18:56)</a>:</h4>
<p><del>Also, why in the last proof, I need to use the underscores?  I would have wanted to use <code>dis_basea0</code> and the others, just like I did <code>dis_symm</code>, but I cannot understand why Lean does not like it.</del></p>



<a name="219722038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219722038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219722038">(Dec 12 2020 at 18:56)</a>:</h4>
<p>Probably <code>dis_basea0</code> takes some extra arguments which <code>apply</code> automatically figures out - similarly if you change the <code>apply dis_basea0</code> to <code>refine disbasea0</code>, it'll probably fail</p>



<a name="219722067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219722067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219722067">(Dec 12 2020 at 18:57)</a>:</h4>
<p>You can use <code>show_term {apply dis_basea0}</code> to see what you could use in place of that refine, and then put that instead of the underscore</p>



<a name="219722110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219722110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219722110">(Dec 12 2020 at 18:58)</a>:</h4>
<p>Thanks!  I fixed the first two: I am still not entirely sure what it is, but the new version works!</p>



<a name="219722469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219722469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219722469">(Dec 12 2020 at 19:07)</a>:</h4>
<p>I had tried <code>show_term</code> but it gives something that does not work.  If I remember correctly, it said <code>exact dis_basea0</code>.</p>



<a name="219744719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/219744719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#219744719">(Dec 13 2020 at 05:09)</a>:</h4>
<p>I pushed a more conceptual argument.</p>
<ol>
<li>On pairs <code>finset</code>s, I added an explicit induction.</li>
<li>On <code>topological_space</code>, I added a general lemma that to show separation of <code>finset</code>s it suffices to show separation of singletons.</li>
<li>Finally, the <code>t2_space</code> assumption is all that is needed to show the required separation!</li>
</ol>



<a name="220093635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220093635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220093635">(Dec 16 2020 at 09:29)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span>  I don't even see <code>disjoint_finsets_opens_of_t2</code> in the current state of the PR.</p>



<a name="220105693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220105693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220105693">(Dec 16 2020 at 11:47)</a>:</h4>
<p>As pointed out by Johan, I think the definition <code>separate</code> doesn't make sense. You should have removed the disjointness assumption from there and move it to the main lemma. And if we need that definition at all then it should be about any sets, not only finite ones. That said I don't think we need it now. You can state your end goal as </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">t2_separation_finsets</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">is_open</span> <span class="n">V</span> <span class="bp">∧</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="n">U</span> <span class="bp">∧</span> <span class="bp">↑</span><span class="n">t</span> <span class="bp">⊆</span> <span class="n">V</span> <span class="bp">∧</span> <span class="n">U</span> <span class="bp">∩</span> <span class="n">V</span> <span class="bp">=</span> <span class="bp">∅</span>
</code></pre></div>



<a name="220105742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220105742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220105742">(Dec 16 2020 at 11:47)</a>:</h4>
<p>And I think it's worth the trouble of also stating the intermediate lemma</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">t2_separation_point_finset</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">is_open</span> <span class="n">V</span> <span class="bp">∧</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">V</span> <span class="bp">∧</span> <span class="n">U</span> <span class="bp">∩</span> <span class="n">V</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
</code></pre></div>
<p>since it makes sense to know it independently.</p>



<a name="220105813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220105813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220105813">(Dec 16 2020 at 11:48)</a>:</h4>
<p>I think you are right that they key is to have relevant induction lemmas for finsets. But I think the one you chose is not the most relevant one.</p>



<a name="220105885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220105885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220105885">(Dec 16 2020 at 11:49)</a>:</h4>
<p>The key feature of these topological lemmas is they are about disjoint points and finsets. So I propose to prove:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">finset.induction_disjoint_point</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">∅</span><span class="o">)</span> <span class="o">(</span><span class="n">hrec</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">x</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">x</span> <span class="o">(</span><span class="n">insert</span> <span class="n">y</span> <span class="n">s</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">x</span> <span class="n">s</span>

<span class="kd">lemma</span> <span class="n">finset.induction_disjoint</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="n">s</span> <span class="bp">∅</span><span class="o">)</span> <span class="o">(</span><span class="n">hrec</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">t</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span> <span class="o">(</span><span class="n">insert</span> <span class="n">x</span> <span class="n">t</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">t</span><span class="o">,</span> <span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span> <span class="n">t</span>
</code></pre></div>
<p>which should be straightforward applications of <code>finset.induction_on</code>.</p>



<a name="220105959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220105959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220105959">(Dec 16 2020 at 11:50)</a>:</h4>
<p>and then use them to prove the two topological lemmas (the second topological lemma using the first one of course).</p>



<a name="220106169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220106169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220106169">(Dec 16 2020 at 11:53)</a>:</h4>
<p>Do you want help or are you still happy to learn stuff using this example?</p>



<a name="220115665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220115665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220115665">(Dec 16 2020 at 13:38)</a>:</h4>
<p>Ah, I found out now your comments here, but I just pushed a new version.  I will now read and merge your comments!</p>



<a name="220115944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220115944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220115944">(Dec 16 2020 at 13:41)</a>:</h4>
<p>I am happy to try your suggestion out.  Should you find that pointing me in the right direction becomes more work for you than to simply do it yourself, please say so!</p>



<a name="220116252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220116252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220116252">(Dec 16 2020 at 13:44)</a>:</h4>
<p>One quick question: I am happy to go with either <code>disjoint a b</code> or <code>a ∩ b = ∅</code>.<br>
Is there any particular reason to prefer one over the other?</p>



<a name="220116353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220116353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220116353">(Dec 16 2020 at 13:45)</a>:</h4>
<p>One should prefer the version which shows up more in mathlib -- this will be the version deemed "canonical", so the one which the simp lemmas will mention etc</p>



<a name="220116661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220116661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220116661">(Dec 16 2020 at 13:48)</a>:</h4>
<p>a regexp search for <code>.* ∩ .* = ∅</code> gives only three hits, and <code>disjoint</code> has 99 hits</p>



<a name="220116903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220116903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220116903">(Dec 16 2020 at 13:50)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="n">s</span> <span class="n">t</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span><span class="o">},</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">library_search</span> <span class="c1">-- works</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span><span class="o">},</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">library_search</span> <span class="c1">-- fails</span>
<span class="kd">end</span>
</code></pre></div>
<p>I would use <code>disjoint</code>.</p>



<a name="220117067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220117067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220117067">(Dec 16 2020 at 13:51)</a>:</h4>
<p>Ok, I will keep <code>disjoint</code>, then!</p>



<a name="220127731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220127731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220127731">(Dec 16 2020 at 15:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/disjoint_nhds_finite_of_t2/near/220115944">said</a>:</p>
<blockquote>
<p>Should you find that pointing me in the right direction becomes more work for you than to simply do it yourself, please say so!</p>
</blockquote>
<p>This is not at all how I see it. I claim it's important that many mathematicians learn how to use a proof assistant, with the distant goal that one day proof assistants will be useful tools for mathematics. Hence I'm happy to spend some time helping other mathematicians to learn. My goal here isn't to get more lemmas about T2 spaces into mathlib as quickly as possible.</p>



<a name="220128126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220128126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220128126">(Dec 16 2020 at 15:17)</a>:</h4>
<p>Looking at the latest version of the PR, I see that using your union induction principle is actually quite efficient, so maybe I was wrong about the most relevant induction lemmas here. I still claim:</p>
<ul>
<li>my two induction principles for finsets could be useful, so it would be nice to have them</li>
<li>you should define <code>separate</code> for arbitrary sets, and maybe rename it to <code>separated</code>, the current version sounds grammatically weird (but I'm not a native speaker)</li>
</ul>



<a name="220128261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220128261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220128261">(Dec 16 2020 at 15:18)</a>:</h4>
<ul>
<li>The version where one point is separated from a finset is also worth spelling out (you can deduce it from the version separating two finsets of course)</li>
</ul>



<a name="220128772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220128772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220128772">(Dec 16 2020 at 15:22)</a>:</h4>
<p>I have another exercise for you, related to your proof and a question you asked recently. I see from your proofs that we have a lemma <code>is_open_union</code>, that you use as <code>is_open_union oU oW</code>. This is a waste of typing. It should be <code>oU.union oW</code> which is shorter and looks nice. It means someone needs to rename <code>is_open_union</code> to <code>is_open.union</code> and then fix mathlib, enjoying all the shorten proofs on the way. The same holds for <code>is_open_inter</code>, <code>is_closed_union</code> and <code>is_closed_inter</code>. This can be a separate PR. The main goal here is to increase your understanding of the dot notation magic.</p>



<a name="220129045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220129045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220129045">(Dec 16 2020 at 15:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/disjoint_nhds_finite_of_t2/near/220116661">said</a>:</p>
<blockquote>
<p>a regexp search for <code>.* ∩ .* = ∅</code> gives only three hits, and <code>disjoint</code> has 99 hits</p>
</blockquote>
<p>This means the definition of <code>t2_space</code> and surrounding lemmas should change.</p>



<a name="220135235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220135235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220135235">(Dec 16 2020 at 16:11)</a>:</h4>
<p>Dear Patrick,</p>
<p>I have finished the earlier exercise, here is a solution (the <code>_1</code> in the names are an artifact, since I had them in the file <code>topology.separation</code> and for the purpose of posting here, I wanted to make sure that I avoided circularity):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.separation</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">classical.prop_decidable</span>

<span class="kd">universes</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span>


<span class="kd">lemma</span> <span class="n">finset.induction_disjoint_point_1</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">∅</span><span class="o">)</span> <span class="o">(</span><span class="n">hrec</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">x</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">x</span> <span class="o">(</span><span class="n">insert</span> <span class="n">y</span> <span class="n">s</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">x</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">finset.induction_on</span> <span class="n">s</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">t</span> <span class="n">ta</span> <span class="n">iP</span> <span class="n">xat</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">apply</span> <span class="n">hrec</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">exact</span> <span class="n">xat</span> <span class="o">(</span><span class="n">finset.mem_insert_self</span> <span class="n">_</span> <span class="n">t</span><span class="o">)</span> <span class="o">})</span> <span class="o">(</span><span class="n">iP</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)),</span>
  <span class="n">exact</span> <span class="n">xat</span> <span class="o">(</span><span class="n">finset.mem_insert_of_mem</span> <span class="n">_x</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">finset.induction_disjoint_1</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="n">s</span> <span class="bp">∅</span><span class="o">)</span> <span class="o">(</span><span class="n">hrec</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">t</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span> <span class="o">(</span><span class="n">insert</span> <span class="n">x</span> <span class="n">t</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">t</span><span class="o">,</span> <span class="n">disjoint</span> <span class="n">s</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">finset.induction_on</span> <span class="n">t</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">h</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">u</span> <span class="n">au</span> <span class="n">hP</span> <span class="n">sau</span><span class="o">,</span> <span class="n">hrec</span> <span class="n">a</span> <span class="n">u</span> <span class="o">(</span><span class="n">finset.disjoint_insert_right.mp</span> <span class="n">sau</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">hP</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">finset.disjoint_of_subset_right</span> <span class="o">(</span><span class="n">finset.subset_insert</span> <span class="n">a</span> <span class="n">u</span><span class="o">)</span> <span class="n">sau</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">t2_separation_point_finset_1</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">is_open</span> <span class="n">V</span> <span class="bp">∧</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">V</span> <span class="bp">∧</span> <span class="n">U</span> <span class="bp">∩</span> <span class="n">V</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">revert</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">finset.induction_disjoint_point</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">s</span> <span class="n">xy</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">is_open_empty</span><span class="o">,</span> <span class="n">is_open_univ</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,</span> <span class="n">mem_univ</span> <span class="n">x</span><span class="o">,</span> <span class="n">inter_univ</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span> <span class="n">oU</span><span class="o">,</span> <span class="n">oV</span><span class="o">,</span> <span class="n">aU</span><span class="o">,</span> <span class="n">bV</span><span class="o">,</span> <span class="n">UV</span><span class="o">⟩,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">Uy</span><span class="o">,</span> <span class="n">Vx</span><span class="o">,</span> <span class="n">oUy</span><span class="o">,</span> <span class="n">oVx</span><span class="o">,</span> <span class="n">aUy</span><span class="o">,</span> <span class="n">bVx</span><span class="o">,</span> <span class="n">UyVx</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">t2_separation</span> <span class="n">xy.symm</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">U</span> <span class="bp">∪</span> <span class="n">Uy</span><span class="o">,</span> <span class="n">V</span> <span class="bp">∩</span> <span class="n">Vx</span><span class="o">,</span> <span class="n">is_open_union</span> <span class="n">oU</span> <span class="n">oUy</span><span class="o">,</span> <span class="n">is_open_inter</span> <span class="n">oV</span> <span class="n">oVx</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">bV</span><span class="o">,</span> <span class="n">bVx</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.coe_insert</span><span class="o">,</span> <span class="bp">←</span> <span class="n">union_singleton</span><span class="o">,</span> <span class="n">union_subset_iff</span><span class="o">],</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">subset_union_of_subset_left</span> <span class="n">aU</span> <span class="n">_</span><span class="o">,</span>
        <span class="n">subset_union_of_subset_right</span> <span class="o">(</span><span class="n">set.singleton_subset_iff.mpr</span> <span class="n">aUy</span><span class="o">)</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">union_inter_distrib_right</span><span class="o">,</span> <span class="bp">←</span> <span class="n">set.inter_assoc</span><span class="o">,</span> <span class="n">UV</span><span class="o">,</span> <span class="n">set.empty_inter</span> <span class="n">_</span><span class="o">,</span> <span class="n">set.empty_union</span><span class="o">],</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">set.inter_comm</span> <span class="n">V</span> <span class="n">_</span><span class="o">,</span> <span class="bp">←</span> <span class="n">set.inter_assoc</span><span class="o">,</span> <span class="n">UyVx</span><span class="o">,</span> <span class="n">set.empty_inter</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">t2_separation_finsets_1</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">t</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">is_open</span> <span class="n">V</span> <span class="bp">∧</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="n">U</span> <span class="bp">∧</span> <span class="bp">↑</span><span class="n">t</span> <span class="bp">⊆</span> <span class="n">V</span> <span class="bp">∧</span> <span class="n">U</span> <span class="bp">∩</span> <span class="n">V</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">symmetry'</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">finset.induction_disjoint</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">u</span> <span class="n">yt</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">is_open_empty</span><span class="o">,</span> <span class="n">is_open_univ</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,</span> <span class="n">subset_univ</span> <span class="n">_</span><span class="o">,</span> <span class="n">inter_univ</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span> <span class="n">oU</span><span class="o">,</span> <span class="n">oV</span><span class="o">,</span> <span class="n">aU</span><span class="o">,</span> <span class="n">bV</span><span class="o">,</span> <span class="n">UV</span><span class="o">⟩,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">Ut</span><span class="o">,</span> <span class="n">Vy</span><span class="o">,</span> <span class="n">oUt</span><span class="o">,</span> <span class="n">oVy</span><span class="o">,</span> <span class="n">aUt</span><span class="o">,</span> <span class="n">bVy</span><span class="o">,</span> <span class="n">UtVy</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">t2_separation_point_finset</span> <span class="n">yt</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">U</span> <span class="bp">∪</span> <span class="n">Vy</span><span class="o">,</span> <span class="n">V</span> <span class="bp">∩</span> <span class="n">Ut</span><span class="o">,</span> <span class="n">is_open_union</span> <span class="n">oU</span> <span class="n">oVy</span><span class="o">,</span> <span class="n">is_open_inter</span> <span class="n">oV</span> <span class="n">oUt</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.coe_insert</span><span class="o">,</span> <span class="bp">←</span> <span class="n">union_singleton</span><span class="o">,</span> <span class="n">union_subset_iff</span><span class="o">],</span>
        <span class="n">refine</span> <span class="o">⟨</span><span class="n">subset_union_of_subset_left</span> <span class="n">aU</span> <span class="n">_</span><span class="o">,</span>
          <span class="n">subset_union_of_subset_right</span> <span class="o">(</span><span class="n">set.singleton_subset_iff.mpr</span> <span class="n">bVy</span><span class="o">)</span> <span class="n">U</span><span class="o">⟩</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">subset_inter_iff.mpr</span> <span class="o">⟨</span><span class="n">bV</span><span class="o">,</span> <span class="n">aUt</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">union_inter_distrib_right</span><span class="o">,</span> <span class="bp">←</span> <span class="n">set.inter_assoc</span><span class="o">,</span> <span class="n">UV</span><span class="o">,</span> <span class="n">set.empty_inter</span> <span class="n">_</span><span class="o">,</span> <span class="n">set.empty_union</span><span class="o">],</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">set.inter_comm</span> <span class="n">V</span> <span class="n">_</span><span class="o">,</span> <span class="bp">←</span> <span class="n">set.inter_assoc</span><span class="o">,</span> <span class="n">set.inter_comm</span> <span class="n">_</span> <span class="n">Ut</span><span class="o">,</span> <span class="n">UtVy</span><span class="o">,</span> <span class="n">set.empty_inter</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="220135735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220135735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220135735">(Dec 16 2020 at 16:13)</a>:</h4>
<p>I was indeed going to say that this solution does not look prettier than what I had before, but I also have not polished it as much!  By "proof irrelevance", I am tempted to maintain the older version, if you agree!  Especially since it already develops a little API around <code>separate</code>.</p>
<p>I will change the name <code>separate</code> to <code>separated</code> and make it take <code>set</code>s instead of <code>finsets</code> as inputs.</p>
<p>After that, I will read again your comments and see what else I missed!</p>



<a name="220136913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220136913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220136913">(Dec 16 2020 at 16:21)</a>:</h4>
<p>I do run into the issue of converting a <code>finset</code> into a <code>set</code>: is there a standard way?</p>



<a name="220137285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220137285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220137285">(Dec 16 2020 at 16:23)</a>:</h4>
<p>(deleted)</p>



<a name="220137498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220137498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220137498">(Dec 16 2020 at 16:25)</a>:</h4>
<p>This seems to work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span>  <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span>
</code></pre></div>



<a name="220137800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220137800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220137800">(Dec 16 2020 at 16:27)</a>:</h4>
<p>There seems to be a coercion:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">s</span>
</code></pre></div>



<a name="220137924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220137924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220137924">(Dec 16 2020 at 16:28)</a>:</h4>
<p>I tried with the uparrow, but it did not seem to work for me...</p>



<a name="220138032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220138032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220138032">(Dec 16 2020 at 16:28)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">↑</span><span class="n">s</span>
</code></pre></div>



<a name="220138112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220138112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220138112">(Dec 16 2020 at 16:29)</a>:</h4>
<p>Ah, if I tell Lean what Type it should have, it works!  Thanks!</p>



<a name="220138177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220138177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220138177">(Dec 16 2020 at 16:29)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="n">disjoint</span> <span class="n">s</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">separated</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="n">t</span> <span class="o">:=</span>
</code></pre></div>
<p>(Now separated takes <code>sets</code> as inputs)</p>



<a name="220138502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220138502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220138502">(Dec 16 2020 at 16:31)</a>:</h4>
<p>You could also state this as a theorem about <code>finite</code> sets</p>



<a name="220138542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220138542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220138542">(Dec 16 2020 at 16:31)</a>:</h4>
<p>if you don't use anything about the finset besides the fact that it coerces to set</p>



<a name="220138812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220138812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220138812">(Dec 16 2020 at 16:33)</a>:</h4>
<p>Ah, I have always glossed over the distinction between <code>finsets</code> and <code>finite</code>.  Maybe this is the time to correct this!</p>
<p>I am doing an <code>finset.induction_on</code>, though: this feels like it will be a problem...</p>



<a name="220138930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220138930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220138930">(Dec 16 2020 at 16:34)</a>:</h4>
<p>you can probably use <code>finite.induction_on</code> then</p>



<a name="220138965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220138965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220138965">(Dec 16 2020 at 16:34)</a>:</h4>
<p>Actually, it would be nice if you could prove this without induction, it will probably be a lot shorter</p>



<a name="220139138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220139138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220139138">(Dec 16 2020 at 16:36)</a>:</h4>
<p>I initially wanted to directly define the intersections over all open sets given by the <code>t2_separation</code>, but I had bad memories of using the <code>big_operators</code> and opted for reducing everything to pairwise intersections/unions...</p>



<a name="220139194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220139194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220139194">(Dec 16 2020 at 16:36)</a>:</h4>
<p>I can very well see that if I knew how to use the <code>big_operators</code>, I could do this directly, instead of by induction...</p>



<a name="220139214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220139214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220139214">(Dec 16 2020 at 16:36)</a>:</h4>
<p>You don't need big ops here, this is a big union which uses the basic set library</p>



<a name="220139244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220139244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220139244">(Dec 16 2020 at 16:37)</a>:</h4>
<p>in any case, with the coercion, it only occupies one more line than before!</p>



<a name="220139428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220139428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220139428">(Dec 16 2020 at 16:38)</a>:</h4>
<p>Ah, I remember now: my issue was getting the "choice" function for the t2_separation on all pairs of points.  That is what stumped me.</p>
<p>And I confess that, while I proved the lemmas that Patrick suggested earlier, I did not really understand the <code>option/get/some</code> stuff...</p>



<a name="220139486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220139486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220139486">(Dec 16 2020 at 16:39)</a>:</h4>
<p>It might also be nice to have a version of the separation axiom that says that given <code>x, y</code> distinct there is <code>x \in U</code> such that <code>y \notin closure U</code></p>



<a name="220139505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220139505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220139505">(Dec 16 2020 at 16:39)</a>:</h4>
<p>that means one less set to deal with</p>



<a name="220139653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220139653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220139653">(Dec 16 2020 at 16:40)</a>:</h4>
<p>You don't really need that here - since you are local to a single proof you can use the <code>choice</code> tactic to make the function on the spot</p>



<a name="220141061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220141061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220141061">(Dec 16 2020 at 16:52)</a>:</h4>
<p>As usual, I like your suggestions!  However, I prefer to keep the PR as it is now and think about what else to add later.  Does this seem reasonable?</p>



<a name="220141211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220141211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220141211">(Dec 16 2020 at 16:53)</a>:</h4>
<p>(Btw, I also pushed the latest version of <a href="https://github.com/leanprover-community/mathlib/issues/5332">#5332</a>.  This version now has <code>separated</code> instead of <code>separate</code> and the inputs are two <code>sets</code> instead of two <code>finsets</code>.  Everything else is essentially the same!)</p>



<a name="220141693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220141693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220141693">(Dec 16 2020 at 16:57)</a>:</h4>
<p>Todo (as per Patrick's comment):</p>
<ol>
<li>add the two induction principles (probably a separate PR);</li>
<li>add lemma for separating one point from a <code>finset</code> (this should be easy, but I may not have time to do it now: it might appear in the next iteration of this PR);</li>
<li>change <code>is_open_union</code> to <code>is_open.union</code> and compress using projection notation.  Similarly for <code>is_open_inter</code>, <code>is_closed_union</code>, <code>is_closed_inter</code> (again, this is probably a separate PR).</li>
</ol>



<a name="220142945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220142945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220142945">(Dec 16 2020 at 17:06)</a>:</h4>
<p>Which of these two version is "better"?  Does it make a difference?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">point_disjoint_finset_opens_of_t2</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">separated</span> <span class="o">(({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↑</span><span class="n">s</span> <span class="o">:=</span>
<span class="n">finset_disjoint_finset_opens_of_t2</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="n">s</span> <span class="o">(</span><span class="n">singleton_disjoint.mpr</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>
<p>or</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">point_disjoint_finset_opens_of_t2</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">separated</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↑</span><span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">coe_singleton</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">finset_disjoint_finset_opens_of_t2</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="n">s</span> <span class="o">(</span><span class="n">singleton_disjoint.mpr</span> <span class="n">h</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="220143298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220143298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220143298">(Dec 16 2020 at 17:09)</a>:</h4>
<p>Also consider</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">point_disjoint_finset_opens_of_t2</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">separated</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="n">s</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



<a name="220143583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220143583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220143583">(Dec 16 2020 at 17:11)</a>:</h4>
<p>even better, prove that if <code>separated (s i) t</code> for all <code>i</code>, then <code>separated (\bigcup i, s i) t</code>, and <code>separated</code> is symmetric, without a <code>t2_space</code> assumption</p>



<a name="220143676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220143676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220143676">(Dec 16 2020 at 17:12)</a>:</h4>
<p>Then, you can apply those two facts (and <code>separated {x} {y}</code> in a <code>t2_space</code>) to directly prove that finite sets are separated in a <code>t2_space</code></p>



<a name="220143827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220143827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220143827">(Dec 16 2020 at 17:13)</a>:</h4>
<p>actually you should follow the lead of these topology theorems in your statement of finite unions and intersections:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_open_bInter</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span><span class="n">i</span><span class="bp">∈</span><span class="n">s</span><span class="o">,</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="bp">→</span> <span class="n">is_open</span> <span class="o">(</span><span class="bp">⋂</span><span class="n">i</span><span class="bp">∈</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">finite.induction_on</span> <span class="n">hs</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">bInter_empty</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">is_open_univ</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">s</span> <span class="n">has</span> <span class="n">hs</span> <span class="n">ih</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">bInter_insert</span><span class="bp">;</span> <span class="n">exact</span>
    <span class="n">is_open_inter</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span> <span class="o">(</span><span class="n">mem_insert</span> <span class="n">_</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="n">ih</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">h</span> <span class="n">i</span> <span class="o">(</span><span class="n">mem_insert_of_mem</span> <span class="n">_</span> <span class="n">hi</span><span class="o">))))</span>

<span class="kd">lemma</span> <span class="n">is_closed_bUnion</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span><span class="n">i</span><span class="bp">∈</span><span class="n">s</span><span class="o">,</span> <span class="n">is_closed</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="bp">→</span> <span class="n">is_closed</span> <span class="o">(</span><span class="bp">⋃</span><span class="n">i</span><span class="bp">∈</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">finite.induction_on</span> <span class="n">hs</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">bUnion_empty</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">is_closed_empty</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">s</span> <span class="n">has</span> <span class="n">hs</span> <span class="n">ih</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">bUnion_insert</span><span class="bp">;</span> <span class="n">exact</span>
    <span class="n">is_closed_union</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span> <span class="o">(</span><span class="n">mem_insert</span> <span class="n">_</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="n">ih</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">h</span> <span class="n">i</span> <span class="o">(</span><span class="n">mem_insert_of_mem</span> <span class="n">_</span> <span class="n">hi</span><span class="o">))))</span>
</code></pre></div>



<a name="220144064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220144064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220144064">(Dec 16 2020 at 17:15)</a>:</h4>
<p>These lemmas are already in the PR: mathematically, they seem equivalent to what you are saying, right?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[symm]</span> <span class="kd">lemma</span> <span class="n">symm</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">separated</span> <span class="n">s</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">separated</span> <span class="n">t</span> <span class="n">s</span> <span class="o">:=</span>

<span class="kd">lemma</span> <span class="n">union_left</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">separated</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">separated</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">separated</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∪</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="o">:=</span>
</code></pre></div>



<a name="220144102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220144102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220144102">(Dec 16 2020 at 17:15)</a>:</h4>
<p>the first one yes, the second one not quite</p>



<a name="220144166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220144166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220144166">(Dec 16 2020 at 17:16)</a>:</h4>
<p>(the assumptions are that alpha is a topological space, no t2 assumption)</p>



<a name="220144175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220144175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220144175">(Dec 16 2020 at 17:16)</a>:</h4>
<p>I mean the left side should be a finite union</p>



<a name="220144197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220144197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220144197">(Dec 16 2020 at 17:16)</a>:</h4>
<p>not a binary union</p>



<a name="220144215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220144215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220144215">(Dec 16 2020 at 17:16)</a>:</h4>
<p>Ok, I replaced the finite union by the finset.induction part...</p>



<a name="220144289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220144289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220144289">(Dec 16 2020 at 17:17)</a>:</h4>
<p>As the two topology proofs show, it should not be more than a few lines to get from the binary version to the finite union version</p>



<a name="220144357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220144357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220144357">(Dec 16 2020 at 17:17)</a>:</h4>
<p>In any case, it is now time for me to get to my "life outside Lean"!  I will take a look at what happens here later!</p>
<p>Thank you very much!</p>



<a name="220145982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/disjoint_nhds_finite_of_t2/near/220145982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/disjoint_nhds_finite_of_t2.html#220145982">(Dec 16 2020 at 17:29)</a>:</h4>
<p>There is life outside Lean??</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
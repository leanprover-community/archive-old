---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html">V(I) /\ V(J) = V(I+J)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="242795323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242795323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandra Foster <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242795323">(Jun 15 2021 at 20:32)</a>:</h4>
<p>There's a classic proposition in algebraic geometry, that the vanishing set V(I + J) of the ideal I + J for ideals I, J is equal to V(I) intersect V(J). Is this anywhere in mathlib? I've been slowly tinkering at it myself and the way I wrote it was like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.mv_polynomial.basic</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>
<span class="kn">import</span> <span class="n">algebra.ring.basic</span>
<span class="kn">import</span> <span class="n">algebra.field</span>
<span class="kn">import</span> <span class="n">algebra.module.submodule</span>
<span class="kn">import</span> <span class="n">ring_theory.ideal.basic</span>
<span class="kn">import</span> <span class="n">ring_theory.nullstellensatz</span>

<span class="kd">noncomputable theory</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">σ</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">ideal_addition_variety_intersection</span>
  <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">k</span><span class="o">))</span>
  <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">k</span><span class="o">)):</span>
  <span class="n">mv_polynomial.zero_locus</span> <span class="o">(</span><span class="n">I</span> <span class="bp">+</span> <span class="n">J</span><span class="o">)</span>
  <span class="bp">=</span> <span class="o">(</span><span class="n">mv_polynomial.zero_locus</span> <span class="n">I</span><span class="o">)</span>
    <span class="bp">∩</span> <span class="o">(</span><span class="n">mv_polynomial.zero_locus</span> <span class="n">J</span><span class="o">)</span>
</code></pre></div>
<p>(I used mv_polynomial.zero_locus from ring_theory.nullstellensatz, which, if this result isn't already in mathlib, might make sense as a place to put it..?)</p>



<a name="242798044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242798044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242798044">(Jun 15 2021 at 20:52)</a>:</h4>
<p>See <a href="https://github.com/leanprover-community/mathlib/blob/master/src/algebraic_geometry/prime_spectrum.lean#L269L271">https://github.com/leanprover-community/mathlib/blob/master/src/algebraic_geometry/prime_spectrum.lean#L269L271</a></p>



<a name="242798070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242798070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242798070">(Jun 15 2021 at 20:52)</a>:</h4>
<p>The rest of that file also contains a bunch of similar lemmas</p>



<a name="242798127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242798127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242798127">(Jun 15 2021 at 20:53)</a>:</h4>
<p>This is in the context of the prime spectrum of a ring, not in the sense of "classical" algebraic geometry in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">K^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>.</p>



<a name="242799450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242799450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandra Foster <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242799450">(Jun 15 2021 at 21:03)</a>:</h4>
<p>That's great regardless, thanks!</p>



<a name="242803248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242803248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242803248">(Jun 15 2021 at 21:38)</a>:</h4>
<p>Here's a documented proof, modulo <code>ideal.mem_add</code>, which I couldn't find! Is it there? Edit: it's <code>mem_sup</code> plus definitional abuse. Eew.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.nullstellensatz</span>

<span class="kd">noncomputable theory</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">σ</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">ideal.mem_add</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">I</span> <span class="n">J</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">∈</span> <span class="n">I</span> <span class="bp">+</span> <span class="n">J</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="bp">∈</span> <span class="n">J</span><span class="o">),</span> <span class="n">g</span> <span class="bp">+</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span>
<span class="n">submodule.mem_sup</span>

<span class="kd">lemma</span> <span class="n">ideal_addition_variety_intersection</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">k</span><span class="o">))</span>
  <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">k</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">mv_polynomial.zero_locus</span> <span class="o">(</span><span class="n">I</span> <span class="bp">+</span> <span class="n">J</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">mv_polynomial.zero_locus</span> <span class="n">I</span><span class="o">)</span> <span class="bp">∩</span> <span class="o">(</span><span class="n">mv_polynomial.zero_locus</span> <span class="n">J</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- extensionality: two sets are equal iff they have the same elements</span>
  <span class="n">ext</span> <span class="n">P</span><span class="o">,</span>
  <span class="c1">-- ↔ can be broken down into → and ←</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- one way: assume P ∈ V(I+J)</span>
    <span class="n">intro</span> <span class="n">hP</span><span class="o">,</span>
    <span class="c1">-- need to prove P ∈ V(I) ∧ P ∈ V(J)</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="c1">-- want P ∈ V(I+J) → P ∈ V(I). But we know V sends ⊆ to ⊇</span>
      <span class="n">refine</span> <span class="n">mv_polynomial.zero_locus_anti_mono</span> <span class="n">_</span> <span class="n">hP</span><span class="o">,</span>
      <span class="c1">-- so now it suffices to prove I ≤ I + J</span>
      <span class="n">exact</span> <span class="n">le_sup_left</span> <span class="o">},</span>
    <span class="o">{</span> <span class="c1">-- essentially same proof the other way</span>
      <span class="n">refine</span> <span class="n">mv_polynomial.zero_locus_anti_mono</span> <span class="n">_</span> <span class="n">hP</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">le_sup_right</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- Other way: assume P ∈ V(I) and P ∈ V(J)</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">hPI</span><span class="o">,</span> <span class="n">hPJ</span><span class="o">⟩,</span>
    <span class="c1">-- assume f ∈ I + J</span>
    <span class="n">intros</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span>
    <span class="c1">-- write f as g + h with g ∈ I and h ∈ J</span>
    <span class="n">rw</span> <span class="n">ideal.mem_add</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hf</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">hh</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="c1">-- evaluation is additive</span>
    <span class="n">rw</span> <span class="n">ring_hom.map_add</span><span class="o">,</span>
    <span class="c1">-- but eval P g = 0 and eval P h = 0</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">hPI</span> <span class="n">g</span> <span class="n">hg</span><span class="o">,</span> <span class="n">hPJ</span> <span class="n">h</span> <span class="n">hh</span><span class="o">],</span>
    <span class="c1">-- and now it's easy</span>
    <span class="n">simp</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="242805505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242805505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242805505">(Jun 15 2021 at 22:01)</a>:</h4>
<p>Re: mem_add -- it's mem_sup! I've edited.</p>



<a name="242806045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242806045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242806045">(Jun 15 2021 at 22:07)</a>:</h4>
<p>Bonus: commenting out <code>[fintype σ]</code> we see the proof still works :D</p>



<a name="242823641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242823641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandra Foster <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242823641">(Jun 16 2021 at 02:32)</a>:</h4>
<p>wow..! I was working away at it myself but I appreciate this solution. linear_algebra.basic is a great discovery, and I am impressed but not surprised that the proof of mem_sup in there is so long. I've been thinking, it's a very interesting choice to have sup be a more basic notion than sum</p>



<a name="242823853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242823853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242823853">(Jun 16 2021 at 02:37)</a>:</h4>
<p><span class="user-mention" data-user-id="419248">@Alexandra Foster</span> the reason we use <code>sup</code> is because ideals in a commutative ring form a lattice, in the sense of <a href="https://leanprover-community.github.io/mathlib_docs/find/lattice">docs#lattice</a> and the sum of ideals corresponds to the sup in this lattice.</p>



<a name="242824534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242824534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242824534">(Jun 16 2021 at 02:50)</a>:</h4>
<p>You will find other instances in mathlib as well. For example, the sup of two subgroups <code>A</code> and <code>B</code> of a given group <code>G</code> is the subgroup generated by <code>A</code> and <code>B</code>, and again the collection of all subgroups form a lattice.</p>



<a name="242824541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242824541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242824541">(Jun 16 2021 at 02:50)</a>:</h4>
<p>Incidentally, this lemma should join mathlib, right?  (Maybe in the <code>ring_theory.nullstellensatz</code> file under the name <code>mv_polynomial.zero_locus_sup</code>.)</p>



<a name="242824670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242824670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242824670">(Jun 16 2021 at 02:52)</a>:</h4>
<p>Yes it probably should be in mathlib, in one form or another... It might be worth it to give a full definition of the Zariski topology on an algebraic set</p>



<a name="242824685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/V%28I%29%20/%5C%20V%28J%29%20%3D%20V%28I%2BJ%29/near/242824685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/V(I).20.2F.5C.20V(J).20.3D.20V(I.2BJ).html#242824685">(Jun 16 2021 at 02:53)</a>:</h4>
<p>(and compare with the Zariski topology of the prime spectrum that we already have)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
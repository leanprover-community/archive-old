---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html">iterate.comm</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="233682418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233682418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233682418">(Apr 08 2021 at 16:14)</a>:</h4>
<p>Dear All,</p>
<p>I think that this lemma is not part of <code>logic/function/iterate</code>.  If it is not there, do you think that it would be a good idea to add it?</p>
<p>Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">comm</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="bp">^</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">m</span><span class="o">]</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">iterate_mul</span><span class="o">,</span> <span class="n">nat.mul_comm</span><span class="o">,</span> <span class="n">iterate_mul</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="233683284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233683284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233683284">(Apr 08 2021 at 16:21)</a>:</h4>
<p>Seems reasonable, I wonder if we should establish a simp-normal form for these sorts of things though, I see there is <a href="https://leanprover-community.github.io/mathlib_docs/find/function.iterate_add">docs#function.iterate_add</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/function.iterate_mul">docs#function.iterate_mul</a> both of which insert more iteration symbols rather than arithmetic operations on nats neither of which is <code>@[simp]</code> though, so I would think adding the symm of those lemmas as simp lemmas would help when working with an expression like this.</p>



<a name="233685653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233685653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233685653">(Apr 08 2021 at 16:38)</a>:</h4>
<p>I don't agree that the symm of those is the right direction for simp. There are basically no lemmas about <code>f^[2]</code>, for example. But if you splat it out, you're more likely to have lemmas about application or composition</p>



<a name="233705472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233705472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233705472">(Apr 08 2021 at 18:31)</a>:</h4>
<p>PR <a href="https://github.com/leanprover-community/mathlib/issues/7121">#7121</a></p>



<a name="233705884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233705884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233705884">(Apr 08 2021 at 18:33)</a>:</h4>
<p>Just noticed <a href="https://leanprover-community.github.io/mathlib_docs/find/function.commute.iterate_iterate_self">docs#function.commute.iterate_iterate_self</a> which seems related.</p>



<a name="233706039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233706039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233706039">(Apr 08 2021 at 18:34)</a>:</h4>
<p>I do not know much about what the best for formalization would be, but my instinct would be to transfer everything to the "exponents" and then act there.  So, I would have formulated <code>iterate_add</code> and <code>iterate_mul</code> in reverse order to the current one.  Since Yuri made this choice, I am probably wrong!</p>



<a name="233707413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233707413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233707413">(Apr 08 2021 at 18:42)</a>:</h4>
<p>Bryan, the statement that you mention seems indeed very close, but I am failing to use it...</p>



<a name="233708034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233708034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233708034">(Apr 08 2021 at 18:47)</a>:</h4>
<p>Right, I'm not sure how <code>commute</code> is supposed to be used, but it looks like there's some useful API around it.</p>



<a name="233708202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233708202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233708202">(Apr 08 2021 at 18:48)</a>:</h4>
<p>I've gotten to having to prove <code>f^[n]^[m] x = f^[n] (f^[m] x)</code>, but I am struggling to make progress.</p>



<a name="233708438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233708438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233708438">(Apr 08 2021 at 18:49)</a>:</h4>
<p>Wait, that is equivalent to <code>f^[n * m] x = f^[n + m] x</code>: this is not what I want!  No wonder I was not making progress!</p>
<p>Bryan, I think that the one that you mention is <em>addition</em> of exponents, not <em>multiplication</em>!</p>



<a name="233708454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233708454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233708454">(Apr 08 2021 at 18:49)</a>:</h4>
<p>Ah, sorry about that!</p>



<a name="233708538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233708538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233708538">(Apr 08 2021 at 18:50)</a>:</h4>
<p>It's commutativity of multiplication in the group of endos</p>



<a name="233708542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233708542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233708542">(Apr 08 2021 at 18:50)</a>:</h4>
<p>No worries!  I find it somewhat confusing myself.</p>



<a name="233708661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233708661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233708661">(Apr 08 2021 at 18:51)</a>:</h4>
<p>function.commute is missing a helper lemma about application</p>



<a name="233708796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233708796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233708796">(Apr 08 2021 at 18:52)</a>:</h4>
<p>Yakov, I would like to understand better your last statement: would you mind expanding a bit and giving me a hint as to what kind of lemma you are thinking of?</p>



<a name="233708826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233708826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233708826">(Apr 08 2021 at 18:52)</a>:</h4>
<p>I would be happy to add it to my "one-lemma PR"!</p>



<a name="233709899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233709899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233709899">(Apr 08 2021 at 18:59)</a>:</h4>
<p>You have, via function.comm that the composition of f and g is the same as composing g and f. congr_fun with that equality gives you that for all x, (f o g) x = (g o f) x</p>



<a name="233710094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233710094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233710094">(Apr 08 2021 at 19:00)</a>:</h4>
<p>So you have the tools now to make the proof you need. You can use apply congr_fun to generalize over whatever you're applying on. The helper lemma would just state that directly, something like</p>



<a name="233710302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233710302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233710302">(Apr 08 2021 at 19:02)</a>:</h4>
<p>function.commute.apply (h : function.commute f g) (x : a) : g (f x) = f (g x) := congr_fun h x</p>



<a name="233710306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233710306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233710306">(Apr 08 2021 at 19:02)</a>:</h4>
<p>Or something</p>



<a name="233710421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233710421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233710421">(Apr 08 2021 at 19:03)</a>:</h4>
<p>Then your proof becomes (function.commute.iterate_iterate_self f m n).apply x</p>



<a name="233710491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233710491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233710491">(Apr 08 2021 at 19:03)</a>:</h4>
<p>Ok, let me try!  Thanks a lot!</p>



<a name="233710523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233710523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233710523">(Apr 08 2021 at 19:03)</a>:</h4>
<p>And there, you're using that projection notation</p>



<a name="233710653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233710653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233710653">(Apr 08 2021 at 19:04)</a>:</h4>
<p>Does that make sense? We're constructing a proposition and right away using a lemma about it. And because of namespaces, we can use the projection</p>



<a name="233710970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233710970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233710970">(Apr 08 2021 at 19:06)</a>:</h4>
<p>Ah hold on, your original lemma is about exponentiation. I misunderstood</p>



<a name="233710993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233710993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233710993">(Apr 08 2021 at 19:06)</a>:</h4>
<p>Yakov, it turns out, that the proof is your lemma even easier!  Maybe this is why Yuri did not add it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">function.commute.apply</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">function.commute</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">h</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
</code></pre></div>



<a name="233711062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711062">(Apr 08 2021 at 19:07)</a>:</h4>
<p>Yes, you're using the defeq of h there</p>



<a name="233711088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711088">(Apr 08 2021 at 19:07)</a>:</h4>
<p>Yes, I think that the one that I want is not the one that Bryan mentioned, but I still took some time to figure out that it wasn't, so I would like to understand how to better get this things!</p>



<a name="233711174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711174">(Apr 08 2021 at 19:07)</a>:</h4>
<p>Indeed, I <code>unfold</code>ed twice before I removed them.</p>



<a name="233711204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711204">(Apr 08 2021 at 19:07)</a>:</h4>
<p>The defeq is via the definition of semiconj</p>



<a name="233711328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711328">(Apr 08 2021 at 19:08)</a>:</h4>
<p>here is the non-minimal proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">function.commute.apply</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">function.commute</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">congr_fun</span> <span class="n">_</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">function.commute</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">semiconj</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">h</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="233711394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711394">(Apr 08 2021 at 19:08)</a>:</h4>
<p>Right. I think it's still nice to provide the API that wraps the defeq operations, just in case someone wants to generalize the definition in a way that defeq no longer works. Others might disagree</p>



<a name="233711463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711463">(Apr 08 2021 at 19:09)</a>:</h4>
<p>Ok, so you are saying that it is better to have the explicit <code>unfold</code> steps?</p>



<a name="233711558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711558">(Apr 08 2021 at 19:10)</a>:</h4>
<p>I can see why this proof is probably the "other" candidate:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">function.commute.apply</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">function.commute</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">function.commute</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">semiconj</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>  <span class="c1">-- at this stage, h : ∀ (x : α), f (g x) = g (f x)</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">h</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="233711608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711608">(Apr 08 2021 at 19:10)</a>:</h4>
<p>Of course, maybe the lemma should be the symm of that. It's not clear a priori which is the "inside" function in commute f g</p>



<a name="233711653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711653">(Apr 08 2021 at 19:10)</a>:</h4>
<p>Ah, I meant for users of the API. In the making of the actual API, it's fine to use defeq</p>



<a name="233711684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711684">(Apr 08 2021 at 19:10)</a>:</h4>
<p>(in my opinion)</p>



<a name="233711761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711761">(Apr 08 2021 at 19:11)</a>:</h4>
<p>I can add this lemma to the PR, even if it is about "addition" instead of "multiplication".</p>



<a name="233711821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711821">(Apr 08 2021 at 19:11)</a>:</h4>
<p>(If you think that it would be useful to have: adding "unused" lemmas is rarely an issue with CI building.)</p>



<a name="233711981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233711981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233711981">(Apr 08 2021 at 19:12)</a>:</h4>
<p>Right. Regarding reduction of exponents: since we're operating solely in the nat monoid, any reduction would lead solely to a growth of the exponent. So it'd be harder to deal with a f^3 than f^2 o f</p>



<a name="233712187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233712187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233712187">(Apr 08 2021 at 19:14)</a>:</h4>
<p>I see, so this is why the direction of these lemmas goes in the direction that feels "wrong" to me: thanks for the explanation!</p>



<a name="233712194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233712194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233712194">(Apr 08 2021 at 19:14)</a>:</h4>
<p>So while the expression is "simpler" with a reduced exponent, it's harder to prove things about it.</p>



<a name="233712656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233712656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233712656">(Apr 08 2021 at 19:17)</a>:</h4>
<p>Yakov, I added your function.commute.apply lemma as well!</p>



<a name="233732100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233732100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233732100">(Apr 08 2021 at 21:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/iterate.2Ecomm/near/233711981">said</a>:</p>
<blockquote>
<p>Right. Regarding reduction of exponents: since we're operating solely in the nat monoid, any reduction would lead solely to a growth of the exponent. So it'd be harder to deal with a f^3 than f^2 o f</p>
</blockquote>
<p>I think this is the key point I was missing here, the example I had in my head of things "cancelling out" when you combine the exponents really can't happen with nat-indexing. So maybe the best form is the version currently there, having a simp-normal form still seems useful though?</p>



<a name="233733984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233733984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233733984">(Apr 08 2021 at 21:31)</a>:</h4>
<p>Is <code>simp</code> a tactic for proving things or simplifying expressions? If the former, you might want to make the proof you use break the monoidal term by 2s or by 3s, that will lead to fewer rewrites.</p>



<a name="233734185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233734185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233734185">(Apr 08 2021 at 21:32)</a>:</h4>
<p>We break off by ones because of the <code>nat.succ</code> structure. But execution of a function that has been raised to a nat power is more efficient if you execute by twos, and even more so by threes. But it's harder to write the method to do that.</p>



<a name="233738325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233738325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233738325">(Apr 08 2021 at 22:06)</a>:</h4>
<p>Are you sure function.commutes.apply is a useful lemma? Does <a href="https://leanprover-community.github.io/mathlib_docs/find/function.commute">docs#function.commute</a> really unfold to composition?</p>



<a name="233738534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233738534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233738534">(Apr 08 2021 at 22:08)</a>:</h4>
<p>Yeah, if you have a term <code>h : function.commutes f g</code>, <code>h x</code> is syntactically <code>f (g x) = g (f x)</code> - the lemma is pointless</p>



<a name="233738543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233738543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233738543">(Apr 08 2021 at 22:08)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="k">#reduce</span> <span class="o">(</span><span class="n">function.commute</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">∀ (x : α), f (g x) = g (f x)</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="233738654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233738654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233738654">(Apr 08 2021 at 22:09)</a>:</h4>
<p>When I'm working with a new prop, I don't always know what it reduces to. And to find out here that <code>(h : function.commute f g) x</code> would mean <code>f (g x) = g (f x)</code> would require going down some search path.</p>



<a name="233738712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233738712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233738712">(Apr 08 2021 at 22:10)</a>:</h4>
<p>Or just <code>#check</code></p>



<a name="233738761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233738761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233738761">(Apr 08 2021 at 22:10)</a>:</h4>
<p>It's not indicated in the docs anywhere. One way to explicitly indicate is just to have a lemma that says exactly what it means.</p>



<a name="233738765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233738765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233738765">(Apr 08 2021 at 22:10)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">(</span><span class="n">function.commute</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">function.commute f g : Prop</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="233738786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233738786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233738786">(Apr 08 2021 at 22:10)</a>:</h4>
<p>I mean, add an x in that check</p>



<a name="233738812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233738812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233738812">(Apr 08 2021 at 22:11)</a>:</h4>
<p>Right, one needed to know that that was a valid thing to say in the first place</p>



<a name="233739142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233739142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233739142">(Apr 08 2021 at 22:14)</a>:</h4>
<p>To be clear, I meant</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">commute</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">h</span> <span class="n">x</span>
</code></pre></div>



<a name="233739178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233739178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233739178">(Apr 08 2021 at 22:14)</a>:</h4>
<p>That's basically a problem for any definition that expands to a function type - eg <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix">docs#matrix</a></p>



<a name="233739199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233739199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233739199">(Apr 08 2021 at 22:15)</a>:</h4>
<p>So maybe a doc-gen solution is needed here?</p>



<a name="233739535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233739535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233739535">(Apr 08 2021 at 22:18)</a>:</h4>
<p>Yes I understand what you meant. This example works because of how commute is defined, and how semiconj is defined. In <a href="https://github.com/leanprover-community/mathlib/issues/7118">#7118</a>, I redefine <code>perm.disjoint</code> to be <code>disjoint f.support g.support</code> instead of <code>def disjoint (f g : perm α) := ∀ x, f x = x ∨ g x = x</code>. So previous proofs that used <code>cases (h : disjoint f g) x with hfx hgx</code> won't work straight out of the box. But if there was a <code>disjoint.apply</code> or whatever, it would be stable to the definitional change.</p>



<a name="233741836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233741836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233741836">(Apr 08 2021 at 22:41)</a>:</h4>
<p>What does <code>h x</code> now produce?</p>



<a name="233741849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233741849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233741849">(Apr 08 2021 at 22:41)</a>:</h4>
<p>(for perm.disjoint)</p>



<a name="233749295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233749295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233749295">(Apr 09 2021 at 00:08)</a>:</h4>
<p>An error, _root_.disjoint expects a set membership prop</p>



<a name="233755633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233755633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233755633">(Apr 09 2021 at 01:36)</a>:</h4>
<p>My experience with the <code>commute</code> issue has been that it took me a while to realise that </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">commute</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">h</span> <span class="n">x</span>
</code></pre></div>
<p>that is, applying <code>h</code> to <code>x</code>, was even a thing.  Of course, I did in the end, but I would have liked that this information had been more prominent.  As a not so experienced user, I still struggle with seeing through the definitions.</p>
<p>Maybe just a pointer in a doc-string would be enough.</p>



<a name="233768445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233768445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233768445">(Apr 09 2021 at 04:58)</a>:</h4>
<p>Feel free to improve docstrings. About LHS vs RHS in <code>iterate_add</code> etc, AFAIR it was not me who made the choice. I moved these lemmas from <code>nat.iterate_*</code> and did not think about LHS vs RHS.</p>



<a name="233768489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233768489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233768489">(Apr 09 2021 at 04:59)</a>:</h4>
<p>I don't know which direction is better.</p>



<a name="233768693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233768693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233768693">(Apr 09 2021 at 05:01)</a>:</h4>
<p>I will not change the direction of the lemmas, but I will make an attempt at doc strings!</p>



<a name="233770837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233770837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233770837">(Apr 09 2021 at 05:38)</a>:</h4>
<p>For those interested, I added the second line to the doc string of <code>commute</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Two maps `f g : α → α` commute if `f ∘ g = g ∘ f`.</span>
<span class="sd">Given `h : function.commute f g` and `a : α`, the term `h a` has Type `h a : f (g a) = g (f a)`. -/</span>
<span class="kd">def</span> <span class="n">commute</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">semiconj</span> <span class="n">f</span> <span class="n">g</span> <span class="n">g</span>
</code></pre></div>
<p>Any comments are more than welcome!  I personally find it very helpful when doc strings give "expected usages", since often definitions are a little opaque.</p>



<a name="233774671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233774671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233774671">(Apr 09 2021 at 06:38)</a>:</h4>
<p>Ok, the doc string appears to have generated lots of support!</p>
<p>At the moment, the lemma directly below the definition of <code>commute</code> is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">commute.apply</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">function.commute</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">h</span> <span class="n">_</span>
</code></pre></div>
<p>and, given the doc string, I am now leaning towards Eric's idea that this is superfluous: this simply allows to write <code>h.apply x</code> instead of <code>h x</code>.</p>
<p><span aria-label="thumbs up" class="emoji emoji-1f44d" role="img" title="thumbs up">:thumbs_up:</span>  this comment if the lemma should stay.  <span aria-label="thumbs down" class="emoji emoji-1f44e" role="img" title="thumbs down">:thumbs_down:</span>  this comment if the lemma should go.</p>



<a name="233775484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233775484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233775484">(Apr 09 2021 at 06:49)</a>:</h4>
<p>A <code>commute.comp_eq</code> lemma that applies funext might still be a useful addition</p>



<a name="233775551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233775551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233775551">(Apr 09 2021 at 06:50)</a>:</h4>
<p>Assuming it doesn't exist already</p>



<a name="233775613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233775613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233775613">(Apr 09 2021 at 06:51)</a>:</h4>
<p>I believe this lemma (<code>commute.apply</code>) would be useful if you made <code>f</code> (and maybe also <code>g</code>) explicit and put <code>h</code> at the end.  Then you could do <code>rw commute.apply f x</code> and get a subgoal for <code>function.commute f g</code>.</p>



<a name="233776159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233776159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233776159">(Apr 09 2021 at 06:58)</a>:</h4>
<p>As far as I can see, <code>commute.comp_eq</code> does not exist, but there is a similar one for <code>semiconj</code> (see code below and recall<br>
<code>def commute (f g : α → α) : Prop := semiconj f g g</code>).</p>
<p>Thus, I <del>am tempted to</del> <em>will not</em> introduce <code>commute.comp_eq </code>, but may revive the <code>commute.apply</code> with explicit function(s), if people agree that this is wanted.  I personally have not worked much with this API, so I am in no position of judging whether it is useful or not.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- We say that `f : α → β` semiconjugates `ga : α → α` to `gb : β → β` if `f ∘ ga = gb ∘ f`. -/</span>
<span class="kd">def</span> <span class="n">semiconj</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">ga</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">gb</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">ga</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">gb</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">semiconj</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">f</span> <span class="n">fab</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">fbc</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">}</span> <span class="o">{</span><span class="n">ga</span> <span class="n">ga'</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">gb</span> <span class="n">gb'</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">gc</span> <span class="n">gc'</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">}</span>

<span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">comp_eq</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">semiconj</span> <span class="n">f</span> <span class="n">ga</span> <span class="n">gb</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">ga</span> <span class="bp">=</span> <span class="n">gb</span> <span class="bp">∘</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">funext</span> <span class="n">h</span>
</code></pre></div>



<a name="233776802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/iterate.comm/near/233776802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/iterate.2Ecomm.html#233776802">(Apr 09 2021 at 07:02)</a>:</h4>
<p>If you have <code>h : commute f g</code>, then you have <code>h.comp_eq</code>. It unfolds <code>commute</code> to <code>semiconj</code>, then applies <code>semiconj.comp_eq</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
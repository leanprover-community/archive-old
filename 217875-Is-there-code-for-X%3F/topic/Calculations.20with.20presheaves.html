---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html">Calculations with presheaves</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="199152683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199152683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jens Hemelaer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199152683">(May 29 2020 at 13:20)</a>:</h4>
<p>Hi! I asked this in the Category Theory zulip before. I'm not very familiar with Lean.<br>
Is there a way to calculate the Hom-sets of presheaves in Lean?<br>
In other words, can Lean generate a list of all morphisms from F to G, where F and G are two presheaves?<br>
Or equivalently, can Lean generate a list of natural transformations between two functors?</p>
<p>I'm thinking of presheaves with only a few sections, over a category that has only a few objects and morphisms (so that the set of natural transformations doesn't become too big).</p>



<a name="199152787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199152787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199152787">(May 29 2020 at 13:21)</a>:</h4>
<p>The usage of "calculate" in mathematics and in Lean (i.e. CS) are very different. In mathematics the process does not need to be automated</p>



<a name="199152825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199152825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199152825">(May 29 2020 at 13:21)</a>:</h4>
<p>and I suspect there is any automatic algorithm to do what you ask</p>



<a name="199152973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199152973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199152973">(May 29 2020 at 13:22)</a>:</h4>
<p>how "calculate the morphisms from F to G" might translate into Lean is "establish an <code>equiv</code> between the type of morphisms from F to G and some nicer type"</p>



<a name="199153898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199153898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jens Hemelaer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199153898">(May 29 2020 at 13:30)</a>:</h4>
<p>Ok, thanks! I'll try to find another way.</p>



<a name="199154645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199154645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199154645">(May 29 2020 at 13:36)</a>:</h4>
<p><span class="user-mention" data-user-id="307445">@Jens Hemelaer</span> If everything in sight is finite, then it might work</p>



<a name="199154668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199154668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199154668">(May 29 2020 at 13:36)</a>:</h4>
<p>But otherwise, I think you have to be more precise about what you really mean</p>



<a name="199154762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199154762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199154762">(May 29 2020 at 13:37)</a>:</h4>
<p>E.g.: can you compute all function from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span>?<br>
(That's a baby example of sections of a presheaf.)</p>



<a name="199156107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199156107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jens Hemelaer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199156107">(May 29 2020 at 13:47)</a>:</h4>
<p>Yes, everything in sight is finite. For example a directed graph is a presheaf on a category with two objects and two morphisms, and in this case I would be interested in the set of graph morphisms from one graph to another. In order to make this realistic computationally, both graphs should have only very few vertices and edges (say 5 or 6).</p>



<a name="199157045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199157045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199157045">(May 29 2020 at 13:55)</a>:</h4>
<p>Yup, such things would be possible in lean.</p>



<a name="199157075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199157075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199157075">(May 29 2020 at 13:55)</a>:</h4>
<p>but fast it would not be</p>



<a name="199157155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199157155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199157155">(May 29 2020 at 13:56)</a>:</h4>
<p>Yup, being fast would probably require you to consider graphs with 1 or 2 vertices (-; <span aria-label="oops" class="emoji emoji-1f643" role="img" title="oops">:oops:</span></p>



<a name="199157218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199157218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199157218">(May 29 2020 at 13:56)</a>:</h4>
<p>On the other hand, if you are willing to write some tactics, you can make it fast.</p>



<a name="199157269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199157269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199157269">(May 29 2020 at 13:57)</a>:</h4>
<p>After all, lean can also prove that 5 digit numbers are prime, and can compute the first 10 digits of pi.</p>



<a name="199157309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199157309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199157309">(May 29 2020 at 13:57)</a>:</h4>
<p>Both require a fair amount of computation. But the computation is not done by definitional reductions.</p>



<a name="199157395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199157395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199157395">(May 29 2020 at 13:58)</a>:</h4>
<blockquote>
<p>compute the first 10 digits of pi</p>
</blockquote>
<p>with certificates</p>



<a name="199157511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199157511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jens Hemelaer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199157511">(May 29 2020 at 13:59)</a>:</h4>
<p>By "slow" do you mean that it would take a lot of computation time, or that it would take a lot of time to implement?</p>



<a name="199157551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199157551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199157551">(May 29 2020 at 13:59)</a>:</h4>
<p>the former</p>



<a name="199163871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199163871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199163871">(May 29 2020 at 14:48)</a>:</h4>
<p>The kind of thing that Lean can do is to understand the definition of a morphism of presheaves, and prove theorems about Hom(F,G) even if it's uncountably infinite.</p>



<a name="199181292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199181292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jens Hemelaer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199181292">(May 29 2020 at 16:53)</a>:</h4>
<p>So I guess that, while it might be possible in theory, Lean is not the right tool for what I want to do.</p>



<a name="199183386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199183386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199183386">(May 29 2020 at 17:09)</a>:</h4>
<p>To decide that, you would have to be more explicit about what you want to do</p>



<a name="199183471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199183471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199183471">(May 29 2020 at 17:10)</a>:</h4>
<p>If you want to compute with explicit graphs, maybe not. If you want to compute with explicit presheaves, maybe yes.</p>



<a name="199183577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199183577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199183577">(May 29 2020 at 17:11)</a>:</h4>
<p>Why is Lean bad for computing explicit graphs?</p>



<a name="199184381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199184381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199184381">(May 29 2020 at 17:19)</a>:</h4>
<p>Because we have nothing about graphs at all, whereas other languages have huge libraries</p>



<a name="199184618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199184618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199184618">(May 29 2020 at 17:21)</a>:</h4>
<p>My instinct is that presheaves might compute quite nicely in lean but I can't be sure - things with fintype seem to compute reasonably well in my experience</p>



<a name="199201044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199201044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jens Hemelaer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199201044">(May 29 2020 at 19:31)</a>:</h4>
<p>I'm sorry for being vague, I only know the absolute basics of theorem proving in Lean.<br>
What I want to do is not theorem proving. I just thought I could take advantage of existing "definitions" in Lean, instead of implementing presheaves and natural transformations from scratch in e.g. Python.</p>
<p>To be more explicit, what I want to do is the following:</p>
<ul>
<li>define a specific category C, as a list of &lt;10 objects and &lt;10 morphisms</li>
<li>define two presheaves F and G on them, i.e. for each presheaf and each object a short list of sections, and a function defining restriction</li>
<li>get as output of the program a list of presheaf morphisms from F to G.</li>
</ul>
<p>I could do this by hand, but then it's easy to make mistakes.</p>



<a name="199202044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199202044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199202044">(May 29 2020 at 19:39)</a>:</h4>
<p>Right. So what we have in Lean is all the machinery to make the definition, but very few algorithms to compute the answer explicitly. Instead we can prove theorems about the answer, e.g. one could prove there are infinitely many presheaves on the real numbers with its usual topology. Now one <em>could</em> write code to do what you want to do, and it would be an interesting exercise, but it would be harder to do than in python because for each algorithm you write, you would also have to write a formal proof that the algorithm always terminated under some specific finiteness conditions which you'd have to make precise and which would cover your use case, and furthermore that it always gave the right answer -- or at least you'd have to do this if you wanted the algorithm to output something which you wanted to know for sure was the set of morphisms. If you did this, then it would be essentially impossible to make mistakes, however it would also be some work. And there would be no guarantee that it would run quickly in Lean 3.</p>



<a name="199202408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199202408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199202408">(May 29 2020 at 19:42)</a>:</h4>
<p>Well... you could use the existing definitions, and just write <code>meta</code> algorithms afterwards.</p>



<a name="199202416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199202416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199202416">(May 29 2020 at 19:42)</a>:</h4>
<p>That way you can skip all the proofy bits</p>



<a name="199202474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199202474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199202474">(May 29 2020 at 19:43)</a>:</h4>
<p>I guess here is an algorithm: assuming each set of sections is finite (of size 10, say), one could literally just define the presheaf morphisms to be the subset of the product over all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Hom(F(U),G(U))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> consisting of those things which obeyed the presheaf axiom. Now you get an algorithm for free, but the moment you try to apply it Lean will make a set possibly of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup><msup><mo stretchy="false">)</mo><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">(10^{10})^{10}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> and then start going through it and printing out the elements which satisfy the axiom. But in practice Lean will never even make the set of course.</p>



<a name="199202693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199202693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199202693">(May 29 2020 at 19:45)</a>:</h4>
<p>Right, I think if you went through and added a bunch of <code>fintype</code> instances, you could get <code>#eval</code> to do the calculation in principle, but it would be slow even by "who needs algorithm design?" standards.</p>



<a name="199202832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199202832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199202832">(May 29 2020 at 19:46)</a>:</h4>
<p>What would be a lot more effective (and fun) would be to have some tactic which can spit out a SAT encoding of what it means to be a morphism of presheaves from the definitions, and then hand that to a SAT solver. However, we don't have anything like that yet.</p>



<a name="199202919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199202919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199202919">(May 29 2020 at 19:47)</a>:</h4>
<p>Say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> is a top space with 1 element, and we consider two presheaves taking values in sets of size at most 5. In practice this is just two sets of size at most 5, and a morphism between them. Enumerating all morphisms between two such sets involves looking at a set of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mn>5</mn><mn>5</mn></msup><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(5^5)^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> and then picking out the elements for which the diagram commutes. Already this is presumably completely unfeasible for Lean.</p>



<a name="199203033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199203033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199203033">(May 29 2020 at 19:48)</a>:</h4>
<p>These numbers like 10 in the original question will just exponentially blow up the size of the answer.</p>



<a name="199205178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199205178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jens Hemelaer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199205178">(May 29 2020 at 20:05)</a>:</h4>
<p>I will take a look at <code>#eval</code>. Yes, the presheaves should have very small size, 10 sections might already be too much.</p>



<a name="199383258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Calculations%20with%20presheaves/near/199383258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Calculations.20with.20presheaves.html#199383258">(Jun 01 2020 at 15:31)</a>:</h4>
<p>(deleted)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
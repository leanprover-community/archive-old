---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/trunc.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html">trunc</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="199447161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199447161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199447161">(Jun 02 2020 at 03:27)</a>:</h4>
<p>Is</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">quot</span>

<span class="n">def</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">Z</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">trunc</span> <span class="o">(</span><span class="n">Z</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="n">trunc</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">Z</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>


<p>definable?</p>



<a name="199447177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199447177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199447177">(Jun 02 2020 at 03:27)</a>:</h4>
<p>(computably)</p>



<a name="199447710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199447710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199447710">(Jun 02 2020 at 03:43)</a>:</h4>
<p>Nope</p>



<a name="199447762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199447762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199447762">(Jun 02 2020 at 03:44)</a>:</h4>
<p>This comes up every once in a while. It has some reasonably obvious computational interpretation, but you can't prove it from lean's axioms</p>



<a name="199447798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199447798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199447798">(Jun 02 2020 at 03:45)</a>:</h4>
<p>I think we could remove the <code>noncomputable</code> keyword by using a <code>vm_override</code> though. Am I wrong? (I haven't used them that way yet)</p>



<a name="199447845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199447845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199447845">(Jun 02 2020 at 03:46)</a>:</h4>
<p>This is also relevant for the QPF implementation that Jeremy, Simon and I worked on last year. I think <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> told me that this makes the definitional equality problem much harder because you have to work under binders; I forget the details now. It might end up like cubical type theory reduction</p>



<a name="199447920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199447920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199447920">(Jun 02 2020 at 03:49)</a>:</h4>
<p>To answer my own question: <code>vm_override</code> don't do that yet</p>



<a name="199447994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199447994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199447994">(Jun 02 2020 at 03:51)</a>:</h4>
<p>Oh, I also remembered a trick that <span class="user-mention" data-user-id="110044">@Chris Hughes</span> pointed out:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">bar</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">trunc</span> <span class="o">(</span><span class="n">trunc</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">foo</span> <span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="o">(</span><span class="n">trunc</span> <span class="n">α</span><span class="o">))</span>
</code></pre></div>


<p>you can do some really funny things with this function, because the VM representation of this function does not respect equality</p>



<a name="199448334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199448334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199448334">(Jun 02 2020 at 04:00)</a>:</h4>
<p>Ah, here it is:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">quot</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">Z</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">trunc</span> <span class="o">(</span><span class="n">Z</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="n">trunc</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">Z</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">unchecked_cast</span> <span class="n">f</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">bar</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">trunc</span> <span class="o">(</span><span class="n">trunc</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">foo</span> <span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="o">(</span><span class="n">trunc</span> <span class="n">α</span><span class="o">))</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">lie</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">@</span><span class="n">bar</span> <span class="n">bool</span><span class="o">)</span><span class="bp">.</span><span class="n">lift</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">trunc</span><span class="bp">.</span><span class="n">mk</span> <span class="n">tt</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">trunc</span><span class="bp">.</span><span class="n">mk</span> <span class="n">ff</span><span class="o">)))</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="k">show</span> <span class="n">trunc</span><span class="bp">.</span><span class="n">mk</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">trunc</span><span class="bp">.</span><span class="n">mk</span> <span class="n">ff</span><span class="o">,</span> <span class="k">from</span> <span class="n">subsingleton</span><span class="bp">.</span><span class="n">elim</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">]</span>

<span class="n">meta</span> <span class="kn">example</span> <span class="o">:</span> <span class="n">lie</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="k">show</span> <span class="n">trunc</span><span class="bp">.</span><span class="n">lift</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">bar</span> <span class="bp">=</span> <span class="bp">_</span><span class="o">,</span> <span class="k">begin</span>
  <span class="n">generalize</span> <span class="o">:</span> <span class="n">bar</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">trunc</span><span class="bp">.</span><span class="n">ind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">_</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">to_bool_tt</span><span class="o">,</span>
  <span class="n">rw</span> <span class="k">show</span> <span class="n">trunc</span><span class="bp">.</span><span class="n">mk</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">trunc</span><span class="bp">.</span><span class="n">mk</span> <span class="n">ff</span><span class="o">,</span> <span class="k">from</span> <span class="n">subsingleton</span><span class="bp">.</span><span class="n">elim</span> <span class="bp">_</span> <span class="bp">_</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">lie</span> <span class="c1">-- ff</span>
</code></pre></div>



<a name="199448439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199448439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199448439">(Jun 02 2020 at 04:03)</a>:</h4>
<p>Ok, to <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> the problem, what I really wanted was:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">def</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">sigma_quotient_fin_card</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">s</span><span class="bp">.</span><span class="n">r</span><span class="o">]:</span>
   <span class="n">trunc</span> <span class="o">(</span><span class="n">α</span> <span class="err">≃</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s</span><span class="o">),</span> <span class="n">fin</span> <span class="o">(</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="err">⟦</span><span class="n">x</span><span class="err">⟧</span> <span class="bp">=</span> <span class="n">q</span><span class="o">}))</span> <span class="o">:=</span>
</code></pre></div>


<p>which I can construct using <code>foo</code>, but so far not otherwise.</p>



<a name="199448616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199448616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199448616">(Jun 02 2020 at 04:07)</a>:</h4>
<p>I think this can be proven. First you fix an ordering of the base type, then this induces an order on every equivalence class and you get the map to fin that way</p>



<a name="199450091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199450091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199450091">(Jun 02 2020 at 04:43)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">sigma_quotient_fin_card</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fa</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">s</span><span class="bp">.</span><span class="n">r</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">trunc</span> <span class="o">(</span><span class="n">α</span> <span class="err">≃</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s</span><span class="o">),</span> <span class="n">fin</span> <span class="o">(</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="err">⟦</span><span class="n">x</span><span class="err">⟧</span> <span class="bp">=</span> <span class="n">q</span><span class="o">}))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">resetI</span><span class="o">,</span> <span class="n">rcases</span> <span class="n">fa</span> <span class="k">with</span> <span class="bp">⟨⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">hS₁</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hS₂</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">rec_on_subsingleton</span> <span class="n">S</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">trunc</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">_</span><span class="o">)</span> <span class="n">hS₁</span> <span class="n">hS₂</span><span class="o">,</span> <span class="n">clear</span> <span class="n">hS₂</span> <span class="n">hS₁</span> <span class="n">S</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">sigma_preimage_equiv</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">sigma_congr_right</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">q</span><span class="o">,</span>
    <span class="n">fintype</span><span class="bp">.</span><span class="n">equiv_fin_of_forall_mem_list</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">px</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">mem_pmap</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">mem_filter</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">h₂</span> <span class="bp">_</span><span class="o">,</span> <span class="n">px</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">)</span>
      <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nodup_pmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="bp">_</span> <span class="n">b</span> <span class="bp">_</span><span class="o">,</span> <span class="n">congr_arg</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nodup_filter</span> <span class="bp">_</span> <span class="n">h₁</span><span class="o">)))),</span>
<span class="kn">end</span>
</code></pre></div>



<a name="199451908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199451908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199451908">(Jun 02 2020 at 05:34)</a>:</h4>
<p>Excellent, thanks. I'll upgrade this to a <code>trunc (Σ' e : α ≃ Σ (q : quotient s), fin (fintype.card {x // ⟦x⟧ = q}), ∀ x, (e x).1 = ⟦x⟧)</code>, recording the "fibre-wise" property, and eventually include it in a PR.</p>



<a name="199453768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/trunc/near/199453768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/trunc.html#199453768">(Jun 02 2020 at 06:22)</a>:</h4>
<p>That could be a subtype instead of a Sigma'</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html">`fintype.equiv_fin` + `fin.cast`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="233835692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233835692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233835692">(Apr 09 2021 at 14:59)</a>:</h4>
<p>It would be nice to turn a proof <code>h : fintype.card ι = n</code> into an equiv <code>ι ≃ fin n</code>. The best I can do right now is <code>((fintype.equiv_fin ι).out).trans (fin.cast h).to_equiv</code>. Does this exist somewhere? Or should I add a new definition <code>fintype.equiv_fin_of_card_eq</code>?</p>



<a name="233837543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233837543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233837543">(Apr 09 2021 at 15:04)</a>:</h4>
<p>Can you give the mwe?</p>



<a name="233837742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233837742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233837742">(Apr 09 2021 at 15:05)</a>:</h4>
<p>It feels like you should be using <code>trunc.map</code> instead of <code>trunc.out</code> to keep it computable</p>



<a name="233837846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233837846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233837846">(Apr 09 2021 at 15:05)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">example</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">ι</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ι</span> <span class="bp">≃</span> <span class="n">fin</span> <span class="n">n</span> <span class="o">:=</span>
<span class="o">((</span><span class="n">fintype.equiv_fin</span> <span class="n">ι</span><span class="o">)</span><span class="bp">.</span><span class="n">out</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">fin.cast</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">to_equiv</span>
</code></pre></div>



<a name="233837975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233837975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233837975">(Apr 09 2021 at 15:06)</a>:</h4>
<p>(In this instance I don't care too much about computability since <code>ι</code> was already noncomputable.)</p>



<a name="233838219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233838219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233838219">(Apr 09 2021 at 15:07)</a>:</h4>
<p>Right, so</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">ι</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trunc</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">≃</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">fintype.equiv_fin</span> <span class="n">ι</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.trans</span> <span class="o">(</span><span class="n">fin.cast</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">to_equiv</span><span class="o">)</span>
</code></pre></div>



<a name="233838383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233838383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233838383">(Apr 09 2021 at 15:07)</a>:</h4>
<p>Sure, but it's probably confusing to have <code>equiv_fin</code> return <code>trunc</code> but <code>equiv_fin_of_card_eq</code> be noncomputable</p>



<a name="233838754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233838754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233838754">(Apr 09 2021 at 15:09)</a>:</h4>
<p>So something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fintype.equiv_fin_of_card_eq</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">ι</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trunc</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">≃</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">fintype.equiv_fin</span> <span class="n">ι</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.trans</span> <span class="o">(</span><span class="n">fin.cast</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">to_equiv</span><span class="o">)</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">fintype.equiv_fin_of_card_eq'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">ι</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ι</span> <span class="bp">≃</span> <span class="n">fin</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">classical.dec_eq</span> <span class="n">ι</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">fintype.equiv_fin_of_card_eq</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">out</span> <span class="o">}</span>
</code></pre></div>



<a name="233838927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233838927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233838927">(Apr 09 2021 at 15:09)</a>:</h4>
<p>(With docstrings pointing to each other and the existing <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.equiv_fin">docs#fintype.equiv_fin</a>.)</p>



<a name="233842247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233842247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233842247">(Apr 09 2021 at 15:22)</a>:</h4>
<p>I think that we should</p>
<ul>
<li>upgrade <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.nonempty_equiv_of_card_eq">docs#fintype.nonempty_equiv_of_card_eq</a> to a computable <code>fintype.trunc_equiv_of_card_eq</code> using <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.equiv_fin">docs#fintype.equiv_fin</a> instead of <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.exists_equiv_fin">docs#fintype.exists_equiv_fin</a>;</li>
<li>add noncomputable <code>fintype.equiv_of_card_eq</code> and a particular case <code>fintype.equiv_fin_of_card_eq</code>.</li>
</ul>



<a name="233842764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233842764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233842764">(Apr 09 2021 at 15:26)</a>:</h4>
<p>I'll go ahead and make the PR doing the things listed above. How about renaming <code>fintype.equiv_fin</code> to <code>fintype.trunc_equiv_fin</code>?</p>



<a name="233842806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233842806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233842806">(Apr 09 2021 at 15:26)</a>:</h4>
<p>That seems like the obvious consequence</p>



<a name="233842848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233842848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233842848">(Apr 09 2021 at 15:26)</a>:</h4>
<p>I think we use trunc as a suffix elsewhere?</p>



<a name="233842927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233842927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233842927">(Apr 09 2021 at 15:27)</a>:</h4>
<p>There're two defs in equiv.perm.sign with trunc results, but I forget their names</p>



<a name="233843008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233843008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233843008">(Apr 09 2021 at 15:28)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.trunc_swap_factors">docs#equiv.perm.trunc_swap_factors</a></p>



<a name="233843033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233843033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233843033">(Apr 09 2021 at 15:28)</a>:</h4>
<p>I'm wrong</p>



<a name="233843069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233843069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233843069">(Apr 09 2021 at 15:28)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.trunc_swap_factors">docs#equiv.perm.trunc_swap_factors</a></p>



<a name="233843173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233843173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233843173">(Apr 09 2021 at 15:29)</a>:</h4>
<p>Apparently there are 64 instances of <code>trunc_</code> as a prefix and 64 of <code>_trunc</code> as a suffix.</p>



<a name="233843246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233843246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233843246">(Apr 09 2021 at 15:29)</a>:</h4>
<p>But many of the <code>_trunc</code> are <code>_truncate_</code></p>



<a name="233843381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233843381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233843381">(Apr 09 2021 at 15:30)</a>:</h4>
<p>So I'm going for <code>trunc_</code>.</p>



<a name="233845472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233845472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233845472">(Apr 09 2021 at 15:42)</a>:</h4>
<p>I wanted to do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">trunc_equiv_of_card_eq</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trunc</span> <span class="o">(</span><span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">equiv.trans</span> <span class="bp">&lt;$&gt;</span> <span class="n">trunc_equiv_fin_of_card_eq</span> <span class="n">h</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">equiv.symm</span> <span class="bp">&lt;$&gt;</span> <span class="n">trunc_equiv_fin</span> <span class="n">β</span><span class="o">)</span>
</code></pre></div>
<p>but the <code>&lt;$&gt;</code>s give an error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">equiv.trans</span> <span class="bp">&lt;$&gt;</span> <span class="n">trunc_equiv_fin_of_card_eq</span> <span class="n">h</span>
<span class="n">term</span>
  <span class="n">trunc_equiv_fin_of_card_eq</span> <span class="n">h</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">trunc.</span><span class="o">{(</span><span class="n">max</span> <span class="mi">1</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u_1</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">1</span> <span class="o">(</span><span class="n">u_1</span><span class="bp">+</span><span class="mi">1</span><span class="o">))}</span> <span class="o">(</span><span class="n">equiv.</span><span class="o">{</span><span class="n">u_1</span><span class="bp">+</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">α</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="bp">@</span><span class="n">fintype.card.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">β</span> <span class="n">_inst_2</span><span class="o">)))</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">trunc.</span><span class="o">{(</span><span class="n">max</span> <span class="mi">1</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u_1</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">u_1</span><span class="bp">+</span><span class="mi">1</span><span class="o">))}</span>
    <span class="o">(</span><span class="n">equiv.</span><span class="o">{</span><span class="n">u_1</span><span class="bp">+</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">α</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="bp">@</span><span class="n">fintype.card.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">β</span> <span class="n">_inst_2</span><span class="o">)))</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">max</span> <span class="n">u_1</span> <span class="n">u_2</span><span class="o">)</span> <span class="n">u_2</span> <span class="n">u_1</span><span class="o">)</span>
</code></pre></div>



<a name="233845805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233845805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233845805">(Apr 09 2021 at 15:44)</a>:</h4>
<p>That's annoying, that <code>&lt;$&gt;</code> doesn't work for different universes.</p>



<a name="233846040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233846040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233846040">(Apr 09 2021 at 15:46)</a>:</h4>
<p>Is <code>fintype.equiv_fin</code> unavoidable using <code>classical.choice</code> (in a computable way), or is that just a bug that <a href="https://github.com/leanprover-community/mathlib/issues/7315">#7315</a> will fix</p>



<a name="233846229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233846229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233846229">(Apr 09 2021 at 15:47)</a>:</h4>
<p>If so, I'm wary of introducing the non-computable variants, because they encourage people to use the axiom of choice in their proofs just to save a few characters:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- in a context with a goal in `Prop`</span>
<span class="k">let</span> <span class="o">⟨</span><span class="n">e</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">fintype.trunc_equiv_fin.nonempty</span><span class="o">,</span> <span class="c1">-- AC-free</span>
<span class="k">let</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">fintype.trunc_equiv_fin</span><span class="o">,</span>  <span class="c1">-- AC, which we end up encouraging by adding this definition</span>
</code></pre></div>



<a name="233846320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233846320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233846320">(Apr 09 2021 at 15:48)</a>:</h4>
<p>How is the first line AC free?</p>



<a name="233846385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233846385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233846385">(Apr 09 2021 at 15:49)</a>:</h4>
<p>Well, assuming <code>trunc_equiv_fin</code> can be made choice-free</p>



<a name="233846626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233846626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233846626">(Apr 09 2021 at 15:50)</a>:</h4>
<p><del>Nothing in the implementation (<a href="https://github.com/leanprover-community/mathlib/blob/aa1fa0b2ba0739deaec3fe65f42640998120bc80/src/data/fintype/basic.lean#L201-L218">https://github.com/leanprover-community/mathlib/blob/aa1fa0b2ba0739deaec3fe65f42640998120bc80/src/data/fintype/basic.lean#L201-L218</a>) screams axiom of choice to me</del></p>



<a name="233846953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233846953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233846953">(Apr 09 2021 at 15:52)</a>:</h4>
<p>Nevermind, <code>lt_trichotomy</code>is part of the proof</p>



<a name="233851011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.equiv_fin%60%20%2B%20%60fin.cast%60/near/233851011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Eequiv_fin.60.20.2B.20.60fin.2Ecast.60.html#233851011">(Apr 09 2021 at 16:19)</a>:</h4>
<p>Created <a href="https://github.com/leanprover-community/mathlib/issues/7136">#7136</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
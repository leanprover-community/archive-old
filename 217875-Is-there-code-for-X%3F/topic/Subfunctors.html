---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html">Subfunctors</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="294882605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294882605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294882605">(Aug 23 2022 at 14:52)</a>:</h4>
<p>Hey,<br>
Is the following code covered by something in the library? Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.types</span>
<span class="kn">import</span> <span class="n">category_theory.functor</span>
<span class="kn">import</span> <span class="n">data.set.function</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kn">namespace</span> <span class="n">category_theory.functor</span>


<span class="kd">def</span> <span class="n">subfunctor</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
  <span class="o">(</span><span class="n">obj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">c</span><span class="o">,</span> <span class="n">set</span> <span class="bp">$</span> <span class="n">F.obj</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">⟶</span> <span class="n">d</span><span class="o">),</span> <span class="n">set.maps_to</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">obj</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">obj</span> <span class="n">d</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="n">subtype</span> <span class="o">(</span><span class="n">obj</span> <span class="n">c</span><span class="o">),</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">c</span> <span class="n">d</span> <span class="n">m</span><span class="o">,</span> <span class="n">set.maps_to.restrict</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">map</span> <span class="n">c</span> <span class="n">d</span> <span class="n">m</span><span class="o">),</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">intro</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">map_id</span><span class="o">,</span> <span class="n">set.maps_to.coe_restrict_apply</span><span class="o">,</span> <span class="n">types_id_apply</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">intros</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">map_comp</span><span class="o">,</span> <span class="n">set.maps_to.coe_restrict_apply</span><span class="o">,</span> <span class="n">types_comp_apply</span><span class="o">],</span> <span class="o">},}</span>

<span class="kd">lemma</span> <span class="n">subfunctor.ext</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
  <span class="o">(</span><span class="n">obj₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">c</span><span class="o">,</span> <span class="n">set</span> <span class="bp">$</span> <span class="n">F.obj</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">map₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">⟶</span> <span class="n">d</span><span class="o">),</span> <span class="n">set.maps_to</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">obj₁</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">obj₁</span> <span class="n">d</span><span class="o">))</span>
  <span class="o">(</span><span class="n">obj₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">c</span><span class="o">,</span> <span class="n">set</span> <span class="bp">$</span> <span class="n">F.obj</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">map₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">⟶</span> <span class="n">d</span><span class="o">),</span> <span class="n">set.maps_to</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">obj₂</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">obj₂</span> <span class="n">d</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">c</span><span class="o">,</span> <span class="n">obj₁</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">obj₂</span> <span class="n">c</span><span class="o">)</span> <span class="bp">→</span> <span class="n">F.subfunctor</span> <span class="n">obj₁</span> <span class="n">map₁</span> <span class="bp">=</span> <span class="n">F.subfunctor</span> <span class="n">obj₂</span> <span class="n">map₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">objeq</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">subfunctor</span><span class="o">],</span>
  <span class="n">fapply</span> <span class="n">category_theory.functor.hext</span><span class="o">,</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">c</span><span class="o">,</span> <span class="n">rw</span> <span class="n">objeq</span> <span class="n">c</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">c</span> <span class="n">d</span> <span class="n">m</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.maps_to.restrict</span><span class="o">]</span> <span class="n">at</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">function.hfunext</span><span class="o">,</span> <span class="n">rw</span> <span class="n">objeq</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">a</span> <span class="n">a'</span> <span class="n">aea'</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.map</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">subtype.heq_iff_coe_eq</span> <span class="n">at</span> <span class="n">aea'</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.coe_mk</span><span class="o">],</span> <span class="n">rw</span> <span class="n">aea'</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">all_goals</span> <span class="o">{</span> <span class="n">rintro</span><span class="o">,</span> <span class="n">rw</span> <span class="o">(</span><span class="n">objeq</span><span class="o">),},},</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">category_theory.functor</span>
</code></pre></div>



<a name="294895726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294895726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294895726">(Aug 23 2022 at 15:47)</a>:</h4>
<p>I don't think we have such subfunctors, but we can speak about natural transformations which are monomorphisms, and that offers a more flexible notion of "subfunctor" as it can be used not just with functors taking values in <code>Type*</code>.</p>



<a name="294897438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294897438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294897438">(Aug 23 2022 at 15:55)</a>:</h4>
<p>The mathlib approach to such constructions would go via the following definition of "bundled subfunctors":</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.types</span>
<span class="kn">import</span> <span class="n">category_theory.functor</span>
<span class="kn">import</span> <span class="n">data.set.function</span>

<span class="kd">universes</span> <span class="n">u</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kd">structure</span> <span class="n">subfunctor</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="n">set</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">X</span><span class="o">))</span>
<span class="o">(</span><span class="n">map_mem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">X</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">carrier</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">F.map</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">carrier</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">subfunctor.to_functor</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">subfunctor</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="n">G.carrier</span> <span class="n">X</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span> <span class="n">t</span><span class="o">,</span> <span class="o">⟨</span><span class="n">F.map</span> <span class="n">f</span> <span class="n">t</span><span class="o">,</span> <span class="n">G.map_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">t.2</span><span class="o">⟩</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">subfunctor.incl</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">subfunctor</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.to_functor</span> <span class="bp">⟶</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">G.carrier</span> <span class="n">X</span><span class="o">),</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">X</span><span class="o">)</span> <span class="o">}</span>

<span class="c1">--etc...</span>

<span class="kd">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="294900608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294900608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294900608">(Aug 23 2022 at 16:10)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.grothendieck_topology.subpresheaf">docs#category_theory.grothendieck_topology.subpresheaf</a>, which is basically the same thing but defined on the opposite category. It might be worthy to generalize it into subfunctors if you need them.</p>



<a name="294900753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294900753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294900753">(Aug 23 2022 at 16:11)</a>:</h4>
<p>One should probably generalize and use subobjects</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.types</span>
<span class="kn">import</span> <span class="n">category_theory.functor</span>
<span class="kn">import</span> <span class="n">category_theory.abelian.subobject</span>
<span class="kn">import</span> <span class="n">data.set.function</span>

<span class="kd">universes</span> <span class="n">u</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kd">structure</span> <span class="n">subfunctor</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="n">subobject</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">X</span><span class="o">))</span>
<span class="o">(</span><span class="n">map_mem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">g</span><span class="o">,</span> <span class="o">(</span><span class="n">carrier</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">arrow</span> <span class="bp">≫</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">carrier</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">arrow</span><span class="o">)</span>

<span class="kd">noncomputable theory</span>

<span class="kd">def</span> <span class="n">subfunctor.map_carrier</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span>  <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">subfunctor</span> <span class="n">F</span><span class="o">)</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G.carrier</span> <span class="n">X</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">G.carrier</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">G.map_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">some</span>

<span class="kd">@[simp, reassoc]</span>
<span class="kd">lemma</span> <span class="n">subfunctor.map_carrier_spec</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span>  <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">subfunctor</span> <span class="n">F</span><span class="o">)</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.map_carrier</span> <span class="n">f</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">G.carrier</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">arrow</span> <span class="bp">=</span> <span class="o">(</span><span class="n">G.carrier</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">arrow</span> <span class="bp">≫</span> <span class="n">F.map</span> <span class="n">f</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">G.map_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">some_spec.symm</span>

<span class="kd">lemma</span> <span class="n">subfunctor.map_carrier_unique</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span>  <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">subfunctor</span> <span class="n">F</span><span class="o">)</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span>
  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="o">(</span><span class="n">G.carrier</span> <span class="n">X</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">G.carrier</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="o">(</span><span class="n">G.carrier</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">arrow</span> <span class="bp">≫</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">G.carrier</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">arrow</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g</span> <span class="bp">=</span> <span class="n">G.map_carrier</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hg</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">subfunctor.to_functor</span>
  <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span>  <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">subfunctor</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="n">G.carrier</span> <span class="n">X</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span><span class="o">,</span> <span class="n">G.map_carrier</span> <span class="n">f</span> <span class="o">}</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">subfunctor.incl</span>
  <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span>  <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">subfunctor</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.to_functor</span> <span class="bp">⟶</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span><span class="n">G.carrier</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">arrow</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="294901545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294901545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294901545">(Aug 23 2022 at 16:15)</a>:</h4>
<p>Thanks! I guess my terminology was a bit off: what I really wanted was the "functor" part of the subfunctor. That is, in my case, I don't really care about the hierarchy of subobjects of <code>F</code>, but only about realizing one such into a functor of its own. By the way, can my code for <code>subfunctor.ext</code> be simplified? I didn't find an easy way to avoid dependent problems.</p>



<a name="294902301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294902301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294902301">(Aug 23 2022 at 16:19)</a>:</h4>
<p>On second thought, you could just use <code>subobject (C ⥤ D)</code></p>



<a name="294903134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294903134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294903134">(Aug 23 2022 at 16:23)</a>:</h4>
<p>The proof for <code>subfunctor.ext</code> could be shortened to<br>
<code>by { intro objeq, have : obj₁ = obj₂ := funext objeq, subst this }</code>.</p>



<a name="294903500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294903500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294903500">(Aug 23 2022 at 16:25)</a>:</h4>
<p>(and I now feel very dumb)</p>



<a name="294903902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294903902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294903902">(Aug 23 2022 at 16:28)</a>:</h4>
<p>But this is an equality of functors, which is very rarely useful.</p>



<a name="294904450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294904450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294904450">(Aug 23 2022 at 16:31)</a>:</h4>
<p>This is probably better:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.types</span>
<span class="kn">import</span> <span class="n">category_theory.functor</span>
<span class="kn">import</span> <span class="n">data.set.function</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kn">namespace</span> <span class="n">category_theory.functor</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">subfunctor</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
  <span class="o">(</span><span class="n">obj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">c</span><span class="o">,</span> <span class="n">set</span> <span class="bp">$</span> <span class="n">F.obj</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">⟶</span> <span class="n">d</span><span class="o">),</span> <span class="n">set.maps_to</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">obj</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">obj</span> <span class="n">d</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="n">subtype</span> <span class="o">(</span><span class="n">obj</span> <span class="n">c</span><span class="o">),</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">c</span> <span class="n">d</span> <span class="n">m</span><span class="o">,</span> <span class="n">set.maps_to.restrict</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">map</span> <span class="n">c</span> <span class="n">d</span> <span class="n">m</span><span class="o">),</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">intro</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">map_id</span><span class="o">,</span> <span class="n">set.maps_to.coe_restrict_apply</span><span class="o">,</span> <span class="n">types_id_apply</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">intros</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">map_comp</span><span class="o">,</span> <span class="n">set.maps_to.coe_restrict_apply</span><span class="o">,</span> <span class="n">types_comp_apply</span><span class="o">],</span> <span class="o">},}</span>

<span class="kd">def</span> <span class="n">subfunctor.ext</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
  <span class="o">(</span><span class="n">obj₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">c</span><span class="o">,</span> <span class="n">set</span> <span class="bp">$</span> <span class="n">F.obj</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">map₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">⟶</span> <span class="n">d</span><span class="o">),</span> <span class="n">set.maps_to</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">obj₁</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">obj₁</span> <span class="n">d</span><span class="o">))</span>
  <span class="o">(</span><span class="n">obj₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">c</span><span class="o">,</span> <span class="n">set</span> <span class="bp">$</span> <span class="n">F.obj</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">map₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">⟶</span> <span class="n">d</span><span class="o">),</span> <span class="n">set.maps_to</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">obj₂</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">obj₂</span> <span class="n">d</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">c</span><span class="o">,</span> <span class="n">obj₁</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">obj₂</span> <span class="n">c</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">F.subfunctor</span> <span class="n">obj₁</span> <span class="n">map₁</span> <span class="bp">≅</span> <span class="n">F.subfunctor</span> <span class="n">obj₂</span> <span class="n">map₂</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">objeq</span><span class="o">,</span>
<span class="n">nat_iso.of_components</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="n">equiv.to_iso</span> <span class="bp">$</span> <span class="n">equiv.subtype_equiv_prop</span> <span class="bp">$</span> <span class="n">objeq</span> <span class="n">_</span> <span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">tidy</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">category_theory.functor</span>
</code></pre></div>



<a name="294905034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294905034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294905034">(Aug 23 2022 at 16:34)</a>:</h4>
<p>In what sense is that better? (not a rhetorical question)</p>



<a name="294905121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294905121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294905121">(Aug 23 2022 at 16:34)</a>:</h4>
<p>is it because it uses more "categorical" building blocks instead of a blind substitution?</p>



<a name="294905344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294905344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294905344">(Aug 23 2022 at 16:36)</a>:</h4>
<p>Yeah essentially. In practice, think about how you would use the equality of functors -- essentially you would have to rewrite it somewhere, which would introduce <code>eq.rec</code>s in the goals, and those are hard to work with.</p>



<a name="294905698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294905698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294905698">(Aug 23 2022 at 16:38)</a>:</h4>
<p>The benefit of the isomorphism above is that it has good defeq properties, so if you compose with such an iso instead of rewriting with an equality, then by applying <code>ext</code> lemmas sufficiently many times, you should be able to reduce goals to, essentially, <code>∀ c, obj₁ c = obj₂ c</code>.</p>



<a name="294906070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Subfunctors/near/294906070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Subfunctors.html#294906070">(Aug 23 2022 at 16:40)</a>:</h4>
<p>ah, OK, so it's really more than aesthetics questions.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/.E2.9C.94.20heq_congr.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.E2.9C.94.20heq_congr.3F.html">✔ heq_congr?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="271075875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%E2%9C%94%20heq_congr%3F/near/271075875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rish Vaishnav <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.E2.9C.94.20heq_congr.3F.html#271075875">(Feb 08 2022 at 03:12)</a>:</h4>
<p>Perfect! Thank you!</p>



<a name="271075903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%E2%9C%94%20heq_congr%3F/near/271075903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.E2.9C.94.20heq_congr.3F.html#271075903">(Feb 08 2022 at 03:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="373814">Rish Vaishnav</span> has marked this topic as resolved.</p>



<a name="271088380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%E2%9C%94%20heq_congr%3F/near/271088380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.E2.9C.94.20heq_congr.3F.html#271088380">(Feb 08 2022 at 07:00)</a>:</h4>
<p>I think the general rule with heq is that either you're doing something wrong or you're intentionally doing something technical and are probably an expert. I've heard people who have had to battle with heq tell me that it's not as bad as everyone says though. To my surprise <span class="user-mention" data-user-id="133584">@Joseph Hua</span> 's first project in my course had a bunch of heqs in!</p>



<a name="271090056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%E2%9C%94%20heq_congr%3F/near/271090056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.E2.9C.94.20heq_congr.3F.html#271090056">(Feb 08 2022 at 07:29)</a>:</h4>
<p>I've never heard of <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#unify_equations">tactic#unify_equations</a> before</p>



<a name="271115830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%E2%9C%94%20heq_congr%3F/near/271115830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.E2.9C.94.20heq_congr.3F.html#271115830">(Feb 08 2022 at 11:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/.E2.9C.94.20heq_congr.3F/near/271088380">said</a>:</p>
<blockquote>
<p>I think the general rule with heq is that either you're doing something wrong or you're intentionally doing something technical and are probably an expert. I've heard people who have had to battle with heq tell me that it's not as bad as everyone says though. To my surprise <span class="user-mention silent" data-user-id="133584">Joseph Hua</span> 's first project in my course had a bunch of heqs in!</p>
</blockquote>
<p>it made some very slick proofs for equality of functors, because it's not asking for definitional equality on types</p>



<a name="271121249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%E2%9C%94%20heq_congr%3F/near/271121249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.E2.9C.94.20heq_congr.3F.html#271121249">(Feb 08 2022 at 12:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/.E2.9C.94.20heq_congr.3F/near/271075788">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="373814">Rish Vaishnav</span> That sort of lemma's not necessary because you can turn each heq into an eq step-by-step. There's a tactic for this, too, which is nice:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">heq_congr</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">hAB</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">hfg</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">g</span><span class="o">)</span>
  <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unify_equations</span> <span class="n">hAB</span> <span class="n">hfg</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I'm not sure this solves the issue. Yes, the general <code>heq_congr</code> lemma is easy to prove once you've stated it (you can also write <code>cases hAB, cases hfg, cases hab, refl</code>). The problem is when you are in a situation where <code>A</code> and <code>B</code> aren't local constants, so the same tactic invocation no longer works (but applying the general lemma would work).</p>
<p>One way of avoiding <code>==</code> in this case is to change the type of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">marginal</span> <span class="o">(</span><span class="n">mv</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span> <span class="n">measure</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">mv</span><span class="o">,</span> <span class="n">β</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>
<p>Can you define it as <code>measure (Π i : ι, β i)</code> instead? This is mathematically less natural, but it should be easier to work with because now the type doesn't depend on <code>mv</code> (working with type families over a type like<code>set ι</code> which has lots of equalities that aren't definitional often leads to this kind of problem).</p>



<a name="271148125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%E2%9C%94%20heq_congr%3F/near/271148125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rish Vaishnav <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.E2.9C.94.20heq_congr.3F.html#271148125">(Feb 08 2022 at 15:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/.E2.9C.94.20heq_congr.3F/near/271121249">said</a>:</p>
<blockquote>
<p>One way of avoiding <code>==</code> in this case is to change the type of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">marginal</span> <span class="o">(</span><span class="n">mv</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span> <span class="n">measure</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">mv</span><span class="o">,</span> <span class="n">β</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>
<p>Can you define it as <code>measure (Π i : ι, β i)</code> instead? This is mathematically less natural, but it should be easier to work with because now the type doesn't depend on <code>mv</code> (working with type families over a type like<code>set ι</code> which has lots of equalities that aren't definitional often leads to this kind of problem).</p>
</blockquote>
<p>This is an interesting suggestion, I could "extend" this marginal distribution definition to the full index type, though this would slightly complicate the (very simple) definitions I currently have. If I run into any big issues with <code>heq</code> I'll give it a shot, but I feel that I'm starting to get used to it.</p>
<p>As Joseph has suggested, I'm just using this for "slickness" in this proof. I had a version of it without <code>heq</code> but it was essentially a dumbed-down version of the proof above for conditional independence on random variables.</p>



<a name="271184676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%E2%9C%94%20heq_congr%3F/near/271184676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.E2.9C.94.20heq_congr.3F.html#271184676">(Feb 08 2022 at 20:15)</a>:</h4>
<p><span class="user-mention" data-user-id="373814">@Rish Vaishnav</span> Something <code>heq</code> wrangling can mean is missing lemmas about new definitions.  For example, the following one might be useful, since you can do <code>simp_rw [marginal_apply_copy μ f (set.union_empty B)]</code> in the <code>independent_iff_cond_irrel</code> theorem you pointed at. You'd still need to develop more lemmas around simplifying expressions involving <code>pi_set_equiv</code> though.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">pi_set_equiv</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">mv</span> <span class="n">mv'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">hmv</span> <span class="o">:</span> <span class="n">mv</span> <span class="bp">=</span> <span class="n">mv'</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">mv</span><span class="o">,</span> <span class="n">β</span> <span class="n">i</span><span class="o">)</span> <span class="bp">≃</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i'</span> <span class="o">:</span> <span class="n">mv'</span><span class="o">,</span> <span class="n">β</span> <span class="n">i'</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">subst</span> <span class="n">hmv</span>

<span class="kd">theorem</span> <span class="n">marginal_apply_copy</span> <span class="o">{</span><span class="n">mv</span> <span class="n">mv'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">hmv</span> <span class="o">:</span> <span class="n">mv</span> <span class="bp">=</span> <span class="n">mv'</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">mv</span><span class="o">,</span> <span class="n">β</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">marginal</span> <span class="n">μ</span> <span class="n">f</span> <span class="n">mv</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">marginal</span> <span class="n">μ</span> <span class="n">f</span> <span class="n">mv'</span> <span class="o">(</span><span class="n">pi_set_equiv</span> <span class="n">β</span> <span class="n">hmv</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">subst</span> <span class="n">hmv</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">congr_arg</span><span class="o">,</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">pi_set_equiv</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">set.image_id'</span><span class="o">,</span> <span class="n">equiv.coe_refl</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="271190060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%E2%9C%94%20heq_congr%3F/near/271190060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.E2.9C.94.20heq_congr.3F.html#271190060">(Feb 08 2022 at 20:59)</a>:</h4>
<p>Some justification for <code>heq</code>-avoidance is from the following interpretation of what <code>heq</code> even is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">lemma</span> <span class="n">heq_iff</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">==</span> <span class="n">b</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span><span class="o">),</span> <span class="n">cast</span> <span class="n">h</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>It's that there's an equality <code>h : α = β</code> such that the canonical equivalence <code>cast h : α → β</code> carries <code>a</code> to <code>b</code>. That's it.</p>
<p>Usually there's something more meaningful than <code>cast h</code> that you can use, and it's usually worth building out some additional definitions and lemmas to support that.</p>



<a name="271235243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%E2%9C%94%20heq_congr%3F/near/271235243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rish Vaishnav <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.E2.9C.94.20heq_congr.3F.html#271235243">(Feb 09 2022 at 06:13)</a>:</h4>
<p>Thanks, will try using that instead.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
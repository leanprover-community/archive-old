---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html">tensor products commute with direct limits</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="274733899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274733899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274733899">(Mar 09 2022 at 18:47)</a>:</h4>
<p>This may be another product of me being bad at searching for things, but does mathlib know that <code> ⊗ M</code> commutes with direct limits?  </p>
<p>Also a small update, but I was able to finish the construction of the equivalence of a module with the direct limit of its finitely generated submodules! (hence why I'm looking for the above lemma haha)</p>



<a name="274735586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274735586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274735586">(Mar 09 2022 at 19:00)</a>:</h4>
<p><span class="user-mention" data-user-id="455674">@Matej Penciak</span> The answer is "yes and no". Mathlib knows that the in the category <code>Module R</code>, the functor <code> ⊗ M</code> is a left adjoint, and hence preserves all colimits. With a bit of luck, there is also a lemma that says that the hands-on direct limit (which I'm assuming you have used) is an example of a colimit in the sense of the category theory library. Combining these facts should give your desired statement.<br>
But this means that you will probably need a bit of glue to repackage your statements in the language of <code>category_theory</code>.</p>



<a name="274735712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274735712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274735712">(Mar 09 2022 at 19:00)</a>:</h4>
<p>2 messages were moved here from <a class="stream-topic" data-stream-id="113489" href="/#narrow/stream/113489-new-members/topic/namespaces.2C.20and.20more">#new members &gt; namespaces, and more</a> by <span class="user-mention silent" data-user-id="112680">Johan Commelin</span>.</p>



<a name="274735804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274735804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274735804">(Mar 09 2022 at 19:01)</a>:</h4>
<p><span class="user-mention" data-user-id="455674">@Matej Penciak</span> I have moved your message to a new thread in a different stream. I think this location is more appropriate.</p>



<a name="274736924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274736924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274736924">(Mar 09 2022 at 19:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/274735804">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="455674">Matej Penciak</span> I have moved your message to a new thread in a different stream. I think this location is more appropriate.</p>
</blockquote>
<p>Gotcha! Thanks</p>



<a name="274737184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274737184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274737184">(Mar 09 2022 at 19:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/274735586">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="455674">Matej Penciak</span> The answer is "yes and no". Mathlib knows that the in the category <code>Module R</code>, the functor <code> ⊗ M</code> is a left adjoint, and hence preserves all colimits. With a bit of luck, there is also a lemma that says that the hands-on direct limit (which I'm assuming you have used) is an example of a colimit in the sense of the category theory library. Combining these facts should give your desired statement.<br>
But this means that you will probably need a bit of glue to repackage your statements in the language of <code>category_theory</code>.</p>
</blockquote>
<p>I think I'll want to use the <code>Module R</code> language for different parts of the proof anyway, so I think I'll try to clean up what I have and try to provide some of that glue next. Thanks for your help!</p>



<a name="274740094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274740094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274740094">(Mar 09 2022 at 19:30)</a>:</h4>
<p>There's a <code>monoidal_closed</code> instance for <code>Module R</code>, and this shows tensoring with an object preserves all colimits.</p>



<a name="274740134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274740134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274740134">(Mar 09 2022 at 19:30)</a>:</h4>
<p>I've been using this just yesterday.</p>



<a name="274740174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274740174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274740174">(Mar 09 2022 at 19:30)</a>:</h4>
<p>Let me know if you need help identifying all the moving parts!</p>



<a name="274784757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274784757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274784757">(Mar 10 2022 at 03:18)</a>:</h4>
<p>Caution: in <code>Module R</code> any two modules lie in the same universe, so if you want to prove the fully universe polymorphic version of the result, you'll face universe issue when applying results in <code>Module R</code>.</p>



<a name="274786435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274786435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274786435">(Mar 10 2022 at 03:52)</a>:</h4>
<p>That's a fair point. On the other hand, I don't think it makes sense to duplicate major parts of the <code>category_theory</code> library just to remain maximally universe polymorphic.</p>



<a name="274786693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274786693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274786693">(Mar 10 2022 at 03:58)</a>:</h4>
<p>There aren't many colimits where the modules are in different universes anyway...</p>



<a name="274795643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274795643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274795643">(Mar 10 2022 at 06:30)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/module.direct_limit">docs#module.direct_limit</a> requires all modules lie in the same universe but possibly different from the ring's universe (of course, you can't define a function in Lean with values lie in different universes); it's <a href="https://leanprover-community.github.io/mathlib_docs/find/tensor_product">docs#tensor_product</a> that allows the two module (and the ring) to be in different universes. We don't seem to have a <code>is_direct_limit</code> predicate, so it seems the easiest way state the result in the OP is to use <code>is_colimit</code>/<code>preserves_colimit</code> (otherwise you need to say an isomorphism to the direct limit commuting with natural maps).</p>
<p>It's interesting to observe that <a href="https://leanprover-community.github.io/mathlib_docs/find/module.direct_limit">docs#module.direct_limit</a> doesn't include any commutativity conditions and there's <a href="https://leanprover-community.github.io/mathlib_docs/find/directed_system">docs#directed_system</a> imposing the conditions, which isn't needed by many declarations in that file, but is used in <a href="https://github.com/eric-wieser/flatstuff/blob/265b4d82dc06220bba8e1941a7039e698ba2392a/src/finite_submodules.lean#L159">flatstuff</a> and certainly is needed for <a href="https://leanprover-community.github.io/mathlib_docs/find/Module.direct_limit_is_colimit">docs#Module.direct_limit_is_colimit</a>.</p>



<a name="274796320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274796320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274796320">(Mar 10 2022 at 06:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/274786435">said</a>:</p>
<blockquote>
<p>That's a fair point. On the other hand, I don't think it makes sense to duplicate major parts of the <code>category_theory</code> library just to remain maximally universe polymorphic.</p>
</blockquote>
<p>I think it's not duplication but refactoring that's required to achieve full universe polymorphism in this case. If <code>M : Type u</code> then <code>M ⊗</code> is a functor from <code>Module.{v} R</code> to <code>Module.{max u v} R</code> which mathlib doesn't have, of which <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.monoidal_category.tensor_left">docs#category_theory.monoidal_category.tensor_left</a> is a special case (u=v). We can show Hom is the right adjoint to this functor, which would specialize to the monoidal category case. Anyway, it's not a small effort and may be not worth it.</p>



<a name="274796421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274796421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274796421">(Mar 10 2022 at 06:47)</a>:</h4>
<p>However, currently flatness is already defined allowing R and M be in different universes, so tensor product between modules in different universe (M with ideals of R) is present in the very definition! So you have to deal with it if you want to keep the generality.</p>



<a name="274796423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274796423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274796423">(Mar 10 2022 at 06:47)</a>:</h4>
<p>But the Hom functor will have different universes, right? In the universe polymorphic setup, they aren't adjoint functors, I think.</p>



<a name="274796551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274796551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274796551">(Mar 10 2022 at 06:49)</a>:</h4>
<p>I think it's easier to have a <code>ulift</code> functor, and show that it preserves limits and colimits.</p>



<a name="274796562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274796562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274796562">(Mar 10 2022 at 06:49)</a>:</h4>
<p>But I think it's also perfectly fine to put everything in the same universe for now.</p>



<a name="274796786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274796786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274796786">(Mar 10 2022 at 06:53)</a>:</h4>
<blockquote>
<p>But the Hom functor will have different universes, right? In the universe polymorphic setup, they aren't adjoint functors, I think.</p>
</blockquote>
<p>Hmm you're right, Hom(N,P) for N : Type v and P : Type (max u v) would lie in Type (max u v) instead of Type u, so the right adjoint may not exist.</p>



<a name="274802214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274802214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274802214">(Mar 10 2022 at 08:10)</a>:</h4>
<p>There are criteria for flatness which involve testing against tensoring with ideals, and you could imagine that these criteria become false if the module is in a larger universe than the ring because there are "not enough ideals" somehow. I can't imagine applications where the ring and module aren't in the same universe (especially now ulift works)</p>



<a name="274841649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274841649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274841649">(Mar 10 2022 at 14:26)</a>:</h4>
<p>Actually I'm not sure whether the tensoring functor preserves colimits if the universe v of the indexing type ι of <a href="https://leanprover-community.github.io/mathlib_docs/find/module.direct_limit">docs#module.direct_limit</a> is smaller than the universes w of the module. In general, does the lifting functor from <code>Module.{u}</code> to <code>Module.{max u v}</code> preserves "large" (i.e. the indexing category J is in higher universe than u) (co)limits? I guess the answer is yes, because if the (co)limit is too large to fit in Module.{u} then the (co)limit would simply not exist in Module.{u}, because you can construct cones with larger and larger cone point? Or you may consider the category <code>Type</code>, for which this becomes a set-theoretic question. I'd be interested to see a counterexample in either case.</p>



<a name="274842178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274842178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274842178">(Mar 10 2022 at 14:31)</a>:</h4>
<p>Anyway, preserves_limits is defined to be <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.preserves_limits_of_size">docs#category_theory.limits.preserves_limits_of_size</a> with J (both objects and morphisms) in the universe of the hom type of the domain of the functor, though, and it should suffice for the current application, since the type of f.g. submodules of a module lies in the same universe as the module.</p>



<a name="274845442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274845442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274845442">(Mar 10 2022 at 14:54)</a>:</h4>
<p>The explicit construction of (co)limits in <code>Type u</code> doesn't really seem to care about universes, right?</p>



<a name="274847561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274847561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274847561">(Mar 10 2022 at 15:08)</a>:</h4>
<p>I didn't check but I think that predates <a href="https://github.com/leanprover-community/mathlib/pull/10243">#10243</a></p>



<a name="274847681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274847681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274847681">(Mar 10 2022 at 15:09)</a>:</h4>
<p>Yes, but the construction is compatible with <code>ulift</code>, right? Or was that not your question?</p>



<a name="274848370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274848370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274848370">(Mar 10 2022 at 15:14)</a>:</h4>
<p>before <a href="https://github.com/leanprover-community/mathlib/pull/10243">#10243</a> you can't talk about limits with J is in not same universe as the morphisms, or functors between categories in different universes preserving limits. And certain (co)limits certainly shouldn't exist in the same universe, e.g. the disjoint union of #(Type u) many <code>unit</code> in Type u. The general construction would work but the result would like Type (u+1).</p>



<a name="274848587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274848587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274848587">(Mar 10 2022 at 15:16)</a>:</h4>
<p>Right, so certain (co)limits don't exist for universe reasons. But apart from those obstructions, all (co)limits exists, and are compatible with making the universe of the ambient category larger by composing with <code>ulift</code>.</p>



<a name="274848996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274848996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274848996">(Mar 10 2022 at 15:19)</a>:</h4>
<p>But I can't seem to rule out that the limit may exist in Type u but isn't isomorphic to the limit in Type (u+1), like a limit in RingedSpace isn't necessarily the same as that in LocallyRingedSpace...</p>



<a name="274910237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274910237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274910237">(Mar 10 2022 at 23:21)</a>:</h4>
<p>Hmm, since <code>Type</code> has generator <code>unit</code> and cogenerator <code>bool</code> in any universe, I think I have proofs that indeed <code>ulift_functor</code> preserves arbitrary large limits and colimits. The comparison morphism from the limit in the lower universe to the limit in the higher universe would also be useful (and dually for colimits). <code>Module</code> also has a generator so limits would be preserved, but what about cogenerator? Maybe we can somehow utilize the concrete category structure on <code>Module</code> ...</p>



<a name="274910552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274910552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274910552">(Mar 10 2022 at 23:25)</a>:</h4>
<p>For filtered colimits, you should be able to reduce to <code>Type*</code>.</p>



<a name="274910601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274910601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274910601">(Mar 10 2022 at 23:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/274848996">said</a>:</p>
<blockquote>
<p>But I can't seem to rule out that the limit may exist in Type u but isn't isomorphic to the limit in Type (u+1), like a limit in RingedSpace isn't necessarily the same as that in LocallyRingedSpace...</p>
</blockquote>
<p>I don't know any of the category theory context so someone should catch me up, but this sounds wrong. It should be possible to prove that limits and colimits taken in <code>Type (u+1)</code> are isomorphic to the analogous limit in <code>Type u</code> if it exists</p>



<a name="274911493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274911493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274911493">(Mar 10 2022 at 23:36)</a>:</h4>
<p>Yes I just came up with proofs, but I don't think these are obvious from these categorical definitions <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.is_limit">docs#category_theory.limits.is_limit</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.preserves_limits_of_size">docs#category_theory.limits.preserves_limits_of_size</a> ...</p>



<a name="274911581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274911581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274911581">(Mar 10 2022 at 23:37)</a>:</h4>
<p>You can see from the "explicit" definitions of limits and colimits in <code>Type*</code> that the ulift functor preserves (maybe even creates?) limits and colimit.</p>



<a name="274912250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274912250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274912250">(Mar 10 2022 at 23:45)</a>:</h4>
<p>The explicit definition may give you something in a higher universe; when it's in the same universe then it's the categorical limit, and ulift would preserve the limit. What I was concerned with is when the construction gives a result in a higher universe, and at the same time there accidentally exists a limit in the original universe.</p>
<p>Will be back in 1.5 hours and try to formalize the proofs.</p>



<a name="274913691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274913691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274913691">(Mar 11 2022 at 00:01)</a>:</h4>
<p>If there is "accidentally" a limit in the original universe, then you can ulift it into the higher universe and it will still be a limit; you can then compare it with the categorical limit to derive isomorphism</p>



<a name="274919511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274919511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274919511">(Mar 11 2022 at 01:09)</a>:</h4>
<p>For the constructed limits (and constructed tensor products etc.) we usually immediately prove that it satisfies the universal property in any universe, but for the accidental limit, we only know its universal property in its universe. Indeed there's a comparison morphism after lifting but it requires proof to show it's an isomorphism. The comparison morphism being isomorphism is equivalent to ulift_functor preserving limit, which means exactly that "ulift it into the higher universe and it will still be a limit", and which I am trying to prove.</p>



<a name="274920570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274920570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274920570">(Mar 11 2022 at 01:26)</a>:</h4>
<p>There are lots of full subcategory inclusions (~ fully faithful functors) that don't preserve (co)limits, so I'd argue that Type u ⥤ Type (u+1) is the exception rather than the rule.</p>
<p>We do know <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.fully_faithful_reflects_limits">docs#category_theory.limits.fully_faithful_reflects_limits</a> and the same for colimits, so (co)limits in the larger category that lie in the smaller category are automatically (co)limits in the smaller category.</p>



<a name="274921688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274921688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274921688">(Mar 11 2022 at 01:45)</a>:</h4>
<blockquote>
<p>There are lots of full subcategory inclusions (~ fully faithful functors) that don't preserve (co)limits, so I'd argue that Type u ⥤ Type (u+1) is the exception rather than the rule.</p>
</blockquote>
<p>This should be true for Type and for any category where the objects have an "internal" definition, including <code>Module</code> and most other categories I can think of. Do you have an example where things go wrong?</p>



<a name="274921838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274921838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274921838">(Mar 11 2022 at 01:47)</a>:</h4>
<p>The reason ulift_functor preserves limits is not because of abstract nonsense but by unpacking the definition of the morphisms and how they interact with <code>ulift</code> specifically. I would expect that the abstract nonsense does not give you enough to prove the theorem, because as you say there are other kinds of fully faithful functors that don't preserve limits</p>



<a name="274922926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274922926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274922926">(Mar 11 2022 at 02:03)</a>:</h4>
<p>I didn't quite propose to use abstract nonsense to prove it; <code>unit</code> being a generator means that Hom(unit, -) is faithful, which means that two functions are distinguished by their values on points; <code>bool</code> being a cogenerator means that Hom(-, bool) is faithful, which means that two functions are distinguished by considering preimages of subsets of the codomain. The key in this argument is that <code>unit</code> and <code>bool</code> already lie in the lowest universe.</p>
<p>I don't know what "internal" means, but <a href="https://mathoverflow.net/a/370624/3332">here</a> is an example showing the inclusion from abelian groups to groups where things go wrong (doesn't preserve colimits).</p>



<a name="274937987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274937987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274937987">(Mar 11 2022 at 07:03)</a>:</h4>
<p>Here is a proof that ulift_functor preserves limits. I realized the colimit case is trickier than I thought; not every g : (Y -&gt; bool) -&gt; (X -&gt; bool) comes from some f : X -&gt; Y (Hom(-,bool) is faithful but not full, unlike Hom(unit,-) which is even an equivalence of categories), and I'm yet to write down a condition g should satisfy in order to recover f ...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.limits.preserves.basic</span>
<span class="kn">open</span> <span class="n">category_theory</span> <span class="n">category_theory.limits</span> <span class="n">opposite</span>
<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">w'</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">w'</span><span class="o">}</span> <span class="n">J</span><span class="o">]</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">cone</span> <span class="n">F</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">cone_of_element</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">cone</span> <span class="o">(</span><span class="n">F</span> <span class="bp">⋙</span> <span class="n">ulift_functor.</span><span class="o">{</span><span class="n">v</span> <span class="n">u</span><span class="o">})}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">c.X</span><span class="o">)</span> <span class="o">:</span> <span class="n">cone</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">punit</span><span class="o">,</span> <span class="n">π</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">j</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">c.π.app</span> <span class="n">j</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">down</span><span class="o">,</span>
    <span class="n">naturality'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">c.w</span> <span class="n">f</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">preserves_limits</span> <span class="o">:</span> <span class="n">preserves_limits_of_size.</span><span class="o">{</span><span class="n">w'</span> <span class="n">w</span><span class="o">}</span> <span class="n">ulift_functor.</span><span class="o">{</span><span class="n">v</span> <span class="n">u</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">preserves_limits_of_shape</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="o">{</span> <span class="n">preserves_limit</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">D</span><span class="o">,</span> <span class="o">{</span> <span class="n">preserves</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">c</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">lift</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">lc</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">h.lift</span> <span class="o">(</span><span class="n">cone_of_element</span> <span class="n">x</span><span class="o">)</span> <span class="n">punit.star</span><span class="o">⟩,</span>
    <span class="n">fac'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">lc</span> <span class="n">j</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">apply</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">h.fac</span> <span class="n">_</span> <span class="n">j</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">uniq'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">lc</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">apply</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">h.uniq</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">down</span><span class="o">)</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">intro</span> <span class="n">j</span><span class="o">,</span> <span class="n">ext</span> <span class="o">⟨⟩,</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">hf</span> <span class="n">j</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="n">ulift.down</span> <span class="n">this</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="274938179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274938179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274938179">(Mar 11 2022 at 07:06)</a>:</h4>
<p>Hmm, the condition should be that of boolean algebra hom, I guess.</p>



<a name="274947087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/274947087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#274947087">(Mar 11 2022 at 08:54)</a>:</h4>
<p>Boolean algebra homs? This is just <a href="https://leanprover-community.github.io/mathlib_docs/find/bounded_lattice_hom">docs#bounded_lattice_hom</a></p>



<a name="275178330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275178330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275178330">(Mar 13 2022 at 22:25)</a>:</h4>
<p>I now have a <a href="https://gist.github.com/alreadydone/ecf34077c0ca9250bfb6ab41e00d76e8">complete proof</a> that ulift_functor preserves all colimits as well. I believe it contains all ingredients to construct the <a href="https://ncatlab.org/nlab/show/complete+Boolean+algebra#cabas">contravariant equivalence</a> between <code>Type</code> and the category of <strong>complete</strong> atomic Boolean algebras, but I use a direct approach that need not mention these concepts.</p>
<p>The same argument should work for limits in Group and AddCommGroup (because the generator Z already lies in the lowest universe), but for Module it would only apply if the lower universe contains the ring R, which also serves as a generator in the higher universe. In these arguments I do not assume the (co)limit exists in the higher universe so I do not have access to the comparison morphism. If you take advantage of that maybe you can prove more.</p>
<p>For colimits it's a different story: ulifting groups doesn't actually preserve colimits! <a href="https://mathoverflow.net/q/353408/3332">One can embed</a> any infinite group G canonically into a simple group of cardinality <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi mathvariant="normal">∣</mi><mi>G</mi><mi mathvariant="normal">∣</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{|G|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight">G</span><span class="mord mtight">∣</span></span></span></span></span></span></span></span></span></span></span></span>, and we may transfinitely iterate this construction to obtain a direct system of groups indexed by ordinals in the universe, <a href="https://mathoverflow.net/a/348643/3332">whose colimit G+ is again a simple group</a>, whose cardinality is too large to lie in the universe, but does live in the next higher universe. In the lower universe, the colimit exists and is the trivial group, because for any cocone over the direct system, there exists a homomorphism from G+ to the cone point, which can't be an isomorphism onto the image due to cardinality reason, so must be trivial as G+ is simple. Therefore, ulifting to the next higher universe doesn't preserve colimits in Group. <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> </p>
<p>It's also interesting to learn that certain free objects (small coproducts of free objects on one generator) don't exist in the same universe but only in the next higher one, like the free complete lattice on three generators, or the free complete Boolean algebra on countably many generators, but these don't provide examples because the colimits don't exist in the lower universe.</p>
<p>There seems to exist other ways things can "go wrong": there are algebraic <a href="https://mathoverflow.net/q/1924/3332">statements independent of ZFC</a>, like the <a href="https://encyclopediaofmath.org/wiki/Whitehead_problem">Whitehead problem</a>. It looks plausible to me that there exists a model of Lean's type theory where <code>Type 0</code> "is" the constructible universe, so all Whitehead groups there are free, while <code>Type 1</code> "satisfies" Martin's axiom, and non-free Whitehead groups exists there. However, I haven't been able to connect such statements to limits.</p>



<a name="275178860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275178860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275178860">(Mar 13 2022 at 22:38)</a>:</h4>
<p>Fascinating! Well done!</p>



<a name="275180478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275180478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275180478">(Mar 13 2022 at 23:15)</a>:</h4>
<p>Asking for a nontrivial exact endofunctor on Set is a pretty reasonable statement, and it's equivalent to the existence of a measurable cardinal, which certainly isn't implied by ZFC: <a href="https://ncatlab.org/nlab/show/measurable+cardinal#in_category_theory">https://ncatlab.org/nlab/show/measurable+cardinal#in_category_theory</a>, maybe this is the sort of connection to limits you might be looking for?</p>



<a name="275189235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275189235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275189235">(Mar 14 2022 at 02:53)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> That construction requires you to take a colimit over a large index set though. Hopefully the theorem should at least be true for small colimits of groups</p>



<a name="275189389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275189389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275189389">(Mar 14 2022 at 02:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/275178330">said</a>:</p>
<blockquote>
<p>There seems to exist other ways things can "go wrong": there are algebraic <a href="https://mathoverflow.net/q/1924/3332">statements independent of ZFC</a>, like the <a href="https://encyclopediaofmath.org/wiki/Whitehead_problem">Whitehead problem</a>. It looks plausible to me that there exists a model of Lean's type theory where <code>Type 0</code> "is" the constructible universe, so all Whitehead groups there are free, while <code>Type 1</code> "satisfies" Martin's axiom, and non-free Whitehead groups exists there. However, I haven't been able to connect such statements to limits.</p>
</blockquote>
<p>I don't believe it is possible for Martin's axiom or CH to be true in a higher universe and false in a lower one, because it is a statement about sets of bounded cardinality. Any "internal" property (i.e. not something like projectiveness that talks about the other types in the given universe) about small sets in a large universe can be reflected back down to the small universe.</p>



<a name="275189725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275189725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275189725">(Mar 14 2022 at 03:04)</a>:</h4>
<p>In your example, if <code>Type 0</code> is the constructible universe, then all Whitehead groups of cardinality <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">ℵ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\aleph_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">ℵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are free, but then any Whitehead group in <code>Type 1</code> is provably "small" because <code>aleph 1</code> is a small cardinal, and hence is isomorphic to a group in <code>Type 0</code>; and group isomorphism preserves the Whitehead property, so all Whitehead groups of cardinality <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">ℵ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\aleph_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">ℵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in any universe are free.</p>



<a name="275189822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275189822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275189822">(Mar 14 2022 at 03:06)</a>:</h4>
<p>Another example of this kind of reasoning is that <code>Con(ZFC + 6 inaccessibles)</code> is a property of <code>nat</code> in <code>Type 0</code> but it is provable in lean because we can construct a model of ZFC + 6 inaccessibles in <code>Type 7</code></p>



<a name="275363819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275363819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275363819">(Mar 15 2022 at 12:11)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> <span class="user-mention" data-user-id="125393">@Junyan Xu</span> definitely have a look at <a href="https://github.com/leanprover-community/mathlib/pull/11677">#11677</a></p>



<a name="275460857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275460857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yi Hu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275460857">(Mar 16 2022 at 02:29)</a>:</h4>
<p>Hello. I am new. I'd like to get an idea about the feasibility of formalizing a 159-page paper and approximate timescales. Thanks!</p>



<a name="275461118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275461118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275461118">(Mar 16 2022 at 02:35)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="485551">@Yi Hu</span>, welcome!  It depends very much on the paper, can you say more about it?  But frankly, formalization is a long way from the research frontier in most fields of math, and you would have to build in the time to get to that research frontier as well as the time for formalizing the paper itself.</p>



<a name="275462970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275462970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yi Hu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275462970">(Mar 16 2022 at 03:15)</a>:</h4>
<p>The paper is here <a href="https://arxiv.org/abs/2203.03842">https://arxiv.org/abs/2203.03842</a><br>
The main components are about a family of polynomials and their proper transforms after (hugely numerous) simple blowups.</p>



<a name="275463293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275463293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275463293">(Mar 16 2022 at 03:22)</a>:</h4>
<p>We're a long way from this, unfortunately.  Although we do aspire to get there (in 5 years?  10?), and it would be great to have you join the effort :-).  </p>
<p>Just looking at the first sentence, I'm not even sure that mathlib has the definition of a rational map between schemes.</p>



<a name="275463658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275463658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275463658">(Mar 16 2022 at 03:31)</a>:</h4>
<p>If you could extract a (very complicated) result purely about commutative algebra or polynomials which you wanted checked, that might be more within reach.</p>



<a name="275473024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/tensor%20products%20commute%20with%20direct%20limits/near/275473024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/tensor.20products.20commute.20with.20direct.20limits.html#275473024">(Mar 16 2022 at 06:58)</a>:</h4>
<p>5 messages were moved from this topic to <a class="stream-topic" data-stream-id="113489" href="/#narrow/stream/113489-new-members/topic/Introductions.3A.20Yi.20Hu">#new members &gt; Introductions: Yi Hu</a> by <span class="user-mention silent" data-user-id="112680">Johan Commelin</span>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
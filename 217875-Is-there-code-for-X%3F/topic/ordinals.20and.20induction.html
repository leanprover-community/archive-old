---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html">ordinals and induction</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="273653022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273653022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273653022">(Mar 01 2022 at 14:58)</a>:</h4>
<p>I would like to make an induction over ordinals less than a given ordinal <code>o</code> (say, <code>o = cardinal.ord (aleph 1 : cardinal.{u})</code>). I can do an induction over all ordinals in <code>ordinal.{u}</code>, but this brings me to universe <code>u+1</code>, which is problematic for me. Instead of this, it would be more convenient to have a representative of <code>o</code> as a type in <code>Type u</code>, with a well-order, but I can't find an API around this. <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , do you have thoughts about a nice way to do this with current mathlib?</p>



<a name="273654384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273654384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273654384">(Mar 01 2022 at 15:06)</a>:</h4>
<p>If <code>o : ordinal</code>, you can use <code>o.out.α</code> for a representative (using <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient_out">docs#quotient_out</a>), and there are a bunch of lemmas about this, like <a href="https://leanprover-community.github.io/mathlib_docs/find/ordinal.type_out">docs#ordinal.type_out</a>.</p>



<a name="273655056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273655056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273655056">(Mar 01 2022 at 15:11)</a>:</h4>
<p>Yes, but as far as I can tell there is no order relation instantiated by default on <code>o.out.α</code>. Maybe it's just a matter of registering them, but since they're not there I was wondering if I was missing another way.</p>



<a name="273655856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273655856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273655856">(Mar 01 2022 at 15:17)</a>:</h4>
<p>Oh, I see. Yeah, most of the ordinal library works with an explicitly given order <code>r</code>, instead of <code>&lt;</code>.</p>



<a name="273656392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273656392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273656392">(Mar 01 2022 at 15:21)</a>:</h4>
<p>Maybe it's just a matter of registering a few instances such as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">has_lt</span> <span class="o">(</span><span class="n">o.out.α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">o.out.r</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">has_well_founded</span> <span class="n">o.out.α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">has_lt.lt</span><span class="o">,</span> <span class="n">o.out.wo.wf</span><span class="o">⟩</span>
</code></pre></div>
<p>(probably building a linear order).</p>



<a name="273656917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273656917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273656917">(Mar 01 2022 at 15:23)</a>:</h4>
<p>What do you want to do with it that you cannot use <code>r</code> directly?</p>



<a name="273658256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273658256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273658256">(Mar 01 2022 at 15:31)</a>:</h4>
<p>Maybe it's an <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> problem. I want to show that the cardinality of the sigma-algebra generated by something is controlled in terms of the cardinality of the something. The standard proof is to construct the sets in thz sigma-algebra by transfinite induction, show that it stabilizes at omega_1, and obtain inductively the cardinality controls. The inductive construction would be something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">has_lt</span> <span class="o">(</span><span class="n">o.out.α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">o.out.r</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">has_well_founded</span> <span class="n">o.out.α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">has_lt.lt</span><span class="o">,</span> <span class="n">o.out.wo.wf</span><span class="o">⟩</span>
<span class="kd">theorem</span> <span class="n">wf</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}):</span> <span class="bp">@</span><span class="n">well_founded</span> <span class="n">o.out.α</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">o.out.wo.wf</span>
<span class="kd">theorem</span> <span class="n">ordinal.out_induction</span> <span class="o">{</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">o.out.α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">o.out.α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">k</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="n">i</span> <span class="o">:=</span>
<span class="n">o.out.wo.wf.induction</span> <span class="n">i</span> <span class="n">h</span>

<span class="kd">def</span> <span class="n">induction_generate_from</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">cardinal.ord</span> <span class="o">(</span><span class="n">aleph</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">cardinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}))</span><span class="bp">.</span><span class="n">out.α</span> <span class="bp">→</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">s</span> <span class="bp">∪</span> <span class="o">{</span><span class="bp">∅</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">t</span><span class="bp">ᶜ</span><span class="o">)</span> <span class="bp">''</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="bp">//</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">},</span> <span class="n">induction_generate_from</span> <span class="n">j.1</span><span class="o">)</span>
      <span class="bp">∪</span> <span class="o">(</span><span class="n">set.range</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="bp">//</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">},</span> <span class="n">induction_generate_from</span> <span class="n">j.1</span><span class="o">)),</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">)))</span>
<span class="n">using_well_founded</span> <span class="o">{</span><span class="n">dec_tac</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="n">j.2</span><span class="o">]}</span>
</code></pre></div>
<p>This seems to work fine, but maybe there's a more idiomatic way.</p>



<a name="273659945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273659945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273659945">(Mar 01 2022 at 15:42)</a>:</h4>
<p>What I did for the small object argument is work as long as possible with a <code>well_order_top</code>, defined <a href="https://github.com/rwbarton/lean-model-categories/blob/top-dev/src/order/well_order_top.lean#L13">here</a> as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">well_order_top</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">complete_linear_order</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">wf_lt</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="o">((</span><span class="bp">&lt;</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">))</span>
</code></pre></div>
<p>but then eventually you have to get your hands on one somehow, which I did <a href="https://github.com/rwbarton/lean-model-categories/blob/top-dev/src/wfs_top.lean#L30">here</a> in basically the same way you have written above.</p>



<a name="273660211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273660211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273660211">(Mar 01 2022 at 15:44)</a>:</h4>
<p>For your cardinality argument of course there is no point in having the flexibility to choose a well-ordered type other than <code>o.out</code> in the cardinality estimate.</p>



<a name="273683189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273683189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273683189">(Mar 01 2022 at 17:59)</a>:</h4>
<p>There's a bunch of API that allows you to go back and forth between ordinals and a representative with the order type of a specific ordinal</p>



<a name="273683243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273683243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273683243">(Mar 01 2022 at 17:59)</a>:</h4>
<p><code>typein</code> and <code>enum</code> will help you here</p>



<a name="273683672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273683672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273683672">(Mar 01 2022 at 18:00)</a>:</h4>
<p>I'm personally opposed to making <code>&lt;</code> a synonym for <code>o.out.r</code> since that would muddle this distinction, I believe.</p>



<a name="273684939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273684939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273684939">(Mar 01 2022 at 18:08)</a>:</h4>
<p>Oh and also, <code>o.out.wo</code> will give you the proof that <code>o.out.r</code> is a well order in <code>o.out.\a</code></p>



<a name="273802937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273802937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273802937">(Mar 02 2022 at 13:07)</a>:</h4>
<p>Yeah, having two different names for the same relation is not ideal.  But I'd rather avoid the <code>o.out.r</code> then, and use <code>&lt;</code> instead everywhere.</p>



<a name="273932616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273932616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273932616">(Mar 03 2022 at 07:20)</a>:</h4>
<p>I have tried to go following your advice of not making <code>&lt;</code> a synonym for <code>o.out.r</code>. I was afraid it would be very heavy to use, but in fact with a few notations it is completely reasonable. You can have a look at <a href="https://github.com/leanprover-community/mathlib/pull/12422">#12422</a> to check that I am using the library in the way it was intended.</p>



<a name="273986264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273986264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273986264">(Mar 03 2022 at 15:11)</a>:</h4>
<p>Actually, I've thought about this for a bit, and particularly after seeing your code, I can definitely see the merit in the <code>&lt;</code> relation being a thing</p>



<a name="273986342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273986342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273986342">(Mar 03 2022 at 15:11)</a>:</h4>
<p>I may have forgotten than <code>&lt;</code> was quite overloaded as is</p>



<a name="273986428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/273986428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#273986428">(Mar 03 2022 at 15:12)</a>:</h4>
<p>(by design)</p>



<a name="274019047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/274019047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#274019047">(Mar 03 2022 at 18:43)</a>:</h4>
<p>Since it seems like other people here agree with the usefulness of this, I'll start to work on this in a few hours</p>



<a name="274138681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/274138681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Glöckle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#274138681">(Mar 04 2022 at 14:48)</a>:</h4>
<p>In my first transfinite induction in lean I wrote some lemmas like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lt_of_lt_of_le_unbundled</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">is_strict_total_order'</span> <span class="n">α</span> <span class="n">r</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hbc</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">r</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span><span class="n">r</span> <span class="n">a</span> <span class="n">c</span>
</code></pre></div>
<p>Is there an easier way? Otherwise I'd also plead for <code>&lt;</code> instead of <code>r</code></p>



<a name="274138958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/274138958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#274138958">(Mar 04 2022 at 14:50)</a>:</h4>
<p>I'm not sure what you mean. Are you trying to avoid <code>≤</code> and <code>&lt;</code>? If not, then you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/has_le.le.lt_of_not_le">docs#has_le.le.lt_of_not_le</a>.</p>



<a name="274139118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/274139118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Glöckle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#274139118">(Mar 04 2022 at 14:51)</a>:</h4>
<p>My point is precisely that: I don't know if it possible to access the lemma you cited without making the <code>&lt;</code> = <code>r</code> synonym</p>



<a name="274139302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/274139302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#274139302">(Mar 04 2022 at 14:52)</a>:</h4>
<p>And do you actually need to avoid using <code>≤</code> and <code>&lt;</code>?</p>



<a name="274139332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/274139332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#274139332">(Mar 04 2022 at 14:53)</a>:</h4>
<p><code>is_strict_order</code> is barely ever used.</p>



<a name="274139526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/274139526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Glöckle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#274139526">(Mar 04 2022 at 14:54)</a>:</h4>
<p>No, but in the status quo, as discussed above, there is only <code>o.out.r</code></p>



<a name="274139708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/274139708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Glöckle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#274139708">(Mar 04 2022 at 14:55)</a>:</h4>
<p>I was only supporting the proposal of introducing this <code>has_lt</code></p>



<a name="274291755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/274291755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#274291755">(Mar 06 2022 at 07:51)</a>:</h4>
<p>Then you're in luck! Check out <a href="https://github.com/leanprover-community/mathlib/pull/12468">#12468</a>.</p>



<a name="310499372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/310499372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#310499372">(Nov 16 2022 at 20:50)</a>:</h4>
<p>I'm trying to generalize this definition<br>
<span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/ordinals.20and.20induction/near/273658256">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">induction_generate_from</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">cardinal.ord</span> <span class="o">(</span><span class="n">aleph</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">cardinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}))</span><span class="bp">.</span><span class="n">out.α</span> <span class="bp">→</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">s</span> <span class="bp">∪</span> <span class="o">{</span><span class="bp">∅</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">t</span><span class="bp">ᶜ</span><span class="o">)</span> <span class="bp">''</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="bp">//</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">},</span> <span class="n">induction_generate_from</span> <span class="n">j.1</span><span class="o">)</span>
      <span class="bp">∪</span> <span class="o">(</span><span class="n">set.range</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="bp">//</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">},</span> <span class="n">induction_generate_from</span> <span class="n">j.1</span><span class="o">)),</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">)))</span>
<span class="n">using_well_founded</span> <span class="o">{</span><span class="n">dec_tac</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="n">j.2</span><span class="o">]}</span>
</code></pre></div><br>
</p>
</blockquote>
<p>in order to define the <a href="https://en.wikipedia.org/wiki/Borel_hierarchy#Boldface_Borel_hierarchy">Borel hierarchy</a>. I have noted that the union now ranges over the interval <code>Iio i</code> (which is exactly the same set as above). But I felt that it looked prettier to write the union above like <code>⋃ j (hij: j &lt; i), induction_generate_from j</code>. It seems that the proofs go through with this alternative formulation.</p>
<p>Is there any benefit of using the intervals here?</p>



<a name="310500302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/310500302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#310500302">(Nov 16 2022 at 20:57)</a>:</h4>
<p>By the way, my first attempt to formalize the definition of $\Sigma^0_i$ and $\Pi^0_i$ goes by defining the <em>pair</em> of both families, and then obtaining each pointset by using <code>fst</code> and <code>snd</code>. Is this the simplest approach?<br>
At least I couldn't find references to definitions by nested (“double”) recursion over an ordinal (or its <code>.out</code>, as in the previous discussion).</p>



<a name="310503644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/310503644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#310503644">(Nov 16 2022 at 21:20)</a>:</h4>
<p>LaTeX: use double dollars $$ not single dollars (don't ask me why). Definitions: yes I would definitely define the pair. An attempt to do some kind of mutual inductive definition will just get translated internally into the pair definition, and mutual inductives are generally avoided in Lean 3.</p>



<a name="310513474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/310513474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#310513474">(Nov 16 2022 at 22:31)</a>:</h4>
<p><span class="user-mention" data-user-id="327749">@Pedro Sánchez Terraf</span> I'd recommend that you use an inductive definition like how <a href="https://leanprover-community.github.io/mathlib_docs/find/measurable_space.generate_measurable/src">src#measurable_space.generate_measurable</a> is done:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.cardinal.ordinal</span>
<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kn">open</span> <span class="n">cardinal</span>

<span class="kd">inductive</span> <span class="n">generate_from</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">basic</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">o</span> <span class="o">(</span><span class="n">u</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">generate_from</span> <span class="n">o</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">empty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">o</span><span class="o">,</span> <span class="n">generate_from</span> <span class="n">o</span> <span class="bp">∅</span>
<span class="bp">|</span> <span class="n">compl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">o</span> <span class="n">u</span> <span class="o">(</span><span class="n">o'</span> <span class="bp">&lt;</span> <span class="n">o</span><span class="o">),</span> <span class="n">generate_from</span> <span class="n">o'</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">generate_from</span> <span class="n">o</span> <span class="n">u</span><span class="bp">ᶜ</span>
<span class="bp">|</span> <span class="n">union</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">o</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">o'</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">o'</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">o</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">generate_from</span> <span class="o">(</span><span class="n">o'</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">))</span> <span class="bp">→</span> <span class="n">generate_from</span> <span class="n">o</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span>
<span class="c">/-</span><span class="cm"> The following version doesn't work:</span>
<span class="cm">| union : ∀ o (f : ℕ → set α), (∀ n, ∃ o' &lt; o, generate_from o' (f n)) → generate_from o (⋃ i, f i)</span>
<span class="cm">inductive type being declared can only be nested inside the parameters of other inductive types -/</span>
</code></pre></div>



<a name="310525964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/310525964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#310525964">(Nov 17 2022 at 00:23)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> Thanks. My particular definition, as <code>generate_measurable_rec</code>, gets stuck at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\omega_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, but then again I'm curious if there is any particular benefit of the approach taken in <a href="https://github.com/leanprover-community/mathlib/blob/master/src/measure_theory/card_measurable_space.lean">card_measurable_space</a>.</p>



<a name="310526170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/310526170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#310526170">(Nov 17 2022 at 00:25)</a>:</h4>
<p>But most importantly, I do not know how to write standard ordinal recursions that use the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, successor, and limit cases.</p>



<a name="310526253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/310526253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#310526253">(Nov 17 2022 at 00:26)</a>:</h4>
<p>There is <a href="https://leanprover-community.github.io/mathlib_docs/find/ordinal.limit_rec_on">docs#ordinal.limit_rec_on</a></p>



<a name="310526413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/310526413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#310526413">(Nov 17 2022 at 00:28)</a>:</h4>
<p>I'll experiment a bit and bring some prototype back. Thanks a lot</p>



<a name="310526790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/310526790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#310526790">(Nov 17 2022 at 00:31)</a>:</h4>
<p>I think we should avoid ordinal.out.α when possible. It seems <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> uses it because he wants to have something in <code>Type u</code> rather than <code>ordinal.{u}</code> which is in <code>Type (u+1)</code>. But I don't quite see why he needs that in the proof. It seems the only crucial fact is that a N-indexed sequence in omega_1 has an upper bound in omega_1, or in other words, omega is not cofinal with omega_1. I don't see how the universe is crucial here. (Update: another crucial fact is that the unions are taken over an initial segment of omega_1, but those also all have cardinality bounded by aleph_0.) </p>
<p>Notice that my definition doesn't use well-foundedness of the ordinals, and I think that will be used when you prove (by induction) that it works as expected (e.g. that <code>generate_from s o</code> consists of exactly those sets obtained from <code>generate_from s o'</code> for <code>o' &lt; o</code>).</p>



<a name="310561315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/310561315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#310561315">(Nov 17 2022 at 08:09)</a>:</h4>
<p>My definition above is just because I could work out the proof with it :-). If you find another more idiomatic way in terms of an inductive definition, this would probably be better. The reason I used <code>(aleph 1 : cardinal.{u})).out.α</code> is because I wanted a well-order of size aleph_1, i.e., I didn't want to do the induction over all ordinals just because we know we can stop at aleph_1 and this will already give all measurable sets. And also for universe reasons: at the end of the day if everything is in universe <code>u</code> you want bounds in terms of cardinals in the same universe, not the next one (although it would probably be possible to downlift things from a higher universe).</p>



<a name="310594689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/310594689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#310594689">(Nov 17 2022 at 11:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/ordinals.20and.20induction/near/310561315">said</a>:</p>
<blockquote>
<p>at the end of the day if everything is in universe <code>u</code> you want bounds in terms of cardinals in the same universe, not the next one (although it would probably be possible to downlift things from a higher universe).</p>
</blockquote>
<p>Indeed, the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">ℵ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\aleph_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">ℵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> of the very first universe should suffice foundationally speaking (but I took the trouble to try that and check that it fails with the proofs as they stand). Thanks!</p>



<a name="310698299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/310698299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#310698299">(Nov 17 2022 at 20:59)</a>:</h4>
<p>Indeed I think even though you can show <code>countable {o' // o &lt; o}</code> you would still get a <code>cardinal.{u+1}</code> by default; you can do computation in universe <code>u+1</code> but need to downlift it using <a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal.lift_le">docs#cardinal.lift_le</a> in the end. However, we certainly want the Borel hierarchy be indexed by ordinals (≤ omega_1) rather than <code>omega_1.out.α</code>; once we have the Borel hierarchy and prove that it stabilizes, we may go back to refactor and hopefully golf the cardinality proof.</p>



<a name="323317081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/323317081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#323317081">(Jan 24 2023 at 17:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/ordinals.20and.20induction/near/310526790">said</a>:</p>
<blockquote>
<p>I think we should avoid ordinal.out.α when possible. </p>
</blockquote>
<p>You mean in public-facing API? I can see your point if so, but otherwise hard disagree. The fact that each <code>ordinal.{u}</code> corresponds to a well-ordered type in <code>Type u</code> is a crucial fact. Most notably, we can take indexed suprema of <code>ordinal.{u}</code> when the indexing type is in universe <code>u</code>, but not when it's any larger. By bumping up the universes, it means that we have to move back and forth between the <code>Iio x ≅o x.out.α</code> order isomorphism, which is not ideal and really defeats the purpose.</p>
<p>Maybe part of why it seems so unnatural is due to the odd notation. This could be easily fixed by introducing something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">ordinal.to_type</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">o.out.α</span>
</code></pre></div>
<p>We can then add a doc comment explaining how this represents a canonical type with the given order type.</p>



<a name="323317924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/323317924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#323317924">(Jan 24 2023 at 18:00)</a>:</h4>
<p>Regarding the public API, I'm reminded that we already have a way around this issue. Instead of using the ordinal supremum, one can use <a href="https://leanprover-community.github.io/mathlib_docs/find/ordinal.bsup">docs#ordinal.bsup</a>. If we want to do even more general stuff, like index a family of sets by ordinals, we can use <a href="https://leanprover-community.github.io/mathlib_docs/find/ordinal.family_of_bfamily">docs#ordinal.family_of_bfamily</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/ordinal.bfamily_of_family">docs#ordinal.bfamily_of_family</a> to easily convert between the <code>out.α</code> indexing and the natural indexing.</p>
<p>I'm not a huge fan of this because it introduces a lot of redundancy into the API (where many theorems have to be stated in terms of either supremum), but that's the best we currently got. Besides, we already get by with this sort of redundancy elsewhere (see all the kinds of set unions in mathlib).</p>



<a name="323318258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/323318258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#323318258">(Jan 24 2023 at 18:02)</a>:</h4>
<p>(deleted)</p>



<a name="323319786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/323319786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#323319786">(Jan 24 2023 at 18:09)</a>:</h4>
<p>Thinking about it further. Maybe both introducing <code>ordinal.to_type</code> and making better use of the <code>ordinal.bsup</code> API are good ideas.</p>



<a name="323322468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/323322468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#323322468">(Jan 24 2023 at 18:20)</a>:</h4>
<p>(Sorry to anyone reading in real time for all the edits, I guess I'm only now really solidifying my ideas here)</p>



<a name="323335799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ordinals%20and%20induction/near/323335799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ordinals.20and.20induction.html#323335799">(Jan 24 2023 at 19:23)</a>:</h4>
<p>I have no objection to using <code>x.out.α</code> in proofs if it makes things shorter; your golf in <a href="https://github.com/leanprover-community/mathlib/pull/17972">#17972</a> looks great to me. However, in this case we want to define a function with all ordinals as its domain; it would be unnatural to define the hierarchy on <code>ω₁.out.α</code> since you would need to transfer by <code>Iio ω₁ ≅o ω₁.out.α</code> if you want to refer to e.g. the 1st level, or the ωth level in the hierarchy. In particular, we want <code>⋃ j &lt; i</code> in the statement rather than <code>⋃ j : i.out.α</code>. Even if you can get away with <code>ω₁.out.α</code> here because the Borel hierarchy stabilizes at ω₁, it wouldn't be possible to do so when defining but IMO that's unnatural; what if we want to define <a href="https://en.wikipedia.org/wiki/Derived_set_(mathematics)#Cantor%E2%80%93Bendixson_rank">derived sets</a> (which stablizes eventually but at arbitrarily large ordinal), <a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal.aleph">docs#cardinal.aleph</a>, or the von Neumann hierarchy (which doesn't stabilize).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
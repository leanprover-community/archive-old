---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html">Minimal relation satisfying `trans_gen`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="266606952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266606952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266606952">(Jan 02 2022 at 10:25)</a>:</h4>
<p>While working on improving and generalizing definitions in the formalization of the angel problem, I spent too much time wrestling with this lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.relation</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal</span>
<span class="kn">open</span> <span class="n">relation</span>
<span class="n">open_locale</span> <span class="n">cardinal</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">(</span><span class="n">r</span> <span class="n">x</span> <span class="bp">⊆</span> <span class="n">R</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
  <span class="o">(</span><span class="bp">#</span> <span class="o">(</span><span class="n">r</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="bp">#</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">))</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span>
  <span class="o">(</span><span class="n">trans_gen</span> <span class="n">R</span> <span class="n">x</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">trans_gen</span> <span class="n">r</span> <span class="n">x</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>What is the easiest way to prove it? I tried several different approaches, but haven't finished any of them, because things start to get complicated.</p>
<p>Here is an informal proof (I just don't know what's the easiest way to translate it to Lean): We explicitly construct relation <code>r</code>. Given some <code>(x : α)</code>. If <code>R x</code> is empty, then <code>r x</code> is empty too. Otherwise, if <code>trans_gen R x t</code> is false, then return the singleton containing some element of <code>R x</code> (using the axiom of choice). If <code>trans_gen R x t</code> is true, it must be constructed using <code>trans_gen.tail</code>, which takes some <code>(y : α)</code> and proofs of <code>trans_gen R x y</code> and <code>R y t</code>. Return the singleton containing that <code>y</code> (we can't obtain <code>y</code> directly, because of proof irrelevance, but it exists, so we can use the axiom of choice).</p>
<p>It turns out that the problem is <code>t</code> being fixed, so we can't easily prove that transitivity works for some other <code>t</code>.</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>My attempt</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.set</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal</span>
<span class="kn">import</span> <span class="n">logic.relation</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">cardinal</span>
<span class="kn">open</span> <span class="n">relation</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">open_locale</span> <span class="n">cardinal</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">trans_gen_flip'</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">trans_gen</span> <span class="n">R</span> <span class="n">x</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trans_gen</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">R</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="n">t</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">h</span> <span class="k">with</span> <span class="n">_</span> <span class="n">h</span> <span class="n">y</span> <span class="n">y₁</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">left</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">fapply</span> <span class="n">trans_gen.trans</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">y</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">left</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">exact</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">trans_gen_flip</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">trans_gen</span> <span class="n">R</span> <span class="n">x</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">trans_gen</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">R</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="n">t</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">split</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">trans_gen_flip'</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">mk_r</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="k">if</span> <span class="n">h₁</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">R</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="n">_</span> <span class="k">else</span> <span class="bp">∅</span><span class="o">,</span>
  <span class="n">refine</span> <span class="k">if</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">trans_gen</span> <span class="n">R</span> <span class="n">x</span> <span class="n">t</span> <span class="k">then</span> <span class="n">_</span> <span class="k">else</span> <span class="o">{</span><span class="n">h₁.some</span><span class="o">},</span>
  <span class="n">refine</span> <span class="k">if</span> <span class="n">h₃</span> <span class="o">:</span> <span class="n">R</span> <span class="n">x</span> <span class="n">t</span> <span class="k">then</span> <span class="o">{</span><span class="n">t</span><span class="o">}</span> <span class="k">else</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">{(</span><span class="n">_</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">R</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">trans_gen</span> <span class="n">R</span> <span class="n">y</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">some</span><span class="o">},</span>
  <span class="n">revert</span> <span class="n">h₃</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">trans_gen.trans_induction_on</span> <span class="n">h₂</span><span class="bp">;</span> <span class="n">clear</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">x</span> <span class="n">t</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">contradiction</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span> <span class="n">h₄</span> <span class="n">h₅</span><span class="o">,</span> <span class="n">by_cases</span> <span class="n">h₆</span> <span class="o">:</span> <span class="n">R</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">h₆</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="n">replace</span> <span class="n">h₃</span> <span class="o">:=</span> <span class="n">h₃</span> <span class="n">h₆</span><span class="o">,</span> <span class="n">clear</span> <span class="n">h₆</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h₃</span> <span class="k">with</span> <span class="n">c₁</span> <span class="n">hc₁</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hc₁.1</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">transitivity</span> <span class="n">y</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hc₁.2</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">h₂</span><span class="o">,</span> <span class="o">}},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">R_of_r</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">trans_gen</span> <span class="o">(</span><span class="n">mk_r</span> <span class="n">R</span> <span class="n">t</span><span class="o">)</span> <span class="n">x</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trans_gen</span> <span class="n">R</span> <span class="n">x</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">trans_gen_flip</span> <span class="n">at</span> <span class="n">h</span> <span class="bp">⊢</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">h</span> <span class="k">with</span> <span class="n">y</span> <span class="n">h</span> <span class="n">y</span> <span class="n">y₁</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">rw</span> <span class="n">mk_r</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">split_ifs</span> <span class="n">at</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">left</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">h₃</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">revert</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">generalize_proofs</span> <span class="n">h₄</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">change</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">_</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">h</span> <span class="n">at</span> <span class="n">h₃</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">h₃</span> <span class="n">h₄.some_spec.1</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">change</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">_</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">left</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">h₁.some_spec</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">transitivity</span> <span class="n">y</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">ih</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">rw</span> <span class="n">mk_r</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">trans_gen_flip</span> <span class="n">at</span> <span class="n">h₁</span> <span class="n">ih</span> <span class="bp">⊢</span><span class="o">,</span>
      <span class="n">dsimp</span> <span class="n">at</span> <span class="n">h₁</span> <span class="n">ih</span> <span class="bp">⊢</span><span class="o">,</span>
      <span class="n">split_ifs</span> <span class="n">at</span> <span class="n">h₂</span> <span class="k">with</span> <span class="n">h₃</span> <span class="n">h₄</span> <span class="n">h₅</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">change</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">t</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>
        <span class="n">subst</span> <span class="n">h₂</span><span class="o">,</span>
        <span class="n">left</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h₅</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">revert</span> <span class="n">h₂</span><span class="o">,</span>
        <span class="n">generalize_proofs</span> <span class="n">h₆</span><span class="o">,</span>
        <span class="n">intro</span> <span class="n">h₂</span><span class="o">,</span>
        <span class="n">change</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">_</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">h₂</span><span class="o">,</span>
        <span class="n">left</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h₆.some_spec.1</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">change</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">_</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">h₂</span><span class="o">,</span>
        <span class="n">left</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h₃.some_spec</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">cases</span> <span class="n">h₂</span><span class="o">,</span>
      <span class="o">},</span>
    <span class="o">},</span>
  <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">r_single</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">R</span> <span class="n">x</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trans_gen</span> <span class="o">(</span><span class="n">mk_r</span> <span class="n">R</span> <span class="n">t</span><span class="o">)</span> <span class="n">x</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">trans_gen.single</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mk_r</span><span class="o">,</span>
  <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">(</span><span class="n">trans_gen.single</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">_</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">(</span><span class="n">r</span> <span class="n">x</span> <span class="bp">⊆</span> <span class="n">R</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
  <span class="o">(</span><span class="bp">#</span> <span class="o">(</span><span class="n">r</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="bp">#</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">))</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span>
  <span class="o">(</span><span class="n">trans_gen</span> <span class="n">R</span> <span class="n">x</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">trans_gen</span> <span class="n">r</span> <span class="n">x</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">use</span> <span class="n">mk_r</span> <span class="n">R</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span>
    <span class="n">change</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">mk_r</span> <span class="n">R</span> <span class="n">t</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">R</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mk_r</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">split_ifs</span> <span class="n">at</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">change</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">t</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">h₃</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">change</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">_</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">subst</span> <span class="n">y</span><span class="o">,</span>
      <span class="n">generalize_proofs</span> <span class="n">h₄</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">h₄.some_spec.1</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">change</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">_</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">h₁.some_spec</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">exact</span> <span class="n">false.elim</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">R</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">mk_emptyc_iff</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mk_r</span><span class="o">,</span>
      <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">rw</span> <span class="n">h</span> <span class="n">at</span> <span class="n">h₃</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">false.elim</span> <span class="n">h₃</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">rw</span> <span class="n">h</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">false.elim</span> <span class="n">h₁.some_spec</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">rw</span> <span class="n">h</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">false.elim</span> <span class="n">h₁.some_spec</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">refl</span><span class="o">,</span>
      <span class="o">},</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="bp">#</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">),</span>
      <span class="o">{</span>
        <span class="gr">sorry</span>
      <span class="o">},</span>
      <span class="n">replace</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">min</span> <span class="o">(</span><span class="bp">#</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">))</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">h₁</span><span class="o">],</span>
      <span class="o">},</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">h₁</span><span class="o">],</span> <span class="n">clear</span> <span class="n">h₁</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">cardinal.eq_one_iff_unique</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mk_r</span><span class="o">,</span>
      <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">simp</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">simp</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">simp</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">rw</span> <span class="n">eq_empty_iff_forall_not_mem</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span> <span class="n">h₁</span><span class="o">,</span>
        <span class="n">exact</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">_</span> <span class="n">h.some_spec</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span>
      <span class="o">},</span>
    <span class="o">},</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">trans_gen.head_induction_on</span> <span class="n">h</span><span class="bp">;</span> <span class="n">clear</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">rintro</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">r_single</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="gr">sorry</span>
    <span class="o">},</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="266607241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266607241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266607241">(Jan 02 2022 at 10:31)</a>:</h4>
<p>You should either change <code>r</code> to <code>α → α → Prop</code> and replace <code>r x</code> with <code>{y | r x y}</code>, or replace <code>trans_gen r</code> with <code>trans_gen (λ x y, y ∈ r x)</code>, else you'll end up with a nonsense goal along the way</p>



<a name="266607632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266607632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266607632">(Jan 02 2022 at 10:40)</a>:</h4>
<p>Sure, I'll polish the proof in the end. But I somehow managed to establish a mental model to literally see <code>y ∈ r x</code> as <code>r x y</code>, or <code>{x} y</code> as <code>y = x</code>, or <code>∅ x</code> as <code>false</code>. <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="266608002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266608002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266608002">(Jan 02 2022 at 10:50)</a>:</h4>
<p>This is basically <a href="https://leanprover-community.github.io/mathlib_docs/find/quiver.geodesic_arborescence">docs#quiver.geodesic_arborescence</a>. It shows that in a directed graph where there is a path from <code>r</code> to any other vertex, there is a subgraph where there is a unique path from <code>r</code> to every other vertex. Of course there is a wrinkle in that your lemma doesn't assume that there are paths to <code>t</code>...</p>



<a name="266608755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266608755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266608755">(Jan 02 2022 at 11:08)</a>:</h4>
<p>BTW I don't think your proof sketch will work. For example suppose <code>α</code> is <code>with_top nat</code>, <code>R</code> is <code>&lt;</code>, and <code>t</code> is <code>top</code>. If you're unlucky, the axiom of choice will pick <code>r n = {n+1}</code>. Then <code>trans_gen r n top</code> is always false: if you follow the path from <code>n</code> in <code>r</code> you will just go <code>n -&gt; n+1 -&gt; n+2 ...</code> forever. This issue is basically the reason to use the 'geodesic' subgraph. I see that you use a different choice of <code>r</code> in the code above, which will work on this counterexample, but you can construct another counterexample where it doesn't work by adding one more <code>top'</code> which is related to <code>top</code> but not to <code>n : nat</code>.</p>



<a name="266611889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266611889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266611889">(Jan 02 2022 at 12:24)</a>:</h4>
<p>Thanks. I'll play with geodesic subgraph and see how it goes.</p>



<a name="266619706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266619706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266619706">(Jan 02 2022 at 15:48)</a>:</h4>
<p>As a side question, how to finish this subgoal?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">S</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">1</span> <span class="bp">≤</span> <span class="bp">#</span> <span class="n">S</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="266620026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266620026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266620026">(Jan 02 2022 at 15:56)</a>:</h4>
<p>I have this proof, but it looks very ugly. I hope there is a better way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">S</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">1</span> <span class="bp">≤</span> <span class="bp">#</span> <span class="n">S</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">set.eq_empty_iff_forall_not_mem</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">fsplit</span><span class="o">,</span> <span class="n">fsplit</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">u</span><span class="o">,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="266620099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266620099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266620099">(Jan 02 2022 at 15:58)</a>:</h4>
<p>Looks like you should switch over to <code>finset</code> and use <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.one_le_card_iff">docs#finset.one_le_card_iff</a></p>



<a name="266620400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266620400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266620400">(Jan 02 2022 at 16:03)</a>:</h4>
<p>Does <a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal.one_le_iff_ne_zero">docs#cardinal.one_le_iff_ne_zero</a> help?</p>



<a name="266620463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266620463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266620463">(Jan 02 2022 at 16:04)</a>:</h4>
<p>and <a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal.mk_ne_zero_iff">docs#cardinal.mk_ne_zero_iff</a></p>



<a name="266628606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266628606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266628606">(Jan 02 2022 at 19:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.relation</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal</span>

<span class="n">open_locale</span> <span class="n">cardinal</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">S</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">1</span> <span class="bp">≤</span> <span class="bp">#</span> <span class="n">S</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">#</span> <span class="n">S</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- library_search</span>
    <span class="n">refine</span> <span class="n">cardinal.one_le_iff_ne_zero.mpr</span> <span class="n">this</span> <span class="o">},</span>
  <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- library_search</span>
  <span class="n">refine</span> <span class="n">cardinal.mk_emptyc_iff.mp</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="266629433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266629433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266629433">(Jan 02 2022 at 19:37)</a>:</h4>
<p>Or, condensing it further:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.relation</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal</span>

<span class="n">open_locale</span> <span class="n">cardinal</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">S</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">1</span> <span class="bp">≤</span> <span class="bp">#</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">cardinal.one_le_iff_ne_zero.mpr</span> <span class="o">(</span><span class="n">mt</span> <span class="n">cardinal.mk_emptyc_iff.mp</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>



<a name="266630807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Minimal%20relation%20satisfying%20%60trans_gen%60/near/266630807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Minimal.20relation.20satisfying.20.60trans_gen.60.html#266630807">(Jan 02 2022 at 20:09)</a>:</h4>
<p>It's interesting how the "side question" turns out to be so bikesheddy. But thanks, those proofs are definitely shorter than mine.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
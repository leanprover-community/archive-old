---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html">Graph Theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="201783213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201783213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201783213">(Jun 23 2020 at 21:07)</a>:</h4>
<p>Do we have Graph Theory in mathlib ? If not, I'd be happy to give it a try this summer</p>



<a name="201783410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201783410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201783410">(Jun 23 2020 at 21:08)</a>:</h4>
<p>There was some work on it with the goal of formalizing the disproof of hedetniemis conjecture at <a href="https://github.com/leanprover-community/mathlib/tree/hedetniemi/src/graph_theory">https://github.com/leanprover-community/mathlib/tree/hedetniemi/src/graph_theory</a></p>



<a name="201783550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201783550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201783550">(Jun 23 2020 at 21:10)</a>:</h4>
<p>There's some stuff like Ramsey theory, Kruskal-Katona/Erdos-Ko-Rado (not in mathlib yet, they're on personal repos)</p>



<a name="201783603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201783603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201783603">(Jun 23 2020 at 21:10)</a>:</h4>
<p>Searching for Hedetniemi in chat will bring up some threads I guess.</p>



<a name="201783704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201783704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201783704">(Jun 23 2020 at 21:11)</a>:</h4>
<p>See also this thread: <a href="#narrow/stream/113489-new-members/topic/Feasibility.20of.20graph.20or.20simplicial.20complex.20statement/near/187842633">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Feasibility.20of.20graph.20or.20simplicial.20complex.20statement/near/187842633</a></p>



<a name="201783729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201783729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201783729">(Jun 23 2020 at 21:11)</a>:</h4>
<p>Sorry those things aren't in mathlib btw</p>



<a name="201783982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201783982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201783982">(Jun 23 2020 at 21:13)</a>:</h4>
<p>I started trying to work on some basic definitions but I kept changing my mind on how I wanted to do that lol</p>



<a name="201784151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201784151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201784151">(Jun 23 2020 at 21:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303889">Alena Gusakov</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201783982">said</a>:</p>
<blockquote>
<p>I started trying to work on some basic definitions but I kept changing my mind on how I wanted to do that lol</p>
</blockquote>
<p>I think this is the same reason no-one else has made a PR yet either</p>



<a name="201784173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201784173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201784173">(Jun 23 2020 at 21:14)</a>:</h4>
<p>There's an even older post here: <a href="#narrow/stream/113488-general/topic/Type.20classes.20again/near/167340123">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type.20classes.20again/near/167340123</a> (this could probably be PR'd to <code>archive/</code> once we get some of the stuff into mathlib)</p>



<a name="201784346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201784346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201784346">(Jun 23 2020 at 21:15)</a>:</h4>
<p>I'm doing some graph theory things right now.  There are a few ways of defining graphs, depending on what you're wanting to do.  One version is using relations, another is Type-valued "relations" for multiple edges between vertices, and one I have now is like 1-D CW complexes.  With the latter, I proved yesterday the handshaking lemma, that the sum of the degrees of the vertices is twice the number of edges.</p>



<a name="201784554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201784554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201784554">(Jun 23 2020 at 21:17)</a>:</h4>
<p>There are some papers on formalizing graph theory in Coq by Doczkal and collaborators <a href="https://perso.ens-lyon.fr/christian.doczkal/index.html">here</a> which might be helpful when thinking about design decisions. I haven't had a chance to really dig in though.</p>



<a name="201784602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201784602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201784602">(Jun 23 2020 at 21:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201784346">said</a>:</p>
<blockquote>
<p>I proved yesterday the handshaking lemma, that the sum of the degrees of the vertices is twice the number of edges.</p>
</blockquote>
<p>Yeah this is a good exercise - I did it too when I proved Ramsey: <a href="https://github.com/b-mehta/combinatorics/blob/extras/src/handshaking.lean#L122">https://github.com/b-mehta/combinatorics/blob/extras/src/handshaking.lean#L122</a></p>



<a name="201785075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201785075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201785075">(Jun 23 2020 at 21:21)</a>:</h4>
<p>Ok so it has been done a lot but not in mathlib</p>



<a name="201785116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201785116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201785116">(Jun 23 2020 at 21:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201783410">said</a>:</p>
<blockquote>
<p>There was some work on it with the goal of formalizing the disproof of hedetniemis conjecture at <a href="https://github.com/leanprover-community/mathlib/tree/hedetniemi/src/graph_theory">https://github.com/leanprover-community/mathlib/tree/hedetniemi/src/graph_theory</a></p>
</blockquote>
<p>By "was" do you mean it's inactive ?</p>



<a name="201785201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201785201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201785201">(Jun 23 2020 at 21:22)</a>:</h4>
<p>Yeah, there's no one actively working on it any more unfortunately; though as far as I know it's the biggest bit of graph theory that's been done in lean</p>



<a name="201785223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201785223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201785223">(Jun 23 2020 at 21:22)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span>  It looks like you have it for simple graphs.  Since I'm going to need it, I used a definition that allows loops and multiple edges: <a href="https://github.com/kmill/lean-graphs/blob/master/src/graphs.lean#L25">https://github.com/kmill/lean-graphs/blob/master/src/graphs.lean#L25</a></p>



<a name="201785248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201785248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201785248">(Jun 23 2020 at 21:22)</a>:</h4>
<p>Well the last commit  was a couple of months ago, and the thread died off, but it was only this year so it should be in good shape still.</p>



<a name="201785271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201785271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201785271">(Jun 23 2020 at 21:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201785223">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span>  It looks like you have it for simple graphs.  Since I'm going to need it, I used a definition that allows loops and multiple edges: <a href="https://github.com/kmill/lean-graphs/blob/master/src/graphs.lean#L25">https://github.com/kmill/lean-graphs/blob/master/src/graphs.lean#L25</a></p>
</blockquote>
<p>Ah nice, yeah I see</p>



<a name="201785298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201785298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201785298">(Jun 23 2020 at 21:23)</a>:</h4>
<p>(and every relation-based graph can be represented as such a graph using the constructor at <a href="https://github.com/kmill/lean-graphs/blob/master/src/graphs.lean#L128">https://github.com/kmill/lean-graphs/blob/master/src/graphs.lean#L128</a>)</p>



<a name="201785480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201785480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201785480">(Jun 23 2020 at 21:24)</a>:</h4>
<p>I wasn't too involved, but an important part of the disproof is the construction of some specific graph with a particular girth and chromatic number, the paper used a probabilistic argument here and my impression was that such arguments are harder to develop in lean at present. Might be better to try a more explicit approach to constructing this part of the proof instead.</p>



<a name="201785767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201785767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201785767">(Jun 23 2020 at 21:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201785248">said</a>:</p>
<blockquote>
<p>Well the last commit  was a couple of months ago, and the thread died off, but it was only this year so it should be in good shape still.</p>
</blockquote>
<p>I'll have a look and see if I can help, though I may be overestimating myself here <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="201786359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201786359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201786359">(Jun 23 2020 at 21:32)</a>:</h4>
<p>Yeah I'm thinking of the paper <a href="https://arxiv.org/abs/2004.09028">https://arxiv.org/abs/2004.09028</a> which looks like it might give a more explicit example for that step than the Erdos-Renyi stuff (but once again I am not a graph theorist so would welcome corrections!)</p>



<a name="201786784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201786784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201786784">(Jun 23 2020 at 21:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201784554">said</a>:</p>
<blockquote>
<p>There are some papers on formalizing graph theory in Coq by Doczkal and collaborators <a href="https://perso.ens-lyon.fr/christian.doczkal/index.html">here</a> which might be helpful when thinking about design decisions. I haven't had a chance to really dig in though.</p>
</blockquote>
<p>If I wanna work on a generic-purpose approach, I think I'm going to keep that as a reference</p>



<a name="201786881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201786881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201786881">(Jun 23 2020 at 21:37)</a>:</h4>
<p>(deleted)</p>



<a name="201786886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201786886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201786886">(Jun 23 2020 at 21:37)</a>:</h4>
<p>(deleted)</p>



<a name="201788634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201788634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201788634">(Jun 23 2020 at 21:52)</a>:</h4>
<p><span class="user-mention" data-user-id="268315">@Anatole Dedecker</span>  Given my experiences so far with graphs (where I need non-simple graphs with multiple edges) and what I've seen in those papers that <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> kindly shared, here's how I might define directed and undirected non-simple graphs (optionally edge-labeled):</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- An edge-labeled directed graph</span>
<span class="kn">structure</span> <span class="n">dgraph</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">L</span><span class="o">)</span>

<span class="kn">inductive</span> <span class="n">sym2_rel</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">sym2_rel</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="bp">⟩</span>
<span class="bp">|</span> <span class="n">swap</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">sym2_rel</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="bp">⟩</span>

<span class="c1">-- The symmetric square is the cartesian product α × α modulo `swap`.</span>
<span class="n">def</span> <span class="n">sym2</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">quot</span> <span class="o">(</span><span class="n">sym2_rel</span> <span class="n">α</span><span class="o">)</span>
<span class="n">def</span> <span class="n">incl_diag</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">sym2_rel</span> <span class="n">α</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">⟩</span>

<span class="c1">-- An edge-labeled undirected graph</span>
<span class="kn">structure</span> <span class="n">graph</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">L</span><span class="o">)</span>

<span class="c1">-- For example,</span>
<span class="n">def</span> <span class="n">loopless</span> <span class="o">{</span><span class="n">L</span><span class="o">}</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="bp">.</span><span class="n">V</span><span class="o">),</span> <span class="bp">¬∃</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">g</span><span class="bp">.</span><span class="n">E</span><span class="o">),</span> <span class="n">g</span><span class="bp">.</span><span class="n">p</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">incl_diag</span> <span class="n">v</span>
</code></pre></div>


<p>The benefit with this definition for undirected graphs is that the edges are <em>intrinsically</em> undirected.  (Depending on your tastes, you might change <code>sym2</code> to <code>finset</code> and add in the axiom that <code>(p e).card</code> is either 1 or 2.)</p>



<a name="201788979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201788979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201788979">(Jun 23 2020 at 21:56)</a>:</h4>
<p>Yeah I think I'd have done something like that. In classical logic I would rather have used quotient, but I've never used them in Lean yet, so I don't really know</p>



<a name="201789218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201789218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201789218">(Jun 23 2020 at 21:58)</a>:</h4>
<p>See also David and Johan's definition here: <a href="https://github.com/leanprover-community/mathlib/blob/hedetniemi/src/graph_theory/basic.lean">https://github.com/leanprover-community/mathlib/blob/hedetniemi/src/graph_theory/basic.lean</a></p>



<a name="201790716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201790716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201790716">(Jun 23 2020 at 22:13)</a>:</h4>
<p>I'd move <code>V</code> to the arguments because sometimes you want to consider a graph on a given type and having two ways to represent a type (<code>α</code> and <code>g.V</code>) can be bad for <code>simp</code> etc. But this is not too important, and it would be nice of someone finally PRs one of the definitions + basic theory to <code>mathlib</code>.</p>



<a name="201791017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201791017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201791017">(Jun 23 2020 at 22:16)</a>:</h4>
<p>Yup that is true indeed, in some sense we are building a structure of graph on the type of its vertices</p>



<a name="201791488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201791488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201791488">(Jun 23 2020 at 22:22)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span>  Yeah, the "Type/Sort-valued relation" seems like a good generalization of the Prop-valued relation approach to graphs, and it probably also makes edge labelings sort of come for free if you want them.  One thing I want to do is induct on the edge set in a graph, and I went for the sort of dual definition (edges are <em>attached</em> to the vertices) in anticipation of that.  You also get the number of edges in the graph by looking at the cardinality of the edge set this way, rather than having to sum up the edge sets over all pairs of vertices.</p>
<p>One thing I've struggled with when thinking about a graph library is how a lot of graph theory can be turned into statements about irreflexive symmetric relations on a (finite) type.  It makes me think that there should be some part of mathlib about this specific case, maybe defining <code>relation.graph</code> and giving basic statements about these sorts of relations.  However, there's also the part of graph theory that considers non-simple graphs, and for this you might have something like the definitions I gave.  <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> Do you think it's reasonable to have both definitions in mathlib?</p>



<a name="201791930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201791930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201791930">(Jun 23 2020 at 22:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="268315">Anatole Dedecker</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201791017">said</a>:</p>
<blockquote>
<p>Yup that is true indeed, in some sense we are building a structure of graph on the type of its vertices</p>
</blockquote>
<p>I think the decision might be more based on whether you think you want to consider lots of different graphs on the same vertex set.  I wasn't sure which way to go with the above definitions (and, in fact, I've been doing it with <code>graph V</code> in my own code).  It seems like it would be annoying working with <code>{g // g.V = V}</code>, and if you really did need the type of all graphs, there's always <code>Σ (V : Type*), graph V</code>.</p>



<a name="201792026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201792026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201792026">(Jun 23 2020 at 22:28)</a>:</h4>
<p>It's <code>Σ V, graph V</code>, not <code>Π</code>.</p>



<a name="201792048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201792048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201792048">(Jun 23 2020 at 22:28)</a>:</h4>
<p>Oh, thanks!</p>



<a name="201792066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201792066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201792066">(Jun 23 2020 at 22:28)</a>:</h4>
<p><code>Π</code> type is the type of functions sending each <code>V</code> to some graph on <code>V</code>.</p>



<a name="201792243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201792243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201792243">(Jun 23 2020 at 22:31)</a>:</h4>
<p>I'm not sure how many definitions of a graph do we want to have in <code>mathlib</code> but I'm pretty sure that we need at least one.</p>



<a name="201792286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201792286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201792286">(Jun 23 2020 at 22:31)</a>:</h4>
<p>I'd suggest starting with some general definition, then see what special cases do we need.</p>



<a name="201793169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201793169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201793169">(Jun 23 2020 at 22:39)</a>:</h4>
<p>Do you know if mathlib already has symmetric products (like sym2)?  If not, where would be a good place to put their definition?</p>



<a name="201793291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201793291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201793291">(Jun 23 2020 at 22:40)</a>:</h4>
<p>I'd encourage PR'ing parts of the hedetniemi branch. The definitions there have been at least partially battle-tested.</p>



<a name="201794754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201794754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201794754">(Jun 23 2020 at 22:57)</a>:</h4>
<p>It seems like the <a href="https://github.com/leanprover-community/mathlib/blob/hedetniemi/src/graph_theory/basic.lean#L16">definition of a multigraph</a> isn't quite right for loop edges.  You'd want <code>inv</code> to be the identity equivalence on the diagonal, I think.</p>



<a name="201797911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201797911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201797911">(Jun 23 2020 at 23:40)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span> and I have done all of the graph theory in a proof of the Friendship Theorem, but we've slowed down on the linear algebra. <a href="https://github.com/jalex-stark/friendship-theorem/tree/master/src">https://github.com/jalex-stark/friendship-theorem/tree/master/src</a></p>



<a name="201798048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201798048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201798048">(Jun 23 2020 at 23:43)</a>:</h4>
<p>I'd be happy to join a bigger graph theory (or other combinatorics) project, if people want a summer collaboration.</p>



<a name="201806292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201806292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201806292">(Jun 24 2020 at 02:27)</a>:</h4>
<p>Don't forget: whatever is not PRed, will stop compiling against <code>master</code> soon.</p>



<a name="201806340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201806340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201806340">(Jun 24 2020 at 02:28)</a>:</h4>
<p>And it's better to make 10 small PRs than one huge PR.</p>



<a name="201806430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201806430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201806430">(Jun 24 2020 at 02:30)</a>:</h4>
<p>So, don't wait till you have nice theorems.</p>



<a name="201806442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201806442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201806442">(Jun 24 2020 at 02:31)</a>:</h4>
<p>A PR with basic definitions and "obvious" <code>simp</code> lemmas is a good start.</p>



<a name="201809646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201809646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201809646">(Jun 24 2020 at 04:01)</a>:</h4>
<p>We can always fix the definitions in later PRs. :-)</p>



<a name="201811054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201811054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201811054">(Jun 24 2020 at 04:40)</a>:</h4>
<p>If no one is already working on a PR, I propose that someone who worked on the <code>hedetniemi</code> branch either:</p>
<ol>
<li>makes a PR, or </li>
<li>gives pointers to what files are in PR-ready shape </li>
</ol>
<p><span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>



<a name="201811934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201811934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201811934">(Jun 24 2020 at 05:04)</a>:</h4>
<p>I'm working on a PR.  I'm taking some of what's in hedetniemi and reworking it for multigraphs.  I'm just trying to prove that the definition I'm using is equivalent to (a corrected version) of what's already there.</p>



<a name="201812159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201812159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201812159">(Jun 24 2020 at 05:09)</a>:</h4>
<p>Great! I've sent you an invitation to collaborate, so you can push to a branch in mathlib and PR from that.</p>



<a name="201812236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201812236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201812236">(Jun 24 2020 at 05:10)</a>:</h4>
<p>Thanks, received!</p>



<a name="201818158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201818158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201818158">(Jun 24 2020 at 07:26)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>, what was the mistake that needed correcting?</p>



<a name="201818172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201818172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201818172">(Jun 24 2020 at 07:27)</a>:</h4>
<p>Will your generalisation to multigraphs still be usable for simple graphs?</p>



<a name="201818432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201818432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201818432">(Jun 24 2020 at 07:30)</a>:</h4>
<p>The mistake is that in</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">directed_multigraph</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">),</span> <span class="n">edge</span> <span class="n">x</span> <span class="n">y</span> <span class="err">≃</span> <span class="n">edge</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>


<p>the <code>inv x x</code> permutation might not be trivial, so you can do some weird quantum thing where you keep flipping over the edge and get a totally new one.  It seems loop edges aren't particularly popular to consider, but I use them a lot in my own work so I'd like them to be supported.</p>



<a name="201818570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201818570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201818570">(Jun 24 2020 at 07:33)</a>:</h4>
<p>My plan for graphs is something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">ends</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">multigraph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">single_edge</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">ends</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">,</span> <span class="bp">¬</span><span class="o">(</span><span class="n">ends</span> <span class="n">e</span><span class="o">)</span><span class="bp">.</span><span class="n">is_diag</span><span class="o">)</span>
</code></pre></div>


<p>There would be a number of constructors to put the main ways of working with graphs into one of these forms.  For example, there's one that takes a corrected version of the hedetniemi-branch multigraph in the following format:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">edge_set_desc</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">edge</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">edge</span> <span class="n">x</span> <span class="n">y</span> <span class="err">≃</span> <span class="n">edge</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">loops</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">inv</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">edge</span> <span class="n">x</span> <span class="n">x</span><span class="o">))</span>
</code></pre></div>



<a name="201818836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201818836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201818836">(Jun 24 2020 at 07:36)</a>:</h4>
<p>Another constructor (not yet written) would be</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">from_relation</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">r</span><span class="o">):</span> <span class="n">simple_graph</span> <span class="n">α</span>
</code></pre></div>



<a name="201818889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201818889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201818889">(Jun 24 2020 at 07:37)</a>:</h4>
<p>Does this use of structure extensions seem OK?</p>



<a name="201818977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201818977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201818977">(Jun 24 2020 at 07:38)</a>:</h4>
<p>I'm also unsure about the terminology.  And, maybe it would make sense to combine <code>graph</code> and <code>simple_graph</code>, since now that I think about it, <code>graph</code> doesn't seem particularly useful.</p>



<a name="201823848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201823848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201823848">(Jun 24 2020 at 08:43)</a>:</h4>
<p>It's good to hear that you're working on a PR! There are a lot of questions here about how to set up definitions. One of the most basic is whether we want a type <code>E</code> of all edges together with an assignment of endpoints, or an indexed family <code>V -&gt; V -&gt; Sort u</code>. One issue with the former definition is that when you say "given <code>a b : V</code>, consider an edge <code>e</code> with endpoints <code>a b</code>", then the endpoints of <code>e</code> will never be definitionally equal to <code>a b</code> -- instead you will have some equalities to rewrite along. (It's easier to bundle an unbundled definition than it is to unbundle a bundled definition.)</p>



<a name="201824515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201824515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201824515">(Jun 24 2020 at 08:53)</a>:</h4>
<p>I think this issue of loops being their own reversal never came up because Johan was working exclusively with the <code>Prop</code>-case, where loops definitionally equal their reversals. Another lawfulness issue is that edge reversal should be involutive -- the reversal of the reversal is the original loop. I think sometimes you might want this condition, while allowing loops which do not equal their reversal? (The example I have in mind is a groupoid, where the reversal of an arrow / edge is its inverse.)</p>



<a name="201824534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201824534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201824534">(Jun 24 2020 at 08:53)</a>:</h4>
<p>An awkwardness with undirected graphs is that edges don't really have endpoints in a specific order.  It seems the indexed family approach requires you to sort of keep track of a quotient type yourself by having some involution that inverts edges.  The dual to the approach I was considering might be having the edges be an indexed family <code>sym2 V -&gt; Sort u</code>, which makes the edges inherently unoriented.</p>
<p>I need to go to sleep now, but here's what I have so far: <a href="https://github.com/leanprover-community/mathlib/tree/graphs/src/combinatorics/graphs">https://github.com/leanprover-community/mathlib/tree/graphs/src/combinatorics/graphs</a></p>



<a name="201824970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201824970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201824970">(Jun 24 2020 at 08:59)</a>:</h4>
<p>Yes, undirected graphs are awkward in the indexed approach. <code>edge : sym2 V -&gt; Sort u</code> might also be problematic since <code>edge (a, b)</code> and <code>edge (b, a)</code> are still not def eq.</p>



<a name="201825071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201825071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201825071">(Jun 24 2020 at 09:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201824515">said</a>:</p>
<blockquote>
<p>I think this issue of loops being their own reversal never came up because Johan was working exclusively with the <code>Prop</code>-case, where loops definitionally equal their reversals. Another lawfulness issue is that edge reversal should be involutive -- the reversal of the reversal is the original loop. I think sometimes you might want this condition, while allowing loops which do not equal their reversal? (The example I have in mind is a groupoid, where the reversal of an arrow / edge is its inverse.)</p>
</blockquote>
<p>Loops don't seem to be too popular, so that's fair.  The sorts of things I have in mind in the future (say, Tutte polynomials) involve any numbers of loops at vertex, so it would be nice to make sure this works.  </p>
<p>(I sort of like the approach of gluing edges to the vertices, but I'm probably just biased as a topologist.)</p>



<a name="201825758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201825758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201825758">(Jun 24 2020 at 09:08)</a>:</h4>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span> Another approach I was using in a different project is</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">ϕ</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">ε_inv</span> <span class="o">:</span> <span class="n">involutive</span> <span class="n">ε</span><span class="o">)</span> <span class="o">(</span><span class="n">ε_fp_free</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">has_fixed_point</span> <span class="n">ε</span><span class="o">)</span>
</code></pre></div>


<p>Here, <code>D</code> is the set of "darts," which are the two ends of an edge.  The edges are the orbits under <code>ε</code>.  This, at least, makes accounting easier for the proof that <code>∑ (v : V), g.deg v = 2 * g.nedges</code>, since it has an intermediate <code>g.ndarts</code>.</p>



<a name="201835546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201835546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201835546">(Jun 24 2020 at 11:16)</a>:</h4>
<p>Wow great to see someone taking care of it ! <span class="user-mention" data-user-id="306601">@Kyle Miller</span> Are you restarting from scratch or do you use the hedetniemi base ?</p>



<a name="201884493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/201884493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#201884493">(Jun 24 2020 at 18:21)</a>:</h4>
<p><span class="user-mention" data-user-id="268315">@Anatole Dedecker</span> Right now, I'm looking deeper into the literature and trying to prove some basic theorems with a given formalism to evaluate the options, and the plan is to port over the hedetniemi branch as much as possible.  I'm happy to have some help, especially since you wanted to work on graphs, too -- I mostly just want to make sure whatever graph formalism mathlib has is general enough for the sorts of things I like to do with graphs.</p>
<p><a href="https://link.springer.com/chapter/10.1007/3-540-58450-1_40">This paper's</a> approach looks very promising.  It avoids the mess of dealing with quotient types (<code>sym2</code>), which has been OK but leaves something to be desired.  Here's the paper's definition in Lean (modified a bit to make use of some Lean features):</p>
<div class="codehilite"><pre><span></span><code><span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="c1">-- A *link* represents an edge along with its endpoints in some given</span>
<span class="c1">-- order.</span>
<span class="kn">structure</span> <span class="n">links</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">src</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">via</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">dest</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span>

<span class="kn">section</span> <span class="n">links</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>

<span class="n">def</span> <span class="n">links</span><span class="bp">.</span><span class="n">rev</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">links</span> <span class="n">V</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">links</span> <span class="n">V</span> <span class="n">E</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">x</span><span class="bp">.</span><span class="n">dest</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">via</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">src</span><span class="bp">⟩</span>

<span class="c1">-- Since we are modeling undirected graphs, two links are essentially</span>
<span class="c1">-- the same if they correspond to the same edge.</span>
<span class="n">def</span> <span class="n">links</span><span class="bp">.</span><span class="n">almost_equal</span> <span class="o">:</span> <span class="n">links</span> <span class="n">V</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">links</span> <span class="n">V</span> <span class="n">E</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x₁</span> <span class="n">x₂</span><span class="o">,</span> <span class="n">x₁</span> <span class="bp">=</span> <span class="n">x₂</span> <span class="bp">∨</span> <span class="n">x₁</span> <span class="bp">=</span> <span class="n">x₂</span><span class="bp">.</span><span class="n">rev</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_equiv</span> <span class="o">(</span><span class="n">links</span> <span class="n">V</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">links</span><span class="bp">.</span><span class="n">almost_equal</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">links</span>

<span class="c1">-- Surjectivity of f restricted to s.</span>
<span class="n">def</span> <span class="n">surjective_on</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>

<span class="c1">-- Injectivity of f on a given set s modulo a given relation R.</span>
<span class="n">def</span> <span class="n">injective_mod_on</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">R</span> <span class="n">x</span> <span class="n">y</span>

<span class="c1">-- A multigraph consists of a vertex set and an edge set along with</span>
<span class="c1">-- exactly two links per non-loop edge and one link per loop edge,</span>
<span class="c1">-- representing how the edge is glued to the vertices.</span>
<span class="kn">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">links</span> <span class="n">V</span> <span class="n">E</span><span class="o">))</span>
<span class="o">(</span><span class="n">all_edges</span> <span class="o">:</span> <span class="n">surjective_on</span> <span class="n">links</span><span class="bp">.</span><span class="n">via</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">all_links</span> <span class="o">:</span> <span class="n">surjective_on</span> <span class="n">links</span><span class="bp">.</span><span class="n">rev</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">adequate</span> <span class="o">:</span> <span class="n">injective_mod_on</span> <span class="o">(</span><span class="bp">≈</span><span class="o">)</span> <span class="n">links</span><span class="bp">.</span><span class="n">via</span> <span class="n">L</span><span class="o">)</span>
</code></pre></div>


<p>This definition will support things like paths through a graph as a sequence of links with compatible <code>src</code> and <code>dest</code> fields.</p>
<p>A "dual" version, like in hedetneimi, might be</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">E</span><span class="o">)</span>
<span class="o">(</span><span class="n">all_edges</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">edges</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">reversible</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">edges</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">edges</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">adequate</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="err">∈</span> <span class="n">edges</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span><span class="n">x&#39;</span> <span class="n">y&#39;</span><span class="o">},</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">edges</span> <span class="n">x&#39;</span> <span class="n">y&#39;</span> <span class="bp">→</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">x&#39;</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y&#39;</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y&#39;</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x&#39;</span><span class="o">))</span>
</code></pre></div>


<p>This unbundles the hedetneimi graph definition even further, I think, since we don't need to think of edges as being equivalence classes under the <code>inv</code> operation: there is an actual type representing the edges.</p>
<p>I need to think about <span class="user-mention" data-user-id="130377">@David Wärn</span>'s point about definitional equalities.  It seems to me that the first definition might indirectly address it: you ask for the set of <em>links</em> between vertices <code>a</code> and <code>b</code>, and these carry the corresponding edges.  The second definition gives you edge sets, and the <code>reversible</code> axiom identifies <code>edge a b</code> with <code>edge b a</code>.  I'd like having a total edge set, like in this definition, since you can do things like define a finite graph as one where both <code>V</code> and <code>g.E</code> are <code>fintype</code>s, so perhaps this is a nice variation on the hedetneimi branch's definition.</p>
<p>I'm going to try rewriting everything I have using this second definition and see how it goes -- while many things were OK already, I think this one will go more smoothly.  (I would appreciate any thoughts about improving these definitions, including finding better names for the structure's fields, especially <code>adequate</code>.)</p>



<a name="202000395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/202000395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#202000395">(Jun 25 2020 at 17:37)</a>:</h4>
<p>This all looks very promising ! To be honest I'm not at all a specialist of graph theory, so I'm happy you're doing the hard part of choosing the best definition, I wouldn't have been self-confident enough to do it <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> . But once you've made your choice I'll be glad to help you stating and proving as many useful lemmas as I can (I even do know some friends who might be interested too) !</p>



<a name="202006605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/202006605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#202006605">(Jun 25 2020 at 18:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="268315">Anatole Dedecker</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/202000395">said</a>:</p>
<blockquote>
<p>But once you've made your choice I'll be glad to help you stating and proving as many useful lemmas as I can (I even do know some friends who might be interested too) !</p>
</blockquote>
<p>Great! My goal is to finish up this current design today or tomorrow, since a variation on <a href="https://link.springer.com/chapter/10.1007/3-540-58450-1_40">Chou94</a>'s approach seems like it's working out well enough for what you'd want out of multigraphs and simple graphs.</p>
<p>There are some surprising issues when it comes to some basic graph operations.  For example, none of the approaches seem to let you define a computable function that gives you the vertex opposite a given edge from a vertex.  The Chou approach sidesteps this by having you work with links instead, which already carry that opposite vertex (proving it was computable).  I'm wanting to avoid anything noncomputable as far as possible.</p>
<p>The definition ends up being very similar to the one in <code>hedetneimi</code>.  There, you effectively have a function <code>edges : V → V → set E</code> that gives the edge set between two vertices along with an axiom <code>∀ v w, edges v w = edges w v</code>.  Here, it's instead essentially a function <code>links : set (V × E × V)</code> with an axiom that reversing a link is still a link.  While this is just an uncurried version of the <code>edges</code> function (recall, a set is a function to <code>Prop</code>), it's proven to be convenient working with elements of <code>V × E × V</code>.  (Don't worry, I'm just expanding definitions here for sake of explanation.  There is a structure definition for links.)</p>



<a name="202023925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/202023925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#202023925">(Jun 25 2020 at 20:57)</a>:</h4>
<p>Hmm, it's interesting that "the other end" should be noncomputable. Fwiw, I think the issue is with <code>Prop</code> -- it generally causes issues when you want things to be computable. Here I computably define "the other element" of an unordered pair, by defining membership using <code>trunc</code> instead of <code>Prop</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">trunc</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>

<span class="c1">-- the relation &quot;equal as unordered pairs&quot;</span>
<span class="kn">inductive</span> <span class="n">swap_rel</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">same</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">swap_rel</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">swap</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">swap_rel</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>

<span class="c1">-- the relation &quot;equal as unordered pairs&quot; is an equivalence</span>
<span class="kn">instance</span> <span class="n">swap_setoid</span> <span class="o">:</span> <span class="n">setoid</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine_struct</span> <span class="o">{</span> <span class="n">r</span><span class="o">:=</span> <span class="n">swap_rel</span> <span class="n">α</span> <span class="o">},</span> <span class="n">tidy</span><span class="bp">;</span>
  <span class="o">{</span> <span class="n">cases_matching</span><span class="bp">*</span> <span class="n">swap_rel</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_;</span>
    <span class="n">apply</span> <span class="n">swap_rel</span><span class="bp">.</span><span class="n">same</span> <span class="bp">&lt;|&gt;</span> <span class="n">apply</span> <span class="n">swap_rel</span><span class="bp">.</span><span class="n">swap</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="c1">-- hence we can quotient by it</span>
<span class="n">def</span> <span class="n">unordered_pair</span> <span class="o">:=</span> <span class="n">quotient</span> <span class="o">(</span><span class="n">swap_setoid</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span>

<span class="c1">-- swapping order really does give the same unordered pair</span>
<span class="kn">lemma</span> <span class="n">eq_swap</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="err">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="err">⟧</span> <span class="bp">=</span> <span class="err">⟦</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span><span class="err">⟧</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">eq</span><span class="o">,</span> <span class="n">apply</span> <span class="n">swap_rel</span><span class="bp">.</span><span class="n">swap</span> <span class="o">}</span>

<span class="c1">-- the &quot;other element&quot; of an unordered pair is unique</span>
<span class="kn">lemma</span> <span class="n">other_unique</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="err">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="err">⟧</span> <span class="bp">=</span> <span class="err">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span><span class="err">⟧</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">eq</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span>

<span class="c1">-- `trunc_mem a p` is a constructive way of saying that `a` is an element of `p`.</span>
<span class="c1">-- Crucially, it is a subsingleton, but not a `Prop`.</span>
<span class="n">def</span> <span class="n">trunc_mem</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">unordered_pair</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">trunc</span> <span class="err">$</span> <span class="o">{</span><span class="n">b</span> <span class="bp">//</span> <span class="n">p</span> <span class="bp">=</span> <span class="err">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="err">⟧</span><span class="o">}</span>

<span class="c1">-- if `a` is an element of `p`, then we can computably extract &quot;the other element&quot; of `p`</span>
<span class="n">def</span> <span class="n">other</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">unordered_pair</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">trunc_mem</span> <span class="n">a</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">trunc</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="bp">⟨</span><span class="n">c</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">other_unique</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">(</span><span class="k">by</span> <span class="n">cc</span><span class="o">),</span> <span class="n">simp</span> <span class="o">}</span>

<span class="c1">-- checking that `other` computes as expected</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">other</span> <span class="n">a</span> <span class="err">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="err">⟧</span> <span class="o">(</span><span class="n">trunc</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">)</span> <span class="c1">-- b</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">other</span> <span class="n">b</span> <span class="err">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="err">⟧</span> <span class="o">(</span><span class="n">trunc</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">eq_swap</span><span class="bp">⟩</span><span class="o">)</span> <span class="c1">-- a</span>
</code></pre></div>



<a name="202027529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/202027529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#202027529">(Jun 25 2020 at 21:29)</a>:</h4>
<p>Thanks for showing me this use of <code>trunc</code>.  A few days ago I was trying to prove <code>other</code> for <code>unordered_pair</code>, but I ran into issues because I only had <code>a ∈ p</code> with a <code>has_mem</code> instance that checked if <code>a</code> equaled either component of the pair.</p>



<a name="204281837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204281837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204281837">(Jul 18 2020 at 03:41)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span> and I are almost done with the Friendship Theorem, and have started breaking up non-graph-theoretic parts into PRs. <a href="https://github.com/jalex-stark/friendship-theorem">https://github.com/jalex-stark/friendship-theorem</a></p>



<a name="204281969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204281969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204281969">(Jul 18 2020 at 03:44)</a>:</h4>
<p>The definition of a graph is on <code>adjacency_matrix.lean</code>. Does anyone with experience on Hedetniemi want to discuss with me whether I should change that definition? Perhaps model theory has biased me, but I like thinking of simple graphs as basically just relations, which can be coerced to be two-sorted multigraphs when relevant.</p>



<a name="204281995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204281995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204281995">(Jul 18 2020 at 03:45)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> <span class="user-mention" data-user-id="130377">@David Wärn</span>  <span class="user-mention" data-user-id="112680">@Johan Commelin</span></p>



<a name="204282057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204282057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204282057">(Jul 18 2020 at 03:47)</a>:</h4>
<p>While some of this is just going in the Freek 100 archive, I want to be consistent with whatever else is going into mathlib.</p>



<a name="204284022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204284022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204284022">(Jul 18 2020 at 04:44)</a>:</h4>
<p>This seems to be the correct definition for a simple graph.  In what I've been working on, I have the same <code>simple_graph</code> (though I decided to reserve <code>E</code> for <code>sym2.from_rel</code> of the relation) and a <code>multigraphs</code> typeclass for giving it the structure of a multigraph when needed.</p>



<a name="204284493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204284493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204284493">(Jul 18 2020 at 05:00)</a>:</h4>
<p>Cool. It sounds like merging eventually will be easy, but link me to some code if you want me to adjust mine.</p>



<a name="204286472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204286472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204286472">(Jul 18 2020 at 06:02)</a>:</h4>
<p>I've been mostly focusing on multigraphs, but here's what the simple graphs version might look like.  This seems like a good enough time to check the underlying idea with everyone.  One design goal is to be able to treat subgraphs of a given graph as graphs themselves.</p>
<p>A conceptual problem with graphs is that the usual synecdoche of referring to a structure by its carrier type fails: a graph is both its vertex and edge sets simultaneously.  A way I found to get around this is to say a type <em>consists</em> of graphs.  Then, you can have the variables <code>{α : Type*} [simple_graphs α] (G : α) </code> to be able to refer to <code>G</code> as a graph, as you'd want.  We can also write <code>G' : subgraph G</code> to denote a subgraph, and there is an instance so that the graph interface applies to <code>G'</code>, too.</p>
<p>I'd like to hear if there are any problems with this approach, or better ways of doing things.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">sym2</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">A type consists of simple graphs if each term has a corresponding</span>
<span class="cm">vertex type and symmetric irreflexive adjacency relation on the</span>
<span class="cm">vertices.  See `simple_graph` for the primary implementation.</span>
<span class="cm">-/</span>
<span class="n">class</span> <span class="n">simple_graphs</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">G</span><span class="o">,</span> <span class="n">symmetric</span> <span class="o">(</span><span class="n">adj</span> <span class="n">G</span><span class="o">))</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">G</span><span class="o">,</span> <span class="n">irreflexive</span> <span class="o">(</span><span class="n">adj</span> <span class="n">G</span><span class="o">))</span>

<span class="kn">namespace</span> <span class="n">simple_graphs</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">The edge set of a simple graph consists of all the unordered pairs</span>
<span class="cm">that satisfy the adjacency relation.</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">E</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">simple_graphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">sym2</span><span class="bp">.</span><span class="n">from_rel</span> <span class="o">(</span><span class="n">sym</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">simple_graphs</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">A simple graph on a vertex set `V` is an irreflexive symmetric</span>
<span class="cm">relation, representing which vertices are adjacent.</span>
<span class="cm">-/</span>
<span class="kn">structure</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span><span class="o">)</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">Of course, the type of simple graphs on a vertex set consists of</span>
<span class="cm">simple graphs.</span>
<span class="cm">-/</span>
<span class="kn">instance</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">simple_graphs</span> <span class="o">(</span><span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">adj</span> <span class="o">:=</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="n">adj</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="n">sym</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="n">loopless</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">complete_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tidy</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tidy</span> <span class="o">}</span>

<span class="kn">open</span> <span class="n">simple_graphs</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">A subgraph of a simple graph `G`.</span>
<span class="cm">-/</span>
<span class="kn">structure</span> <span class="n">subgraph</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">simple_graphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">))</span>
<span class="o">(</span><span class="n">E&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)))</span>
<span class="o">(</span><span class="n">edge_subset</span> <span class="o">:</span> <span class="n">E&#39;</span> <span class="err">⊆</span> <span class="n">E</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">has_ends</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="err">∈</span> <span class="n">E&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="err">∈</span> <span class="n">e</span><span class="o">),</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">V&#39;</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">simple_graphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graphs</span> <span class="o">(</span><span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G&#39;</span><span class="o">,</span> <span class="n">subgraph</span><span class="bp">.</span><span class="n">V&#39;</span> <span class="n">G&#39;</span><span class="o">,</span>
  <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G&#39;</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="err">⟦</span><span class="o">(</span><span class="n">v</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">w</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span><span class="err">⟧</span> <span class="err">∈</span> <span class="n">subgraph</span><span class="bp">.</span><span class="n">E&#39;</span> <span class="n">G&#39;</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">G&#39;</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">eq_swap</span> <span class="o">},</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">G&#39;</span> <span class="n">v</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">from_rel_irreflexive</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">simple_graphs</span><span class="bp">.</span><span class="n">loopless</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">subgraph</span><span class="bp">.</span><span class="n">edge_subset</span> <span class="bp">_</span> <span class="n">h</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">is_diag_iff_proj_eq</span><span class="o">,</span>
  <span class="kn">end</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">The type of subgraphs on a given simple graph is a bounded lattice.</span>
<span class="cm">-/</span>
<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">simple_graphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">bounded_lattice</span> <span class="o">(</span><span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">A spanning subgraph consists of all of the vertices along with a</span>
<span class="cm">subset of the edges.</span>
<span class="cm">-/</span>
<span class="kn">structure</span> <span class="n">spanning_subgraph</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">simple_graphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">E&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)))</span>
<span class="o">(</span><span class="n">edge_subset</span> <span class="o">:</span> <span class="n">E&#39;</span> <span class="err">⊆</span> <span class="n">E</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">simple_graphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graphs</span> <span class="o">(</span><span class="n">spanning_subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G&#39;</span><span class="o">,</span> <span class="n">V</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G&#39;</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="err">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="err">⟧</span> <span class="err">∈</span> <span class="n">spanning_subgraph</span><span class="bp">.</span><span class="n">E&#39;</span> <span class="n">G&#39;</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">G&#39;</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">eq_swap</span> <span class="o">},</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">G&#39;</span> <span class="n">v</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">from_rel_irreflexive</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">simple_graphs</span><span class="bp">.</span><span class="n">loopless</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">spanning_subgraph</span><span class="bp">.</span><span class="n">edge_subset</span> <span class="bp">_</span> <span class="n">h</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">is_diag_iff_proj_eq</span><span class="o">,</span>
  <span class="kn">end</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">simple_graphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">bounded_lattice</span> <span class="o">(</span><span class="n">spanning_subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="204370338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204370338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204370338">(Jul 19 2020 at 20:52)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>, <span class="user-mention" data-user-id="252300">@Jalex Stark</span>  and I are about to PR a tiny bit of graph theory. We put your name on one of the files because I incorporated some of that text into it.</p>



<a name="204370777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204370777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204370777">(Jul 19 2020 at 21:06)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/3458">#3458</a></p>



<a name="204538485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204538485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204538485">(Jul 21 2020 at 11:58)</a>:</h4>
<p>Maybe naive question, but is there a reason why not to use <code>has_hom</code> from the category theory library for directed multigraphs (or vice versa). They seem more or less the same thing to me (apart from the fact that one is a structure and the other is a class).</p>



<a name="204606085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204606085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204606085">(Jul 21 2020 at 21:41)</a>:</h4>
<p><span class="user-mention" data-user-id="317890">@Julian Külshammer</span> A reason I can think of is that a given vertex set might have multiple possible edge sets associated to it.  In category theory, we assume that the object type determines a natural collection of morphisms.  This assumption breaks down for graphs.</p>
<p>This, perhaps, is a way to make it work:</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">digraphs</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>


<p>This says that each term <code>G : α</code> has an associated vertex type and <code>has_hom</code> structure on it.</p>
<p>There's also a dual version of this.  Something like it is used in a paper about labeled multigraphs:</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">digraphs</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">E</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">V</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">E</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">V</span> <span class="n">G</span><span class="o">)</span>
</code></pre></div>


<p>A benefit is that there is a concrete edge set.  This is useful, for example, in defining what a finite graph is.</p>
<p>Yet another possible definition, which is one step away from undirected multigraphs (which is what I was working on) is</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">link</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span>

<span class="n">class</span> <span class="n">digraphs</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">links</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">set</span> <span class="o">(</span><span class="n">link</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="n">G</span><span class="o">)))</span>
<span class="o">(</span><span class="n">all_edges</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span> <span class="n">G</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">links</span> <span class="n">G</span><span class="o">),</span> <span class="n">link</span><span class="bp">.</span><span class="n">e</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span>
<span class="o">(</span><span class="n">edge_inj</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">set</span><span class="bp">.</span><span class="n">inj_on</span> <span class="n">link</span><span class="bp">.</span><span class="n">e</span> <span class="o">(</span><span class="n">links</span> <span class="n">G</span><span class="o">))</span>
</code></pre></div>


<p>This is surprisingly nice to work with.  The <code>links</code> field is essentially a function <code>V G → V G → E G → Prop</code> (which is equivalent to <code>V G → V G → set (E G)</code>), but having it as a tuple seems to let you rewrite fewer things in proofs.</p>
<p>It's not too hard to define functions that go between each of these representations.</p>



<a name="204636613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204636613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204636613">(Jul 22 2020 at 07:18)</a>:</h4>
<p>@Kyle Miller There are many examples in category theory where you have the same vertex "set" but different kinds of morphisms between them. One very common example of this is the category of complexes, its homotopy category, or its derived category. Another example is that of the Kleisli category of a monad. </p>
<p>Thanks a lot for your different possible implementations of multigraphs. What you call the "dual version" is definitely the most common representation in the area of mathematics I am working in (representation theory of finite dimensional algebras), where such a thing is called a quiver. </p>
<p>I also saw a comment by <span class="user-mention" data-user-id="110032">@Reid Barton</span> in <a href="https://github.com/leanprover-community/mathlib/pull/613">https://github.com/leanprover-community/mathlib/pull/613</a> describing that has_hom was introduced to talk more easily about the free category on a graph, so I was wondering whether the two notions should be connected (or one removed and pointing to the other). I don't know enough about lean yet to answer this question, so I thought I ask here.</p>



<a name="204637873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204637873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204637873">(Jul 22 2020 at 07:41)</a>:</h4>
<p><span class="user-mention" data-user-id="317890">@Julian Külshammer</span> A common trick that we use when we have the same "underlying set" is a so-called type wrapper (which is just the identity function).</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">derived_category</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">C</span>
</code></pre></div>


<p>And then you can have different typeclasses on <code>C</code> and on <code>derived_category C</code>. In particular, their morphisms can be different.</p>



<a name="204640672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204640672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204640672">(Jul 22 2020 at 08:24)</a>:</h4>
<p>Just to be clear: here I'm already thinking of <code>C</code> as the category of chain complexes. Not some sort of abelian category. So maybe I shouldn't have called it <code>derived_category</code>, but more something like <code>localisation_category</code>, or something like that.</p>



<a name="204640748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204640748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204640748">(Jul 22 2020 at 08:25)</a>:</h4>
<p><span class="user-mention" data-user-id="317890">@Julian Külshammer</span> Yeah, I sort of had path algebras in the back of my mind when I was writing the second (and third) definitions.</p>
<p>Since you asked, here's how you might connect the second definition to <code>has_hom</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">Give the terms of a type the structure of a directed graph.</span>
<span class="cm">-/</span>
<span class="n">class</span> <span class="n">digraphs</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">source</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">E</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">V</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">target</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">E</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">V</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">digraphs</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">Associate a `has_hom` structure to the digraph&#39;s vertex type.</span>
<span class="cm">-/</span>
<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">digraphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">has_hom</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span> <span class="n">G</span> <span class="bp">//</span> <span class="n">source</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">v</span> <span class="bp">∧</span> <span class="n">target</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">w</span><span class="o">}</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">A concrete directed graph on a given vertex and edge set.</span>
<span class="cm">-/</span>
<span class="kn">structure</span> <span class="n">digraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">):=</span>
<span class="o">(</span><span class="n">source</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">target</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">digraphs</span> <span class="o">(</span><span class="n">digraph</span> <span class="n">V</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">E</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">E</span><span class="o">,</span>
  <span class="n">source</span> <span class="o">:=</span> <span class="n">digraph</span><span class="bp">.</span><span class="n">source</span><span class="o">,</span>
  <span class="n">target</span> <span class="o">:=</span> <span class="n">digraph</span><span class="bp">.</span><span class="n">target</span> <span class="o">}</span>

<span class="kn">structure</span> <span class="n">subdigraph</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">digraphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">))</span>
<span class="o">(</span><span class="n">E&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">E</span> <span class="n">G</span><span class="o">))</span>
<span class="o">(</span><span class="n">has_sources</span> <span class="o">:</span> <span class="n">E&#39;</span><span class="bp">.</span><span class="n">image</span> <span class="n">source</span> <span class="err">⊆</span> <span class="n">V&#39;</span><span class="o">)</span>
<span class="o">(</span><span class="n">has_targets</span> <span class="o">:</span> <span class="n">E&#39;</span><span class="bp">.</span><span class="n">image</span> <span class="n">target</span> <span class="err">⊆</span> <span class="n">V&#39;</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">digraphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">digraphs</span> <span class="o">(</span><span class="n">subdigraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">subtype</span> <span class="n">H</span><span class="bp">.</span><span class="n">V&#39;</span><span class="o">,</span>
  <span class="n">E</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">subtype</span> <span class="n">H</span><span class="bp">.</span><span class="n">E&#39;</span><span class="o">,</span>
  <span class="n">source</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">H</span> <span class="bp">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">source</span> <span class="n">e</span><span class="o">,</span> <span class="n">H</span><span class="bp">.</span><span class="n">has_sources</span> <span class="bp">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩⟩</span><span class="o">,</span>
  <span class="n">target</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">H</span> <span class="bp">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">target</span> <span class="n">e</span><span class="o">,</span> <span class="n">H</span><span class="bp">.</span><span class="n">has_targets</span> <span class="bp">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩⟩</span> <span class="o">}</span>
</code></pre></div>


<p>I also give a concrete definition of a <code>digraph</code> and sub-digraphs for illustration of the possible interface.</p>
<p>What I was talking about earlier is that in Lean, many algebraic and categorical objects are referred to by some sort of carrier type.  Then, class resolution is able to give you the tacit structure.  As you note, there are many categories that are defined on the same object set, but, as Johan explains, Lean's class resolution gives you a trick to have it give different tacit structures.</p>
<p>With the above <code>has_hom</code> instance, even though different digraphs might have the same underlying vertex types, because they are referred to <code>V G</code> for a specific <code>G</code>, the class resolution will find the correct <code>has_hom</code> instance for that graph.  At least, that's my understanding -- I don't have much practical experience here.</p>



<a name="204641551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204641551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204641551">(Jul 22 2020 at 08:35)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Oh sorry I misunderstood! But how about </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">derived_category</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">chain_complex</span> <span class="n">C</span>
</code></pre></div>


<p>? One could imagine this line of code actually being written, right? <span class="user-mention" data-user-id="110087">@Scott Morrison</span> have I understood this correctly? It just looks like a cool definition.</p>



<a name="204641662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204641662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204641662">(Jul 22 2020 at 08:36)</a>:</h4>
<p>Of course derived categories will actually be a major pain when you try to formalise them.</p>



<a name="204641679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204641679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204641679">(Jul 22 2020 at 08:37)</a>:</h4>
<p>Maybe that's the point where we should go infty-cats</p>



<a name="204641708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204641708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204641708">(Jul 22 2020 at 08:37)</a>:</h4>
<p>Do we know this?</p>



<a name="204641721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204641721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204641721">(Jul 22 2020 at 08:37)</a>:</h4>
<p>Do we know what?</p>



<a name="204641879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204641879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204641879">(Jul 22 2020 at 08:39)</a>:</h4>
<p>I spent a long time poo-pooing the category theory library, inspired by Mario, but it's just getting better and better. The universe issues have been solved, the notation is slowly sinking in, and the fact that mathematicians like <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> just seem to have learnt Scott's current API effortlessly makes me wonder how far Lean 3 can go.</p>



<a name="204641899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204641899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204641899">(Jul 22 2020 at 08:39)</a>:</h4>
<p>The more we push Lean 3 in ways like this, the more we learn about what we want from Lean 4</p>



<a name="204641990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204641990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204641990">(Jul 22 2020 at 08:40)</a>:</h4>
<p>Sure... but derived categories are different right?</p>



<a name="204642006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642006">(Jul 22 2020 at 08:41)</a>:</h4>
<p>I don't understand why</p>



<a name="204642021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642021">(Jul 22 2020 at 08:41)</a>:</h4>
<p>Well, maybe not the derived categories per se, but taking derived functors...</p>



<a name="204642035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642035">(Jul 22 2020 at 08:41)</a>:</h4>
<p>you need to make awful choices... and lots of stuff gets swept under the rug in informal math.</p>



<a name="204642044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642044">(Jul 22 2020 at 08:41)</a>:</h4>
<p>Are you saying that at least one of derived categories and derived functors will be impossible in Lean 3?</p>



<a name="204642058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642058">(Jul 22 2020 at 08:41)</a>:</h4>
<p>Or just that they will be very difficult?</p>



<a name="204642122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642122">(Jul 22 2020 at 08:42)</a>:</h4>
<p>I fear that even though possible, getting a useful API will be really tricky.</p>



<a name="204642131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642131">(Jul 22 2020 at 08:42)</a>:</h4>
<p>We've seen how tricky sheaves are.</p>



<a name="204642142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642142">(Jul 22 2020 at 08:42)</a>:</h4>
<p>Defining a sheaf is easy peasy lemon squeezy</p>



<a name="204642144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642144">(Jul 22 2020 at 08:43)</a>:</h4>
<p>But making them usable...</p>



<a name="204642145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642145">(Jul 22 2020 at 08:43)</a>:</h4>
<p>Kenny got good at them!</p>



<a name="204642165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642165">(Jul 22 2020 at 08:43)</a>:</h4>
<p>I guess "an expert managed to do it" is not a great response here</p>



<a name="204642272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642272">(Jul 22 2020 at 08:44)</a>:</h4>
<p>(Don't mind me as you're discussing formalizing derived categories <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span>)</p>
<p><span class="user-mention silent" data-user-id="317890">Julian Külshammer</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/204636613">said</a>:</p>
<blockquote>
<p>There are many examples in category theory where you have the same vertex "set" but different kinds of morphisms between them.</p>
</blockquote>
<p>One more thought about this: For categories, there are a handful of different possibilities in use.  But for graphs, sort of the whole point is varying the edge sets.  This suggests, at least to me, that directed graphs need to be handled somewhat differently from the way categories are handled in Lean.  This informed, to some degree, the above proposed design of digraphs.</p>



<a name="204642367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642367">(Jul 22 2020 at 08:45)</a>:</h4>
<p>Ooh, sorry. We should move to another thread.</p>



<a name="204642505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642505">(Jul 22 2020 at 08:47)</a>:</h4>
<p>Oh I'm sorry <span class="user-mention" data-user-id="306601">@Kyle Miller</span> :-) I'll move to another thread.</p>



<a name="204642868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204642868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204642868">(Jul 22 2020 at 08:50)</a>:</h4>
<p>No problem! It's sort of related, and I didn't mean to interrupt you.</p>



<a name="204648130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/204648130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#204648130">(Jul 22 2020 at 10:00)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> <span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Thanks for all the interesting comments. It seems there is much to learn and explore in that direction.</p>



<a name="205978199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978199">(Aug 05 2020 at 00:53)</a>:</h4>
<p>So I'm a bit late to the party here, but I was wondering if I could join in on the graph theory project? I've been trying to do small projects here and there to learn Lean but graph theory is what I ultimately wanted to do</p>



<a name="205978452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978452">(Aug 05 2020 at 00:58)</a>:</h4>
<p>hmm are you asking a question like "if I want to contribute to the development of graph theory in mathlib, where should I start"?</p>



<a name="205978463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978463">(Aug 05 2020 at 00:58)</a>:</h4>
<p>yes! thank you that's a better way of putting it haha</p>



<a name="205978478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978478">(Aug 05 2020 at 00:59)</a>:</h4>
<p>we need more API</p>



<a name="205978485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978485">(Aug 05 2020 at 00:59)</a>:</h4>
<p>I don't know how to prove anything about the cardinality of the edge set of a graph</p>



<a name="205978501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978501">(Aug 05 2020 at 00:59)</a>:</h4>
<p>i was looking at stuff like subgraphs and connectivity - i didn't see it in the PR, are you guys working on that?</p>



<a name="205978558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978558">(Aug 05 2020 at 01:00)</a>:</h4>
<p>noted!</p>



<a name="205978569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978569">(Aug 05 2020 at 01:00)</a>:</h4>
<p><span class="user-mention" data-user-id="322118">@Michael Hahn</span> and I are working with eulerian circuits in a separate repo</p>



<a name="205978582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978582">(Aug 05 2020 at 01:01)</a>:</h4>
<p>i think at least our induction principle for graphs is ready to be PRed</p>



<a name="205978660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978660">(Aug 05 2020 at 01:02)</a>:</h4>
<p><a href="https://github.com/apurvnakade/mc2020-projects/tree/mathlib_simple_graph/src/michael">https://github.com/apurvnakade/mc2020-projects/tree/mathlib_simple_graph/src/michael</a></p>



<a name="205978661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978661">(Aug 05 2020 at 01:02)</a>:</h4>
<p>gotcha. i wanted to try to define some basic stuff for trees, would you be able to link the repo?</p>



<a name="205978687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978687">(Aug 05 2020 at 01:03)</a>:</h4>
<p>too fast. thanks!</p>



<a name="205978746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978746">(Aug 05 2020 at 01:04)</a>:</h4>
<p>should i just fork it or something?</p>



<a name="205978764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978764">(Aug 05 2020 at 01:05)</a>:</h4>
<p>hmm</p>



<a name="205978776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978776">(Aug 05 2020 at 01:05)</a>:</h4>
<p>What I would do is work in a branch of mathlib, and if there are things from that project I wanted, I would copy-paste them</p>



<a name="205978803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978803">(Aug 05 2020 at 01:06)</a>:</h4>
<p>okay cool, thank you!</p>



<a name="205978858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978858">(Aug 05 2020 at 01:07)</a>:</h4>
<p>working in a branch of mathlib will make it easier to collaborate with people here, and also easier to spin off parts of your branch into a PR</p>



<a name="205978877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978877">(Aug 05 2020 at 01:08)</a>:</h4>
<p>michael and I are working in a separate repo because this is a summer project for him and we want there to be a place where it lives when it's done, even if it doesn't make it to mathlib</p>



<a name="205978988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978988">(Aug 05 2020 at 01:10)</a>:</h4>
<p>makes sense</p>



<a name="205978993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205978993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205978993">(Aug 05 2020 at 01:10)</a>:</h4>
<p>speaking of summer projects, i did originally intend to do graph theory for that, i just initially didn't see much stuff done and felt intimidated, and then i didn't keep up with stuff here. ya live and you learn ig lol</p>



<a name="205979100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205979100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205979100">(Aug 05 2020 at 01:14)</a>:</h4>
<p>it's still summer, I think</p>



<a name="205979145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205979145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205979145">(Aug 05 2020 at 01:14)</a>:</h4>
<p>i mean yeah fair</p>



<a name="205979148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205979148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205979148">(Aug 05 2020 at 01:14)</a>:</h4>
<p>wanna do a project with me lol</p>



<a name="205979153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205979153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205979153">(Aug 05 2020 at 01:14)</a>:</h4>
<p>speedrun <span aria-label="racecar" class="emoji emoji-1f3ce" role="img" title="racecar">:racecar:</span></p>



<a name="205979976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205979976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205979976">(Aug 05 2020 at 01:38)</a>:</h4>
<p>i stepped away at an inopportune time, sorry. I'm happy to follow / code review your graph work if it happens in either a mathlib branch or a repo that you tell me about.</p>



<a name="205981970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205981970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205981970">(Aug 05 2020 at 02:22)</a>:</h4>
<p>you're fine! <a href="https://github.com/agusakov/graph_theory_2020">https://github.com/agusakov/graph_theory_2020</a><br>
it doesn't have anything yet, still gotta make my first commits</p>



<a name="205981975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205981975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205981975">(Aug 05 2020 at 02:23)</a>:</h4>
<p>appreciate it!</p>



<a name="205982886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205982886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205982886">(Aug 05 2020 at 02:45)</a>:</h4>
<p>do you know which commands to type to start up the repo with a lean project? (now i see some of your other GitHub projects; i'm guessing the answer is yes)</p>



<a name="205983633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205983633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205983633">(Aug 05 2020 at 03:00)</a>:</h4>
<p>yep!</p>



<a name="205984106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205984106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205984106">(Aug 05 2020 at 03:09)</a>:</h4>
<p>made my first commit, i only have some tiny definitions so far</p>



<a name="205984264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205984264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205984264">(Aug 05 2020 at 03:12)</a>:</h4>
<p>paths can have repeated edges</p>



<a name="205984269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205984269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205984269">(Aug 05 2020 at 03:12)</a>:</h4>
<p><code>p.is_tour</code> says that there are no repeated edges</p>



<a name="205984596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205984596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205984596">(Aug 05 2020 at 03:17)</a>:</h4>
<p>oh gosh thanks haha</p>



<a name="205985071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205985071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205985071">(Aug 05 2020 at 03:26)</a>:</h4>
<p>i'm having trouble figuring out how to use it - i keep getting errors and i can't really find it anywhere in the files</p>



<a name="205986470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205986470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205986470">(Aug 05 2020 at 04:01)</a>:</h4>
<p>sorry, it's actually called <code>p.is_trail</code>, defined at the end of this file<br>
<a href="https://github.com/apurvnakade/mc2020-projects/blob/mathlib_simple_graph/src/michael/path.lean">https://github.com/apurvnakade/mc2020-projects/blob/mathlib_simple_graph/src/michael/path.lean</a></p>



<a name="205986559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205986559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205986559">(Aug 05 2020 at 04:03)</a>:</h4>
<p>gotcha! i actually went ahead and defined an <code>is_tour</code> cause i saw that <code>is_trail</code> allows for repeated vertices, just not repeated edges so it all worked out lol</p>



<a name="205987562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/205987562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#205987562">(Aug 05 2020 at 04:31)</a>:</h4>
<p>some (most?) of our definitions are adapted from the <code>mathlib:hedetniemi</code> branch</p>



<a name="206098823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/206098823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#206098823">(Aug 06 2020 at 02:25)</a>:</h4>
<p>Taking a look at this since I did some graph theory in lean a while back - are you working on the mathlib_simple_graph branch or master?</p>



<a name="206102197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/206102197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#206102197">(Aug 06 2020 at 03:50)</a>:</h4>
<p>mathlib_simple_graph</p>



<a name="206102206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/206102206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#206102206">(Aug 06 2020 at 03:50)</a>:</h4>
<p>alright, are you accepting PRs?</p>



<a name="206102219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/206102219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#206102219">(Aug 06 2020 at 03:51)</a>:</h4>
<p>yes</p>



<a name="206102327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/206102327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#206102327">(Aug 06 2020 at 03:54)</a>:</h4>
<p>and finally, what's the progress on the things listed here: <a href="https://github.com/apurvnakade/mc2020-projects/tree/mathlib_simple_graph/src/michael">https://github.com/apurvnakade/mc2020-projects/tree/mathlib_simple_graph/src/michael</a>? I've done the fourth a while ago</p>



<a name="206102509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/206102509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#206102509">(Aug 06 2020 at 03:59)</a>:</h4>
<p><span class="user-mention" data-user-id="322118">@Michael Hahn</span> wrote that list. I guess we currently don't have a definition of the konigsberg graph, because we haven't yet allowed multiple edges</p>



<a name="206102694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/206102694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#206102694">(Aug 06 2020 at 04:03)</a>:</h4>
<p>i find the current type of edges pretty awkward to work with</p>



<a name="206102861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/206102861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#206102861">(Aug 06 2020 at 04:08)</a>:</h4>
<p>we need at least a coercion <code>H.E \to G.E</code> when <code>H.is_subgraph G</code> before we can make a serious application of subgraph induction.</p>



<a name="287375487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/287375487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mahdi Khaleghi <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#287375487">(Jun 24 2022 at 19:37)</a>:</h4>
<p>Is there a code for embedded graphs in the sphere in homotopy type theory in Lean4?</p>



<a name="287375830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/287375830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#287375830">(Jun 24 2022 at 19:40)</a>:</h4>
<p>Just to be clear -- Lean 4 is not a homotopy type theory prover, its axioms are incompatible with the univalence axiom. So there's no anything in homotopy type theory in Lean 4.</p>



<a name="287376329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/287376329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mahdi Khaleghi <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#287376329">(Jun 24 2022 at 19:44)</a>:</h4>
<p>thanks. are there open topics related to combinatorial graph theory that we can participate to implement?</p>



<a name="287376743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/287376743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#287376743">(Jun 24 2022 at 19:48)</a>:</h4>
<p>We have a <a class="stream" data-stream-id="252551" href="/#narrow/stream/252551-graph-theory">#graph theory</a> stream where you might want to ask</p>



<a name="287625661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Graph%20Theory/near/287625661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mahdi Khaleghi <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Graph.20Theory.html#287625661">(Jun 27 2022 at 19:25)</a>:</h4>
<p>I'll check them out. Thanks.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
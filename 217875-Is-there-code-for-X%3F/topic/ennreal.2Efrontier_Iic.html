---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html">ennreal.frontier_Iic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="263734104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263734104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263734104">(Dec 04 2021 at 22:02)</a>:</h4>
<p>What is the right way of proving that the boundary of an <code>Iic</code>-interval up to a finite <code>x : ennreal</code> is the singleton <code>{x}</code>?</p>
<p>I.e.:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.algebra.ordered.basic</span>
<span class="kn">import</span> <span class="n">topology.instances.ennreal</span>

<span class="kn">open</span> <span class="n">order</span> <span class="n">set</span>
<span class="n">open_locale</span> <span class="n">topological_space</span> <span class="n">nnreal</span> <span class="n">ennreal</span>

<span class="kd">lemma</span> <span class="n">ennreal.frontier_Iic_how</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="bp">∞</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">frontier</span> <span class="o">(</span><span class="n">Iic</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="263734116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263734116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263734116">(Dec 04 2021 at 22:02)</a>:</h4>
<p>For comparison, in <code>ℝ</code>, the following is found by <code>library_search</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.algebra.ordered.basic</span>
<span class="kn">import</span> <span class="n">topology.instances.ennreal</span>

<span class="kn">open</span> <span class="n">order</span> <span class="n">set</span>
<span class="n">open_locale</span> <span class="n">topological_space</span> <span class="n">nnreal</span> <span class="n">ennreal</span>

<span class="kd">lemma</span> <span class="n">real.frontier_Iic_like_this</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">frontier</span> <span class="o">(</span><span class="n">Iic</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:=</span> <span class="n">frontier_Iic</span>
</code></pre></div>



<a name="263734124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263734124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263734124">(Dec 04 2021 at 22:02)</a>:</h4>
<p>The reason <code>frontier_Iic</code> does not apply to <code>ennreal</code> is the assumption <code>[no_top_order]</code> in it. The assumption <code>hx : x ≠ ∞</code> of course has mathematically "the same content".</p>



<a name="263734163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263734163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263734163">(Dec 04 2021 at 22:03)</a>:</h4>
<p>Below is a super clumsy solution (but I believe in the right generality). I think such lemmas are important enough to include in mathlib (at least <code>frontier_Ici</code> in <code>nnreal</code> etc. would lead to similar issues), but my question is: what is the non-clumsy way to do these?</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.algebra.ordered.basic</span>
<span class="kn">import</span> <span class="n">topology.instances.ennreal</span>

<span class="kn">open</span> <span class="n">order</span> <span class="n">set</span>
<span class="n">open_locale</span> <span class="n">topological_space</span> <span class="n">nnreal</span> <span class="n">ennreal</span>

<span class="kd">lemma</span> <span class="n">compl_singleton_eq_Iio_union_Ioi</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">order_topology</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">densely_ordered</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">{</span><span class="n">b</span><span class="o">}</span><span class="bp">ᶜ</span> <span class="bp">=</span> <span class="n">Iio</span> <span class="n">b</span> <span class="bp">∪</span> <span class="n">Ioi</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">interior_Iic'</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">order_topology</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">densely_ordered</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">interior</span> <span class="o">(</span><span class="n">Iic</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Iio</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_interior_iff_mem_nhds</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">hxb</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">hxb</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">exists_Ico_subset_of_mem_nhds</span> <span class="n">hx</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hbv</span><span class="o">,</span> <span class="n">hss</span><span class="o">⟩⟩,</span>
      <span class="n">rcases</span> <span class="n">exists_between</span> <span class="n">hbv</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">z</span><span class="o">,</span> <span class="n">hbz</span><span class="o">,</span> <span class="n">hzv</span><span class="o">⟩,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">lt_self_iff_false</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">lt_of_lt_of_le</span> <span class="n">hbz</span> <span class="o">(</span><span class="n">hss</span> <span class="o">⟨</span><span class="n">hbz.le</span><span class="o">,</span> <span class="n">hzv</span><span class="o">⟩)),</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">Iic_diff_right</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">mem_of_mem_nhds</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hxb</span><span class="o">⟩,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">interior_maximal</span> <span class="n">Iio_subset_Iic_self</span> <span class="n">is_open_Iio</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">order_topology.to_order_closed_topology</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">frontier_Iic'</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">order_topology</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">densely_ordered</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">frontier</span> <span class="o">(</span><span class="n">Iic</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">b</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">compl_injective</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">compl_frontier_eq_union_interior</span><span class="o">,</span> <span class="n">compl_singleton_eq_Iio_union_Ioi</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">compl_Iic</span><span class="o">,</span> <span class="n">interior_Ioi</span><span class="o">,</span> <span class="n">interior_Iic</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span> <span class="bp">∪</span> <span class="o">(</span><span class="n">Ioi</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">interior_Iic'</span> <span class="n">h</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">ennreal.frontier_Iic</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="bp">∞</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">frontier</span> <span class="o">(</span><span class="n">Iic</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">frontier_Iic'</span> <span class="o">⟨</span><span class="bp">∞</span><span class="o">,</span> <span class="n">lt_top_iff_ne_top.mpr</span> <span class="n">hx</span><span class="o">⟩,</span> <span class="o">}</span>
</code></pre></div>
</div></div>



<a name="263734535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263734535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263734535">(Dec 04 2021 at 22:11)</a>:</h4>
<p>I believe the relevant existing stuff should be around <a href="https://leanprover-community.github.io/mathlib_docs/find/frontier_Iic">docs#frontier_Iic</a> .</p>



<a name="263755323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263755323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263755323">(Dec 05 2021 at 07:43)</a>:</h4>
<p>The proper way is to prove theorems like <a href="https://leanprover-community.github.io/mathlib_docs/find/closure_Ioi">docs#closure_Ioi</a> with assumption <code>(Ioi x).nonempty</code>.</p>



<a name="263755386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263755386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263755386">(Dec 05 2021 at 07:45)</a>:</h4>
<p>You can either add new lemmas as prime versions or use <code>h : (Ioi x).nonempty . some_tac</code>, where <code>some_tac</code> tries to apply <code>set.nonempty_Ioi</code> and <code>set.nonempty_Iio</code>.</p>



<a name="263755497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263755497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263755497">(Dec 05 2021 at 07:48)</a>:</h4>
<p>It looks like we have <a href="https://leanprover-community.github.io/mathlib_docs/find/closure_Ioi'">docs#closure_Ioi'</a></p>



<a name="263755577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263755577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263755577">(Dec 05 2021 at 07:51)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">interior_Ici'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="o">(</span><span class="n">Iio</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">:</span> <span class="n">interior</span> <span class="o">(</span><span class="n">Ici</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Ioi</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">let</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ha</span> <span class="k">in</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">compl_Iio</span><span class="o">,</span> <span class="n">interior_compl</span><span class="o">,</span> <span class="n">closure_Iio'</span> <span class="n">hb</span><span class="o">,</span> <span class="n">compl_Iic</span><span class="o">]</span>


<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">frontier_Ici'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="o">(</span><span class="n">Iio</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">:</span> <span class="n">frontier</span> <span class="o">(</span><span class="n">Ici</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">frontier</span><span class="o">,</span> <span class="n">ha</span><span class="o">]</span>
</code></pre></div>



<a name="263755631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263755631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263755631">(Dec 05 2021 at 07:52)</a>:</h4>
<p>The first proof can be simplified if you rewrite <code>closure_Ioi'</code> so that it assumes <code>(Ioi a).nonempty</code></p>



<a name="263755647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263755647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263755647">(Dec 05 2021 at 07:52)</a>:</h4>
<p>I'm not sure whether new lemmas should just replace the old ones or not.</p>



<a name="263794839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263794839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263794839">(Dec 05 2021 at 23:16)</a>:</h4>
<p>Thank you very much! This looks great.</p>
<p>In the existing formulations, the typeclass <code>[no_top_order]</code> is really doing its work when it applies: I was super happy how smoothly (<code>:= by library_search</code>) the proof of <code>frontier (Iic x) = {x}</code> went in <code>ℝ</code> and <code>ℝ≥0</code>. I would therefore not want to remove the old ones, even if I think the new ones are needed as well.</p>
<p>I made a PR <a href="https://github.com/leanprover-community/mathlib/issues/10630">#10630</a> including both the Iic and Ici cases, with Yury's succinct proofs. [Edit: I guess I should include Iio and Ioi cases as well.]</p>



<a name="263794877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263794877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263794877">(Dec 05 2021 at 23:16)</a>:</h4>
<p>By the way, I have not found documentation for the <code>let ... in ...</code> syntax, especially the <code>in</code> keyword in it. Any hints on where to look? I could not find it described in the <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> nor at <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.interactive.let">docs#tactic.interactive.let</a> . By trial and error I figured the following would be essentially the same, right?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">interior_Ici'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="o">(</span><span class="n">Iio</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">:</span> <span class="n">interior</span> <span class="o">(</span><span class="n">Ici</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Ioi</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">ha</span> <span class="k">with</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">compl_Iio</span><span class="o">,</span> <span class="n">interior_compl</span><span class="o">,</span> <span class="n">closure_Iio'</span> <span class="n">hb</span><span class="o">,</span> <span class="n">compl_Iic</span><span class="o">],</span> <span class="o">}</span>
</code></pre></div>
<p>So is <code>let X := Y in</code> more or less the same as starting in tactic mode with <code>cases Y with X</code> and then continuing?</p>



<a name="263795532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263795532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263795532">(Dec 05 2021 at 23:32)</a>:</h4>
<p><code>let ... in ...</code> is term mode syntax</p>



<a name="263795549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263795549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263795549">(Dec 05 2021 at 23:33)</a>:</h4>
<p>If <code>X</code> is a pattern, then it's like you say. Otherwise, it is like the <code>let</code> tactic</p>



<a name="263795829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263795829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263795829">(Dec 05 2021 at 23:40)</a>:</h4>
<p>Ok, I think I only looked in <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> tactics chapter, which makes no sense given that it is a term mode syntax. Searching for small words such as <code>let</code> and <code>in</code> is not easy, though. But I think I roughly got it now. Thanks!</p>



<a name="263803400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263803400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263803400">(Dec 06 2021 at 02:43)</a>:</h4>
<p>I made a few comments. Please implement suggested changes, then change the label from <code>awaiting-author</code> to <code>awaiting-review</code>.</p>



<a name="263936255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263936255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263936255">(Dec 06 2021 at 22:52)</a>:</h4>
<p>Thank you! I implemented the changes.</p>



<a name="263936354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263936354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263936354">(Dec 06 2021 at 22:53)</a>:</h4>
<p>The "build mathlib" check now reports <code>Build succeeded, but the file was noisy</code>. I don't know what this means or how to fix it. Could someone help me understand what it is about?</p>
<p>(Btw, I didn't yet add the label "awaiting-review", since there is this failing check.)</p>



<a name="263936892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263936892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263936892">(Dec 06 2021 at 22:58)</a>:</h4>
<p>It probably means that there is some blue output, e.g. a <code>#check</code> or non-terminal <code>ring</code> in the file somewhere.</p>



<a name="263939852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263939852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263939852">(Dec 06 2021 at 23:31)</a>:</h4>
<p>Thank you! There was indeed a blue <code>#lint</code> at the end of the file <span aria-label="oops" class="emoji emoji-1f643" role="img" title="oops">:oops:</span>.</p>



<a name="263943359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263943359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263943359">(Dec 07 2021 at 00:16)</a>:</h4>
<p>I changed assumptions in more lemmas. Let's see if it compiles.</p>



<a name="263963810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263963810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263963810">(Dec 07 2021 at 06:31)</a>:</h4>
<p>Would it be possible to change this error message to make it more informative?</p>



<a name="263970045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ennreal.frontier_Iic/near/263970045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ennreal.2Efrontier_Iic.html#263970045">(Dec 07 2021 at 08:21)</a>:</h4>
<p>It's in <code>scripts/detect_errors.py</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
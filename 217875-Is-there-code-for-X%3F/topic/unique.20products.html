---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html">unique products</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="296258988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296258988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296258988">(Aug 31 2022 at 05:39)</a>:</h4>
<p>Dear All,</p>
<p>I discovered today that <a href="https://mathoverflow.net/questions/172530/kaplanskys-unit-conjecture-and-unique-products">unique products</a> is a thing.  I am thinking of implementing them.  What do people think of the code below?</p>
<p>Any comments are greatly appreciated!</p>
<p>Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.monoid_algebra.basic</span>

<span class="sd">/--  `unique_mul G A B a0 b0` means that the element `a0 * b0` can be written</span>
<span class="sd">uniquely as a product of an element of `A` and an element of `B`. -/</span>
<span class="kd">@[to_additive "`unique_add A B a0 b0` means that the element `a0 + b0` can be written</span>
<span class="kd">uniquely as a sum of an element from `A` and an element from `B`."]</span>
<span class="kd">def</span> <span class="n">unique_mul</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">a0</span> <span class="n">b0</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">⦃</span><span class="n">a</span> <span class="n">b</span><span class="o">⦄,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a0</span> <span class="bp">*</span> <span class="n">b0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b0</span>

<span class="sd">/--  `unique_summands G` asserts that any two non-empty finite subsets of `G`</span>
<span class="sd">have the `unique_add` property. -/</span>
<span class="kd">class</span> <span class="n">unique_summands</span> <span class="o">(</span><span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">adds</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B.nonempty</span><span class="o">),</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a0</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">),</span> <span class="n">unique_add</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a0</span> <span class="n">b0</span><span class="o">)</span>

<span class="sd">/--  `unique_products G` asserts that any two non-empty finite subsets of `G`</span>
<span class="sd">have the `unique_mul` property. -/</span>
<span class="kd">class</span> <span class="n">unique_products</span> <span class="o">(</span><span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">muls</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B.nonempty</span><span class="o">),</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a0</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">),</span> <span class="n">unique_mul</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a0</span> <span class="n">b0</span> <span class="o">)</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">unique_summands</span><span class="o">]</span> <span class="n">unique_products</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">unique_summands</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">unique_products</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">muls</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">,</span> <span class="k">let</span> <span class="n">A'</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">A</span> <span class="k">in</span> <span class="k">have</span> <span class="n">hA'</span><span class="o">:</span> <span class="n">A'.nonempty</span> <span class="o">:=</span> <span class="n">hA</span><span class="o">,</span> <span class="kd">by</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a0</span><span class="o">,</span> <span class="n">hA0</span><span class="o">,</span> <span class="n">b0</span><span class="o">,</span> <span class="n">hB0</span><span class="o">,</span> <span class="n">J</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">unique_summands.adds</span> <span class="n">hA'</span> <span class="n">hB</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">⟨</span><span class="n">additive.to_mul</span> <span class="n">a0</span><span class="o">,</span> <span class="n">hA0</span><span class="o">,</span> <span class="n">additive.to_mul</span> <span class="n">b0</span><span class="o">,</span> <span class="n">hB0</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">aA</span> <span class="n">bB</span> <span class="n">H</span><span class="o">,</span> <span class="n">J</span> <span class="n">aA</span> <span class="n">bB</span> <span class="n">H</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="296262523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296262523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296262523">(Aug 31 2022 at 06:18)</a>:</h4>
<p>This is a thing in additive combinatorics, actually!</p>



<a name="296262597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296262597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296262597">(Aug 31 2022 at 06:19)</a>:</h4>
<p>Yes, I put the import of where I was going to use it, but actually it is much lower than that.  Anyway, I'm going to make a PR, but do give comments on the definition!  I have checked that this would work smoothly with non-zero divisors.</p>



<a name="296262970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296262970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296262970">(Aug 31 2022 at 06:23)</a>:</h4>
<p>(The application is fairly direct: if the grading type of an <code>add_monoid_algebra</code> satisfies the <code>unique_summands</code> property, then the <code>add_monoid_algebra</code> has no non-zero zero-divisors as soon as the base ring has no non-zero zero-divisors.</p>
<p>As far as I can tell, this easy result implies easily all(?) the <code>no_zero_divisors</code> instances around <code>add_monoid_algebra, polynomial, mv_polynomial</code> in mathlib.)</p>



<a name="296263065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263065">(Aug 31 2022 at 06:24)</a>:</h4>
<p>How often is this satisfied in practice? I guess <code>pnat</code> has this property?</p>



<a name="296263229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263229">(Aug 31 2022 at 06:26)</a>:</h4>
<p>I have a proof of what is below:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[to_additive covariants.to_unique_summands]</span>
<span class="kd">instance</span> <span class="n">covariants.to_unique_products</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">[</span><span class="n">covariant_class</span> <span class="n">A</span> <span class="n">A</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">[</span><span class="n">covariant_class</span> <span class="n">A</span> <span class="n">A</span> <span class="o">(</span><span class="n">function.swap</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">contravariant_class</span> <span class="n">A</span> <span class="n">A</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">:</span> <span class="n">unique_products</span> <span class="n">A</span> <span class="o">:=</span>
</code></pre></div>



<a name="296263289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263289">(Aug 31 2022 at 06:27)</a>:</h4>
<p>Basically, if you have a linear order and with an operation and the operation is "sufficiently monotone", then <code>unique_products</code> holds.</p>



<a name="296263344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263344">(Aug 31 2022 at 06:27)</a>:</h4>
<p>This applies to the grading types of <code>mv_polynomials</code>, for instance.</p>



<a name="296263481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263481">(Aug 31 2022 at 06:29)</a>:</h4>
<p>Both of these work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">unique_summands</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">unique_products</span> <span class="n">pnat</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">unique_summands</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="296263526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263526">(Aug 31 2022 at 06:29)</a>:</h4>
<p>Aah, of course <code>ℕ</code> also satisfies it.</p>



<a name="296263534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263534">(Aug 31 2022 at 06:29)</a>:</h4>
<p><code>0</code> is not a problem.</p>



<a name="296263658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263658">(Aug 31 2022 at 06:30)</a>:</h4>
<p>(I added <code>int</code> above.)</p>



<a name="296263802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263802">(Aug 31 2022 at 06:32)</a>:</h4>
<p>Wait, I'm still confused. What is the motivation again for these classes? You mentioned something with gradings.<br>
Are we morally more interested in <code>unique_summands</code> or <code>unique_products</code>?</p>



<a name="296263816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263816">(Aug 31 2022 at 06:32)</a>:</h4>
<p>Btw Johan, while what I wrote is correct, this is what you probably had in mind:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">unique_summands</span> <span class="n">pnat</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="296263887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263887">(Aug 31 2022 at 06:33)</a>:</h4>
<p>By the way, <code>unique_mul</code> is equivalent to <code>(A * B).card = A.card * B.card</code></p>



<a name="296263905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263905">(Aug 31 2022 at 06:34)</a>:</h4>
<p><code>unique_products ℕ</code> is false, right?</p>



<a name="296263928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263928">(Aug 31 2022 at 06:34)</a>:</h4>
<p>For <code>add_monoid_algebra</code>, summands would make more sense.  But in more general group theory, people do study the "unique property" and in that context the operation is not commutative and they tend to use products.</p>



<a name="296263944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296263944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296263944">(Aug 31 2022 at 06:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/unique.20products/near/296263905">said</a>:</p>
<blockquote>
<p><code>unique_products ℕ</code> is false, right?</p>
</blockquote>
<p>I guess so!</p>



<a name="296264001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296264001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296264001">(Aug 31 2022 at 06:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/unique.20products/near/296263887">said</a>:</p>
<blockquote>
<p>By the way, <code>unique_mul</code> is equivalent to <code>(A * B).card = A.card * B.card</code></p>
</blockquote>
<p>I don't think so</p>



<a name="296264027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296264027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296264027">(Aug 31 2022 at 06:35)</a>:</h4>
<p>You are leaving out <code>a0</code> and <code>b0</code></p>



<a name="296264051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296264051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296264051">(Aug 31 2022 at 06:35)</a>:</h4>
<p>Rain, so I'm closing my laptop</p>



<a name="296264134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296264134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296264134">(Aug 31 2022 at 06:36)</a>:</h4>
<p>Ah yes, you're talking about a single element. Then you should replace <code>a0 * b0</code> by a single variable.</p>



<a name="296264651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296264651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296264651">(Aug 31 2022 at 06:42)</a>:</h4>
<p>Yaël, so should I should also quantify over 4 elements?</p>



<a name="296264684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296264684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296264684">(Aug 31 2022 at 06:43)</a>:</h4>
<p>(or two pairs?)</p>



<a name="296265121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296265121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296265121">(Aug 31 2022 at 06:47)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> here is a concrete proposal:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">unique_mul</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">⦃</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span><span class="o">⦄,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">d</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">d</span>
</code></pre></div>
<p>To me, it seems a little more cumbersome, but maybe I am wrong.  Likely, there is a better way of expressing this concept.</p>



<a name="296265263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296265263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296265263">(Aug 31 2022 at 06:48)</a>:</h4>
<p>I'll have time later today to find the correct combinatorial definition.</p>



<a name="296265684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296265684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296265684">(Aug 31 2022 at 06:53)</a>:</h4>
<p><code>unique_products pnat</code> is equivalent to <code>unique_summands (ℕ →₀ ℕ)</code> via a monoid isomorphism. <code>unique_products ℕ</code> is not true since A={0}, B={1,2} admit no unique product.</p>
<p>I don't like the disparity between the names <code>summand</code> and <code>product</code>. Could the former just be <code>sum</code>?</p>
<p>The property could also be phrased to say there is an element of G that has a unique preimage in A×B under multiplication; maybe this is what Yaël means?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">unique_products</span> <span class="o">(</span><span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">muls</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B.nonempty</span><span class="o">),</span>
  <span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∃!</span> <span class="n">ab</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">×ˢ</span> <span class="n">B</span><span class="o">,</span> <span class="n">ab.1</span> <span class="bp">*</span> <span class="n">ab.2</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">)</span>

<span class="kd">class</span> <span class="n">unique_products'</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">muls</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B.nonempty</span><span class="o">),</span>
  <span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">unique</span> <span class="o">(</span><span class="n">function.uncurry</span> <span class="n">has_mul.mul</span> <span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">g</span><span class="o">}</span> <span class="bp">∩</span> <span class="n">A</span> <span class="bp">×ˢ</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="n">G</span><span class="o">))))</span>
</code></pre></div>



<a name="296274727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296274727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296274727">(Aug 31 2022 at 08:03)</a>:</h4>
<p>Sorry for the sudden silence: I was talking to a student.</p>
<p>Without trying them out, I would say that the last definition <code>unique_products'</code> may be harder to work with than the other candidates.</p>
<p>Does anyone have any strong opinion on which one should be the definition of <code>unique_products</code>?</p>



<a name="296274880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296274880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296274880">(Aug 31 2022 at 08:05)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> I am happy to use <code>unique_sum</code> for what is called <code>unique_summads</code> above.</p>



<a name="296274948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296274948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296274948">(Aug 31 2022 at 08:05)</a>:</h4>
<p>That would suggest <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum">docs#finset.sum</a>. What about <code>unique_mul</code>/<code>unique_add</code>?</p>



<a name="296275051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296275051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296275051">(Aug 31 2022 at 08:06)</a>:</h4>
<p>Unique products is the established name in the literature, so I would rather keep that one.</p>



<a name="296283016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296283016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296283016">(Aug 31 2022 at 09:00)</a>:</h4>
<p>Can't we use <code>to_additive</code> on classes? Would the name <code>unique_prod</code> be automatically additivized to <code>unique_sum</code>?</p>



<a name="296285387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296285387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296285387">(Aug 31 2022 at 09:16)</a>:</h4>
<p>How about calling them <code>unique_prods</code> and <code>unique_sums</code>?  It is easy enough to get <code>to_additive</code> to learn about <code>prods -&gt; sums</code>, the "multiplicative" name would be closer to the usual convention and <code>unique_sums</code> would probably clash less with <code>finset.sum</code>?</p>



<a name="296292321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296292321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296292321">(Aug 31 2022 at 10:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/unique.20products/near/296283016">said</a>:</p>
<blockquote>
<p>Can't we use <code>to_additive</code> on classes? Would the name <code>unique_prod</code> be automatically additivized to <code>unique_sum</code>?</p>
</blockquote>
<p>From the <code>to_additive</code> doc-module:</p>
<blockquote>
<p>This file defines an attribute <code>to_additive</code> that can be used to<br>
automatically transport theorems and definitions (but not inductive<br>
types and structures) from a multiplicative theory to an additive theory.</p>
</blockquote>
<p>When I use simply to_additive on the class it creates something with the right name, but adds a single declaration to the environment: there is exactly one declaration with the same prefix.</p>
<p>I will define the two classes separately and will bind them with <code>to_additive</code> after the fact.</p>



<a name="296292512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296292512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296292512">(Aug 31 2022 at 10:04)</a>:</h4>
<p>Yes that's how you should do it.</p>



<a name="296305601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296305601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296305601">(Aug 31 2022 at 11:36)</a>:</h4>
<p>Honestly, I am finding </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">unique_products</span> <span class="o">(</span><span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">muls</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B.nonempty</span><span class="o">),</span>
  <span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∃!</span> <span class="n">ab</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">×ˢ</span> <span class="n">B</span><span class="o">,</span> <span class="n">ab.1</span> <span class="bp">*</span> <span class="n">ab.2</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">)</span>
</code></pre></div>
<p>very hard to work with.  I agree that it looks very nice, but it is a nightmare of proof obligations, angle bracket and repeated fields.</p>



<a name="296305681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296305681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296305681">(Aug 31 2022 at 11:37)</a>:</h4>
<p>I am trying to see how workable this definition is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[to_additive]</span>
<span class="kd">def</span> <span class="n">unique_mul'</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">subsingleton</span> <span class="o">{</span> <span class="n">ab</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">ab.1</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∧</span> <span class="n">ab.2</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">ab.1</span> <span class="bp">*</span> <span class="n">ab.2</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">}</span>
</code></pre></div>
<p>(where I still need to think about how to make sure that there actually is a witness when we want one!)</p>



<a name="296307046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296307046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296307046">(Aug 31 2022 at 11:47)</a>:</h4>
<p>Your original version looks best to me.</p>



<a name="296308610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296308610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296308610">(Aug 31 2022 at 11:56)</a>:</h4>
<p>How so? Carrying around these non-empty hypotheses that need to be checked all the time, when the existence isn't really what we are worried about definitely seems onerous to me.</p>



<a name="296310184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296310184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296310184">(Aug 31 2022 at 12:05)</a>:</h4>
<p>Maybe using <a href="https://leanprover-community.github.io/mathlib_docs/find/set.image2">docs#set.image2</a> in the definition would give you a lot of useful structure to start with?</p>



<a name="296310557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296310557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296310557">(Aug 31 2022 at 12:07)</a>:</h4>
<p>I am having difficulties of two kind with the <code>exists ... exists!...</code> definition.  First, <code>g</code> is determined by what comes next, <code>ab</code> but you really need to snake your way around angle brackets and <code>rfl</code>s to get to a stage where you can use this.  I could get used to it, but it seems too much effort for such a simple concept.  Second, if you have <code>unique_mul'</code> as your goal and you use <code>rintro?</code> you obtain a mess of hypotheses that are very hard to parse for me, unless I <code>dsimp</code> them and even after that, it is not clear what to do.  Here is a sample:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">unique_mul_forall</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span><span class="n">a0</span> <span class="n">b0</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">aA</span> <span class="o">:</span> <span class="n">a0</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">bB</span> <span class="o">:</span> <span class="n">b0</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">unique_mul</span> <span class="n">A</span> <span class="n">B</span> <span class="o">(</span><span class="n">a0</span> <span class="bp">*</span> <span class="n">b0</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">a</span> <span class="n">b</span><span class="o">⦄,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a0</span> <span class="bp">*</span> <span class="n">b0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">ᾰ_w_fst</span><span class="o">,</span> <span class="n">ᾰ_w_snd</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">ᾰ_h_left_w</span><span class="o">,</span> <span class="n">ᾰ_h_left_h_left</span><span class="o">,</span> <span class="n">ᾰ_h_left_h_right</span><span class="o">⟩,</span> <span class="n">ᾰ_h_right</span><span class="o">⟩</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ᾰ_1</span> <span class="n">ᾰ_2</span> <span class="n">ᾰ_3</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>leaving as state:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">G</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="n">_inst_1</span><span class="o">:</span> <span class="n">has_mul</span> <span class="n">G</span>
<span class="n">AB</span><span class="o">:</span> <span class="n">finset</span> <span class="n">G</span>
<span class="n">a0b0ab</span><span class="o">:</span> <span class="n">G</span>
<span class="n">ᾰ_1</span><span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">A</span>
<span class="n">ᾰ_2</span><span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">B</span>
<span class="n">ᾰ_3</span><span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a0</span> <span class="bp">*</span> <span class="n">b0</span>
<span class="n">ᾰ_w_fstᾰ_w_snd</span><span class="o">:</span> <span class="n">G</span>
<span class="n">ᾰ_h_right</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span><span class="o">),</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">ab</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">×ˢ</span> <span class="n">B</span><span class="o">),</span> <span class="n">ab.fst</span> <span class="bp">*</span> <span class="n">ab.snd</span> <span class="bp">=</span> <span class="n">a0</span> <span class="bp">*</span> <span class="n">b0</span><span class="o">)</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="o">(</span><span class="n">ᾰ_w_fst</span><span class="o">,</span> <span class="n">ᾰ_w_snd</span><span class="o">)</span>
<span class="n">ᾰ_h_left_w</span><span class="o">:</span> <span class="o">(</span><span class="n">ᾰ_w_fst</span><span class="o">,</span> <span class="n">ᾰ_w_snd</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">×ˢ</span> <span class="n">B</span>
<span class="n">ᾰ_h_left_h_left</span><span class="o">:</span> <span class="o">(</span><span class="n">ᾰ_w_fst</span><span class="o">,</span> <span class="n">ᾰ_w_snd</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span> <span class="bp">*</span> <span class="o">(</span><span class="n">ᾰ_w_fst</span><span class="o">,</span> <span class="n">ᾰ_w_snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span> <span class="bp">=</span> <span class="n">a0</span> <span class="bp">*</span> <span class="n">b0</span>
<span class="n">ᾰ_h_left_h_right</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="o">(</span><span class="n">ᾰ_w_fst</span><span class="o">,</span> <span class="n">ᾰ_w_snd</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">×ˢ</span> <span class="n">B</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="n">ᾰ_w_fst</span><span class="o">,</span> <span class="n">ᾰ_w_snd</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">×ˢ</span> <span class="n">B</span><span class="o">),</span> <span class="o">(</span><span class="n">ᾰ_w_fst</span><span class="o">,</span> <span class="n">ᾰ_w_snd</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span> <span class="bp">*</span> <span class="o">(</span><span class="n">ᾰ_w_fst</span><span class="o">,</span> <span class="n">ᾰ_w_snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span> <span class="bp">=</span> <span class="n">a0</span> <span class="bp">*</span> <span class="n">b0</span><span class="o">)</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">ᾰ_h_left_w</span>
<span class="bp">⊢</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b0</span>
</code></pre></div>



<a name="296310703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296310703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296310703">(Aug 31 2022 at 12:08)</a>:</h4>
<p>(the <code>rintro</code> is the uncleaned output of <code>rintro?</code>, but, ignoring the weird variable names, the end result is a mess anyway)</p>



<a name="296311100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296311100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296311100">(Aug 31 2022 at 12:11)</a>:</h4>
<p>The initial definition that I posted may not be as snappy, but does not expand to something unwieldy if you are not careful to tame it.</p>
<p>The non-empty assertions are fairly common to have in context, at least for my use case.  Also, note that </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">unique_mul</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">a0</span> <span class="n">b0</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">⦃</span><span class="n">a</span> <span class="n">b</span><span class="o">⦄,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a0</span> <span class="bp">*</span> <span class="n">b0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b0</span>
</code></pre></div>
<p>does not have a proof obligation: you start with elements on <code>G</code> but then the proofs that you need to provide are harmless and are really dealing with the substance of <code>unique_mul</code>.</p>



<a name="296311230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296311230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296311230">(Aug 31 2022 at 12:12)</a>:</h4>
<p>As always, this is my impression and it is not set in stone!  I am simply reporting that for me, the <code>exists...exists!...</code> definition is hard to use.</p>



<a name="296312021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296312021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296312021">(Aug 31 2022 at 12:18)</a>:</h4>
<p>Trying to find slogans why I prefer the other definition:</p>
<ul>
<li>it uses more universal quantifiers than existential ones;</li>
<li>it works with compositions of arrows, instead of products.</li>
</ul>
<p>In my experience, both of the above provide a smoother user experience.</p>



<a name="296312505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296312505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296312505">(Aug 31 2022 at 12:20)</a>:</h4>
<p>In any case, I am also aware that the only thing that is important is that whatever definition is used, there is also a lemma to states that it is equivalent to the one that I like!  Thus, if everyone prefers the <code>exists...exists!...</code> one, then all this means is that I will roll my sleeves up, prove that it is equivalent to the one that I want and then never look at the implemented definition again!  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="296318903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296318903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296318903">(Aug 31 2022 at 12:57)</a>:</h4>
<p>I opened a PR with the initial definition.  I can certainly change it, but mostly wanted to have <code>olean</code>s, since modifying <code>to_additive</code> is never easy on the CPU of my computer!</p>



<a name="296318915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296318915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296318915">(Aug 31 2022 at 12:58)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/16329">#16329</a></p>



<a name="296331925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296331925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296331925">(Aug 31 2022 at 14:06)</a>:</h4>
<p>I'm struggling to see how <code>unique_summands</code> holds for <code>nat</code>; if <code>A=B={0,1}</code> and <code>g = 1</code> then surely there is no unique choice <code>ab</code>?</p>



<a name="296332209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296332209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296332209">(Aug 31 2022 at 14:08)</a>:</h4>
<p>The <code>g</code> is bound by an existential quantifier, not a universal one.</p>



<a name="296332268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296332268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296332268">(Aug 31 2022 at 14:08)</a>:</h4>
<p>You usually choose the smallest or largest elements and take it from there.</p>



<a name="296332404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296332404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296332404">(Aug 31 2022 at 14:09)</a>:</h4>
<p>In your example, <code>g=0</code> or <code>g=2</code> work, but <code>g=1</code> does not.</p>



<a name="296332487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296332487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296332487">(Aug 31 2022 at 14:09)</a>:</h4>
<p>But since we are asking for the existence of a good <code>g</code>, all is ok!</p>



<a name="296332606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296332606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296332606">(Aug 31 2022 at 14:10)</a>:</h4>
<p>Yaël also thought that it was universal quantification earlier in the thread.</p>



<a name="296334014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296334014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296334014">(Aug 31 2022 at 14:16)</a>:</h4>
<p>In case it helps, this is where <code>unique_sums</code> is heading.  When you multiply two elements of an <code>add_monoid_algebra</code>, the "generic" monomial in the resulting product is a sum of several contributions.  <code>unique_sums</code> isolates, if they exist, the monomials that receive a unique contribution.  These monomials are unlikely to be "in the middle", they tend to be "on the boundary".  This explains why, when you have an order, you end up seeing either <code>min</code>s or <code>max</code>s.</p>
<p>I hope that this helps with the intuition!</p>



<a name="296335001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296335001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296335001">(Aug 31 2022 at 14:21)</a>:</h4>
<p>Curse android and it not showing ∃ <del>or ∀</del> in your example and leaving me to guess!</p>



<a name="296401458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296401458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296401458">(Aug 31 2022 at 16:27)</a>:</h4>
<p>I pushed two implications relating the definition in the PR with two of the definitions in this thread.</p>
<p>I have not yet thought of what is needed to make them iffs, since I was not yet ready to think about such hard concepts as whether a finset is empty or not.</p>
<p>Also, <code>olean</code>s with the <code>to_additive</code> change are available, I simply stopped CI before it could finish linting/testing, in case you want to experiment yourself.</p>



<a name="296568017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296568017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296568017">(Sep 01 2022 at 11:41)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/16329">#16329</a> now has a more extensive doc-module and the lemmas that I wanted in (and some more).</p>
<p>Does anyone want more lemmas added to this file?  Are there more comments on the definition?  I proved the equivalence of Junyan Xu's version and the one that I initially had, so I do not mind swapping the definitions.  However, I still find it easier to work with the current one than with the other.</p>



<a name="296570035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296570035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296570035">(Sep 01 2022 at 11:55)</a>:</h4>
<p>I wonder whether we want that to go under <code>combinatorics.additive</code>. <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span>, thoughts?</p>



<a name="296572637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296572637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296572637">(Sep 01 2022 at 12:12)</a>:</h4>
<p>Ah, I am glad that you brought the issue of where it goes!  I was thinking maybe in <code>finset</code>.</p>



<a name="296573105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296573105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296573105">(Sep 01 2022 at 12:15)</a>:</h4>
<p>Sidon sets are certainly additive combinatorics, but it would say something for all elements, not for a single one</p>



<a name="296573166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296573166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296573166">(Sep 01 2022 at 12:16)</a>:</h4>
<p>So far, everything that's about pointwise operations of finsets is either in <code>data.finset.pointwise</code> or under <code>combinatorics.additive</code>. But I don't know whether this qualifies as additive combinatorics or not.</p>



<a name="296573491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296573491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296573491">(Sep 01 2022 at 12:17)</a>:</h4>
<p>While I realize that combinatorics does not only deal with finite sets, <code>unique_prods</code> should fail on any finite set with at least two elements and an operation.  This makes me a little skeptical about putting it in combinatorics: I am not sure that I would ever look for it there, whereas I would want to use this for zero-divisors in add_monoid_algebras.</p>



<a name="296573741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296573741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296573741">(Sep 01 2022 at 12:19)</a>:</h4>
<p>I think that <code>finset.something</code> is a better fit: I would look there if I were thinking about support of elements of <code>add_monoid_algebra</code>s and I guess that combinatorics stuff can easily be found in <code>finset</code>, right?</p>



<a name="296573752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/unique%20products/near/296573752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/unique.20products.html#296573752">(Sep 01 2022 at 12:19)</a>:</h4>
<p>Given that combinatorics is often concerned about finite things embedded into infinite ones, that wouldn't bother me much.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
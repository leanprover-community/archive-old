---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html">bottom type (⊥)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="309285224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309285224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Osazuwa Ness <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309285224">(Nov 12 2022 at 02:39)</a>:</h4>
<p>Is there a bottom type ⊥ in Lean4?</p>
<p>For example, in Haskell you might write:<br>
<code>
f:: Bool -&gt; Bool
f = undefined
</code><br>
and that works because "undefined" evaluates to bottom, which is a member of Bool and any type.<br>
But in lean I tried<br>
<code>def f (α : Bool) : Bool := none</code><br>
and got a type mismatch.  So I guess "none" isn't it.</p>



<a name="309285289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309285289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309285289">(Nov 12 2022 at 02:40)</a>:</h4>
<p>Do you mean <code>False</code>?</p>



<a name="309285303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309285303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309285303">(Nov 12 2022 at 02:41)</a>:</h4>
<p>Or maybe you're looking for <code>⊥</code> (<a href="https://leanprover-community.github.io/mathlib_docs/find/has_bot">docs#has_bot</a> in mathlib)</p>



<a name="309285799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309285799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309285799">(Nov 12 2022 at 02:50)</a>:</h4>
<p>No, there is no bottom value in the haskell sense. Indeed if there was you could use it to prove any proposition and hence trivialize the logical content of the theory</p>



<a name="309285890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309285890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309285890">(Nov 12 2022 at 02:52)</a>:</h4>
<p>(nit: <code>undefined</code> is a bottom <em>value</em> inhabiting every type, not a bottom <em>type</em>. As Yael says, a bottom type is one with no elements and lean has <code>False</code> for the bottom type in the universe of propositions and <code>Empty</code> for the bottom type in <code>Type</code>.)</p>



<a name="309286245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309286245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Osazuwa Ness <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309286245">(Nov 12 2022 at 02:59)</a>:</h4>
<p>So Lean must then have some mechanism prohibiting non-terminating expressions?  What is that? Sorry, I think I read about this somewhere but can't recall where, I'm coming back to learning Lean a brief pause.</p>



<a name="309286352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309286352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309286352">(Nov 12 2022 at 03:01)</a>:</h4>
<p>All recursive functions have to decrease along some well founded metric</p>



<a name="309286422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309286422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309286422">(Nov 12 2022 at 03:02)</a>:</h4>
<p>in many cases lean can infer an appropriate relation on its own but if it fails you can use the <code>termination_by</code> clause to supply your own</p>



<a name="309286465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309286465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309286465">(Nov 12 2022 at 03:03)</a>:</h4>
<p>in particular <code>def foo : p := foo</code> is not accepted</p>



<a name="309287121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309287121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calvin Lee <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309287121">(Nov 12 2022 at 03:16)</a>:</h4>
<p>err<br>
lean has <code>sorry</code> which functions almost exactly the same as <code>undefined</code> in haskell. It is an axiom which can inhabit any value, and you use it when you can't prove something <em>yet</em>.<br>
but it should never be used in proofs or code that exists (and in fact you can figure this out by checking if the definition depends on <code>sorryAx</code>)</p>



<a name="309287185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309287185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calvin Lee <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309287185">(Nov 12 2022 at 03:16)</a>:</h4>
<p>I suppose <code>sorry</code> is an answer to any thread in this channel<br>
but I think it deserves special mention as a potential "bottom value"</p>



<a name="309287466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309287466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309287466">(Nov 12 2022 at 03:22)</a>:</h4>
<p>that's true, but <code>sorry</code> has special handling and lean will give you grief if you use it</p>



<a name="309287491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bottom%20type%20%28%E2%8A%A5%29/near/309287491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bottom.20type.20(.E2.8A.A5).html#309287491">(Nov 12 2022 at 03:22)</a>:</h4>
<p>you can also make your own axioms and use them to prove false things if you want. Lean won't even complain in that case</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
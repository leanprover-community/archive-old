---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html">finset.some</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="272241442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272241442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272241442">(Feb 17 2022 at 10:42)</a>:</h4>
<p>I'm trying to show that the type of atoms of <code>finset α</code> is equivalent to <code>α</code>. This is true because the atoms are precisely the singletons. To make this work, I need to extract an element out of a nonempty <code>finset</code>. Can this be made computable? Do we have it? <code>finset.some</code> doesn't exist.</p>



<a name="272241662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272241662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272241662">(Feb 17 2022 at 10:44)</a>:</h4>
<p>I expect we cannot make this computable as long as <code>finset.nonempty</code> is a <code>Prop</code>.</p>



<a name="272241696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272241696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272241696">(Feb 17 2022 at 10:44)</a>:</h4>
<p>Why not? It should just be a <code>quotient.lift</code> out of <code>subtype.val</code> right?</p>



<a name="272241762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272241762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272241762">(Feb 17 2022 at 10:45)</a>:</h4>
<p>That's what I think too. You can do induction on the finset, which is the difference with <code>set</code>.</p>



<a name="272241884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272241884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272241884">(Feb 17 2022 at 10:47)</a>:</h4>
<p>Wait no, I thought you wanted to extract an element from the atoms. Yeah, this is going to be noncomputable.</p>



<a name="272241931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272241931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272241931">(Feb 17 2022 at 10:47)</a>:</h4>
<p>I do,  but I thought this could be computable more generally.</p>



<a name="272241947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272241947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272241947">(Feb 17 2022 at 10:47)</a>:</h4>
<p><code>(finset.univ : finset (fin 2)).filter (λ i, (i = 0 ∧ ¬ riemann_hypothesis) ∨ (i = 1 ∧ riemann_hypothesis))</code>.</p>



<a name="272242078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272242078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272242078">(Feb 17 2022 at 10:49)</a>:</h4>
<p>Eheh, I had in mind finsets that were themselves made computably.</p>



<a name="272242090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272242090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272242090">(Feb 17 2022 at 10:49)</a>:</h4>
<p>(Depending on the definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.nonempty">docs#finset.nonempty</a> this is a full Brouwer-style counterexample showing it is indeed noncomputable for finsets with &gt; 1 elements.)</p>



<a name="272242242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272242242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272242242">(Feb 17 2022 at 10:50)</a>:</h4>
<p>So how do I get the element out of an atom, precisely? Will that also work for <code>set</code>?</p>



<a name="272242420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272242420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272242420">(Feb 17 2022 at 10:52)</a>:</h4>
<p>You can do it if you make "<code>s</code> is an atom" contain data (like <code>{ x // x ∈ s}</code>). <br>
If it is a proposition, we can get a similar counterexample to Anne's, by taking the set of minimal elements of Anne's set (which will always be a singleton) (EDIT: oh wait, Anne's set is already a singleton)</p>



<a name="272242488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272242488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272242488">(Feb 17 2022 at 10:53)</a>:</h4>
<p>With <a href="https://leanprover-community.github.io/mathlib_docs/find/quot.lift_on">docs#quot.lift_on</a> it should be possible right? Since taking the head of an list of elements of the underlying multiset will always return the same element.</p>



<a name="272242609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272242609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272242609">(Feb 17 2022 at 10:55)</a>:</h4>
<p>I expect you will need the decidability of <code>(∈ s)</code> at some point...</p>



<a name="272242643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272242643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272242643">(Feb 17 2022 at 10:55)</a>:</h4>
<p>Showing there exists a finset containing all elements of <code>{ x | (x = 0 ∧ ¬ RH) ∨ (x = 1 ∧ RH) }</code> is noncomputable. But given such a finset you can extract an element without problems.</p>



<a name="272242711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272242711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272242711">(Feb 17 2022 at 10:56)</a>:</h4>
<p>ah, I see what you mean... Yeah, I think you're right.</p>



<a name="272242720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272242720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272242720">(Feb 17 2022 at 10:56)</a>:</h4>
<p>In other words, the decidability lives in <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype.fintype">docs#subtype.fintype</a>.</p>



<a name="272242792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272242792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272242792">(Feb 17 2022 at 10:57)</a>:</h4>
<p>Unfortunately I don't have the luxury of changing the meaning of an atom. I have to work with <code>{a // is_atom a}</code> because I'm proving <a href="https://en.wikipedia.org/wiki/Birkhoff's_representation_theorem">Birkhoff's representation theorem</a> in the form of <code>FinBoolAlgᵒᵖ ≌ Fintype</code> and <code>atoms</code> is one of the functors. <code>atoms (finset α) ≃ α</code> is the unit (or counit? I never know).</p>



<a name="272242992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272242992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272242992">(Feb 17 2022 at 10:58)</a>:</h4>
<p>Basically to do this computably you have to show <code>∀ (xs ys : list α), is_atom (xs : finset α) → is_atom (ys : finset α) → head xs = head ys → xs = ys</code>, then you should be able to define <code>head</code> on multisets that are atoms via <a href="https://leanprover-community.github.io/mathlib_docs/find/quot.lift">docs#quot.lift</a>, then you restrict this to finsets (which are defined as a subtype of multisets).</p>



<a name="272288420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272288420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272288420">(Feb 17 2022 at 16:55)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Do you have a proof that atoms have cardinality 1? If so, here's a sloppily-proved definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">multiset.from_atom</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m.card</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">quot.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">multiset.card</span> <span class="o">(</span><span class="n">coe</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span>
  <span class="k">match</span> <span class="n">l</span><span class="o">,</span> <span class="n">h</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">h</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">_</span><span class="o">),</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">x</span>
  <span class="kd">end</span><span class="o">)</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">a</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">list.nil_perm.mp</span> <span class="n">hab</span><span class="o">,</span> <span class="n">injection</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">list.perm_nil.mp</span> <span class="n">hab</span><span class="o">,</span> <span class="n">injection</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">a_hd</span> <span class="o">::</span> <span class="n">a_tl</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b_hd</span> <span class="o">::</span> <span class="n">b_tl</span> <span class="o">:=</span> <span class="n">multiset.coe_eq_coe.mpr</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">simp</span><span class="bp">!</span> <span class="o">[</span><span class="n">this</span><span class="o">],</span>
  <span class="n">ext</span> <span class="n">h'</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">multiset.card</span> <span class="o">(</span><span class="n">b_hd</span> <span class="o">::</span> <span class="n">b_tl</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="n">at</span> <span class="n">h'</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h''</span> <span class="o">:=</span> <span class="n">h'</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">this</span><span class="o">]</span> <span class="n">at</span> <span class="n">h''</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">list.length_eq_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">h'</span> <span class="n">h''</span><span class="o">,</span>
  <span class="n">subst_vars</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">subst_vars</span><span class="o">,</span>
<span class="kd">end</span> <span class="n">m</span> <span class="n">h</span>

<span class="kd">def</span> <span class="n">finset.from_atom</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s.card</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">s.val.from_atom</span> <span class="n">h</span>
</code></pre></div>



<a name="272288589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272288589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272288589">(Feb 17 2022 at 16:57)</a>:</h4>
<p>As far as I know, there's no way to generically extract an element from an arbitrary nonempty finset: if there is more than one element, which one do you choose?</p>
<p>But if there's precisely one element, then you can dig into the underlying list and extract it computably.</p>



<a name="272288659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272288659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272288659">(Feb 17 2022 at 16:57)</a>:</h4>
<p>I have a draft at <a href="https://github.com/leanprover-community/mathlib/pull/10865">#10865</a></p>



<a name="272288994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272288994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272288994">(Feb 17 2022 at 16:59)</a>:</h4>
<p>I see you have <code>is_atom_iff</code>, so that plugs into <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_eq_one">docs#finset.card_eq_one</a></p>



<a name="272291422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272291422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272291422">(Feb 17 2022 at 17:15)</a>:</h4>
<p>You can also do <code>finset.from_atom</code> more directly by using <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.choose">docs#finset.choose</a></p>



<a name="272309558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.some/near/272309558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esome.html#272309558">(Feb 17 2022 at 19:20)</a>:</h4>
<p>Or you define an arbitrary linear order on the underlying type because it's finite (as seen as the subtype of things in the finset), and sort on those and pick the first one</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html">Correct setting for positive shifts of intervals</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="229519565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229519565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229519565">(Mar 09 2021 at 17:41)</a>:</h4>
<p>There are many trivial lemmas in <code>data.set.intervals.image_preimage</code> about images of intervals under various functions, in particular - adding a constant. However, they all require at least a group structure on the linear order, so none imply the obvious fact that adding a constant maps intervals to intervals in <code>nat</code>. I've tried to look through the structures in mathlib that give the right setting for this fact, but they all seem either too weak or too strong.  I'm trying to avoid having to deal with <code>nat</code> as a special case. </p>
<p>Specifically, I want lemmas like : </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">Ioc_add_bij</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">):</span>
<span class="n">set.bij_on</span> <span class="o">(</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">Ioc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">Ioc</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="n">d</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>I believe what is required is an <code>add_comm_monoid</code>, with an ordering such that for all <code>0 \le a \le b</code>, there exists <code>c</code> with <code>a + c = b</code>. Is there any instance or combination of instances that gives these properties?</p>



<a name="229519766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229519766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229519766">(Mar 09 2021 at 17:42)</a>:</h4>
<p>Can you link to the statement you'd like to use that seems too restrictive to apply to <code>nat</code>?</p>



<a name="229519985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229519985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229519985">(Mar 09 2021 at 17:44)</a>:</h4>
<p>So <a href="https://leanprover-community.github.io/mathlib_docs/find/set.image_add_const_Ico">docs#set.image_add_const_Ico</a>?</p>



<a name="229520073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229520073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229520073">(Mar 09 2021 at 17:44)</a>:</h4>
<p>Yes, exactly : <a href="https://leanprover-community.github.io/mathlib_docs/data/set/intervals/image_preimage.html#images-under-codex--a--xcode">https://leanprover-community.github.io/mathlib_docs/data/set/intervals/image_preimage.html#images-under-codex--a--xcode</a></p>



<a name="229520167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229520167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229520167">(Mar 09 2021 at 17:45)</a>:</h4>
<p>(What a beautiful url anchor, thanks doc-gen)</p>



<a name="229520306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229520306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229520306">(Mar 09 2021 at 17:45)</a>:</h4>
<p>(For what it's worth, I've written proofs for my example lemma and various related facts; it just feels a bit weird that I would have to do so).</p>



<a name="229520383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229520383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229520383">(Mar 09 2021 at 17:46)</a>:</h4>
<p>I wonder if some of the lemmas in that file can be reduced to <a href="https://leanprover-community.github.io/mathlib_docs/find/ordered_add_comm_monoid">docs#ordered_add_comm_monoid</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/ordered_cancel_add_comm_monoid">docs#ordered_cancel_add_comm_monoid</a></p>



<a name="229520691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229520691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229520691">(Mar 09 2021 at 17:47)</a>:</h4>
<p>Yeah, I'm not sure. At least if you want bijections, I think that you do need a 'partial subtraction' of the type I described, and I don't know if that follows from a more general cancellative property</p>



<a name="229523363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229523363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229523363">(Mar 09 2021 at 18:01)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/canonically_linear_ordered_add_monoid">docs#canonically_linear_ordered_add_monoid</a> is sufficient to prove <code>image_const_add_Ici</code> for nat:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">image_const_add_Ici</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">canonically_linear_ordered_add_monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">x</span><span class="o">)</span> <span class="bp">''</span> <span class="n">Ici</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">Ici</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_image</span><span class="o">,</span> <span class="n">mem_Ici</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">hc'</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">add_le_add_left</span> <span class="n">hc</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_eq</span> <span class="n">hc'</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">le_iff_exists_add.mp</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">,</span> <span class="n">self_le_add_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">add_assoc</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="229523472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229523472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229523472">(Mar 09 2021 at 18:02)</a>:</h4>
<p>I don't think there's any deep reason why <code>nat</code> (or more general) versions of these lemmas are missing. I suspect that <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span>  just didn't need them in that generality when he made the PR. They'd certainly be welcome if someone were to PR them!</p>



<a name="229523900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229523900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229523900">(Mar 09 2021 at 18:04)</a>:</h4>
<p>Eric -that's true, but that setting doesn't apply to <code>int</code>, which fails this axiom</p>
<p><code>le_iff_exists_add : ∀ (a b : α), a ≤ b ↔ ∃ (c_1 : α), b = a + c_1</code>.</p>
<p>A one-sided version of that axiom, with only the forwards implication, is what's needed to apply to both <code>nat</code> and (for example )<code>int</code>.</p>



<a name="229523972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229523972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229523972">(Mar 09 2021 at 18:05)</a>:</h4>
<p>Right, although the existing lemmas covers <code>int</code> right?</p>



<a name="229525958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229525958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229525958">(Mar 09 2021 at 18:16)</a>:</h4>
<p>Indeed, I added lemmas in the generality I needed. Feel free to generalize them and/or add <code>'</code> versions that work for canonically ordered (add) comm monoids.</p>



<a name="229526473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229526473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229526473">(Mar 09 2021 at 18:18)</a>:</h4>
<blockquote>
<p>A one-sided version of that axiom, with only the forwards implication, is what's needed to apply to both nat and (for example )int.</p>
</blockquote>
<p>I'd be loosely in favor of an ad-hoc typeclass in that file to avoid the need for separate primed and unprimed versions, containing the axiom you suggest and instantiated for <code>ordered_add_comm_monoid</code> and <code>canonically_linear_ordered_add_monoid</code></p>



<a name="229570676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229570676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229570676">(Mar 09 2021 at 22:50)</a>:</h4>
<p>(deleted)</p>



<a name="229609050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229609050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229609050">(Mar 10 2021 at 06:20)</a>:</h4>
<p>To get a bijection version (addition translates an interval bijectively) it is even more awkward. A <code>[canonically_linear_ordered_add_monoid]</code> instance is not enough without some sort of cancellation law (otherwise it fails on singleton intervals). </p>
<p>Here is some code that gives the required lemma, proved using a bespoke typecless with (I think) the minimal required assumptions, and instances for both <code>nat</code> and <code>ordered_add_comm_group</code>. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">ordered_cancel_add_comm_exists_sub_monoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">ordered_cancel_add_comm_monoid</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_add_of_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">ordered_add_comm_group.ordered_cancel_add_comm_exists_sub_monoid</span>
<span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)[</span><span class="n">ordered_add_comm_group</span> <span class="n">α</span><span class="o">]:</span>
  <span class="n">ordered_cancel_add_comm_exists_sub_monoid</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">exists_add_of_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">add_sub_cancel'_right</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩}</span>

<span class="kd">instance</span> <span class="n">nat.ordered_cancel_add_comm_exists_sub_monoid</span> <span class="o">:</span>
  <span class="n">ordered_cancel_add_comm_exists_sub_monoid</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">exists_add_of_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">nat.add_sub_of_le</span> <span class="n">hab</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩}</span>

<span class="kn">open</span> <span class="n">set</span> <span class="n">ordered_cancel_add_comm_exists_sub_monoid</span>

<span class="kd">lemma</span> <span class="n">Ioo_add_bij</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}[</span><span class="n">ordered_cancel_add_comm_exists_sub_monoid</span> <span class="n">α</span><span class="o">](</span><span class="n">a</span> <span class="n">b</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">):</span>
  <span class="n">bij_on</span> <span class="o">(</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">Icc</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mem_Icc</span><span class="o">]</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">add_le_add_right</span> <span class="n">h.1</span> <span class="n">_</span><span class="o">,</span> <span class="n">add_le_add_right</span> <span class="n">h.2</span> <span class="n">_</span><span class="o">⟩},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">add_right_cancel</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">mem_image</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">mem_Icc</span> <span class="n">at</span> <span class="n">h</span> <span class="bp">⊢</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_add_of_le</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">add_right_comm</span><span class="o">,</span> <span class="n">add_le_add_iff_right</span><span class="o">]</span> <span class="n">at</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span> <span class="n">a</span><span class="bp">+</span><span class="n">c</span><span class="o">,</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">⟩,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">add_right_comm</span><span class="o">⟩,</span>
<span class="kd">end</span>
</code></pre></div>
<p>This would also work for <code>nnreal</code>, but I don't know a good typeclass that encapsulates both <code>nnreal</code> and <code>nat</code>, because <code>canonically_linear_ordered_add_monoid</code> is too weak. Thoughts on this would be welcome.</p>



<a name="229610744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229610744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229610744">(Mar 10 2021 at 06:43)</a>:</h4>
<p>Can you give me an example of a canonically linear ordered add monoid for which a theorem you want to be true fails?</p>
<p>Johan asked a question about nnreal a few months ago which, after Mario and I discussed it here (I'm sorry I'm on mobile and the link is too fiddly to find) and we boiled the question down to "when is a topological monoid a submonoid of a topological group?". There is the usual algebraic obstruction -- the monoid needs to be cancellative, or else it doesn't embed into any group at all. However there is also a topological obstruction, as observed by Reid's example of nnreal with following topology: every subset which is open with the usual order topology is open, and also every subset of [0,1] is open. This is a topological monoid, but addition of a fixed element is not an open map in contrast to what happens in a topological group. Conversely adding this condition looked like it was precisely the right one to make the group localisation inherit a topological group structure.</p>
<p>What is the counterexample of a canonically ordered monoid which you have in mind which stops your lemmas being true?</p>



<a name="229616913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229616913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229616913">(Mar 10 2021 at 08:00)</a>:</h4>
<p>I am not really sure if this would work, but I think that this might be a great addition to the <code>counterexamples</code> branch, if it works!  (This is somewhat shameless self-promotion of my branch <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>)</p>
<p>In the branch, there is an example of a <code>canonically_ordered_comm_semiring</code> in which multiplication by <code>2</code> is not injective.  The example is obtained from <code>ℕ × zmod 2</code>, with the ring structure given by the usual componentwise addition and multiplication.  The ordering is defined by declaring <code>(a,s) ≤ (b,t)</code> if and only if</p>
<ul>
<li><code>a &lt; b</code>, or</li>
<li><code>(a,s) = (b,t)</code>.</li>
</ul>
<p>Thus, "far apart", the order ignores the <code>zmod 2</code> components, but prevents <code>(a,0)</code> and <code>(a,1)</code> from being comparable. [This is actually formalized.]</p>
<p>It seems to me that, if you remove from the ring the "initial segment" of elements of the form <code>(a,1)</code>, for <code>0 ≤ a ≤ 2</code>you still have all the properties above and moreover, the interval <code>[0, 2]</code> now has fewer elements than the interval <code>[2, 4]</code>, since in the initial one, you are missing out on all the interesting <code>zmod 2</code> elements.<br>
[Note: there is a formalization that if you remove just <code>(0,1)</code>, you still get a <code>canonically_ordered_comm_semiring</code>, but I had not thought about removing more elements.]</p>
<p>I hope that this makes sense!</p>



<a name="229617627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229617627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229617627">(Mar 10 2021 at 08:04)</a>:</h4>
<p>Also, the <code>cancellation</code> that you want is on addition, right?  This should hold for the example above, since it is a subsemiring of the <code>comm_ring</code> <code>ℤ × zmod 2</code>.</p>



<a name="229618193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229618193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229618193">(Mar 10 2021 at 08:10)</a>:</h4>
<p>Ah, I see an issue with my approach: the identity of the semiring <code>ℕ × zmod 2</code> is <code>(1,1)</code>, so you cannot simply remove it.  However, it might be possible to tweak this into an example showing that without your axiom, intervals are not "homogeneous".</p>



<a name="229657369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229657369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229657369">(Mar 10 2021 at 13:28)</a>:</h4>
<p>Ah, it looks like canonically ordered monoids have cancellation after all - I was doing something wrong earlier and the instance wasn't firing. This makes me happier. </p>
<p>Potentially this, and some other small things related to intervals, could make my first PR. Can anyone suggest a good name for this typeclass? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- an add_comm_monoid with one-sided 'subtraction' in the sense that if a ≤ b,</span>
<span class="sd">there is some c for which a + c = b -/</span>
<span class="kd">class</span> <span class="n">ordered_cancel_add_exists_add_monoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">ordered_cancel_add_comm_monoid</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_add_of_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">ordered_add_comm_group.ordered_cancel_add_exists_add_monoid</span>
<span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)[</span><span class="n">ordered_add_comm_group</span> <span class="n">α</span><span class="o">]:</span>
  <span class="n">ordered_cancel_add_exists_add_monoid</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">exists_add_of_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">add_sub_cancel'_right</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩}</span>

<span class="kd">instance</span> <span class="n">canonically_ordered_comm_monoid.ordered_cancel_add_exists_add_monoid</span>
<span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)[</span><span class="n">canonically_ordered_add_monoid</span> <span class="n">α</span><span class="o">]:</span>
  <span class="n">ordered_cancel_add_exists_add_monoid</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">exists_add_of_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span><span class="o">,</span> <span class="n">le_iff_exists_add.mp</span> <span class="n">hab</span><span class="o">}</span>


<span class="kn">open</span> <span class="n">set</span> <span class="n">ordered_cancel_add_exists_add_monoid</span>

<span class="kd">lemma</span> <span class="n">Icc_add_bij</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}[</span><span class="n">ordered_cancel_add_exists_add_monoid</span> <span class="n">α</span><span class="o">](</span><span class="n">a</span> <span class="n">b</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">):</span>
  <span class="n">bij_on</span> <span class="o">(</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mem_Icc</span><span class="o">]</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">add_le_add_right</span> <span class="n">h.1</span> <span class="n">_</span><span class="o">,</span> <span class="n">add_le_add_right</span> <span class="n">h.2</span> <span class="n">_</span><span class="o">⟩},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">add_right_cancel</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">mem_image</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">mem_Icc</span> <span class="n">at</span> <span class="n">h</span> <span class="bp">⊢</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_add_of_le</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">add_right_comm</span><span class="o">,</span> <span class="n">add_le_add_iff_right</span><span class="o">]</span> <span class="n">at</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span> <span class="n">a</span><span class="bp">+</span><span class="n">c</span><span class="o">,</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">⟩,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">add_right_comm</span><span class="o">⟩,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="229705174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229705174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229705174">(Mar 10 2021 at 17:15)</a>:</h4>
<p>I think <code>cancel</code> should not appear in the name, since in <code>cancel_monoid</code> the statement like <code>b = a + c</code> appears in the hypothesis rather than the goal.  Maybe <code>ordered_has_sub_add_monoid</code>?</p>
<p>Anyway, since these gadgets are remarkably hard to name, I suggest you open the PR and the discussion can continue there! :)</p>



<a name="229717836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229717836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229717836">(Mar 10 2021 at 18:31)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  the plot thickens! There was a small but important typo in my code just above, where I forgot to change an <code>ℕ</code> back into an <code>α</code>. Changing it into an <code>α</code> breaks the code, because canonically ordered additive monoids (even with a linear order) aren't cancellative. </p>
<p>In fact, re Kevin's question, there is a nice example to show this - take the usual ordering on <code>nat</code> with the monoid where addition is (the usual) <code>max</code>. This is a canonical linear ordered monoid (it satisfies all those axioms; in particular <code>a \le b</code> iff there is some <code>c</code> with <code>max a c = b</code>) but it isn't cancellative, and it is also easy to see that adding a constant maps intervals to intervals, but not bijectively. </p>
<p>So it really seems that <code>ordered_cancel_add_comm_monoid</code> together with <code>(exists_add_of_le : ∀ (a b : α), a ≤ b → ∃ (c : α), b = a + c)</code> is the right set of assumptions; this happens to work for both <code>nat</code> and <code>nnreal</code>, but the only existing general class that obviously has an instance for this is <code>ordered_add_comm_group</code>. Maybe the right abstraction is just that this should hold for either an ordered add_comm group, or the submonoid of nonnegative elements of such a group. If this is the answer, it feels unlikely to be worth formalizing.</p>



<a name="229718425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229718425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229718425">(Mar 10 2021 at 18:35)</a>:</h4>
<p>Well, there is also:<br>
<a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.le_iff_exists_add">docs#multiset.le_iff_exists_add</a> <br>
<a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal.le_iff_exists_add">docs#cardinal.le_iff_exists_add</a> :)</p>



<a name="229718548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229718548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229718548">(Mar 10 2021 at 18:35)</a>:</h4>
<p>good point!</p>



<a name="229718654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229718654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229718654">(Mar 10 2021 at 18:36)</a>:</h4>
<p>also set union</p>



<a name="229718713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229718713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229718713">(Mar 10 2021 at 18:36)</a>:</h4>
<p>(deleted)</p>



<a name="229718758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229718758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229718758">(Mar 10 2021 at 18:37)</a>:</h4>
<p>I'd argue (perhaps controversially) that if the same lemma statement appears ≥3 times, it's worthy of a typeclass</p>



<a name="229718805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229718805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229718805">(Mar 10 2021 at 18:37)</a>:</h4>
<p>That or one of the lemmas it uses is</p>



<a name="229719042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229719042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229719042">(Mar 10 2021 at 18:38)</a>:</h4>
<p>So would the typeclass correspond to  'the nonnegative elements of some <code>ordered_add_comm_group</code>' and have instances from <code>nat</code> and <code>nnreal</code>?</p>



<a name="229719439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229719439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229719439">(Mar 10 2021 at 18:41)</a>:</h4>
<p>I was thinking you might just be able to get away with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_exists_add_of_le</span> <span class="o">[</span><span class="n">ordered_cancel_add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_add_of_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>



<a name="229719593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229719593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229719593">(Mar 10 2021 at 18:42)</a>:</h4>
<p>Then your lemma becomes</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">Icc_add_bij</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_cancel_add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_exists_add_of_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">):</span>
  <span class="n">bij_on</span> <span class="o">(</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
</code></pre></div>



<a name="229719749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229719749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229719749">(Mar 10 2021 at 18:43)</a>:</h4>
<p>ok, that seems nicer than the way I was writing it using <code>extends</code>.</p>



<a name="229719789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229719789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229719789">(Mar 10 2021 at 18:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals/near/229718425">said</a>:</p>
<blockquote>
<p>Well, there is also:<br>
<a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.le_iff_exists_add">docs#multiset.le_iff_exists_add</a> <br>
<a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal.le_iff_exists_add">docs#cardinal.le_iff_exists_add</a> :)</p>
</blockquote>
<p>Well, <code>cardinal</code> is an instance of <code>canonically_linear_ordered_add_monoid</code> already, and multiset is a <code>canonically_ordered_add_monoid</code></p>



<a name="229720005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229720005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229720005">(Mar 10 2021 at 18:45)</a>:</h4>
<p>But I echo Heather's comment that this would be easier to discuss in a PR</p>



<a name="229720087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229720087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229720087">(Mar 10 2021 at 18:45)</a>:</h4>
<p>that'll happen in the next few hours. Thanks everyone!</p>



<a name="229737745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Correct%20setting%20for%20positive%20shifts%20of%20intervals/near/229737745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Correct.20setting.20for.20positive.20shifts.20of.20intervals.html#229737745">(Mar 10 2021 at 20:27)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/6629">#6629</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
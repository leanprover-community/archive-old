---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html">Restricting permutations</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="246206677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/246206677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#246206677">(Jul 16 2021 at 10:26)</a>:</h4>
<p>I have a permutation <code>σ : equiv.perm ℕ</code>, and I know that <code>σ</code> doesn't send anything <code>&lt; k</code> to anything <code>≥ k</code>. Is there a nice way to write <code>σ</code> as the composition of some <code>σ' : equiv.perm (fin k)</code> and <code>τ : equiv.perm ℕ</code>?</p>



<a name="246206760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/246206760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#246206760">(Jul 16 2021 at 10:26)</a>:</h4>
<p>Take <code>σ' = 1</code>?</p>



<a name="246206826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/246206826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#246206826">(Jul 16 2021 at 10:27)</a>:</h4>
<p>I guess you mean some kind of horizontal composition</p>



<a name="246206898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/246206898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#246206898">(Jul 16 2021 at 10:28)</a>:</h4>
<p>Is there a function that takes the disjoint sum of permutations? That would at least let you write the theorem statement</p>



<a name="246207090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/246207090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#246207090">(Jul 16 2021 at 10:30)</a>:</h4>
<p>The statement is something like <code>σ = σ'.extend_domain (equiv.of_left_inverse coe _ _) * τ ∧ ∀ n, τ n ≠ n → n ≥ k</code></p>



<a name="246207329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/246207329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#246207329">(Jul 16 2021 at 10:33)</a>:</h4>
<p>Oh, I was thinking of something more like <code>\exists σ' τ, σ = e.perm_congr (perm.sum σ' τ)</code> where <code>e : ℕ ⊕ fin k ≃ ℕ</code></p>



<a name="246207418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/246207418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#246207418">(Jul 16 2021 at 10:34)</a>:</h4>
<p>the definitions of <code>equiv.perm_congr : A ~= B -&gt; perm A ~= perm B</code> and <code>perm.sum : perm A -&gt; perm B -&gt; perm (A ⊕ B)</code> should be obvious</p>



<a name="246207435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/246207435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#246207435">(Jul 16 2021 at 10:35)</a>:</h4>
<p>Ah, I see. That would be a lot nicer than what I have now :P</p>



<a name="246207482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/246207482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#246207482">(Jul 16 2021 at 10:36)</a>:</h4>
<p>Those are <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm_congr">docs#equiv.perm_congr</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.sum_congr">docs#equiv.sum_congr</a> respectively</p>



<a name="246207556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/246207556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#246207556">(Jul 16 2021 at 10:36)</a>:</h4>
<p>I just love it when I can wish theorems into existence like that <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>



<a name="246207708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/246207708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#246207708">(Jul 16 2021 at 10:38)</a>:</h4>
<p>actually the second one is <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.sum_congr">docs#equiv.perm.sum_congr</a>, although I think that's defeq to an instantiation of <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.sum_congr">docs#equiv.sum_congr</a></p>



<a name="249403942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/249403942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#249403942">(Aug 13 2021 at 19:36)</a>:</h4>
<p>This lemma doesn't seem to exist.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">perm.compl_equiv</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">s</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">perm</span> <span class="o">(</span><span class="n">s</span><span class="bp">ᶜ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">≃</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">equiv.set.compl</span> <span class="o">(</span><span class="n">equiv.refl</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="n">symm.trans</span> <span class="o">(</span><span class="n">subtype_equiv_right</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">)</span>
</code></pre></div>
<p>But I'm wondering whether it's written the correct way. Should I replace <code>s</code> by a prop and <code>perm (sᶜ : set α)</code> by <code>perm {a // ¬p a}</code>?</p>



<a name="249404966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/249404966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#249404966">(Aug 13 2021 at 19:46)</a>:</h4>
<p>Is the right-hand side <code>{f : perm α // f.support = s}</code>? (<a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.support">docs#equiv.perm.support</a>)</p>



<a name="249405132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/249405132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#249405132">(Aug 13 2021 at 19:48)</a>:</h4>
<p>Oh, that's only for fintypes</p>



<a name="249408575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/249408575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#249408575">(Aug 13 2021 at 20:16)</a>:</h4>
<p>I've thought about generalizing <a href="http://perm.support">perm.support</a> to arbitrary types, but it gets difficult to work with cardinality of supports then.</p>



<a name="249408820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/249408820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#249408820">(Aug 13 2021 at 20:18)</a>:</h4>
<p>The equiv you're looking for can be made using the equiv that splits a type along a prop into a sum of compl subtypes, then refl for the left one. I worked and added the one recently, don't remember it's name.</p>



<a name="249526770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Restricting%20permutations/near/249526770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Restricting.20permutations.html#249526770">(Aug 15 2021 at 19:20)</a>:</h4>
<p>I ended up making it by hand using <code>equiv.perm.subtype_perm</code> and <code>equiv.perm.of_subtype</code>. See <a href="https://github.com/leanprover-community/mathlib/issues/8691">#8691</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html">Bézout's identity</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="222324467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222324467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adrián Doña Mateo <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222324467">(Jan 11 2021 at 16:54)</a>:</h4>
<p>I need a generalised Bézout's identity for more than 2 integers for an IMO problem. Is there something like that in mathlib?</p>



<a name="222326802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222326802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222326802">(Jan 11 2021 at 17:10)</a>:</h4>
<p>Not that I know of</p>



<a name="222327646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222327646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222327646">(Jan 11 2021 at 17:17)</a>:</h4>
<p>What's the statement?</p>



<a name="222328411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222328411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adrián Doña Mateo <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222328411">(Jan 11 2021 at 17:22)</a>:</h4>
<p>Given any integers <code>a₁,...,aₙ</code> there always exist integers <code>x₁,...,xₙ</code> such that <code>x₁ * a₁ + ⋯ + xₙ * aₙ = gcd(a₁,...,aₙ)</code>. I believe something similar is true for principal ideal domains.</p>



<a name="222328847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222328847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adrián Doña Mateo <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222328847">(Jan 11 2021 at 17:26)</a>:</h4>
<p>I don't think there is a definition of <code>gcd</code> for more than two elements in mathlib so seems like there can't be for this. Any thoughts on how difficult it would be to define this and prove the generalised identity?</p>



<a name="222329212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222329212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222329212">(Jan 11 2021 at 17:28)</a>:</h4>
<p>You can state this with <code>multiset.gcd</code> or <code>finset.gcd</code></p>



<a name="222329296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222329296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222329296">(Jan 11 2021 at 17:29)</a>:</h4>
<p>And multiset has a good inductive principle, so you could prove your desired version by induction</p>



<a name="222329452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222329452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222329452">(Jan 11 2021 at 17:30)</a>:</h4>
<p>What data structure did you want to use to encode the tuple of numbers?</p>



<a name="222329494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222329494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adrián Doña Mateo <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222329494">(Jan 11 2021 at 17:31)</a>:</h4>
<p>I thought finset would make the most sense</p>



<a name="222329690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222329690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222329690">(Jan 11 2021 at 17:32)</a>:</h4>
<p>Seems like this would be nice to prove for multiset, from which the proof for finset ought to be obvious?</p>



<a name="222343335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222343335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222343335">(Jan 11 2021 at 19:12)</a>:</h4>
<p>Here's a messy sketch of this <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators</span>
<span class="kn">open</span> <span class="n">int</span>
<span class="kn">open</span> <span class="n">euclidean_domain</span>

<span class="kd">lemma</span> <span class="n">map_mul_sum</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">l.map</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)))</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">l.sum</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">convert</span> <span class="n">list.sum_hom</span> <span class="n">l</span> <span class="o">⟨((</span><span class="bp">*</span><span class="o">)</span> <span class="n">r</span><span class="o">),</span> <span class="n">mul_zero</span> <span class="n">r</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">mul_add</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">⟩</span>
<span class="kd">lemma</span> <span class="n">zip_with_mul_map_mul</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁.zip_with</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">l₂.map</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)))</span> <span class="bp">=</span>
                                                     <span class="o">(</span><span class="n">l₁.zip_with</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="n">l₂</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">asd</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span><span class="o">),</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span> <span class="bp">//</span> <span class="n">l.foldr</span> <span class="n">gcd</span> <span class="mi">0</span> <span class="bp">=</span> <span class="o">(</span><span class="n">l.zip_with</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="o">[],</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span> <span class="o">::</span> <span class="n">ll</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">gcd_a</span> <span class="n">h</span> <span class="o">(</span><span class="n">ll.foldr</span> <span class="n">gcd</span> <span class="mi">0</span><span class="o">)</span> <span class="o">::</span> <span class="o">((</span><span class="n">asd</span> <span class="n">ll</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">h</span> <span class="o">(</span><span class="n">ll.foldr</span> <span class="n">gcd</span> <span class="mi">0</span><span class="o">)))),</span> <span class="kd">begin</span>
 <span class="n">simp</span><span class="o">,</span>
 <span class="n">convert</span> <span class="n">gcd_eq_gcd_ab</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
 <span class="k">have</span> <span class="o">:=</span> <span class="o">(</span><span class="n">asd</span> <span class="n">ll</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
 <span class="n">simp</span> <span class="o">[</span><span class="n">zip_with_mul_map_mul</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_mul_sum</span><span class="o">],</span>
 <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
 <span class="n">congr</span><span class="o">,</span>
 <span class="n">exact</span> <span class="n">this.symm</span><span class="o">,</span>
<span class="kd">end</span><span class="o">⟩</span>
<span class="k">#eval</span> <span class="n">asd</span> <span class="o">[</span><span class="mi">6</span><span class="o">,</span> <span class="mi">15</span><span class="o">,</span> <span class="mi">10</span><span class="o">]</span>
</code></pre></div>



<a name="222419902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222419902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adrián Doña Mateo <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222419902">(Jan 12 2021 at 11:43)</a>:</h4>
<p>Is it preferable to have a function to this subtype or a theorem that states the existence of such list?</p>



<a name="222420002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222420002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222420002">(Jan 12 2021 at 11:44)</a>:</h4>
<p>Given that <span class="user-mention" data-user-id="127136">@Alex J. Best</span> has gone to the effort of a computable construction, it seems a shame to not use it and and provide a non-computable construction via <code>exists</code>.</p>



<a name="222420054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222420054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adrián Doña Mateo <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222420054">(Jan 12 2021 at 11:45)</a>:</h4>
<p>That makes sense, thanks!</p>



<a name="222420164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/B%C3%A9zout%27s%20identity/near/222420164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/B.C3.A9zout's.20identity.html#222420164">(Jan 12 2021 at 11:47)</a>:</h4>
<p>Although it might make sense to split <code>asd</code> into</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bezout_factors</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span>

<span class="kd">lemma</span> <span class="n">bezout_prop</span> <span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">:</span>  <span class="o">(</span><span class="n">bezout_factors</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">foldr</span> <span class="n">gcd</span> <span class="mi">0</span> <span class="bp">=</span> <span class="o">(</span><span class="n">l.zip_with</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">bezout_factors</span> <span class="n">l</span><span class="o">))</span><span class="bp">.</span><span class="n">sum</span>
</code></pre></div>
<p>but only if that makes the definition simpler</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
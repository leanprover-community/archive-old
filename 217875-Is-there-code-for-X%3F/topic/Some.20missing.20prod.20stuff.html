---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html">Some missing prod stuff</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="270832364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270832364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270832364">(Feb 05 2022 at 15:27)</a>:</h4>
<p>I search around and I couldn't find these guys:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.prod</span>
<span class="kn">import</span> <span class="n">order.filter.basic</span>

<span class="kn">open</span> <span class="n">filter</span>
<span class="n">open_locale</span> <span class="n">filter</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">prod.dup</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">prod.mk'</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">×</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="n">prod.map</span> <span class="n">f</span> <span class="n">g</span> <span class="o">(</span><span class="n">prod.dup</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">prod.mk'_fst_snd</span> <span class="o">:</span> <span class="n">prod.mk'</span> <span class="o">(</span><span class="bp">@</span><span class="n">prod.fst</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">prod.snd</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">funext</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">prod.mk'</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">prod.dup</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">filter.prod_map_fst_snd_eq</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)}</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">≤</span> <span class="n">filter.map</span> <span class="n">prod.fst</span> <span class="n">f</span> <span class="bp">×ᶠ</span> <span class="n">map</span> <span class="n">prod.snd</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">filter.prod</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hle₁</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≤</span> <span class="n">comap</span> <span class="n">prod.fst</span> <span class="o">(</span><span class="n">map</span> <span class="n">prod.fst</span> <span class="n">f</span><span class="o">),</span> <span class="k">from</span> <span class="n">le_comap_map</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hle₂</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≤</span> <span class="n">comap</span> <span class="n">prod.snd</span> <span class="o">(</span><span class="n">map</span> <span class="n">prod.snd</span> <span class="n">f</span><span class="o">),</span> <span class="k">from</span> <span class="n">le_comap_map</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">le_inf</span> <span class="n">hle₁</span> <span class="n">hle₂</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Would anyone be against adding these to mathlib?</p>



<a name="270850780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270850780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270850780">(Feb 05 2022 at 21:43)</a>:</h4>
<p>So <code>mk' f g x = (f x, g x)</code>?</p>



<a name="270850845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270850845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270850845">(Feb 05 2022 at 21:44)</a>:</h4>
<p>That's similar to <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.prod">docs#linear_map.prod</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.prod">docs#add_monoid_hom.prod</a>, so should probably be called <code>function.prod</code> or <code>pi.prod</code></p>



<a name="270850963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270850963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270850963">(Feb 05 2022 at 21:47)</a>:</h4>
<p>Do we have <a href="https://leanprover-community.github.io/mathlib_docs/find/prod.lift">docs#prod.lift</a> ?</p>



<a name="270851012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270851012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270851012">(Feb 05 2022 at 21:48)</a>:</h4>
<p>Your <code>prod.mk</code> is just <code>prod.lift f g x</code>, for a correctly defined <code>prod.lift</code>...</p>



<a name="270851607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270851607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270851607">(Feb 05 2022 at 22:01)</a>:</h4>
<p>Doesn't lift usually go in the other direction? (in which case <code>lift</code> is just <code>prod.rec</code>)</p>



<a name="270851773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270851773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270851773">(Feb 05 2022 at 22:05)</a>:</h4>
<p>No, look at e.g. <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.prod.lift">docs#category_theory.limits.prod.lift</a></p>



<a name="270851796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270851796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270851796">(Feb 05 2022 at 22:05)</a>:</h4>
<p>Do we even have <a href="https://leanprover-community.github.io/mathlib_docs/find/prod.rec">docs#prod.rec</a> ?</p>



<a name="270851797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270851797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270851797">(Feb 05 2022 at 22:06)</a>:</h4>
<p>I think we want something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">pi.prod</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">γ</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="n">a</span> <span class="bp">×</span> <span class="n">γ</span> <span class="n">a</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">,</span> <span class="n">g</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>



<a name="270851859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270851859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270851859">(Feb 05 2022 at 22:06)</a>:</h4>
<p><code>prod.rec</code> is built-in like most <code>.rec</code>s</p>



<a name="270851945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270851945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270851945">(Feb 05 2022 at 22:08)</a>:</h4>
<p>I think <code>lift</code> goes the other way outside <code>category_theory</code>, eg <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient.lift">docs#quotient.lift</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/tensor_algebra.lift">docs#tensor_algebra.lift</a>.</p>



<a name="270851973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270851973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270851973">(Feb 05 2022 at 22:08)</a>:</h4>
<p>It is well know that <code>quotient.lift</code> should be called <code>quotient.desc</code>.</p>



<a name="270851997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270851997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270851997">(Feb 05 2022 at 22:09)</a>:</h4>
<p><code>lift</code> is a general word used for limits, and products are limits.</p>



<a name="270852149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270852149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270852149">(Feb 05 2022 at 22:12)</a>:</h4>
<p>My understanding was that <code>foo.lift</code> was for building maps <em>out</em> of <code>foo</code> from "simpler" maps</p>



<a name="270852160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270852160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270852160">(Feb 05 2022 at 22:12)</a>:</h4>
<p>But your proposed <code>prod.lift</code> builds a map <em>into</em> <code>prod</code></p>



<a name="270852174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270852174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270852174">(Feb 05 2022 at 22:13)</a>:</h4>
<p>Maybe that naming convention is bad, but that was the pattern I recall us having right now</p>



<a name="270852181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270852181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270852181">(Feb 05 2022 at 22:13)</a>:</h4>
<p>I think of <code>lift</code> outside of the CT library more as "get the thing given by the universal property"</p>



<a name="270852195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270852195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270852195">(Feb 05 2022 at 22:13)</a>:</h4>
<p>Whatever that universal property might be.</p>



<a name="270852241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270852241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270852241">(Feb 05 2022 at 22:14)</a>:</h4>
<p>What's the universal property of <code>prod</code>? Isn't it <code>prod.rec</code>?</p>



<a name="270852265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270852265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270852265">(Feb 05 2022 at 22:14)</a>:</h4>
<p>Or are there multiple universal properties?</p>



<a name="270852346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270852346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270852346">(Feb 05 2022 at 22:16)</a>:</h4>
<p>This is some weird type theory thing about "positive" and "negative" types.</p>



<a name="270852350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270852350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270852350">(Feb 05 2022 at 22:16)</a>:</h4>
<p>In category theory, the universal property of the product is that mapping into the product is the same as mapping into both factors.</p>



<a name="270880434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270880434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270880434">(Feb 06 2022 at 09:30)</a>:</h4>
<p>The way I see it, since <code>prod</code> is a negative type, there should be a <code>prod.corec</code> that would be what I called <code>prod.mk'</code>.</p>



<a name="270888446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270888446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270888446">(Feb 06 2022 at 12:52)</a>:</h4>
<p>I PR'd <code>prod.mk'</code> as <code>pi.prod</code> in <a href="https://github.com/leanprover-community/mathlib/pull/11877">#11877</a>, and found some downstream <code>foo.prod</code>s that could be reimplemented using <code>pi.prod</code>.</p>



<a name="270905357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270905357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270905357">(Feb 06 2022 at 18:59)</a>:</h4>
<p>I will make a PR for <code>filter.prod_map_fst_snd_eq</code> then.</p>



<a name="270914433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270914433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270914433">(Feb 06 2022 at 22:02)</a>:</h4>
<p>It should probably not have <code>eq</code> in the name since the statement is about <code>le</code>!</p>



<a name="270948376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/270948376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#270948376">(Feb 07 2022 at 08:55)</a>:</h4>
<p>Yes, you're right.</p>



<a name="271353205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271353205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271353205">(Feb 09 2022 at 21:57)</a>:</h4>
<p>I think mathlib is also missing <code>α × (β × γ) ↔ (α × β) × γ</code>. Or maybe this exists for <code>pi</code>, and I just can't find it.</p>



<a name="271353330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271353330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271353330">(Feb 09 2022 at 21:58)</a>:</h4>
<p>Does that even typecheck? Can you give a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> ?</p>



<a name="271353391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271353391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271353391">(Feb 09 2022 at 21:58)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.prod_assoc">docs#equiv.prod_assoc</a></p>



<a name="271353621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271353621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271353621">(Feb 09 2022 at 22:00)</a>:</h4>
<p>Ah, nice. Thanks.</p>



<a name="271697512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271697512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271697512">(Feb 12 2022 at 16:53)</a>:</h4>
<p>I was looking for this lemma</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">filter.prod_map_rlassoc</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">map</span> <span class="o">(</span><span class="n">equiv.prod_assoc</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="o">(</span><span class="n">f</span> <span class="bp">×ᶠ</span> <span class="o">(</span><span class="n">g</span> <span class="bp">×ᶠ</span> <span class="n">h</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="bp">×ᶠ</span> <span class="n">g</span><span class="o">)</span> <span class="bp">×ᶠ</span> <span class="n">h</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>but I could not find it. Would someone confirm that mathlib does have this? Also, proving this is turning into a challenge.</p>



<a name="271698336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271698336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271698336">(Feb 12 2022 at 17:09)</a>:</h4>
<p>The <code>set</code> version of this lemma is also missing and I need it to prove the filter version above.</p>



<a name="271698827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271698827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271698827">(Feb 12 2022 at 17:20)</a>:</h4>
<p>I think we have neither.</p>



<a name="271698840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271698840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271698840">(Feb 12 2022 at 17:21)</a>:</h4>
<p>Is this some kind of general result about monads?</p>



<a name="271701240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271701240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271701240">(Feb 12 2022 at 18:08)</a>:</h4>
<p>I don't think so. In my mind, these are just "lifted" versions of prod_assoc.</p>



<a name="271701691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271701691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271701691">(Feb 12 2022 at 18:13)</a>:</h4>
<p>It's probably possible to get the set and filter versions of prod_assoc via applicative.seq?</p>



<a name="271701813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271701813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271701813">(Feb 12 2022 at 18:15)</a>:</h4>
<p>It's also true for <code>finset</code>. So I guess the criterion is a functor with a notion of product.</p>



<a name="271702391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271702391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271702391">(Feb 12 2022 at 18:24)</a>:</h4>
<p>Monoidal functors perhaps? <a href="https://en.wikipedia.org/wiki/Monoidal_functor">https://en.wikipedia.org/wiki/Monoidal_functor</a></p>



<a name="271702446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271702446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271702446">(Feb 12 2022 at 18:25)</a>:</h4>
<p>Applicatives are basically what those are.</p>



<a name="271702516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271702516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271702516">(Feb 12 2022 at 18:26)</a>:</h4>
<p>Sounds like it.</p>



<a name="271706021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271706021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271706021">(Feb 12 2022 at 19:37)</a>:</h4>
<p><span class="user-mention" data-user-id="416322">@Bernd Losert</span> I did half of it, the other half is just mutatis mutandis:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">order.filter.basic</span>

<span class="n">open_locale</span> <span class="n">filter</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">filter.prod_map_rlassoc</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">map</span> <span class="o">(</span><span class="n">equiv.prod_assoc</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="o">(</span><span class="n">f</span> <span class="bp">×ᶠ</span> <span class="o">(</span><span class="n">g</span> <span class="bp">×ᶠ</span> <span class="n">h</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="bp">×ᶠ</span> <span class="n">g</span><span class="o">)</span> <span class="bp">×ᶠ</span> <span class="n">h</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">U</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_map</span><span class="o">,</span> <span class="n">mem_prod_iff</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span> <span class="c1">-- can't see how to do it any other way</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">tα</span><span class="o">,</span> <span class="n">hα</span><span class="o">,</span> <span class="n">tβγ</span><span class="o">,</span> <span class="n">hβγ</span><span class="o">,</span> <span class="n">hαβγ</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="n">mem_prod_iff</span> <span class="n">at</span> <span class="n">hβγ</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hβγ</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">tβ</span><span class="o">,</span> <span class="n">hβ</span><span class="o">,</span> <span class="n">tγ</span><span class="o">,</span> <span class="n">hγ</span><span class="o">,</span> <span class="n">hβγ</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">tα.prod</span> <span class="n">tβ</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">tγ</span><span class="o">,</span> <span class="n">hγ</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">mem_prod_iff</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">tα</span><span class="o">,</span> <span class="n">hα</span><span class="o">,</span> <span class="n">tβ</span><span class="o">,</span> <span class="n">hβ</span><span class="o">,</span> <span class="n">rfl.subset</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">⟩,</span> <span class="n">c</span><span class="o">⟩</span> <span class="o">⟨⟨</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩,</span> <span class="n">hc</span><span class="o">⟩,</span>
      <span class="n">exact</span> <span class="bp">@</span><span class="n">hαβγ</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">ha</span><span class="o">,</span> <span class="n">hβγ</span> <span class="o">(⟨</span><span class="n">hb</span><span class="o">,</span> <span class="n">hc</span><span class="o">⟩</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">tβ.prod</span> <span class="n">tγ</span><span class="o">)⟩</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- same again</span>
    <span class="gr">sorry</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="271706118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271706118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271706118">(Feb 12 2022 at 19:39)</a>:</h4>
<p>I would love to see a proof using all that monadery stuff.</p>



<a name="271706222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271706222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271706222">(Feb 12 2022 at 19:42)</a>:</h4>
<p>I fear that the answer to the monadic stuff is that "It's what defines an associative functor" or however it's called and that what you're proving is precisely that <code>set</code> and <code>filter</code> are associative functors or however they are called.</p>



<a name="271706459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271706459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271706459">(Feb 12 2022 at 19:47)</a>:</h4>
<p>If you're talking about applicative functors and your claim is true then no doubt this is just the sort of thing which people like Johannes Hoelzl and <span class="user-mention" data-user-id="110026">@Simon Hudon</span> were doing years and years ago.</p>



<a name="271707366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271707366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271707366">(Feb 12 2022 at 20:07)</a>:</h4>
<p>If you're using <code>finset</code> with applicative functions, indeed you need associativity and commutativity in order to map an effect to every element of the set. If you're looking at <code>set</code> and not <code>finset</code>, you need the operator of your applicative functor to be a big operator, applicable to arbitrary sets. I've never seen something like that though</p>



<a name="271708927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271708927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271708927">(Feb 12 2022 at 20:46)</a>:</h4>
<p>Ok, you succeeded again to trick me into playing with filters. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.filter.bases</span>

<span class="n">open_locale</span> <span class="n">filter</span>

<span class="kn">open</span> <span class="n">filter</span> <span class="n">equiv</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">filter.has_basis.equiv</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">ι</span> <span class="n">ι'</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f.has_basis</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ι'</span> <span class="bp">≃</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span> <span class="n">f.has_basis</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∘</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h.mem_iff</span><span class="o">,</span> <span class="n">e.exists_congr_left</span><span class="o">]⟩</span>

<span class="kd">lemma</span> <span class="n">filter.prod_map_rlassoc</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">map</span> <span class="o">(</span><span class="n">prod_assoc</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span> <span class="o">((</span><span class="n">f</span> <span class="bp">×ᶠ</span> <span class="n">g</span><span class="o">)</span> <span class="bp">×ᶠ</span> <span class="n">h</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">×ᶠ</span> <span class="o">(</span><span class="n">g</span> <span class="bp">×ᶠ</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">map_eq_comap_of_inverse</span> <span class="o">(</span><span class="n">prod_assoc</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span><span class="bp">.</span><span class="n">self_comp_symm</span> <span class="o">(</span><span class="n">prod_assoc</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span><span class="bp">.</span><span class="n">symm_comp_self</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">((((</span><span class="n">basis_sets</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">$</span> <span class="n">basis_sets</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">$</span> <span class="n">basis_sets</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">comap</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">eq_of_same_basis</span><span class="o">,</span>
  <span class="n">convert</span> <span class="o">((</span><span class="n">basis_sets</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(((</span><span class="n">basis_sets</span> <span class="n">g</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="n">basis_sets</span> <span class="n">h</span><span class="o">)))</span><span class="bp">.</span><span class="n">equiv</span> <span class="o">(</span><span class="n">prod_assoc</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="bp">;</span>
  <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">and_assoc</span><span class="o">]</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>Note that I modified slightly the statement since I didn't see the point of going against <code>equiv.prod_assoc</code>.</p>



<a name="271709002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271709002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271709002">(Feb 12 2022 at 20:48)</a>:</h4>
<p>Does that first lemma generalize to surjective e?</p>



<a name="271709188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271709188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271709188">(Feb 12 2022 at 20:53)</a>:</h4>
<p>Sure</p>



<a name="271709242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271709242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271709242">(Feb 12 2022 at 20:54)</a>:</h4>
<p>I wrote this lemma very quickly since it's a complete tautology that is exactly what is needed here.</p>



<a name="271709249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271709249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271709249">(Feb 12 2022 at 20:54)</a>:</h4>
<p>Do you mean the surjective case is already there?</p>



<a name="271709316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271709316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271709316">(Feb 12 2022 at 20:56)</a>:</h4>
<p>Let's do it for Eric:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">filter.has_basis.comp_of_surjective</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">ι</span> <span class="n">ι'</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f.has_basis</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">ι'</span> <span class="bp">→</span> <span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.has_basis</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h.mem_iff</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">ht</span><span class="o">⟩,</span>
    <span class="n">rcases</span> <span class="n">hg</span> <span class="n">i</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">i'</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">i'</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">ht</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">i'</span><span class="o">,</span> <span class="n">hi'</span><span class="o">,</span> <span class="n">ht</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">g</span> <span class="n">i'</span><span class="o">,</span> <span class="n">hi'</span><span class="o">,</span> <span class="n">ht</span><span class="o">⟩</span> <span class="o">}</span>
<span class="kd">end</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">filter.has_basis.equiv</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">ι</span> <span class="n">ι'</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f.has_basis</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ι'</span> <span class="bp">≃</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span> <span class="n">f.has_basis</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∘</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">h.comp_of_surjective</span> <span class="n">e.surjective</span>
</code></pre></div>



<a name="271709326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271709326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271709326">(Feb 12 2022 at 20:57)</a>:</h4>
<p>Now the required lemma has a more complicated proof, but it looks shorter on screen <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="271709665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271709665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271709665">(Feb 12 2022 at 21:04)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/12002">#12002</a></p>



<a name="271714117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271714117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271714117">(Feb 12 2022 at 22:54)</a>:</h4>
<p>Well you didn't have to write it so long!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">has_basis.comp_of_surjective</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l.has_basis</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">ι'</span> <span class="bp">→</span> <span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l.has_basis</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">h.mem_iff.trans</span> <span class="n">hg.exists</span><span class="o">⟩</span>
</code></pre></div>



<a name="271714482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271714482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271714482">(Feb 12 2022 at 23:03)</a>:</h4>
<p>(apologies, it was unkind of me to trick you into proving the surjective case without telling you that I had <a href="https://leanprover-community.github.io/mathlib_docs/find/function.surjective.exists">docs#function.surjective.exists</a> in mind as the proof)</p>



<a name="271715802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Some%20missing%20prod%20stuff/near/271715802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Some.20missing.20prod.20stuff.html#271715802">(Feb 12 2022 at 23:37)</a>:</h4>
<p>So in fact it's now a one-liner. I really like these kinds of questions, it's the community at its best.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html">Reduce like operation for finite sets</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="229313963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229313963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joao Bregunci <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229313963">(Mar 08 2021 at 15:12)</a>:</h4>
<p>I was thinking if there is a reduce type like operation as in functional programming for finite sets. What I mean by this is if I have a finite set of a certain type and an operation that is associative and commutative if I can apply a reduce like operation. A simple example of this would be if I have a finite set of <code>Prop</code> if I could create the <code>and</code> of all of them. I would prefer to not work with <code>lists</code> if possible, even thought these already have <code>fold</code> operations...</p>



<a name="229314448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229314448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229314448">(Mar 08 2021 at 15:15)</a>:</h4>
<p>Is <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.fold">docs#finset.fold</a> what you're looking for?</p>



<a name="229315238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229315238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joao Bregunci <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229315238">(Mar 08 2021 at 15:20)</a>:</h4>
<p>Exactly that. Thanks, just a question about <strong>mathlib</strong>. I was searching for this is <strong>data.set.finite</strong>, but didn't find. Is there a better way to search in <strong>mathlib</strong>? Sorry if this seems silly, but often I find myself a little bit lost on where to search...</p>



<a name="229316186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229316186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229316186">(Mar 08 2021 at 15:26)</a>:</h4>
<p>data.set.finite is nonconstructive -- a possibly nonconstructive proof that a set is finite. Finset is more likely to reduce, you might want to look at the file where finset is defined.</p>



<a name="229316461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229316461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229316461">(Mar 08 2021 at 15:27)</a>:</h4>
<p>I don't know think we have any great solutions for searching mathlib now (that's why we have this Zulip stream).</p>
<p>There's a search box in the top right of our docs page. Confusingly, it has two different modes. The more obvious behavior is that it searches declaration names as you type and displays them in a clickable dropdown (the VS Code extension's "symbol search" does this too, but only for declarations in files you've imported, you can access this by hitting Ctrl+T (Cmd+T on macOS)). The second mode is if you hit the search button, it directs you to a site-specific google search (which sadly is often out of date) (locally, I just use VS Code's search on mathlib; if you're working on a dependency, note that you may have to tell VS Code to include the <code>_target/deps/mathlib</code> directory in the search).</p>



<a name="229316807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229316807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229316807">(Mar 08 2021 at 15:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> in some programming languages <code>reduce</code> is the name for <code>fold</code>. I think that this is the kind of reduce that Joao means.</p>



<a name="229316943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229316943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229316943">(Mar 08 2021 at 15:30)</a>:</h4>
<p>We can certainly have a nonconstructive fold for <code>data.set.finite</code></p>



<a name="229334856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229334856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joao Bregunci <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229334856">(Mar 08 2021 at 16:57)</a>:</h4>
<p>Thanks for all the assistance, it has been extremely helpful.</p>



<a name="229356411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229356411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229356411">(Mar 08 2021 at 19:08)</a>:</h4>
<p><span class="user-mention" data-user-id="362285">@Joao Bregunci</span> Is the non-duplication important for the <code>Prop</code>s? If not, you might consider <code>mulitset</code>.  Implementation-wise, a <code>finset</code> is a <code>multiset</code> with no duplication, and a <code>multiset</code> is a <code>list</code> up to permutation.  The <code>fold</code> operation for <code>finset</code> is defined in terms of <code>foldr</code> for <code>multiset</code>, which is defined in terms of <code>foldr</code> for <code>list</code>.</p>



<a name="229380128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229380128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joao Bregunci <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229380128">(Mar 08 2021 at 21:49)</a>:</h4>
<p>Kyle Miller, I think that explaining my goal would be a little bit easier. I have a set of Propositions which I will call <code>Theory</code> and I want  to show that given some Interpretation of these <code>Prop</code>, that is a way in which I evaluate these <code>Prop</code>, then I can arrive at a certain conclusion. So what I am thinking of is the following in a simple pseudocode:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∃</span> <span class="n">interp</span><span class="o">,</span>  <span class="n">interp</span> <span class="n">s1</span> <span class="bp">∧</span> <span class="n">interp</span> <span class="n">s2</span> <span class="bp">⋯</span> <span class="bp">∧</span> <span class="n">interp</span> <span class="n">sn</span> <span class="bp">→</span> <span class="n">interp</span> <span class="n">dn</span>
</code></pre></div>
<p>I can assume that I won't have duplicates, so I am going to take a look at <code>multiset</code>. My goal was to be able to concisely build the <code>and</code> above with n terms. Just a small question, to use this <code>fold</code> operation do I need to create any instance for the <code>and</code> operator? Because with Bryan suggestion, sorry if I am wrong, I would need to create a <code>instance is_commutative</code> and <code>instance is_associative</code> for the <code>and</code> operator...</p>



<a name="229389557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229389557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229389557">(Mar 08 2021 at 22:42)</a>:</h4>
<p>Could you say a bit more about what a <code>Theory</code> is?  Is <code>Prop</code> the usual kind of <code>Prop</code>? Or is it a data type representing some logical expression?  Is there any specific reason you want to avoid <code>list</code>?</p>



<a name="229390095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229390095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229390095">(Mar 08 2021 at 22:46)</a>:</h4>
<p>In case it's useful, there's <code>list.all</code>, which is a <code>bool</code> version of sort of what you want.  A <code>Prop</code>-valued version is easy to write:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list</span>

<span class="kd">def</span> <span class="n">list.all'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">list.foldr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">r</span><span class="o">,</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span> <span class="n">true</span> <span class="n">l</span>
</code></pre></div>
<p>You could use it with <code>l.all' interp</code> where <code>l</code> is a list of things to be interpreted, and <code>interp</code> takes a proposition and yields a <code>Prop</code>.</p>



<a name="229390666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229390666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229390666">(Mar 08 2021 at 22:50)</a>:</h4>
<p>Here's a multiset version:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.multiset.fold</span>

<span class="kd">def</span> <span class="n">multiset.and</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">multiset</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">multiset.fold</span> <span class="o">(</span><span class="bp">∧</span><span class="o">)</span> <span class="n">true</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">multiset.all</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l.map</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">and</span>
</code></pre></div>



<a name="229391533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Reduce%20like%20operation%20for%20finite%20sets/near/229391533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Reduce.20like.20operation.20for.20finite.20sets.html#229391533">(Mar 08 2021 at 22:58)</a>:</h4>
<p>A quick example of how it might be used:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">MyProp</span>
<span class="bp">|</span> <span class="n">P</span> <span class="o">:</span> <span class="n">MyProp</span>
<span class="bp">|</span> <span class="n">Or</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">MyProp</span><span class="o">)</span> <span class="o">:</span> <span class="n">MyProp</span>
<span class="bp">|</span> <span class="n">Not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">MyProp</span><span class="o">)</span> <span class="o">:</span> <span class="n">MyProp</span>

<span class="kn">open</span> <span class="n">MyProp</span>

<span class="kd">def</span> <span class="n">interp_with</span> <span class="o">(</span><span class="n">p'</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">MyProp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">p'</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Or</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">interp_with</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">interp_with</span> <span class="n">q</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Not</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">¬</span> <span class="n">interp_with</span> <span class="n">p</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">({</span><span class="n">P</span><span class="o">,</span> <span class="n">Or</span> <span class="o">(</span><span class="n">Not</span> <span class="n">P</span><span class="o">)</span> <span class="n">P</span><span class="o">,</span> <span class="n">Not</span> <span class="o">(</span><span class="n">Not</span> <span class="n">P</span><span class="o">)}</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">MyProp</span><span class="o">)</span><span class="bp">.</span><span class="n">all</span> <span class="o">(</span><span class="n">interp_with</span> <span class="n">true</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">multiset.all</span><span class="o">,</span> <span class="n">interp_with</span><span class="o">,</span> <span class="n">multiset.and</span><span class="o">]</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html">bUnion for set</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="251241556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/251241556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#251241556">(Aug 30 2021 at 14:53)</a>:</h4>
<p>Is there something like <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.bUnion">docs#finset.bUnion</a> for <code>set</code>?</p>



<a name="251242002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/251242002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#251242002">(Aug 30 2021 at 14:56)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/set.sUnion">docs#set.sUnion</a>?</p>



<a name="251242154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/251242154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#251242154">(Aug 30 2021 at 14:57)</a>:</h4>
<p>Certainly <code>⋃ (x ∈ s), t x</code> will do what you want</p>



<a name="251248857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/251248857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#251248857">(Aug 30 2021 at 15:40)</a>:</h4>
<p><code>set.Union</code> does both unbounded and bounded unions, and theorems about specifically <code>⋃ (x ∈ s), t x</code>tend to have <code>bUnion</code> in the name.  This would be the notation that <code>finset.bUnion</code> would use if it had any.</p>
<p>Internal detail that you should be able to ignore: the notation means<br>
<code>set.Union (λ (x : α), set.Union (λ (H : x ∈ s), t x))</code><br>
which might not be be quite what you'd expect -- it's interesting how doing the union over <code>x ∈ s</code> is a way to conditionally control whether the set <code>t x</code> is included in the union.</p>



<a name="251266036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/251266036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#251266036">(Aug 30 2021 at 17:44)</a>:</h4>
<p>Here's another attempt at making a unified notation for <code>set.Union</code> and <code>finset.bUnion</code>.  Some features:</p>
<ul>
<li><code>⋃ x, f x</code> will try <code>finset.univ.bUnion f</code> if <code>[fintype x]</code>.</li>
<li><code>⋃ (x ∈ s), f x</code> will try <code>s.bUnion f</code>.</li>
<li>These can be mixed, like in <code>⋃ (x ∈ s) y, f x y</code>.</li>
<li><code>⋃ (i &lt; 5), f i</code>, for example, will try <code>finset.univ.bUnion (λ (x : {i | i &lt; 5}), f x)</code> when the property as a set is a <code>fintype</code>.</li>
</ul>
<p>All the usual things still work for <code>set</code> unions.</p>



<a name="251266042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/251266042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#251266042">(Aug 30 2021 at 17:44)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">data.set.lattice</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>
<span class="kn">import</span> <span class="n">data.set.finite</span>

<span class="kd">class</span> <span class="n">has_Union</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Union</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`⋃`</span> <span class="n">binders</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">r</span><span class="o">:(</span><span class="n">scoped</span> <span class="n">f</span><span class="o">,</span> <span class="n">has_Union.Union</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span>

<span class="kd">instance</span> <span class="n">set_Union</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_Union</span> <span class="n">f</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">Union</span> <span class="o">:=</span> <span class="n">set.Union</span> <span class="n">f</span><span class="o">}</span>

<span class="sd">/-- Ideally this instance would cause an error if it ever were actually used.</span>
<span class="sd">It's here to help typeclass inference along -- we need every union in a chain</span>
<span class="sd">of unions to have a definition. -/</span>
<span class="kd">@[priority 0]</span>
<span class="kd">instance</span> <span class="n">finset_Union_default_error</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="n">f</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">Union</span> <span class="o">:=</span> <span class="bp">∅</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_pred</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">}]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">has_Union.Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">Union</span> <span class="o">:=</span> <span class="n">finset.univ.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">}),</span> <span class="n">f</span> <span class="n">y</span><span class="o">)}</span>

<span class="kd">instance</span> <span class="n">finset_Union</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="n">f</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">Union</span> <span class="o">:=</span> <span class="n">finset.univ.bUnion</span> <span class="n">f</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_attach_bUnion</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">has_Union.Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span> <span class="n">h</span><span class="o">))</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">Union</span> <span class="o">:=</span> <span class="n">s.attach.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">f</span> <span class="n">p</span> <span class="n">p.property</span><span class="o">)}</span>

<span class="kd">instance</span> <span class="n">finset_bUnion</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">has_Union.Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">Union</span> <span class="o">:=</span> <span class="n">s.bUnion</span> <span class="n">f</span><span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.bUnion</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finset.univ.bUnion</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="n">ι'</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">s'</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι'</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">ι'</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="bp">∈</span> <span class="n">s'</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">s'.bUnion</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="n">ι'</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι'</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">ι'</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">finset.univ.bUnion</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="n">x</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩)</span> <span class="bp">=</span> <span class="n">s.attach.bUnion</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="n">ι'</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">ι'</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="bp">&lt;</span> <span class="mi">5</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="mi">5</span> <span class="bp">∧</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="bp">&lt;</span> <span class="mi">5</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset.range</span> <span class="mi">5</span><span class="o">)</span><span class="bp">.</span><span class="n">bUnion</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="251266201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/251266201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#251266201">(Aug 30 2021 at 17:45)</a>:</h4>
<p>There seems to be just one wart: if typeclass inference can't properly resolve <code>has_Union</code> for <code>finset</code>-valued unions, the union is the empty set.  It would be nice if there were a way to make it be an error if this instance were to ever be used.  (<code>sorry</code> is one possibility.)</p>



<a name="251266293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/251266293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#251266293">(Aug 30 2021 at 17:46)</a>:</h4>
<p>This <code>has_Union</code> typeclass could be easily modified for sums, products, and intersections.</p>



<a name="251276713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/251276713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#251276713">(Aug 30 2021 at 18:56)</a>:</h4>
<p>Didn't you post this before? Can you find the old thread?</p>



<a name="251278901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/251278901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#251278901">(Aug 30 2021 at 19:10)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> I rewrote it from scratch, and I was too lazy to dig up the old thread.</p>



<a name="251279190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/251279190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#251279190">(Aug 30 2021 at 19:12)</a>:</h4>
<p>Maybe I should have, because I apparently went through exactly the same exercise with exactly the same results... Not sure exactly what that suggests, but I'll go with maybe it's a workable idea.</p>



<a name="251279384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/251279384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#251279384">(Aug 30 2021 at 19:13)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality/near/224129427">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finsets.2C.20unions.2C.20and.20cardinality/near/224129427</a></p>



<a name="268434972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268434972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268434972">(Jan 18 2022 at 18:25)</a>:</h4>
<p>I had tried getting this generalized union class to work a while back, but the dependent types made it completely unworkable in practice, which is why it's never seemed to go anywhere.</p>



<a name="268435025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268435025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268435025">(Jan 18 2022 at 18:25)</a>:</h4>
<p>I took another crack at it this morning with a new approach, and it seems like it might actually work.</p>



<a name="268435080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268435080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268435080">(Jan 18 2022 at 18:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">data.set.lattice</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>
<span class="kn">import</span> <span class="n">data.set.finite</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">Union_binder</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">α</span>

<span class="kd">@[inline, reducible]</span>
<span class="kd">def</span> <span class="n">Union_binder.mk</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Union_binder</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">Union_binder.mk_eq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Union_binder.mk</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">class</span> <span class="n">has_Union</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Union</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`⋃`</span> <span class="n">binders</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">r</span><span class="o">:(</span><span class="n">scoped</span> <span class="n">f</span><span class="o">,</span> <span class="n">Union_binder.mk</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">has_Union.Union</span> <span class="n">r</span>

<span class="kd">instance</span> <span class="n">set_Union</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_Union</span> <span class="o">(</span><span class="n">Union_binder</span> <span class="bp">$</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="n">set.Union</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">set_bUnion</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="n">Union_binder</span> <span class="bp">$</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">Union_binder</span> <span class="bp">$</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">set.Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">set.Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="n">h</span><span class="o">))</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_Union</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="n">Union_binder</span> <span class="bp">$</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="n">finset.univ.bUnion</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_pred</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">}]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="n">Union_binder</span> <span class="bp">$</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">Union_binder</span> <span class="bp">$</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="o">({</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">})</span><span class="bp">.</span><span class="n">to_finset.attach.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">x.property</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}))</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">finset_attach_bUnion</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="n">Union_binder</span> <span class="bp">$</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">Union_binder</span> <span class="bp">$</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">Union</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">s.attach.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">f</span> <span class="n">p</span> <span class="n">p.property</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.bUnion</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finset.univ.bUnion</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="n">ι'</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">s'</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι'</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">ι'</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="bp">⋃</span> <span class="o">(</span><span class="n">y</span> <span class="bp">∈</span> <span class="n">s'</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">s'.bUnion</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="n">ι'</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι'</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">ι'</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="bp">⋃</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">finset.univ.bUnion</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="n">x</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩)</span> <span class="bp">=</span> <span class="n">s.attach.bUnion</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>

<span class="c1">--set_option pp.notation false</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>

<span class="c1">-- Cannot combine unions into a single union with this approach:</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="n">ι'</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">ι'</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="c1">--  (⋃ x y, f x y) = {z | ∃ x y, z ∈ f x y} :=</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⋃</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="bp">&lt;</span> <span class="mi">5</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="mi">5</span> <span class="bp">∧</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="bp">&lt;</span> <span class="mi">5</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset.range</span> <span class="mi">5</span><span class="o">)</span><span class="bp">.</span><span class="n">bUnion</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>

<span class="c1">-- rewrite works:</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">y</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">),</span> <span class="n">g</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">],</span>
<span class="kd">end</span>

<span class="c1">-- rewrite works:</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">y</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">),</span> <span class="n">g</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">Union_diff</span> <span class="o">{</span><span class="n">ι</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span><span class="o">,</span> <span class="n">t</span> <span class="n">i</span><span class="o">)</span> <span class="bp">\</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">⋃</span> <span class="n">i</span><span class="o">,</span> <span class="n">t</span> <span class="n">i</span> <span class="bp">\</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>



<a name="268435234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268435234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268435234">(Jan 18 2022 at 18:27)</a>:</h4>
<p>This code demonstrates a <code>has_Union</code> class that works for both <code>set</code> and <code>finset</code>. The only tradeoff seems to be that, like <code>big_operators</code>, you can only have one binder per union. So rather than <code>⋃ x y, f x y</code>, you have to write <code>⋃ x, ⋃ y, f x y</code>.</p>



<a name="268435409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268435409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268435409">(Jan 18 2022 at 18:28)</a>:</h4>
<p>It also works for bounded quantification, like <code>⋃ (x ∈ s), f x</code>.  To pull this off, there is a special identity function called <code>Union_binder</code> to help typeclass search know which arguments are meant to be binders.</p>



<a name="268435498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268435498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268435498">(Jan 18 2022 at 18:29)</a>:</h4>
<p>You can also do <code>⋃ (i &lt; 5), f i</code> as a <code>finset</code> union, which is fun.</p>



<a name="268435731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268435731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268435731">(Jan 18 2022 at 18:31)</a>:</h4>
<p>I haven't done any large tests of whether there are any further problems when it comes to rewrites -- this version does have the complication that to do a Union for <code>finset</code>, it has to do <code>s.attach.bUnion</code> rather than just <code>s.bUnion</code> universally, since it's not able to peer into the term to decide whether the union is dependent on the proof of finset membership.</p>



<a name="268436046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268436046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268436046">(Jan 18 2022 at 18:34)</a>:</h4>
<p>In principle, this technique seems like it should work for <code>big_operators</code>, too. That means we'd be able to write <code>∑ (x ∈ s), f x</code> instead of <code>∑ x in s, f x</code>.  However, that's with the caveat that the sum would be dependent on <code>x ∈ s</code>... The <code>∑ (x : α), f x</code> notation would have the same meaning as before.</p>



<a name="268439804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268439804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268439804">(Jan 18 2022 at 19:02)</a>:</h4>
<p>I'm not sure exactly why this additional instance would be necessary yet, but if you have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">finset_set</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">s</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_Union</span> <span class="o">(</span><span class="n">Union_binder</span> <span class="bp">$</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">Union_binder</span> <span class="bp">$</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Union</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">s.to_finset.attach.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">x.property</span><span class="o">))</span> <span class="o">}</span>
</code></pre></div>
<p>then you can do <code>finset</code> unions over finite <code>set</code>s:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">ι</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">s</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s.to_finset.bUnion</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">has_Union.Union</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>
<p>(similarly, we'd be able to do sums over finite <code>set</code>s)</p>



<a name="268441196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268441196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268441196">(Jan 18 2022 at 19:13)</a>:</h4>
<p>How does that interact with <a href="https://github.com/leanprover-community/mathlib/pull/11516">#11516</a>?</p>



<a name="268447411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268447411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268447411">(Jan 18 2022 at 20:00)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Oh good, you're already refactoring these things. I was going to ask you, actually, if you wanted to take this up and investigate whether we can switch over this (or something like it).</p>



<a name="268447618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268447618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268447618">(Jan 18 2022 at 20:02)</a>:</h4>
<p>For <code>set</code>, I am hoping that the only problem is that this setup doesn't have multi-index unions -- do you think that's a big loss?  There's probably some way to add them back in, but it's sort of brittle.</p>



<a name="268451230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268451230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268451230">(Jan 18 2022 at 20:30)</a>:</h4>
<p>What exactly are you expecting from this typeclass? I can think of a few things in this area:</p>
<ul>
<li>Homogeneize between <code>set</code> and <code>finset</code>. To me that's low priority, and I've actually worked against a bit as I'm trying to phase <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.bUnion">docs#finset.bUnion</a> out of existence in favor of <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sup">docs#finset.sup</a>. An alternative scenario would be to actually extend the <code>⨆</code>/<code>⨅</code> to finsets, in which case having <code>finset.bUnion</code>/<code>finset.bInter</code> could make sense, at least in notation.</li>
<li>Make bounded operators the primitive thing. Again, I've worked against that. <a href="https://github.com/leanprover-community/mathlib/pull/11516">#11516</a> is literally about ensuring the library really treats bounded operators as nested operators and not as things of their own.</li>
<li>Fix the conditional supremum/infimum. This, to me, is high priority, because currently bounded conditional supremums do not do what you expect.</li>
</ul>



<a name="268452283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268452283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268452283">(Jan 18 2022 at 20:39)</a>:</h4>
<p>I can already see a few problems with your implementation:</p>
<ul>
<li>It breaks the heuristic of how nested infinitary operators work. Well, big operators already do.</li>
<li>Your <code>set_bUnion</code> instance has <code>p : ι → Prop</code> rather than <code>p : ι → Sort*</code>. Easily fixable, I think?</li>
<li><code>finset.bUnion</code> doesn't translate to your notation. It is propeq to it but not defeq. And if it translates, where will the coercion in <code>example (s : finset ι) (f : ι → finset α) : set α := ⋃ i ∈ s, f i</code> be inserted?</li>
<li>It is using <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.range">docs#finset.range</a> rather than <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.Iio">docs#finset.Iio</a>. That should be easily fixable.</li>
<li>I expect it to be generally less robust than the current simpler implementation.</li>
</ul>



<a name="268452345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268452345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268452345">(Jan 18 2022 at 20:40)</a>:</h4>
<p>I'd like there to be a uniform style of interface for various fold-like operations on sets, finsets, potentially multisets, and so on.</p>
<p>Unions/intersections are one test for this, but of course Sup/Inf would be great, too. Sums and products are another target, to give more freedom for what we are summing over (we could sum over a multiset with multiplicity).</p>



<a name="268454263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bUnion%20for%20set/near/268454263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bUnion.20for.20set.html#268454263">(Jan 18 2022 at 20:57)</a>:</h4>
<blockquote>
<ul>
<li>It breaks the heuristic of how nested infinitary operators work. Well, big operators already do.</li>
</ul>
</blockquote>
<p>Yes, when I said "this setup doesn't have multi-index unions" that's what I was referring to -- do you think this is a big loss?</p>
<blockquote>
<ul>
<li>Your <code>set_bUnion</code> instance has <code>p : ι → Prop</code> rather than <code>p : ι → Sort*</code>. Easily fixable, I think?</li>
</ul>
</blockquote>
<p>Why would it be <code>Sort*</code>-valued? I mean, it could be, but the point of that instance is for bounded unions.</p>
<blockquote>
<ul>
<li><code>finset.bUnion</code> doesn't translate to your notation. It is propeq to it but not defeq. And if it translates, where will the coercion in <code>example (s : finset ι) (f : ι → finset α) : set α := ⋃ i ∈ s, f i</code> be inserted?</li>
</ul>
</blockquote>
<p>I didn't think it was high-priority for it to <em>be</em> <code>finset.bUnion</code>, so I'm not sure non-defeq is a problem here (as you said, you're wanting to phase out <code>finset.bUnion</code>).</p>
<p>For your example, you need to choose the interpretation with a type ascription with the way the code currently is written:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">⋃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>
<blockquote>
<ul>
<li>It is using <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.range">docs#finset.range</a> rather than <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.Iio">docs#finset.Iio</a>. That should be easily fixable.</li>
</ul>
</blockquote>
<p>That's the sort of thing why I was going to ask you whether you'd look into this -- you've been looking at lattices and have done a lot with intervals. This is only a proof-of-concept.</p>
<blockquote>
<ul>
<li>I expect it to be generally less robust than the current simpler implementation.</li>
</ul>
</blockquote>
<p>Please get back with examples where it's less robust, and hopefully they can be fixed. In any case, maybe even if it might be less robust, having a uniform interface for these things will help with ergonomics/usability across mathlib, so on balance it might still be better than what we have.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html">Obtain isomorphism from short exact sequence</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="309479374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309479374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309479374">(Nov 13 2022 at 17:19)</a>:</h4>
<p>I've been working on filling out some of the API around <a href="https://en.wikipedia.org/wiki/Dual_space#Quotient_spaces_and_annihilators">dual annihilators</a> of submodules, and an isomorphism that would be nice to have is that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>V</mi><mi mathvariant="normal">/</mi><mi>W</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo>≈</mo><mi mathvariant="normal">ann</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(V/W)^* \approx \operatorname{ann}(W)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">ann</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">)</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> is a subspace of a vector space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>.</p>
<p>The argument I was thinking of is that you can take the short exact sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>→</mo><mi>W</mi><mo>→</mo><mi>V</mi><mo>→</mo><mi>V</mi><mi mathvariant="normal">/</mi><mi>W</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \to W \to V \to V/W \to 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, dualize it to get <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>→</mo><mo stretchy="false">(</mo><mi>V</mi><mi mathvariant="normal">/</mi><mi>W</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup><mo>→</mo><msup><mi>W</mi><mo>∗</mo></msup><mo>→</mo><msup><mi>V</mi><mo>∗</mo></msup><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \to (V/W)^* \to W^* \to V^* \to 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, and then identify <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>V</mi><mi mathvariant="normal">/</mi><mi>W</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">(V/W)^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> with the kernel of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mo>∗</mo></msup><mo>→</mo><msup><mi>V</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">W^* \to V^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>, which happens to be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ann</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{ann}(W)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">ann</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">)</span></span></span></span> by definition.</p>
<p>This is where I'm working: <a href="https://github.com/leanprover-community/mathlib/pull/17521/files#diff-44f047eef7a6b2bf415612b8834b73544a7697e940b4b7f81e5359560e28ab7cR936">https://github.com/leanprover-community/mathlib/pull/17521/files#diff-44f047eef7a6b2bf415612b8834b73544a7697e940b4b7f81e5359560e28ab7cR936</a></p>
<p>Here's the sorried definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.dual</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">V₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V₁</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">K</span> <span class="n">V₁</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">dual_quot_equiv_dual_annihilator</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">K</span> <span class="n">V₁</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">module.dual</span> <span class="n">K</span> <span class="o">(</span><span class="n">V₁</span> <span class="bp">⧸</span> <span class="n">W</span><span class="o">)</span> <span class="bp">≃ₗ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">W.dual_annihilator</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="309480068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309480068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309480068">(Nov 13 2022 at 17:27)</a>:</h4>
<p>While the high-powered fact is that taking duals of vector spaces is an exact functor so colimits become limits, maybe there's an easier construction that comes from pre-existing linear algebra in mathlib?</p>



<a name="309483255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309483255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309483255">(Nov 13 2022 at 17:57)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I think I proved this result in <a href="https://github.com/adamtopaz/lean-acl-pairs">https://github.com/adamtopaz/lean-acl-pairs</a></p>



<a name="309483323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309483323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309483323">(Nov 13 2022 at 17:58)</a>:</h4>
<p>I was planning to put the general duality stuff proved there in mathlib, but haven't gotten to it yet</p>



<a name="309490250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309490250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309490250">(Nov 13 2022 at 19:11)</a>:</h4>
<p>No need of <code>field</code> here, <code>comm_ring</code> suffices (and no need of (dualizing) exact sequences, it's pretty much by definition):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.dual</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">V₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V₁</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">K</span> <span class="n">V₁</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">dual_quot_equiv_dual_annihilator</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">K</span> <span class="n">V₁</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">module.dual</span> <span class="n">K</span> <span class="o">(</span><span class="n">V₁</span> <span class="bp">⧸</span> <span class="n">W</span><span class="o">)</span> <span class="bp">≃ₗ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">W.dual_annihilator</span> <span class="o">:=</span>
<span class="n">linear_equiv.of_linear</span>
  <span class="o">(</span><span class="n">linear_map.cod_restrict</span> <span class="n">_</span> <span class="o">(</span><span class="n">module.dual.transpose</span> <span class="n">W.mkq</span><span class="o">)</span> <span class="bp">$</span>
    <span class="bp">λ</span> <span class="n">φ</span><span class="o">,</span> <span class="o">(</span><span class="n">submodule.mem_dual_annihilator</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">$</span>
    <span class="bp">λ</span> <span class="n">w</span> <span class="n">hw</span><span class="o">,</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">φ</span> <span class="bp">$</span> <span class="n">W</span><span class="bp">^.</span><span class="n">quotient.mk_eq_zero.2</span> <span class="n">hw</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">φ.map_zero</span><span class="o">)</span>
  <span class="o">(</span><span class="n">linear_map.flip</span> <span class="bp">$</span> <span class="n">W.liftq</span> <span class="o">(</span><span class="n">linear_map.dom_restrict</span> <span class="o">(</span><span class="n">module.dual_pairing</span> <span class="n">K</span> <span class="n">V₁</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span> <span class="bp">$</span>
    <span class="bp">λ</span> <span class="n">w</span> <span class="n">hw</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="o">⟨</span><span class="n">φ</span><span class="o">,</span> <span class="n">hφ</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">submodule.mem_dual_annihilator</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hφ</span> <span class="n">w</span> <span class="n">hw</span> <span class="o">})</span>
  <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">refl</span> <span class="o">})</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">refl</span> <span class="o">})</span>
</code></pre></div>



<a name="309491682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309491682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309491682">(Nov 13 2022 at 19:27)</a>:</h4>
<p>You need <code>field</code> (or some projectivity assumption) for the cokernel on the dual side.</p>



<a name="309492135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309492135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309492135">(Nov 13 2022 at 19:31)</a>:</h4>
<p>In general, <code>V₁ ⧸ W →ₗ[K] V</code> can be identified with a <code>K</code>-submodule of <code>V₁ →ₗ[K] V</code>. More generally, if <code>U →ₗ[K] V</code> is surjective then the induced map <code>(V →ₗ[K] W) →ₗ[K] (U →ₗ[K] W)</code> is injective for any <code>W</code>, so we can identify <code>V →ₗ[K] W</code> with a K-submodule of <code>U →ₗ[K] W</code>.</p>
<p>By the way, <code>W* → V*</code> should be <code>V* → W*</code> in the first post.</p>



<a name="309492228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309492228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309492228">(Nov 13 2022 at 19:32)</a>:</h4>
<blockquote>
<p>You need field (or some projectivity assumption) for the cokernel on the dual side.</p>
</blockquote>
<p>Where is cokernel on the dual side used? In your repo or in Kyle's work?</p>



<a name="309492344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309492344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309492344">(Nov 13 2022 at 19:34)</a>:</h4>
<p>Oh I don't think it appears in the original post. Or in the repo. I just mentioned this because it's part of having a "good" duality theory. You want quotients in the dual to correspond to submodules in the original module, and vice versa.</p>



<a name="309494381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309494381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309494381">(Nov 13 2022 at 19:57)</a>:</h4>
<p>I think it's actually an interesting question regarding how to best set up such "duality" theories. In the case that I needed for my repo linked above, I had a vector space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> over a field <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>, and, essentially, obtained a duality between quotients of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> and closed (w.r.t. the weak topology) subspaces of the dual. I'm sure the functional analysts have developed a general approach to such things... does anyone know of a good reference for this?</p>



<a name="309499923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309499923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309499923">(Nov 13 2022 at 21:10)</a>:</h4>
<p>Section IV.1.4 in Bourbaki TVS seems to be related, but there are probably ways to make it way easier for the special case of the weak dual topology.</p>



<a name="309910638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309910638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309910638">(Nov 14 2022 at 17:21)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="224323">@Junyan Xu</span>!</p>
<p>I extracted this characterization you mentioned of the dual annihilator as a quick corollary of the equivalence:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">range_dual_map_mkq_eq_dual_annihilator</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">submodule.mkq</span> <span class="n">W</span><span class="o">)</span><span class="bp">.</span><span class="n">dual_map.range</span> <span class="bp">=</span> <span class="n">W.dual_annihilator</span>
</code></pre></div>
<p>In <a href="https://github.com/leanprover-community/mathlib/pull/17521">#17521</a> I also have the following lemma for vector spaces</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">range_dual_map_eq_dual_annihilator_ker</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">V₁</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">V₂</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.dual_map.range</span> <span class="bp">=</span> <span class="n">f.ker.dual_annihilator</span>
</code></pre></div>
<p>Do you think this could be generalized to commutative rings as well? I've already added a version for when <code>f</code> is a surjection as a corollary to <code>range_dual_map_mkq_eq_dual_annihilator</code>.</p>



<a name="309917600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309917600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309917600">(Nov 14 2022 at 17:58)</a>:</h4>
<p>Looks nice! I think you can get <code>f.dual_map.range ≤ f.ker.dual_annihilator</code> but for the other direction you can only get a R-linear functional on <code>V₁ ⧸ f.ker</code> but can't necessarily extend it to a functional on <code>V₂</code>.</p>



<a name="309917672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309917672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309917672">(Nov 14 2022 at 17:58)</a>:</h4>
<p>Yeah, I just realized it doesn't generalize. For example, the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="double-struck">Z</mi><mo>→</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">f : \mathbb{Z}\to\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span> from multiplication by two.</p>



<a name="309917722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309917722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309917722">(Nov 14 2022 at 17:58)</a>:</h4>
<p>you need projectivity :)</p>



<a name="309919271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309919271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309919271">(Nov 14 2022 at 18:06)</a>:</h4>
<p>Yeah, you can prove it with a very weak form of projectivity:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">range_dual_map_eq_dual_annihilator_ker</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M'</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="o">((</span><span class="n">linear_map.range</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">subtype.dual_map</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">f.dual_map.range</span> <span class="bp">=</span> <span class="n">f.ker.dual_annihilator</span> <span class="o">:=</span>
</code></pre></div>
<div class="spoiler-block"><div class="spoiler-header">
<p>proof</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="k">have</span> <span class="n">rr_surj</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">f.range_restrict</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">linear_map.range_eq_top</span><span class="o">,</span> <span class="n">linear_map.range_range_restrict</span><span class="o">]</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">range_dual_map_eq_dual_annihilator_ker_of_surjective</span> <span class="n">f.range_restrict</span> <span class="n">rr_surj</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">this</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">transitivity</span> <span class="o">((</span><span class="n">submodule.subtype</span> <span class="n">f.range</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">f.range_restrict</span><span class="o">)</span><span class="bp">.</span><span class="n">dual_map.range</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">linear_map.dual_map_comp_dual_map</span><span class="o">,</span> <span class="n">linear_map.range_comp_of_range_eq_top</span><span class="o">],</span>
    <span class="n">rwa</span> <span class="n">linear_map.range_eq_top</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">linear_map.ker_range_restrict</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="309919624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309919624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309919624">(Nov 14 2022 at 18:08)</a>:</h4>
<p>That's probably useful as is (using a surjectivity assumption) but I think it's worthwhile to formulate a lemma using <a href="https://leanprover-community.github.io/mathlib_docs/find/module.projective">docs#module.projective</a> as well, since that's a typeclass, and any module over a field is projective</p>



<a name="309919675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309919675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309919675">(Nov 14 2022 at 18:09)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> That inequality is very easy in comparison and works for commutative semirings too. It looks like @JasonKYi added it two years ago (thanks!)</p>



<a name="309920037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309920037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309920037">(Nov 14 2022 at 18:10)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> I wasn't sure I was going to include it in the PR since the condition is rather technical and I don't need any of this (I'm just trying to add everything that might be considered to be basic theory for dual annihilators to check off the "orthogonality" item off the undergrad list!), but a projective version seems reasonable, though perhaps not to undergrads</p>



<a name="309920344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309920344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309920344">(Nov 14 2022 at 18:12)</a>:</h4>
<p>Hmm, <code>module.projective</code> isn't available in <code>linear_algebra/dual</code>. Would it be bad to import it?</p>



<a name="309920757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309920757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309920757">(Nov 14 2022 at 18:14)</a>:</h4>
<p>Given what we've been seeing in the lower parts of the import graph lately, I would suggest this import is "bad".</p>



<a name="309920822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309920822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309920822">(Nov 14 2022 at 18:14)</a>:</h4>
<p>A priori, <code>projective</code> and <code>dual</code> seem orthogonal concepts. So neither should import the other.</p>



<a name="309920879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309920879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309920879">(Nov 14 2022 at 18:15)</a>:</h4>
<p>I don't know what their lub should be though.</p>



<a name="309920927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309920927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309920927">(Nov 14 2022 at 18:15)</a>:</h4>
<p>Maybe there should be a separate file for some sort of "duality theory" (and perhaps the current <code>dual</code> should be renamed)?</p>



<a name="309921148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309921148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309921148">(Nov 14 2022 at 18:16)</a>:</h4>
<p>OTOH, I would guess that <code>dual</code> is pretty close to being a leaf in the import tree</p>



<a name="309922307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309922307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309922307">(Nov 14 2022 at 18:22)</a>:</h4>
<p>Actually, I'm getting confused. Is projectivity the right concept, or is it injectivity? It seems like <code>function.surjective f.range.subtype.dual_map</code> is true if <code>R</code> is an injective <code>R</code>-module.</p>



<a name="309922462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309922462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309922462">(Nov 14 2022 at 18:23)</a>:</h4>
<p>You just need an Ext term to vanish, so you can either assume the ring is injective, or some module is projective</p>



<a name="309922772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309922772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309922772">(Nov 14 2022 at 18:24)</a>:</h4>
<p>What about the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="double-struck">Z</mi><mo>→</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">f:\mathbb{Z}\to\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span> example where it's multiplication by 2? All of these are projective <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span>-modules.</p>



<a name="309923033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309923033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309923033">(Nov 14 2022 at 18:25)</a>:</h4>
<p>But the cokernel isnt</p>



<a name="309923139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309923139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309923139">(Nov 14 2022 at 18:26)</a>:</h4>
<p>The issue is that Z/2 is not projective</p>



<a name="309925069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309925069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309925069">(Nov 14 2022 at 18:36)</a>:</h4>
<p>Note that at least for domains <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-module <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is injective if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is a field, so I think using a projectivity assumption on the quotient would be more useful in more cases.</p>



<a name="309925706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309925706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309925706">(Nov 14 2022 at 18:39)</a>:</h4>
<p>For now, I'll leave the PR with this technical version, and maybe I'll look into where to put a projective version (maybe one answer is to add a lemma that gives this surjectivity assumption given projectivity of the cokernel?)</p>



<a name="309925986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309925986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309925986">(Nov 14 2022 at 18:40)</a>:</h4>
<p>Here's another question. I've got</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">dual_annihilator_infi_eq</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">_root_.finite</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">submodule</span> <span class="n">K</span> <span class="n">V₁</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⨅</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">W</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">dual_annihilator</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">⨆</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="o">(</span><span class="n">W</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">dual_annihilator</span><span class="o">)</span>
</code></pre></div>
<p>with this finiteness condition. It's surely true in more cases (like probably if <code>W</code> is a cofiltered family). Is there an obviously good condition to state?</p>



<a name="309926149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309926149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309926149">(Nov 14 2022 at 18:41)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.dual_annihilator">docs#submodule.dual_annihilator</a></p>



<a name="309926275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309926275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309926275">(Nov 14 2022 at 18:42)</a>:</h4>
<p>right, in general there is some (topological) closure that needs to happen as well.</p>



<a name="309926313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309926313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309926313">(Nov 14 2022 at 18:42)</a>:</h4>
<p>I'm very tempted to leave this with a finite indexing type, or at best see if when the vector space is finite-dimensional then there is good API for restricting infinite indexing sets to equivalent finite ones.</p>



<a name="309927586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309927586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309927586">(Nov 14 2022 at 18:49)</a>:</h4>
<p>It should be easy to obtain an inclusion in one direction in the general case. Maybe that's enough for now?</p>



<a name="309928113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/309928113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#309928113">(Nov 14 2022 at 18:52)</a>:</h4>
<p>Yeah, <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.supr_dual_annihilator_le_infi">docs#submodule.supr_dual_annihilator_le_infi</a> was straightforward.</p>



<a name="310083421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/310083421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#310083421">(Nov 14 2022 at 21:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence/near/309920822">said</a>:</p>
<blockquote>
<p>A priori, <code>projective</code> and <code>dual</code> seem orthogonal concepts. So neither should import the other.</p>
</blockquote>
<p>Yes probably we should add another file, but I've previously noticed that a lot of stuff around dual and contraction <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/280956947">could be generalized</a> from finite free modules to finite projective modules, so they would need to be moved to the new file when generalized. Also note that projective modules of rank 1 are invertible sheaves / line bundles, and the dual is the inverse. For Dedekind domains all nonzero ideals are projective (invertible). So there's definitely a lot of overlapping theory to be developed.</p>
<p>About the generalization from comm_ring to comm_semiring: It's <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.has_quotient">docs#submodule.has_quotient</a> that requires [ring R], and we should probably generalize it as well. (If there's an initial ring that a semiring maps to (not sure if one of commutativity and addition cancellativity is needed) then we may use that, but that's more complicated and the construction isn't in mathlib AFAIK.)</p>



<a name="310087012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Obtain%20isomorphism%20from%20short%20exact%20sequence/near/310087012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence.html#310087012">(Nov 14 2022 at 21:40)</a>:</h4>
<p>I think that rather than generalizing by hand a lot of stuff from free to projective modules, what we should do is to prove that these properties are local for the Zariski topology (and characterize projective modules, something is not in mathlib I am afraid).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
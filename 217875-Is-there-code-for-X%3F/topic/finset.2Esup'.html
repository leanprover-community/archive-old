---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html">finset.sup'</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="234105824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234105824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234105824">(Apr 12 2021 at 05:39)</a>:</h4>
<p>No one has <code>finset.sup'</code> (for nonempty finsets, but only requiring <code>semilattice_sup</code> rather than <code>semilattice_sup_bot</code>) up their sleeves, do they? It seems like an obvious omission, but I'm not so keen to go fill it in right now. :-)</p>



<a name="234106076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234106076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234106076">(Apr 12 2021 at 05:43)</a>:</h4>
<p>There's a recent open PR for this</p>



<a name="234106128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234106128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234106128">(Apr 12 2021 at 05:44)</a>:</h4>
<p>I better go review it! :-)</p>



<a name="234106187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234106187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234106187">(Apr 12 2021 at 05:45)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7087">#7087</a></p>



<a name="234106523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234106523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234106523">(Apr 12 2021 at 05:49)</a>:</h4>
<p>It already looks in great shape. (Thanks, <span class="user-mention" data-user-id="111433">@Alistair Tucker</span>, for having exactly what I wanted ready. :-)</p>



<a name="234106635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234106635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234106635">(Apr 12 2021 at 05:51)</a>:</h4>
<p><img alt=":merge:" class="emoji" src="https://zulip-avatars.s3.amazonaws.com/3121/emoji/images/18527.png" title="merge"></p>



<a name="234108090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234108090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234108090">(Apr 12 2021 at 06:11)</a>:</h4>
<p>That PR raises an omission in our naming guide, with <code>finset.of_sup_of_forall</code> - how should lemmas be named when their conclusion is <code>p (f x)</code>, where <code>p</code> is an argument passed to the lemma?</p>



<a name="234110166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234110166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234110166">(Apr 12 2021 at 06:39)</a>:</h4>
<p>That theorem actually looks like an induction principle. I would call it <code>sup_induction</code> or something like that</p>



<a name="234126336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234126336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234126336">(Apr 12 2021 at 09:08)</a>:</h4>
<p><span class="user-mention" data-user-id="111433">@Alistair Tucker</span>, I'm finding I need</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">lt_sup'_iff</span> <span class="o">[</span><span class="n">is_total</span> <span class="n">α</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">s.sup'</span> <span class="n">H</span> <span class="n">f</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>Any chance you want to do the <code>le</code> version, and the <code>inf'</code> analogues?</p>



<a name="234126373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234126373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234126373">(Apr 12 2021 at 09:09)</a>:</h4>
<p>I have a terrible proof of the above...</p>



<a name="234130503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234130503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234130503">(Apr 12 2021 at 09:45)</a>:</h4>
<p>How do you feel about this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semilattice_sup</span> <span class="n">α</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">finset</span>

<span class="kd">lemma</span> <span class="n">sup_of_mem</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">s.sup</span> <span class="o">(</span><span class="n">coe</span> <span class="bp">∘</span> <span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">with_bot</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">finset.sup'</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">option.get</span> <span class="bp">$</span> <span class="k">let</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">H</span> <span class="k">in</span> <span class="n">option.is_some_iff_exists.2</span> <span class="o">(</span><span class="n">sup_of_mem</span> <span class="n">f</span> <span class="n">hb</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">sup'_le</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">s.sup'</span> <span class="n">H</span> <span class="n">f</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">sup'_le_iff</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">s.sup'</span> <span class="n">H</span> <span class="n">f</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">not_lt'</span> <span class="o">[</span><span class="n">is_total</span> <span class="n">α</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">total_of</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h1</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">h1.lt_or_eq.resolve_left</span> <span class="n">h</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">h1</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">total_of</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h1</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">le_antisymm</span> <span class="n">h</span> <span class="n">h1</span><span class="o">,</span> <span class="n">apply</span> <span class="n">lt_irrefl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">not_lt_of_le</span> <span class="n">h</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">lt_sup'_iff</span> <span class="o">[</span><span class="n">is_total</span> <span class="n">α</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">s.sup'</span> <span class="n">H</span> <span class="n">f</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">a</span> <span class="bp">&lt;</span> <span class="n">s.sup'</span> <span class="n">H</span> <span class="n">f</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="o">(</span><span class="bp">∃</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">b</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">not_congr</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="o">[</span><span class="n">not_not</span><span class="o">,</span> <span class="n">not_not</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span> <span class="o">},</span>
  <span class="n">push_neg</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">not_lt'</span><span class="o">,</span> <span class="n">sup'_le_iff</span> <span class="n">H</span> <span class="n">f</span><span class="o">]</span>
<span class="kd">end</span>
</code></pre></div>



<a name="234131149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234131149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234131149">(Apr 12 2021 at 09:50)</a>:</h4>
<p>Why doesn't <a href="https://leanprover-community.github.io/mathlib_docs/find/not_lt">docs#not_lt</a> work for you there? Do we have examples where <code>[is_total α (≤)]</code> but not <code>[linear_order α]</code>?</p>



<a name="234132043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234132043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234132043">(Apr 12 2021 at 09:58)</a>:</h4>
<p><code>not_lt'</code> golfs slightly to:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">not_lt'</span> <span class="o">[</span><span class="n">semilattice_sup</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">is_total</span> <span class="n">α</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">not_lt</span> <span class="n">_</span> <span class="o">{</span>
  <span class="n">le_total</span> <span class="o">:=</span> <span class="n">is_total.total</span><span class="o">,</span>
  <span class="n">decidable_le</span> <span class="o">:=</span> <span class="n">classical.dec_rel</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">decidable_eq</span> <span class="o">:=</span> <span class="n">classical.dec_eq</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">decidable_lt</span> <span class="o">:=</span> <span class="n">classical.dec_rel</span> <span class="n">_</span><span class="o">,</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">α</span><span class="o">)</span> <span class="o">}</span> <span class="n">_</span> <span class="n">_</span>
</code></pre></div>



<a name="234132172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234132172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234132172">(Apr 12 2021 at 09:59)</a>:</h4>
<p>But this feels silly, because</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">semilattice_sup</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">infer_instance</span>
</code></pre></div>



<a name="234132262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234132262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234132262">(Apr 12 2021 at 10:00)</a>:</h4>
<p>So I think <code>is_total</code> is probably a wrong turn in <span class="user-mention" data-user-id="110087">@Scott Morrison</span>'s requested statement</p>



<a name="234134135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234134135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234134135">(Apr 12 2021 at 10:17)</a>:</h4>
<p>It's nicer with <code>linear_order</code>, definitely.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">lt_sup'_iff</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">s.sup'</span> <span class="n">H</span> <span class="n">f</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="o">{</span> <span class="n">contrapose</span><span class="bp">!</span><span class="o">,</span> <span class="n">rw</span> <span class="n">sup'_le_iff</span> <span class="n">H</span> <span class="n">f</span><span class="o">,</span> <span class="n">exact</span> <span class="n">id</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>Even better if <code>contrapose</code> handled iffs</p>



<a name="234140609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234140609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234140609">(Apr 12 2021 at 11:17)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="307953">@Ruben Van de Velde</span>, that's nice! I can roll this, and the variations, into an upcoming PR, unless you feel like getting to them first!</p>



<a name="234141017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234141017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234141017">(Apr 12 2021 at 11:21)</a>:</h4>
<p>No, go for it</p>



<a name="234142566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234142566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234142566">(Apr 12 2021 at 11:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/finset.2Esup'/near/234131149">said</a>:</p>
<blockquote>
<p>Why doesn't <a href="https://leanprover-community.github.io/mathlib_docs/find/not_lt">docs#not_lt</a> work for you there? Do we have examples where <code>[is_total α (≤)]</code> but not <code>[linear_order α]</code>?</p>
</blockquote>
<p>I don't know if we have examples in mathlib yet but it's not hard to come up with examples in maths - Peter mentioned one a couple of days ago: consider the order given by <code>inv_image</code> where the target is a linear order, then the new order is a total preorder but it's not antisymmetric</p>



<a name="234149469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234149469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234149469">(Apr 12 2021 at 12:37)</a>:</h4>
<p>In the example above there was already a <code>[semilattice_sup α]</code> assumption - but I see I didn't make it clear in that question</p>



<a name="234176904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234176904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234176904">(Apr 12 2021 at 15:12)</a>:</h4>
<p>Following the pattern in the rest of the file, one would first prove that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lt_sup_iff</span> <span class="o">[</span><span class="n">is_total</span> <span class="n">α</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">s.sup</span> <span class="n">f</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>
<p>(It should be in there anyway for completeness.) Then it's pretty straightforward to do a version for <code>sup'</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lt_sup'_iff</span> <span class="o">[</span><span class="n">is_total</span> <span class="n">α</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">s.sup'</span> <span class="n">H</span> <span class="n">f</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">with_bot.coe_lt_coe</span><span class="o">,</span> <span class="n">coe_sup'</span><span class="o">,</span> <span class="n">lt_sup_iff</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">bex_congr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">with_bot.coe_lt_coe</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="234177128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234177128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234177128">(Apr 12 2021 at 15:13)</a>:</h4>
<p>There was some reason why I had to go down the <code>is_total</code> route rather than <code>linear_order</code> but I can't remember right now</p>



<a name="234178608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234178608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234178608">(Apr 12 2021 at 15:21)</a>:</h4>
<p>I would probably have proved <code>lt_sup_iff</code> by induction like so</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lt_sup_iff</span> <span class="o">[</span><span class="n">is_total</span> <span class="n">α</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">s.sup</span> <span class="n">f</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">s</span> <span class="n">using</span> <span class="n">finset.cons_induction</span> <span class="k">with</span> <span class="n">b</span> <span class="n">s</span> <span class="n">hb</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">false.elim</span> <span class="o">(</span><span class="n">not_lt_bot</span> <span class="n">h</span><span class="o">),</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">sup_cons</span><span class="o">,</span> <span class="n">_root_.lt_sup_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">mem_cons.2</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">rfl</span><span class="o">),</span> <span class="n">h</span><span class="o">⟩,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rcases</span> <span class="n">ih</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">hlt</span><span class="o">⟩,</span>
        <span class="n">exact</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">mem_cons.2</span> <span class="o">(</span><span class="n">or.inr</span> <span class="n">hc</span><span class="o">),</span> <span class="n">hlt</span><span class="o">⟩,</span> <span class="o">},</span> <span class="o">},</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">hlt</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">lt_of_lt_of_le</span> <span class="n">hlt</span> <span class="o">(</span><span class="n">le_sup</span> <span class="n">hb</span><span class="o">),</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>But maybe Ruben's proof points to a better way... let me check.</p>



<a name="234188522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234188522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234188522">(Apr 12 2021 at 16:23)</a>:</h4>
<p>You probably went down the <code>is_total</code> route because <code>[linear_order α] [semilattice_sup α]</code> introduced two different <code>has_le</code>s</p>



<a name="234188690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234188690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234188690">(Apr 12 2021 at 16:25)</a>:</h4>
<p>But <code>[linear_order α]</code> by itself induces a <code>semilattice_sup α</code> anyway, so there's no need for both</p>



<a name="234193054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234193054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234193054">(Apr 12 2021 at 16:53)</a>:</h4>
<p>I've made a branch for this. Based on Ruben's proof although it turns out there is such a thing as <code>as_linear_order</code> which makes it considerably shorter. <span class="user-mention" data-user-id="307953">@Ruben Van de Velde</span> or <span class="user-mention" data-user-id="310045">@Eric Wieser</span> would either of you like to make changes and/or a PR? I suppose Scott will be asleep atm.</p>



<a name="234193160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234193160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234193160">(Apr 12 2021 at 16:54)</a>:</h4>
<p>Oops <a href="https://github.com/leanprover-community/mathlib/tree/lt_sup_iff">https://github.com/leanprover-community/mathlib/tree/lt_sup_iff</a></p>



<a name="234193483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234193483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234193483">(Apr 12 2021 at 16:56)</a>:</h4>
<blockquote>
<p>You probably went down the <code>is_total route</code> because...</p>
</blockquote>
<p>Maybe something about having <code>bot</code>? I'll check later</p>



<a name="234193760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234193760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234193760">(Apr 12 2021 at 16:58)</a>:</h4>
<p>I'd missed that your last PR already added the <code>is_total</code> arguments  - I'll play with removing them</p>



<a name="234193792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234193792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234193792">(Apr 12 2021 at 16:58)</a>:</h4>
<p>Do we have those arguments on lemmas about <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.max'">docs#finset.max'</a>?</p>



<a name="234194785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234194785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234194785">(Apr 12 2021 at 17:04)</a>:</h4>
<p>Oh you're right, <code>bot</code> is indeed the issue</p>



<a name="234195008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234195008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234195008">(Apr 12 2021 at 17:05)</a>:</h4>
<p>Which was needed for <code>sup</code>, but not <code>sup'</code></p>



<a name="234195828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234195828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234195828">(Apr 12 2021 at 17:11)</a>:</h4>
<p>But <code>sup</code> is still a mess for similar reasons. Perhaps we should have a <code>linear_order_bot</code> and <code>linear_order_top</code> class, to sit between <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_order">docs#linear_order</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/complete_linear_order">docs#complete_linear_order</a>?</p>



<a name="234208775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234208775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234208775">(Apr 12 2021 at 18:36)</a>:</h4>
<p>When I was a lad back in 2017, there was just lattice, semilattice_sup_bot, semilattice_inf_top, conditionally_complete_lattice, and then complete_lattice. Then people wanted semilattice_sup_top and semilattice_inf_bot, and now we're getting variants with total orders. Similarly we now seem to have monoids with 0, add_monoids with 1 and so on. My impression is that given any subset of the set of all notation coming up in the topological hierarchy, sooner or later someone will want an object which has all of the subset but nothing else, because their favourite mathematical object has precisely this subset but not the rest. The same is happening in the algebraic heirarchy -- all this distrib_mul_action stuff is what you get with + and * but no 0 or 1, for example, with added heterogeneous issues thrown in. People seem really reluctant to pull off everything into pieces, because then complete_lattice would extend has_bot, has_top, has_sup, has_Sup, has_inf, has_Inf and then there would be a gazillion Props on top. But my impression is that this is somehow the way we're moving. Is there some more principled way of doing this stuff rather than just inventing 2^N new typeclasses?</p>



<a name="234227340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234227340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234227340">(Apr 12 2021 at 20:45)</a>:</h4>
<p>I believe that the defs in core around <a href="https://leanprover-community.github.io/mathlib_docs/find/is_total/src">src#is_total</a> was an attempt at such a principled approach - there seems to be an <code>@[algebra]</code> attribute for some feature that I can only assume never materialized.</p>



<a name="234279850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234279850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234279850">(Apr 13 2021 at 07:19)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span>  So should we regard <code>is_total</code> as a great thing or as an outdated piece of junk? You don't seem to approve of it but for example a version of <code>exists_mem_eq_sup</code> written for <code>[semilattice_sup_bot α] [is_total α (≤)]</code> instead of <code>[complete_linear_order  α ]</code> would resolve the problem with <code>ℕ</code> that cropped up in this thread <a href="#narrow/stream/113489-new-members/topic/strict.20instance.20requirement">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/strict.20instance.20requirement</a>.</p>



<a name="234280025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280025">(Apr 13 2021 at 07:21)</a>:</h4>
<p>I'm no longer sure</p>



<a name="234280173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280173">(Apr 13 2021 at 07:23)</a>:</h4>
<p>It's useful when working with general relations that aren't the le on the type</p>



<a name="234280216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280216">(Apr 13 2021 at 07:23)</a>:</h4>
<p>If <code>is_total (\le)</code> is a good thing, then we should change as many lemmas as possible to use it instead of linear_order</p>



<a name="234280320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280320">(Apr 13 2021 at 07:24)</a>:</h4>
<p>A total semilattice is a lattice</p>



<a name="234280331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280331">(Apr 13 2021 at 07:24)</a>:</h4>
<p>in fact it is a linear order</p>



<a name="234280430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280430">(Apr 13 2021 at 07:25)</a>:</h4>
<p>Maybe we need <code>linear_order_bot</code>?</p>



<a name="234280495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280495">(Apr 13 2021 at 07:26)</a>:</h4>
<p>Either we need that, or we need to switch to using is_total as a mixing for totality</p>



<a name="234280543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280543">(Apr 13 2021 at 07:26)</a>:</h4>
<p>how many theorems need this combo?</p>



<a name="234280549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280549">(Apr 13 2021 at 07:27)</a>:</h4>
<p>Currently we're in a middle ground where we have to switch between the two and end up reproving things like <code>not_lt_iff</code> as happened up thread</p>



<a name="234280587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280587">(Apr 13 2021 at 07:27)</a>:</h4>
<p>I think I found 2 within finset.lattice, and another two for the top version</p>



<a name="234280635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280635">(Apr 13 2021 at 07:27)</a>:</h4>
<p>if it's only those then I guess the <code>is_total</code> mixin is fine</p>



<a name="234280706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280706">(Apr 13 2021 at 07:28)</a>:</h4>
<p>I haven't searched mathlib-wide</p>



<a name="234280750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280750">(Apr 13 2021 at 07:28)</a>:</h4>
<p>That's okay, you can just convert lemmas when you find them / need them</p>



<a name="234280846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234280846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234280846">(Apr 13 2021 at 07:29)</a>:</h4>
<p>Looking <code>is_total</code> up is more expensive since it's two typeclass searches with one dependent on the other, so I don't think we want to use too many mixins</p>



<a name="234282458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finset.sup%27/near/234282458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finset.2Esup'.html#234282458">(Apr 13 2021 at 07:44)</a>:</h4>
<p>Doesn't the dependency make it less expensive?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
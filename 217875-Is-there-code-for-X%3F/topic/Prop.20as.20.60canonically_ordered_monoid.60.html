---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html">Prop as `canonically_ordered_monoid`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="298294813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Prop%20as%20%60canonically_ordered_monoid%60/near/298294813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html#298294813">(Sep 11 2022 at 22:24)</a>:</h4>
<p>Do we have something like this? Of course it's non-standard to use <code>+</code> to denote <code>or</code>, but that's better than <code>*</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="kt">Prop</span><span class="bp">.</span><span class="n">canonically_ordered_add_monoid</span> <span class="o">:</span> <span class="n">canonically_ordered_add_monoid</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∨</span><span class="o">),</span>
  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">_</span><span class="o">,</span> <span class="n">propext</span> <span class="o">(</span><span class="n">or_assoc</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="n">false</span><span class="o">,</span>
  <span class="n">zero_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">propext</span> <span class="o">(</span><span class="n">false_or</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">add_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">propext</span> <span class="o">(</span><span class="n">or_false</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">add_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">propext</span> <span class="o">(</span><span class="n">or_comm</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">bot</span> <span class="o">:=</span> <span class="n">false</span><span class="o">,</span>
  <span class="n">bot_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">false.elim</span><span class="o">,</span>
  <span class="n">add_le_add_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span> <span class="n">or.imp_right</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exists_add_of_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">propext</span> <span class="o">(</span><span class="n">or_iff_right_of_imp</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩,</span>
  <span class="n">le_self_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">or.inl</span><span class="o">,</span>
<span class="bp">..</span> <span class="kt">Prop</span><span class="bp">.</span><span class="n">partial_order</span> <span class="o">}</span>

<span class="k">#print</span> <span class="kd">axioms</span> <span class="kt">Prop</span><span class="bp">.</span><span class="n">canonically_ordered_add_monoid</span> <span class="c">/-</span><span class="cm"> propext -/</span>

<span class="kd">instance</span> <span class="n">set.canonically_ordered_add_monoid</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">canonically_ordered_add_monoid</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∪</span><span class="o">),</span> <span class="n">le</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊆</span><span class="o">),</span> <span class="n">lt</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊂</span><span class="o">),</span> <span class="c">/-</span><span class="cm"> could be omitted but these are better syntactically -/</span>
<span class="bp">..</span> <span class="n">pi.canonically_ordered_add_monoid</span> <span class="o">}</span>
</code></pre></div>



<a name="298294840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Prop%20as%20%60canonically_ordered_monoid%60/near/298294840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html#298294840">(Sep 11 2022 at 22:25)</a>:</h4>
<p>Since it doesn't use any classical axioms I expect that it generalizes to Heyting algebras; with classical axioms it becomes a linear order. I'm investigating what conditions would be required for <code>has_ordered_sub</code>.</p>



<a name="298295113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Prop%20as%20%60canonically_ordered_monoid%60/near/298295113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html#298295113">(Sep 11 2022 at 22:30)</a>:</h4>
<p>Maybe you want <a href="https://leanprover-community.github.io/mathlib_docs/find/boolean_algebra.to_boolean_ring">docs#boolean_algebra.to_boolean_ring</a>?</p>



<a name="298295143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Prop%20as%20%60canonically_ordered_monoid%60/near/298295143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html#298295143">(Sep 11 2022 at 22:31)</a>:</h4>
<p>We also have <a href="https://leanprover-community.github.io/mathlib_docs/find/generalized_boolean_algebra.to_non_unital_comm_ring">docs#generalized_boolean_algebra.to_non_unital_comm_ring</a> and probably could get a few weaker versions now that <a href="https://leanprover-community.github.io/mathlib_docs/find/heyting_algebra">docs#heyting_algebra</a> is a thing.</p>



<a name="298295213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Prop%20as%20%60canonically_ordered_monoid%60/near/298295213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html#298295213">(Sep 11 2022 at 22:33)</a>:</h4>
<p>addition in boolean_ring is xor, IIRC.</p>



<a name="298295237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Prop%20as%20%60canonically_ordered_monoid%60/near/298295237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html#298295237">(Sep 11 2022 at 22:33)</a>:</h4>
<p>Right, then it looks more like <a href="https://leanprover-community.github.io/mathlib_docs/find/set_semiring.canonically_ordered_comm_semiring">docs#set_semiring.canonically_ordered_comm_semiring</a></p>



<a name="298295294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Prop%20as%20%60canonically_ordered_monoid%60/near/298295294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html#298295294">(Sep 11 2022 at 22:34)</a>:</h4>
<p>Oh great, <a href="https://leanprover-community.github.io/mathlib_docs/find/set_semiring">docs#set_semiring</a> is the alias for <code>set</code> that I'm looking for.</p>



<a name="298295316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Prop%20as%20%60canonically_ordered_monoid%60/near/298295316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html#298295316">(Sep 11 2022 at 22:35)</a>:</h4>
<p>Thanks!</p>



<a name="298312945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Prop%20as%20%60canonically_ordered_monoid%60/near/298312945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html#298312945">(Sep 12 2022 at 04:59)</a>:</h4>
<p>The multiplication in <a href="https://leanprover-community.github.io/mathlib_docs/find/set_semiring">docs#set_semiring</a> is actually pointwise multiplication coming from a monoid structure on α, while the addition and order don't depend on the monoid structure. I think we should single out the <code>canonically_ordered_add_monoid</code> structure, but then <code>set_semiring</code> would be a misnomer.</p>
<p>In fact there is another way to put a semiring structure on <code>set α</code>, with multiplication given by intersection. However it doesn't satisfy the no zero-divisor condition <code>eq_zero_or_eq_zero_of_mul_eq_zero</code> since the intersection of two nonempty sets can be empty if they're disjoint, so it's not a <code>canonically_ordered_comm_semiring</code>, unless <code>α</code> is a subsingleton and we're in the classical setting. See the following for <code>Prop</code>, i.e. the special case <code>α := unit</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="kt">Prop</span><span class="bp">.</span><span class="n">canonically_ordered_comm_semiring</span> <span class="o">:</span> <span class="n">canonically_ordered_comm_semiring</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∧</span><span class="o">),</span>
  <span class="n">left_distrib</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">propext</span> <span class="n">and_or_distrib_left</span><span class="o">,</span>
  <span class="n">right_distrib</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">propext</span> <span class="n">or_and_distrib_right</span><span class="o">,</span>
  <span class="n">zero_mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">propext</span> <span class="o">(</span><span class="n">false_and</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">mul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">propext</span> <span class="o">(</span><span class="n">and_false</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">_</span><span class="o">,</span> <span class="n">propext</span> <span class="o">(</span><span class="n">and_assoc</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="n">true</span><span class="o">,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">propext</span> <span class="o">(</span><span class="n">true_and</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">propext</span> <span class="o">(</span><span class="n">and_true</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">mul_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">propext</span> <span class="o">(</span><span class="n">and_comm</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">eq_zero_or_eq_zero_of_mul_eq_zero</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span> <span class="c">/-</span><span class="cm"> classically true -/</span>
<span class="bp">..</span> <span class="kt">Prop</span><span class="bp">.</span><span class="n">canonically_ordered_add_monoid</span> <span class="o">}</span>
</code></pre></div>



<a name="298313010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Prop%20as%20%60canonically_ordered_monoid%60/near/298313010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html#298313010">(Sep 12 2022 at 05:00)</a>:</h4>
<p>And I've also realized that <code>has_ordered_sub</code> corresponds to the co-Heyting condition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">has_sub</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">sub</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">b</span> <span class="o">}</span>
<span class="c">/-</span><span class="cm"> classically satisfies `has_ordered_sub`; in a co-Heyting algebra we should define</span>
<span class="cm">  `sub := (\)` and then the condition `a \ b ≤ c ↔ a ≤ b ⊔ c` is exactly `has_ordered_sub`. -/</span>
</code></pre></div>



<a name="298610765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Prop%20as%20%60canonically_ordered_monoid%60/near/298610765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html#298610765">(Sep 13 2022 at 15:28)</a>:</h4>
<p>I realized that <code>semilattice_sup</code> + <code>order_bot</code> is sufficient to obtain a <code>canonically_ordered_add_monoid</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">semilattice_sup.to_canonically_ordered_add_monoid</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">sls</span> <span class="o">:</span> <span class="n">semilattice_sup</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">ob</span> <span class="o">:</span> <span class="n">order_bot</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">canonically_ordered_add_monoid</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊔</span><span class="o">),</span>
  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">sup_assoc</span><span class="o">,</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊥</span><span class="o">),</span>
  <span class="n">zero_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">bot_sup_eq</span><span class="o">,</span>
  <span class="n">add_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">sup_bot_eq</span><span class="o">,</span>
  <span class="n">add_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">sup_comm</span><span class="o">,</span>
  <span class="n">add_le_add_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">sup_le_sup_left</span><span class="o">,</span>
  <span class="n">exists_add_of_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">sup_eq_right.2</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩,</span>
  <span class="n">le_self_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">le_sup_left</span><span class="o">,</span>
<span class="bp">..</span> <span class="n">sls</span><span class="o">,</span> <span class="bp">..</span> <span class="n">ob</span> <span class="o">}</span>
</code></pre></div>
<p>I also found Prop.distrib_lattice unnecessarily invokes classical axioms, so I opened <a href="https://github.com/leanprover-community/mathlib/pull/16497">#16497</a> to remove it.</p>



<a name="298614743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Prop%20as%20%60canonically_ordered_monoid%60/near/298614743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Prop.20as.20.60canonically_ordered_monoid.60.html#298614743">(Sep 13 2022 at 15:47)</a>:</h4>
<p>We could make a general <code>as_canonical_order</code> where we inherit those instances, and then redefine <code>set_semiring</code> as <code>as_canonical_order (set α)</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
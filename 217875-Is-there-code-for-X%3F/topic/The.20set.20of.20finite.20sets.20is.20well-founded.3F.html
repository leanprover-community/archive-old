---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html">The set of finite sets is well-founded?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="315213888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315213888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315213888">(Dec 11 2022 at 14:25)</a>:</h4>
<p>Hey! I have a set <code>S : set $ set X</code> and I know that all elements of <code>S</code> are <code>finite</code>. Is there an easy way to get a minimal element of <code>S</code>?<br>
Equivalently (I believe), is there something along the lines of <code>is_well_founded_on ({s : set X | s.finite}) (ssubset)</code> ?</p>
<p>Actually, let me ensure I'm not falling into <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> : I have the following code (trying to deal with <a href="#narrow/stream/116395-maths/topic/Properties.20on.20.60fintype_inverse_systems.60">this</a> ) and I want to drop the <code>fintype</code> assumption in favour of the one in the docstring (last lemma).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.filtered</span>
<span class="kn">import</span> <span class="n">topology.category.Top.limits</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">category_theory.category.basic</span>
<span class="kn">import</span> <span class="n">category_theory.full_subcategory</span>
<span class="kn">import</span> <span class="n">data.set.finite</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>
<span class="kn">import</span> <span class="n">category_theory.types</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">open</span> <span class="n">classical</span>
<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">noncomputable theory</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">prop_decidable</span>


<span class="kd">def</span> <span class="n">category_theory.functor.eventual_range</span>
  <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">J</span><span class="o">]</span> <span class="o">[</span><span class="n">is_cofiltered</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="bp">⋂</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">category_theory.functor.is_mittag_leffler</span>
  <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">J</span><span class="o">]</span> <span class="o">[</span><span class="n">is_cofiltered</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">),</span>
             <span class="bp">∀</span> <span class="o">(</span><span class="n">i'</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:</span> <span class="n">i'</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f'</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">category_theory.functor.is_mittag_leffler_iff_eventual_range</span>
  <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">J</span><span class="o">]</span> <span class="o">[</span><span class="n">is_cofiltered</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">F.is_mittag_leffler</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="n">F.eventual_range</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">category_theory.functor.eventual_range</span><span class="o">],</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="sd">/--</span>
<span class="sd">There is probably a nice general argument along the lines of:</span>
<span class="sd">* If J is cofiltered, then so is J/j (the comma category) for any j.</span>
<span class="sd">* The functor F : J ⥤ Type v defines a functor J/j ⥤ (F.obj j) by sending (f : i ⟶ j) to set.range $ F.map f</span>
<span class="sd">* The image of a cofiltered category is cofiltered</span>
<span class="sd">-/</span>
<span class="kd">lemma</span> <span class="n">category_theory.functor.ranges_directed_of_is_cofiltered</span>
  <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">J</span><span class="o">]</span> <span class="o">[</span><span class="n">is_cofiltered</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">directed_on</span> <span class="o">(</span><span class="bp">⊇</span><span class="o">)</span> <span class="o">(</span><span class="n">set.range</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">Σ'</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f.2</span><span class="o">)))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="n">_</span> <span class="o">⟨⟨</span><span class="n">i</span><span class="o">,</span><span class="n">ij</span><span class="o">⟩,</span><span class="n">rfl</span><span class="o">⟩</span> <span class="n">_</span> <span class="o">⟨⟨</span><span class="n">k</span><span class="o">,</span><span class="n">kj</span><span class="o">⟩,</span><span class="n">rfl</span><span class="o">⟩,</span>
  <span class="k">let</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">is_cofiltered.min</span> <span class="n">i</span> <span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">li</span> <span class="o">:=</span> <span class="n">is_cofiltered.min_to_left</span> <span class="n">i</span> <span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">lk</span> <span class="o">:=</span> <span class="n">is_cofiltered.min_to_right</span> <span class="n">i</span> <span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">is_cofiltered.eq</span> <span class="o">(</span><span class="n">li</span> <span class="bp">≫</span> <span class="n">ij</span><span class="o">)</span> <span class="o">(</span><span class="n">lk</span> <span class="bp">≫</span> <span class="n">kj</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">ml</span> <span class="o">:=</span> <span class="n">is_cofiltered.eq_hom</span> <span class="o">(</span><span class="n">li</span> <span class="bp">≫</span> <span class="n">ij</span><span class="o">)</span> <span class="o">(</span><span class="n">lk</span> <span class="bp">≫</span> <span class="n">kj</span><span class="o">),</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="bp">$</span> <span class="n">ml</span> <span class="bp">≫</span> <span class="n">li</span> <span class="bp">≫</span> <span class="n">ij</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_range</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">⟨⟨⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">ml</span> <span class="bp">≫</span> <span class="n">li</span> <span class="bp">≫</span> <span class="n">ij</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩⟩,</span>
  <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">superset</span><span class="o">],</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">functor.map_comp</span><span class="o">,</span> <span class="n">types_comp</span><span class="o">],</span>
    <span class="n">change</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">ij</span> <span class="bp">∘</span> <span class="n">F.map</span> <span class="n">li</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">F.map</span> <span class="n">ml</span> <span class="k">with</span> <span class="n">F.map</span> <span class="n">ij</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">li</span> <span class="bp">∘</span> <span class="n">F.map</span> <span class="n">ml</span><span class="o">),</span>
    <span class="n">apply</span> <span class="n">set.range_comp_subset_range</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">superset</span><span class="o">],</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">category_theory.is_cofiltered.eq_condition</span><span class="o">,</span> <span class="n">functor.map_comp</span><span class="o">,</span> <span class="n">types_comp</span><span class="o">],</span>
    <span class="n">change</span> <span class="n">is_cofiltered.eq_hom</span> <span class="o">(</span><span class="n">li</span> <span class="bp">≫</span> <span class="n">ij</span><span class="o">)</span> <span class="o">(</span><span class="n">lk</span> <span class="bp">≫</span> <span class="n">kj</span><span class="o">)</span> <span class="k">with</span> <span class="n">ml</span><span class="o">,</span>
    <span class="n">change</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">kj</span> <span class="bp">∘</span> <span class="n">F.map</span> <span class="n">lk</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">F.map</span> <span class="n">ml</span> <span class="k">with</span> <span class="n">F.map</span> <span class="n">kj</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">lk</span> <span class="bp">∘</span> <span class="n">F.map</span> <span class="n">ml</span><span class="o">),</span>
    <span class="n">apply</span> <span class="n">set.range_comp_subset_range</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="c1">-- Probably exists somewhere</span>
<span class="kd">lemma</span> <span class="n">directed_on_min</span> <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">J</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">directed_on</span> <span class="o">(</span><span class="bp">≥</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">m</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">min</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">a</span> <span class="n">as</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">,</span> <span class="n">xm</span><span class="o">,</span> <span class="n">xa</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">m</span> <span class="n">H</span> <span class="n">a</span> <span class="n">as</span><span class="o">,</span>
  <span class="n">cases</span> <span class="o">(</span><span class="n">min</span> <span class="n">x</span> <span class="n">xs</span> <span class="n">xm</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">xa</span><span class="o">,</span>
<span class="kd">end</span>

<span class="sd">/--</span>
<span class="sd">With enough `well_founded`-fu, one could probably weaken the `fintype` hypothesis to</span>
<span class="sd">\```</span>
<span class="sd">  ∀ (j i : J) (f : i ⟶ j), (set.range $ F.map f).finite</span>
<span class="sd">\```</span>
<span class="sd">-/</span>
<span class="kd">lemma</span> <span class="n">category_theory.functor.is_mittag_leffler_of_fintype</span>
  <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">J</span><span class="o">]</span> <span class="o">[</span><span class="n">is_cofiltered</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
  <span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">j</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">F.is_mittag_leffler</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="bp">Σ'</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="n">j</span><span class="o">,</span><span class="mi">𝟙</span> <span class="n">j</span><span class="o">⟩⟩,</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">function.argmin</span>
             <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Σ'</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f.2</span><span class="o">))</span>
             <span class="o">(</span><span class="n">finite.well_founded_of_trans_of_irrefl</span> <span class="n">has_ssubset.ssubset</span><span class="o">),</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">f.1</span><span class="o">,</span> <span class="n">f.2</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i'</span> <span class="n">f'</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">refine</span> <span class="n">directed_on_min</span> <span class="o">(</span><span class="n">F.ranges_directed_of_is_cofiltered</span> <span class="n">j</span><span class="o">)</span>
         <span class="o">(</span><span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f.2</span><span class="o">))</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span> <span class="n">_</span>
         <span class="o">(</span><span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f'</span><span class="o">))</span> <span class="o">⟨⟨</span><span class="n">i'</span><span class="o">,</span><span class="n">f'</span><span class="o">⟩,</span><span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">rintro</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span> <span class="n">klef</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">lt_or_eq_of_le</span> <span class="n">klef</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">function.not_lt_argmin</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Σ'</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f.2</span><span class="o">))</span> <span class="n">_</span> <span class="n">g</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="315214710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315214710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315214710">(Dec 11 2022 at 14:31)</a>:</h4>
<p>I assume by minimal you mean something weaker than "in <a href="https://leanprover-community.github.io/mathlib_docs/find/lower_bounds">docs#lower_bounds</a>"? otherwise <code>S := {{1, 2}, {2,3}]</code> is a problem.</p>



<a name="315214860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315214860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315214860">(Dec 11 2022 at 14:32)</a>:</h4>
<p>Or did you also mean "every finite set is in <code>S</code>"?</p>



<a name="315214887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315214887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315214887">(Dec 11 2022 at 14:32)</a>:</h4>
<p>Indeed, I need an element of the set with nothing below it, essentially.</p>



<a name="315232240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315232240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315232240">(Dec 11 2022 at 17:00)</a>:</h4>
<p>Probably you want <code>set (finset \a)</code>, rather?</p>



<a name="315238202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315238202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315238202">(Dec 11 2022 at 17:53)</a>:</h4>
<blockquote>
<p>∀ (j i : J) (f : i ⟶ j), (set.range $ <a href="http://F.map">F.map</a> f).finite</p>
</blockquote>
<p>Notice that if you take <code>f</code> to be the identity you'd be able to show all <code>F.obj j</code> are finite from this. Maybe you want to assume <code>∀ j, ∃ i (f : i ⟶ j), (set.range $ F.map f).finite</code> instead.</p>
<p>Also, <code>category_theory.functor.is_mittag_leffler_of_fintype</code> should use <code>finite</code> instead of <code>fintype</code>.</p>



<a name="315238970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315238970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315238970">(Dec 11 2022 at 18:00)</a>:</h4>
<p>You should be able to deduce well-foundedness of <code>finset α</code> from <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.well_founded_lt">docs#multiset.well_founded_lt</a> and the order embedding from <code>finset α</code> to <code>multiset α</code> (does this exist?).</p>



<a name="315239528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315239528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315239528">(Dec 11 2022 at 18:05)</a>:</h4>
<p>I would guess the order embedding is trivial to construct but doesn't exist</p>



<a name="315239577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315239577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315239577">(Dec 11 2022 at 18:05)</a>:</h4>
<p>The fact that we have that result for <code>multiset</code> suggests we should have it in mathlib for finset, XY problems aside</p>



<a name="315239588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315239588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315239588">(Dec 11 2022 at 18:05)</a>:</h4>
<p>I was about to write the same thing!</p>



<a name="315239721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315239721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315239721">(Dec 11 2022 at 18:06)</a>:</h4>
<p>The proof of the multiset lemma is a single line, <code>subrelation.wf (λ _ _, multiset.card_lt_of_lt) (measure_wf multiset.card)</code></p>



<a name="315239762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315239762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315239762">(Dec 11 2022 at 18:07)</a>:</h4>
<p>I would guess you can directly copy that using <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_lt_of_ssubset">docs#finset.card_lt_of_ssubset</a></p>



<a name="315239824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315239824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315239824">(Dec 11 2022 at 18:07)</a>:</h4>
<p>... if that existed</p>



<a name="315240216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315240216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315240216">(Dec 11 2022 at 18:10)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_lt_card">docs#finset.card_lt_card</a></p>



<a name="315240222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315240222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315240222">(Dec 11 2022 at 18:10)</a>:</h4>
<p>The naming is all over the place.</p>



<a name="315241196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315241196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315241196">(Dec 11 2022 at 18:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F/near/315232240">said</a>:</p>
<blockquote>
<p>Probably you want <code>set (finset \a)</code>, rather?</p>
</blockquote>
<p>Well, I really wanted the set of <code>finite</code> sets since it's a range, but Junyan's comment makes me reconsider the stupidity of what I asked for</p>



<a name="315241259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315241259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315241259">(Dec 11 2022 at 18:19)</a>:</h4>
<p>Re <code>finite</code> vs <code>fintype</code>: does that mean that <code>nonempty_section_of_fintype_inverse_system</code> should be corrected too?</p>



<a name="315241825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315241825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315241825">(Dec 11 2022 at 18:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F/near/315241196">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F/near/315232240">said</a>:</p>
<blockquote>
<p>Probably you want <code>set (finset \a)</code>, rather?</p>
</blockquote>
<p>Well, I really wanted the set of <code>finite</code> sets since it's a range, but Junyan's comment makes me reconsider the stupidity of what I asked for</p>
</blockquote>
<p>Mmh, I think the proof would indeed work with the <code>\forall j \exists i (f : i \--&gt; j), …</code> version</p>



<a name="315247117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315247117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315247117">(Dec 11 2022 at 19:15)</a>:</h4>
<blockquote>
<p>Hey! I have a set S : set $ set X and I know that all elements of S are finite. Is there an easy way to get a minimal element of S?</p>
</blockquote>
<p>Take an element of minimal cardinality?</p>



<a name="315251558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315251558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315251558">(Dec 11 2022 at 20:03)</a>:</h4>
<p>Seems going through finset is still easier because we have <a href="https://leanprover-community.github.io/mathlib_docs/find/set.finite.to_finset_ssubset">docs#set.finite.to_finset_ssubset</a>.<br>
But we don't seem to have the fact that a strict subset of a finite set has strictly less cardinality (neither <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.card">docs#nat.card</a> nor <a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal.mk">docs#cardinal.mk</a>).</p>



<a name="315287096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315287096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315287096">(Dec 12 2022 at 04:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F/near/315247117">said</a>:</p>
<blockquote>
<blockquote>
<p>Hey! I have a set S : set $ set X and I know that all elements of S are finite. Is there an easy way to get a minimal element of S?</p>
</blockquote>
<p>Take an element of minimal cardinality?</p>
</blockquote>
<p>Yeah, I'm probably gonna take this approach</p>



<a name="315298487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315298487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315298487">(Dec 12 2022 at 06:46)</a>:</h4>
<p>I went with the following, which is not too bad as far as I can tell:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">category_theory.functor.is_mittag_leffler_of_exists_finite_range</span>
  <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">J</span><span class="o">]</span> <span class="o">[</span><span class="n">is_cofiltered</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">i</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="o">(</span><span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f</span><span class="o">))</span><span class="bp">.</span><span class="n">finite</span> <span class="o">)</span> <span class="o">:</span>
  <span class="n">F.is_mittag_leffler</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">j</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Σ'</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:</span> <span class="bp">Σ'</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">),</span>
               <span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f'.2</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f.2</span><span class="o">)</span> <span class="bp">→</span>
                 <span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f'.2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f.2</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">f</span><span class="o">⟩,</span> <span class="n">fmin</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i'</span> <span class="n">f'</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="n">directed_on_min</span> <span class="o">(</span><span class="n">F.ranges_directed_of_is_cofiltered</span> <span class="n">j</span><span class="o">)</span> <span class="n">_</span> <span class="o">⟨⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">f</span><span class="o">⟩,</span><span class="n">rfl</span><span class="o">⟩</span> <span class="n">_</span> <span class="n">_</span> <span class="o">⟨⟨</span><span class="n">i'</span><span class="o">,</span><span class="n">f'</span><span class="o">⟩,</span><span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_range</span><span class="o">,</span> <span class="n">psigma.exists</span><span class="o">,</span> <span class="n">forall_exists_index</span><span class="o">],</span>
    <span class="n">rintro</span> <span class="n">_</span> <span class="n">k</span> <span class="n">g</span> <span class="n">rfl</span> <span class="n">gf</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">fmin</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span><span class="n">g</span><span class="o">⟩</span> <span class="n">gf</span><span class="o">,</span> <span class="o">},</span>

  <span class="k">let</span> <span class="n">fins</span> <span class="o">:=</span> <span class="n">subtype</span> <span class="o">{</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">Σ'</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span> <span class="bp">|</span> <span class="o">(</span><span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f.2</span><span class="o">))</span><span class="bp">.</span><span class="n">finite</span> <span class="o">},</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">fins</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span><span class="n">f</span><span class="o">,</span><span class="n">fin</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">j</span><span class="o">,</span> <span class="n">exact</span> <span class="o">⟨⟨⟨</span><span class="n">i</span><span class="o">,</span><span class="n">f</span><span class="o">⟩,</span><span class="n">fin</span><span class="o">⟩⟩,</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">fmin</span> <span class="o">:=</span> <span class="n">function.argmin</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fins</span><span class="o">),</span> <span class="n">f.prop.to_finset.card</span><span class="o">)</span> <span class="n">nat.lt_wf</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">fmin.val</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">g</span> <span class="n">gf</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">lt_or_eq_of_le</span> <span class="n">gf</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">gfin</span> <span class="o">:</span> <span class="o">(</span><span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">g.2</span><span class="o">))</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span> <span class="n">fmin.prop.subset</span> <span class="n">gf</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fins</span><span class="o">),</span> <span class="n">f.prop.to_finset.card</span><span class="o">)</span><span class="bp">.</span><span class="n">not_lt_argmin</span> <span class="n">nat.lt_wf</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">gfin</span><span class="o">⟩</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">finset.card_lt_card</span> <span class="o">(</span><span class="n">set.finite.to_finset_ssubset.mpr</span> <span class="n">h_1</span><span class="o">),</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">assumption</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="315914221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/The%20set%20of%20finite%20sets%20is%20well-founded%3F/near/315914221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F.html#315914221">(Dec 14 2022 at 21:03)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/17950">#17950</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
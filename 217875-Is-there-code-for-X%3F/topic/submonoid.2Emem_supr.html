---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/submonoid.2Emem_supr.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submonoid.2Emem_supr.html">submonoid.mem_supr</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="234672788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submonoid.mem_supr/near/234672788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submonoid.2Emem_supr.html#234672788">(Apr 15 2021 at 13:18)</a>:</h4>
<p>For <code>mem_supr</code> for submonoids, subgroups and submodules we tend to have <code>mem_supr_of_directed</code> (if in the supr of a directed collection then it's in one of the collection), and <code>mem_supr_of_mem</code> (if in one of them, then in the supr). Do we have any of the following (I probably only need one):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.finprod</span>
<span class="kn">import</span> <span class="n">data.finsupp</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="c1">-- finprod variant</span>
<span class="kd">lemma</span> <span class="n">submonoid.mem_supr</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">submonoid</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">m</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">⨆</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">,</span> <span class="bp">∏ᶠ</span> <span class="n">i</span><span class="o">,</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- finset variant</span>
<span class="kd">lemma</span> <span class="n">submonoid.mem_supr'</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">add_submonoid</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">m</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">⨆</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">),</span> <span class="bp">Π</span> <span class="n">j</span> <span class="bp">∈</span> <span class="n">J</span><span class="o">,</span> <span class="n">s</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- finsupp variant which I only know how to make for add_monoids because maybe we don't have `→₁`?</span>
<span class="kd">lemma</span> <span class="n">add_submonoid.mem_supr</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">add_submonoid</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">m</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">⨆</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→₀</span> <span class="n">M</span><span class="o">,</span> <span class="n">s.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>[There are also versions for <code>subgroup</code> and <code>submodule</code>]. It would not surprise me if we had ways of moving from any of these three lemmas to any other (modulo issues with the multiplicative version with finsupp). I would imagine it would not be hard to prove any or all of these using some kind of induction principle if we knew that the supr was the closure of the set.Union, because we have <a href="https://leanprover-community.github.io/mathlib_docs/find/submonoid.closure_induction">docs#submonoid.closure_induction</a> . Do we already have anything else which would make one of these short?</p>



<a name="234674153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submonoid.mem_supr/near/234674153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submonoid.2Emem_supr.html#234674153">(Apr 15 2021 at 13:26)</a>:</h4>
<p>Does <a href="https://leanprover-community.github.io/mathlib_docs/find/add_submonoid.closure_Union">docs#add_submonoid.closure_Union</a> help?</p>



<a name="234677433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submonoid.mem_supr/near/234677433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submonoid.2Emem_supr.html#234677433">(Apr 15 2021 at 13:44)</a>:</h4>
<p>It's definitely a step in the right direction. From then on it's just some induction I guess. Thanks!</p>



<a name="245872791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submonoid.mem_supr/near/245872791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submonoid.2Emem_supr.html#245872791">(Jul 13 2021 at 19:10)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.mem_supr_iff_exists_dfinsupp">docs#submodule.mem_supr_iff_exists_dfinsupp</a> (once CI rebuilds the docs)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
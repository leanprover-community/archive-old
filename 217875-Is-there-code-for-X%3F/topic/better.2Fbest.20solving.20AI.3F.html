---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html">better/best solving AI?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="231923433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231923433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Belisarius Cawl <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231923433">(Mar 26 2021 at 07:13)</a>:</h4>
<p>I was looking at the docs for simp and it said that the program can get stuck in replacement loops if one is not careful to put the simpler side on the left hand. This got me wondering - since the concept of automated provers (possibly with statistical approaches) is not new: How far is this integrated and how would one go about invoking it?</p>
<p>EDIT<br>
For example, remembering already visited nodes in the reformulation-equivalence graph would get rid of loops. Since this graph is probably quite unending this is where the AI/statistics part would come in.</p>



<a name="231923856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231923856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231923856">(Mar 26 2021 at 07:19)</a>:</h4>
<p><span class="user-mention" data-user-id="400229">@Belisarius Cawl</span> Several things have been attempted. For example, there is <code>rewrite_search</code>.<br>
One thing that I've discovered since I started formalising is that there is a delicate balance between proof search, speed, and maintainability.<br>
So if you have a smart AI that takes some time to find a proof that isn't completely straightforward, it should be able to emit a fast (and maintainable) way to replicate the proof. This isn't always straightforward.</p>



<a name="231923942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231923942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231923942">(Mar 26 2021 at 07:20)</a>:</h4>
<p>But if you have 5000 lemmas in mathlib that are proven using <code>by smart_ai</code> and the ai takes 15 seconds to find the proof, then compile time is sky-rocketing.</p>



<a name="231924073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924073">(Mar 26 2021 at 07:22)</a>:</h4>
<p>On the other hand, if something in <code>logic.basic</code> changes, and <code>smart_ai</code> for some stupid reason can no longer find the proof of a certain lemma <code>X</code>, then it shouldn't require an author with domain specific knowledge to fix the proof of <code>X</code>. That is why <code>by smart_ai</code> should output a maintainable proof, and not just a fast but completely opaque proof term.</p>



<a name="231924124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924124">(Mar 26 2021 at 07:23)</a>:</h4>
<p><code>simp</code> seems to find the middle ground, by asking from library authors to adhere to certain conventions (e.g., simpler side goes on the right, and make the simp-set as confluent as possible, etc...). If we stick to those conventions, in practice we seem to hit a nice balance between automation, speed, and maintainability.</p>



<a name="231924184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924184">(Mar 26 2021 at 07:24)</a>:</h4>
<p>Speed is obtained by using <code>squeeze_simp</code> to output a certificate that uses <code>simp only [15, different, lemma, names]</code></p>



<a name="231924232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Belisarius Cawl <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924232">(Mar 26 2021 at 07:25)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I don't understand the last part. If I find a path why not just print it? Verifying it should be orders of magnitude faster.</p>



<a name="231924359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924359">(Mar 26 2021 at 07:26)</a>:</h4>
<p>It depends on what <code>smart_ai</code> does... what do you mean with "path"?</p>



<a name="231924384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924384">(Mar 26 2021 at 07:27)</a>:</h4>
<p>If <code>smart_ai</code> is only rewriting along lemmas of the form <code>A = B</code> that it finds in the library, then yes. This is <code>rewrite_search</code></p>



<a name="231924413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924413">(Mar 26 2021 at 07:27)</a>:</h4>
<p>If you want it to also handle inequalities, or maybe other smart knowledge, then I don't know what "path" is.</p>



<a name="231924416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Belisarius Cawl <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924416">(Mar 26 2021 at 07:27)</a>:</h4>
<p>I visualize the problem as a graph, where each edge is a lemma application.</p>



<a name="231924485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924485">(Mar 26 2021 at 07:28)</a>:</h4>
<p>Right, so if you print that "path", you are printing the proof term. Which is often larger and uglier than you expect. And quite opaque.</p>



<a name="231924501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Belisarius Cawl <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924501">(Mar 26 2021 at 07:28)</a>:</h4>
<p>ah yes, I did not register that as a problem.</p>



<a name="231924532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924532">(Mar 26 2021 at 07:29)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">LCFP.map_comp_Tinv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">NormedGroup</span><span class="o">)</span> <span class="o">(</span><span class="n">r'</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">_inst_5</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r'</span><span class="o">)]</span> <span class="o">(</span><span class="n">c</span> <span class="n">c₂</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span>
<span class="o">[</span><span class="n">_inst_6</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="n">c₂</span> <span class="bp">≤</span> <span class="n">r'</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)]</span> <span class="o">{</span><span class="n">M₁</span> <span class="n">M₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">ProFiltPseuNormGrpWithTinv</span> <span class="n">r'</span><span class="o">)</span><span class="bp">ᵒᵖ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M₁</span> <span class="bp">⟶</span> <span class="n">M₂</span><span class="o">),</span>
  <span class="o">(</span><span class="n">LCFP</span> <span class="n">V</span> <span class="n">r'</span> <span class="n">c</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">Tinv</span> <span class="n">V</span> <span class="n">r'</span> <span class="n">n</span> <span class="n">c</span> <span class="n">c₂</span> <span class="n">M₂</span> <span class="bp">=</span> <span class="n">Tinv</span> <span class="n">V</span> <span class="n">r'</span> <span class="n">n</span> <span class="n">c</span> <span class="n">c₂</span> <span class="n">M₁</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">LCFP</span> <span class="n">V</span> <span class="n">r'</span> <span class="n">c₂</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">NormedGroup</span><span class="o">)</span> <span class="o">(</span><span class="n">r'</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">_inst_5</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r'</span><span class="o">)]</span> <span class="o">(</span><span class="n">c</span> <span class="n">c₂</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span>
<span class="o">[</span><span class="n">_inst_6</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="n">c₂</span> <span class="bp">≤</span> <span class="n">r'</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)]</span> <span class="o">{</span><span class="n">M₁</span> <span class="n">M₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">ProFiltPseuNormGrpWithTinv</span> <span class="n">r'</span><span class="o">)</span><span class="bp">ᵒᵖ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M₁</span> <span class="bp">⟶</span> <span class="n">M₂</span><span class="o">),</span>
  <span class="n">id</span>
    <span class="o">((</span><span class="n">id</span>
        <span class="o">((</span><span class="bp">λ</span>
          <span class="o">(</span><span class="n">a</span> <span class="n">a_1</span> <span class="o">:</span>
            <span class="o">(</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="n">filtration_obj</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₁</span><span class="o">)</span> <span class="n">c</span><span class="o">))</span> <span class="bp">⟶</span>
              <span class="o">(</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="n">filtration_obj</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">)</span> <span class="n">c₂</span><span class="o">)))</span> <span class="o">(</span><span class="n">e_1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a_1</span><span class="o">)</span>
          <span class="o">(</span><span class="n">ᾰ</span> <span class="n">ᾰ_1</span> <span class="o">:</span>
            <span class="o">(</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="n">filtration_obj</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₁</span><span class="o">)</span> <span class="n">c</span><span class="o">))</span> <span class="bp">⟶</span>
              <span class="o">(</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="n">filtration_obj</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">)</span> <span class="n">c₂</span><span class="o">)))</span> <span class="o">(</span><span class="n">e_2</span> <span class="o">:</span> <span class="n">ᾰ</span> <span class="bp">=</span> <span class="n">ᾰ_1</span><span class="o">),</span>
            <span class="n">congr</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">eq</span> <span class="n">e_1</span><span class="o">)</span> <span class="n">e_2</span><span class="o">)</span>
           <span class="o">((</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">((</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span> <span class="bp">≫</span>
              <span class="o">(</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span><span class="o">)</span>
           <span class="o">((</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span><span class="o">)</span>
           <span class="o">(((</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map_comp</span> <span class="o">((</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span>
               <span class="o">(</span><span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.trans</span>
              <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Profinite</span><span class="bp">ᵒᵖ</span> <span class="bp">⥤</span> <span class="n">NormedGroup</span><span class="o">)</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Profinite</span><span class="bp">ᵒᵖ</span><span class="o">}</span> <span class="o">(</span><span class="n">ᾰ</span> <span class="n">ᾰ_1</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span>
                <span class="o">(</span><span class="n">e_4</span> <span class="o">:</span> <span class="n">ᾰ</span> <span class="bp">=</span> <span class="n">ᾰ_1</span><span class="o">),</span> <span class="n">congr_arg</span> <span class="n">c.map</span> <span class="n">e_4</span><span class="o">)</span>
                 <span class="o">(</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span>
                 <span class="o">(((</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span><span class="o">)</span>
                 <span class="o">(</span><span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span>
                 <span class="n">op_comp.symm</span><span class="o">))</span>
           <span class="o">((</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₁</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span> <span class="bp">≫</span>
              <span class="o">(</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">((</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c₂</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span><span class="o">)</span>
           <span class="o">((</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span>
              <span class="o">((</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c₂</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span> <span class="bp">≫</span> <span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₁</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span><span class="o">)</span>
           <span class="o">(((</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map_comp</span> <span class="o">(</span><span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₁</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span>
               <span class="o">((</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c₂</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.trans</span>
              <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Profinite</span><span class="bp">ᵒᵖ</span> <span class="bp">⥤</span> <span class="n">NormedGroup</span><span class="o">)</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Profinite</span><span class="bp">ᵒᵖ</span><span class="o">}</span> <span class="o">(</span><span class="n">ᾰ</span> <span class="n">ᾰ_1</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span>
                <span class="o">(</span><span class="n">e_4</span> <span class="o">:</span> <span class="n">ᾰ</span> <span class="bp">=</span> <span class="n">ᾰ_1</span><span class="o">),</span> <span class="n">congr_arg</span> <span class="n">c.map</span> <span class="n">e_4</span><span class="o">)</span>
                 <span class="o">(</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span>
                 <span class="o">((</span><span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₁</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span> <span class="bp">≫</span> <span class="o">((</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c₂</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span><span class="o">)</span>
                 <span class="o">((</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c₂</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span> <span class="bp">≫</span> <span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₁</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span>
                 <span class="n">op_comp.symm</span><span class="o">))))</span><span class="bp">.</span><span class="n">mpr</span>
       <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Profinite</span><span class="bp">ᵒᵖ</span> <span class="bp">⥤</span> <span class="n">NormedGroup</span><span class="o">)</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Profinite</span><span class="bp">ᵒᵖ</span><span class="o">}</span> <span class="o">(</span><span class="n">ᾰ</span> <span class="n">ᾰ_1</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">e_4</span> <span class="o">:</span> <span class="n">ᾰ</span> <span class="bp">=</span> <span class="n">ᾰ_1</span><span class="o">),</span>
           <span class="n">congr_arg</span> <span class="n">c.map</span> <span class="n">e_4</span><span class="o">)</span>
          <span class="o">(</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span>
          <span class="o">(</span><span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span>
          <span class="o">((</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c₂</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span> <span class="bp">≫</span> <span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₁</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span>
          <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">f</span> <span class="n">f_1</span> <span class="o">:</span> <span class="n">filtration_obj</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">)</span> <span class="n">c₂</span> <span class="bp">⟶</span> <span class="n">filtration_obj</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₁</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">e_1</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f_1</span><span class="o">),</span>
              <span class="n">congr_arg</span> <span class="n">has_hom.hom.op</span> <span class="n">e_1</span><span class="o">)</span>
             <span class="o">(</span><span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span><span class="o">)</span>
             <span class="o">((</span><span class="n">ProFiltPseuNormGrpWithTinv.level</span> <span class="n">r'</span> <span class="n">c₂</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.unop</span> <span class="bp">≫</span> <span class="n">Tinv₀_hom</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₁</span><span class="o">)</span> <span class="n">c₂</span> <span class="n">c</span><span class="o">)</span>
             <span class="o">(</span><span class="n">continuous_map.ext</span>
                <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">((</span><span class="n">filtration_obj</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">)</span> <span class="n">c₂</span><span class="o">)</span><span class="bp">.</span><span class="n">to_Top</span><span class="o">)),</span>
                   <span class="n">subtype.cases_on</span> <span class="n">x</span>
                     <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">))</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">filtration</span> <span class="bp">↥</span><span class="o">(</span><span class="n">unop</span> <span class="n">M₂</span><span class="o">)</span> <span class="n">c₂</span><span class="o">),</span>
                        <span class="n">subtype.ext</span> <span class="o">(</span><span class="n">profinitely_filtered_pseudo_normed_group_with_Tinv_hom.map_Tinv</span> <span class="n">f.unop</span> <span class="n">x</span><span class="o">)))))))</span>
</code></pre></div>



<a name="231924547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924547">(Mar 26 2021 at 07:29)</a>:</h4>
<p>That's the proof term of the latest lemma that I just proved</p>



<a name="231924556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924556">(Mar 26 2021 at 07:30)</a>:</h4>
<p>You can <code>#print lemma_name</code> to try this yourself</p>



<a name="231924619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924619">(Mar 26 2021 at 07:30)</a>:</h4>
<p>The proof script that generated the term is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">Tinv</span><span class="o">,</span> <span class="n">LCFP</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="o">(</span><span class="n">LCP</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map_comp</span><span class="o">,</span> <span class="bp">←</span> <span class="n">op_comp</span><span class="o">],</span>
  <span class="n">congr'</span> <span class="mi">2</span><span class="o">,</span>
  <span class="n">ext</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">f.unop.map_Tinv</span> <span class="n">x</span>
<span class="kd">end</span>
</code></pre></div>



<a name="231924664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Belisarius Cawl <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924664">(Mar 26 2021 at 07:30)</a>:</h4>
<p>Seems pretty obvious... haha :D</p>
<p>Jokes aside, I treat that as machine code. I guess a real mathematician would want to be able to understand it though.</p>



<a name="231924676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924676">(Mar 26 2021 at 07:31)</a>:</h4>
<p>And this is an "easy" lemma, that everyone who knows the maths would consider "too easy to even state"</p>



<a name="231924719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924719">(Mar 26 2021 at 07:31)</a>:</h4>
<p>The important point is that this proof term will break very easily if some little detail in another place of the library is changed.</p>



<a name="231924729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924729">(Mar 26 2021 at 07:31)</a>:</h4>
<p>But the tactic script is a lot more robust</p>



<a name="231924733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Belisarius Cawl <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924733">(Mar 26 2021 at 07:31)</a>:</h4>
<p>It's a kind of philosophical topic it seems - If I proved my prover and my prover proves something with gibberish, does that count as understanding?</p>



<a name="231924812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Belisarius Cawl <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924812">(Mar 26 2021 at 07:32)</a>:</h4>
<p>you could solve the brittleness with version tags, no?</p>



<a name="231924816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924816">(Mar 26 2021 at 07:32)</a>:</h4>
<p>I appreciate the philosophical point. But my arguments are much more pragmatic.</p>



<a name="231924933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Belisarius Cawl <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924933">(Mar 26 2021 at 07:34)</a>:</h4>
<p>so you could have recent versions tagged as buggy or just "friendly" updated (like expansion or equivalent rewrite)</p>



<a name="231924985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231924985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231924985">(Mar 26 2021 at 07:34)</a>:</h4>
<p>We want the following features from mathlib:</p>
<ol>
<li>it should be able to grow (so we want some form of automation, because we don't want to keep stuck with low-level concepts and tools)</li>
<li>it should be reasonably fast to compile mathlib (currently ~2 hrs on reasonable hardware)</li>
<li>it should be maintainable (PR authors that edit file <code>X</code> shouldn't expect 100 other files to break, and if 3 files break that they don't know much about, they should still be able to fix the proofs easily)</li>
</ol>



<a name="231925142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231925142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231925142">(Mar 26 2021 at 07:36)</a>:</h4>
<p>So, any form of automation that helps with (1) forward, should take (2) and (3) into account</p>



<a name="231925174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231925174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231925174">(Mar 26 2021 at 07:37)</a>:</h4>
<p>It's not clear to me how the version tags would help. It sounds like they will turn (3) into a nightmare.</p>



<a name="231925221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231925221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231925221">(Mar 26 2021 at 07:37)</a>:</h4>
<p><code>tidy</code> is another tactic that will search for proofs, and <code>tidy?</code> will print a tactic script that uses lower-level tactics to produce the proof that <code>tidy</code> found</p>



<a name="231925278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231925278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231925278">(Mar 26 2021 at 07:38)</a>:</h4>
<p>This model seems to scale well, but it's not easy to write a good <code>smart_ai?</code>. (At least it's not easy for <em>me</em>.)</p>



<a name="231925333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231925333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231925333">(Mar 26 2021 at 07:39)</a>:</h4>
<p>There is also the new <code>gptf</code>, with a very impressive trained neural net behind it. It definitely fits Johan's criterion, in that its job is solely to suggest what you might type in next! At the end of the process there's no sign that it was ever involved.</p>



<a name="231925437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231925437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231925437">(Mar 26 2021 at 07:41)</a>:</h4>
<p>Another example is <code>solve_by_elim</code>, which does backwards chaining from a specified set of lemmas, and <code>library_search</code> that tries to apply a single lemma from the entire library to close the goal.</p>



<a name="231925455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231925455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231925455">(Mar 26 2021 at 07:41)</a>:</h4>
<p><code>solve_by_elim</code> is usually robust enough to "leave in place", but <code>library_search</code> is sadly slow.</p>



<a name="231925459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231925459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Belisarius Cawl <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231925459">(Mar 26 2021 at 07:41)</a>:</h4>
<p>I am thinking along the lines of - what are edits that cause a proof to break? Either the old version had a bug (in which case you need of course to discard everything relying on it) or you rewrite it because you have an equivalent but somehow "better" formulation (in which case you can keep your old proof, as long as you show that your rewrite is equivalent). Likely I don't really understand your problem though.</p>
<p>I am thinking of something like Nix. Also I got a feeling that modularization could help. Again, as an outsider.</p>
<p>Of course such an AI would be nontrivial which makes it exciting. There is a lot of art/subjectivity in (statistical) AI.</p>



<a name="231925469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231925469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231925469">(Mar 26 2021 at 07:41)</a>:</h4>
<p>One of course wishes for the pushout of these two tactics. :-)</p>



<a name="231925532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231925532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231925532">(Mar 26 2021 at 07:42)</a>:</h4>
<p>Proofs break constantly in mathlib. :-) Make a few pull requests and you'll get a feel for what is going on.</p>



<a name="231925574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231925574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Belisarius Cawl <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231925574">(Mar 26 2021 at 07:43)</a>:</h4>
<p>I really want to right now - but I have to constrain myself. Am already three rabbit holes down from my original task (which has nothing to do at all with proofs ;) )</p>



<a name="231925591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231925591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231925591">(Mar 26 2021 at 07:43)</a>:</h4>
<p>mathlib definitely does not grow "just from the top". We are perpetually adding e.g. <code>simp</code> lemmas that make things work more smoothly, but that changes the behaviour of <code>simp</code> in every existing proof. It takes some care to only use tactics like this in ways that will break in predicable / manageable ways.</p>



<a name="231933497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/better/best%20solving%20AI%3F/near/231933497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/better.2Fbest.20solving.20AI.3F.html#231933497">(Mar 26 2021 at 09:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="400229">Belisarius Cawl</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/better.2Fbest.20solving.20AI.3F/near/231924232">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> I don't understand the last part. If I find a path why not just print it? Verifying it should be orders of magnitude faster.</p>
</blockquote>
<p>A (related) technical term you might be interested in is a proof certificate, although that's more of a problem-specific concept. For example, to prove "¬ linear_independent R v" a proof certificate would be a list of coefficients <code>c i</code> such that <code>Σ i, c i * v i = 0</code>. So you could have a <code>find_linear_dependence</code> tactic outputting a definition of <code>c</code>, and a <code>check_linear_dependence c</code> tactic that verifies the linear combination adds up to 0. (You could say <code>squeeze_simp</code> outputs a proof certificate for the problem of determining whether two expressions are the same.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
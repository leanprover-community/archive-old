---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/PL.20theory.20stuff.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/PL.20theory.20stuff.html">PL theory stuff</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="279931255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/PL%20theory%20stuff/near/279931255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Breitner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/PL.20theory.20stuff.html#279931255">(Apr 23 2022 at 15:16)</a>:</h4>
<p>I might have to play around with a weird program language calculus, with non-trivial binders, reduction rules, contexts etc. I think intuitively I’d reach for Isabelle (its <code>Nominal2</code> package is great to talk about terms up-to-alpha-equivalence, and get strong induction principles for free) or maybe Coq (because that’s what everyone else is using). But before I do that: How well does Lean fare for PL theory formalization? Any particular good libraries or tools I should be aware of?</p>



<a name="279961529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/PL%20theory%20stuff/near/279961529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/PL.20theory.20stuff.html#279961529">(Apr 24 2022 at 04:30)</a>:</h4>
<p>It doesn't have any particular support specific to PL theory, but the usual stuff with constructing inductive types and inductive predicates and doing cases and induction works well enough, and I have done some nontrivial PL theory stuff in lean (both 3 and 4). I think the situation is fairly similar to Coq formalization, assuming you aren't using one of the big libraries like Iris</p>



<a name="279975989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/PL%20theory%20stuff/near/279975989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Breitner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/PL.20theory.20stuff.html#279975989">(Apr 24 2022 at 11:01)</a>:</h4>
<p>Thanks. Maybe I’m spoiled a bit, but I appreciate some automation for reasoning up to alpha-equivalence and substitution. Too bad PLT Redex is implemented in Racket and not Lean :-)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
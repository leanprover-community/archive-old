---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html">bijection `range n → zmod n`?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="278478184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278478184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278478184">(Apr 10 2022 at 16:56)</a>:</h4>
<p>Is something like the following in the library somewhere?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">range_to_zmod_bijective</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>  <span class="n">function.bijective</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">range</span> <span class="n">n</span><span class="o">),</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="278478288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278478288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278478288">(Apr 10 2022 at 16:58)</a>:</h4>
<p>We have something stronger, namely <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.subtype_congr">docs#equiv.subtype_congr</a></p>



<a name="278478626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278478626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278478626">(Apr 10 2022 at 17:04)</a>:</h4>
<p>That does not seem to give me what I want, at least not directly. How would I use it here?</p>



<a name="278478768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278478768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278478768">(Apr 10 2022 at 17:07)</a>:</h4>
<p><code>↥(range n)</code> is the subtype <code>{m : ℕ // m ∈ range n}</code>. <code>zmod n</code> is <code>fin n</code>, which is <code>{m : ℕ // 0 &lt; m}</code>. Hence <code>equiv.subtype_congr mem_range : ↥(range n) ≃ zmod n</code>.</p>



<a name="278478837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278478837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278478837">(Apr 10 2022 at 17:09)</a>:</h4>
<p>If now you care about the fact that it's <code>coe</code> and not another function, you can try showing that it's equal to the <code>equiv.subtype_congr</code> above, which I believe is an API lemma already.</p>



<a name="278478841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278478841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278478841">(Apr 10 2022 at 17:09)</a>:</h4>
<p>You can also just use <a href="https://leanprover-community.github.io/mathlib_docs/find/zmod.nat_cast_zmod_val">docs#zmod.nat_cast_zmod_val</a> along with <a href="https://leanprover-community.github.io/mathlib_docs/find/zmod.val_lt">docs#zmod.val_lt</a></p>



<a name="278478846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278478846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278478846">(Apr 10 2022 at 17:09)</a>:</h4>
<p><code>equiv.subtype_congr mem_range</code> doesn't typecheck:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">equiv.subtype_congr</span> <span class="n">mem_range</span>
<span class="n">term</span>
  <span class="n">mem_range</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_1</span> <span class="bp">∈</span> <span class="n">range</span> <span class="bp">?</span><span class="n">m_2</span> <span class="bp">↔</span> <span class="bp">?</span><span class="n">m_1</span> <span class="bp">&lt;</span> <span class="bp">?</span><span class="n">m_2</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="bp">?</span><span class="n">m_2</span> <span class="n">x</span><span class="o">}</span> <span class="bp">≃</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="bp">?</span><span class="n">m_3</span> <span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span>
</code></pre></div>



<a name="278478865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278478865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278478865">(Apr 10 2022 at 17:09)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> does <code>equiv.subtype_congr</code> say what you think it says?</p>



<a name="278478869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278478869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278478869">(Apr 10 2022 at 17:09)</a>:</h4>
<p>Oh, I do not mean <code>equiv.subtype_congr</code> indeed...</p>



<a name="278478916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278478916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278478916">(Apr 10 2022 at 17:10)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.subtype_equiv_right">docs#equiv.subtype_equiv_right</a></p>



<a name="278478951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278478951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278478951">(Apr 10 2022 at 17:11)</a>:</h4>
<p><code>equiv.subtype_equiv_right mem_range</code> also does not typecheck:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">equiv.subtype_equiv_right</span> <span class="n">mem_range</span>
<span class="n">term</span>
  <span class="n">mem_range</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_1</span> <span class="bp">∈</span> <span class="n">range</span> <span class="bp">?</span><span class="n">m_2</span> <span class="bp">↔</span> <span class="bp">?</span><span class="n">m_1</span> <span class="bp">&lt;</span> <span class="bp">?</span><span class="n">m_2</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">),</span> <span class="bp">?</span><span class="n">m_2</span> <span class="n">x</span> <span class="bp">↔</span> <span class="bp">?</span><span class="n">m_3</span> <span class="n">x</span>
</code></pre></div>



<a name="278479019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479019">(Apr 10 2022 at 17:12)</a>:</h4>
<p>Remove one explicit argument: <code>equiv.subtype_equiv_right (λ _, mem_range)</code></p>



<a name="278479052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479052">(Apr 10 2022 at 17:13)</a>:</h4>
<p><code>equiv.subtype_equiv_right (@mem_range _)</code> seems to look better.</p>



<a name="278479115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479115">(Apr 10 2022 at 17:14)</a>:</h4>
<p>Still, I don't see yet how to go from</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">range</span> <span class="n">n</span><span class="o">)</span> <span class="n">x</span><span class="o">}</span> <span class="bp">≃</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="n">x</span><span class="o">}</span>
</code></pre></div>
<p>to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">bijective</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)),</span> <span class="bp">↑</span><span class="n">a</span><span class="o">)</span>
</code></pre></div>



<a name="278479127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479127">(Apr 10 2022 at 17:15)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.bijective">docs#equiv.bijective</a></p>



<a name="278479139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479139">(Apr 10 2022 at 17:15)</a>:</h4>
<p>Try <code>convert (equiv.subtype_equiv_right $ λ _, mem_range).bijective</code>.</p>



<a name="278479307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479307">(Apr 10 2022 at 17:18)</a>:</h4>
<p>If you want a more mathlib-like lemma which you can't bash by the hacky approach I just gave you, here it is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">set</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">nat.cast_zmod_inj_on</span> <span class="o">:</span> <span class="o">(</span><span class="n">Ico</span> <span class="n">a</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">inj_on</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="278479340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479340">(Apr 10 2022 at 17:19)</a>:</h4>
<p><code>convert (equiv.subtype_equiv_right (@mem_range n)).bijective</code> leaves me with two goals, <code>zmod n = {x // x &lt; n}</code> and <code>(λ (a : ↥(range n)), ↑a) == ⇑(equiv.subtype_equiv_right mem_range)</code>.<br>
I'm already having problems with the first...</p>



<a name="278479407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479407">(Apr 10 2022 at 17:20)</a>:</h4>
<p>Oh, you must case on <code>n</code> first.</p>



<a name="278479532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479532">(Apr 10 2022 at 17:22)</a>:</h4>
<p>Even then you will need to apply some <code>ext</code>s and prove that <code>x % (n+1) = x</code> when <code>x &lt; n+1</code>.</p>



<a name="278479561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479561">(Apr 10 2022 at 17:23)</a>:</h4>
<p>This is likely very relevant: <a href="https://github.com/leanprover-community/mathlib/pull/10888">#10888</a></p>



<a name="278479572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479572">(Apr 10 2022 at 17:23)</a>:</h4>
<p>In particular, <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.mod_inj_on_Ico">docs#nat.mod_inj_on_Ico</a></p>



<a name="278479574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479574">(Apr 10 2022 at 17:23)</a>:</h4>
<p>What is <code>range</code> here? The original question isn't a mwe</p>



<a name="278479590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479590">(Apr 10 2022 at 17:23)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/range">docs#range</a></p>



<a name="278479642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479642">(Apr 10 2022 at 17:24)</a>:</h4>
<p>I assumed <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.range">docs#finset.range</a></p>



<a name="278479645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479645">(Apr 10 2022 at 17:24)</a>:</h4>
<p><code>range</code> is <code>finset.range</code></p>



<a name="278479653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479653">(Apr 10 2022 at 17:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.zmod.basic</span>

<span class="kd">lemma</span> <span class="n">range_to_zmod_bijective</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">function.bijective</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">),</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span> <span class="n">contradiction</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">e</span> <span class="o">:</span> <span class="n">finset.range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">≃</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">equiv.subtype_equiv_right</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="o">,</span> <span class="n">finset.mem_range</span><span class="o">)),</span>
  <span class="n">convert</span> <span class="n">e.bijective</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span> <span class="n">ext</span> <span class="o">⟨</span><span class="n">x</span><span class="o">⟩,</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">e</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">fin.coe_of_nat_eq_mod</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">nat.succ_ne_zero</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">finset.mem_range</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nat.mod_eq_of_lt</span> <span class="n">x_property</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="278479664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479664">(Apr 10 2022 at 17:24)</a>:</h4>
<p>But I think just proving this directly would be even shorterr</p>



<a name="278479739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479739">(Apr 10 2022 at 17:26)</a>:</h4>
<p>What's the goal after the <code>convert</code> there?</p>



<a name="278479743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479743">(Apr 10 2022 at 17:26)</a>:</h4>
<p>Thanks.<br>
What do you mean by "this" or by "directly"?</p>



<a name="278479764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479764">(Apr 10 2022 at 17:26)</a>:</h4>
<p>I mean proving this just by proving that the map is injective and surjective.</p>



<a name="278479819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479819">(Apr 10 2022 at 17:27)</a>:</h4>
<p>That's what I had in mind first (and would have tried had the answer just been "no") <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="278479879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479879">(Apr 10 2022 at 17:28)</a>:</h4>
<p>It might be worthwhile to have that equiv in mathlib in any case.</p>



<a name="278479991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278479991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278479991">(Apr 10 2022 at 17:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278479572">said</a>:</p>
<blockquote>
<p>In particular, <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.mod_inj_on_Ico">docs#nat.mod_inj_on_Ico</a></p>
</blockquote>
<p>Let me insist on this.</p>



<a name="278480058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480058">(Apr 10 2022 at 17:32)</a>:</h4>
<p>What's wrong with <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.mod_eq_of_lt">docs#nat.mod_eq_of_lt</a> ?</p>



<a name="278480076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480076">(Apr 10 2022 at 17:33)</a>:</h4>
<p>I believe Michael should first prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat.cast_zmod_inj_on</span> <span class="o">:</span> <span class="o">(</span><span class="n">Ico</span> <span class="n">a</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">inj_on</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">nat.cast_zmod_bij_on</span> <span class="o">:</span> <span class="o">(</span><span class="n">Ico</span> <span class="n">a</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">bij_on</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="n">univ</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="278480088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480088">(Apr 10 2022 at 17:33)</a>:</h4>
<p>Ah ok.</p>



<a name="278480145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480145">(Apr 10 2022 at 17:34)</a>:</h4>
<p>I'd rather get on with putting Legendre symbols right...</p>



<a name="278480155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480155">(Apr 10 2022 at 17:34)</a>:</h4>
<p>Welcome to mathlib <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="278480181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480181">(Apr 10 2022 at 17:35)</a>:</h4>
<p>Presumably these should be proved for <code>fin</code> too? (from which the zmod cases follow easily by a case split)</p>



<a name="278480188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480188">(Apr 10 2022 at 17:35)</a>:</h4>
<p>BTW, what is preferred notation: <code>∑ (a : finset.range p), ...</code> vs. <code>∑ (a : Ico 0 p), ...</code>?</p>



<a name="278480235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480235">(Apr 10 2022 at 17:36)</a>:</h4>
<p>Probably <code>∑ a in finset.range p</code></p>



<a name="278480270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480270">(Apr 10 2022 at 17:37)</a>:</h4>
<p>OK, that's what I did:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">legendre_sym_sum_zero</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">finset.range</span> <span class="n">p</span><span class="o">),</span> <span class="n">legendre_sym</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="278480274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480274">(Apr 10 2022 at 17:37)</a>:</h4>
<p>... which does not mean the same but is what you want, unless you need to access the proof that <code>a &lt; p</code>.</p>



<a name="278480280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480280">(Apr 10 2022 at 17:37)</a>:</h4>
<p>The "old" file has lots of <code>Ico</code>s...</p>



<a name="278480298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480298">(Apr 10 2022 at 17:37)</a>:</h4>
<p><code>∑ (a : finset.range p)</code> is different to <code>∑ a in finset.range p</code></p>



<a name="278480356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480356">(Apr 10 2022 at 17:38)</a>:</h4>
<p><code>∑ (a : finset.range p)</code> means <code>∑ a in (finset.univ : finset (finset.range p)),</code></p>



<a name="278480378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480378">(Apr 10 2022 at 17:38)</a>:</h4>
<p>By now, <code>legendre_sym p a</code> reduces to <code>quadratic_char p (a : zmod p)</code>, so <code>a &lt; p</code> is not needed.</p>



<a name="278480382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480382">(Apr 10 2022 at 17:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278480280">said</a>:</p>
<blockquote>
<p>The "old" file has lots of <code>Ico</code>s...</p>
</blockquote>
<p>That's likely not a bad thing. How were they used?</p>



<a name="278480402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480402">(Apr 10 2022 at 17:39)</a>:</h4>
<p>For stuff related to Gauss' Lemma and Eisenstein's Lemma, mostly.</p>



<a name="278480514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480514">(Apr 10 2022 at 17:41)</a>:</h4>
<p>If I do <code>∑ (a ∈ finset.range p), legendre_sym p a = 0</code>, then I get an error message</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="n">prime</span> <span class="n">p</span><span class="o">),</span>
<span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">2</span>
<span class="bp">⊢</span> <span class="n">fintype</span> <span class="n">ℤ</span>
</code></pre></div>
<p>Is that because somewhere <code>p ≠ 0</code> is needed?</p>



<a name="278480522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480522">(Apr 10 2022 at 17:41)</a>:</h4>
<p>That's still not what I wrote</p>



<a name="278480570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480570">(Apr 10 2022 at 17:42)</a>:</h4>
<p>You need to literally write <code>in</code></p>



<a name="278480604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480604">(Apr 10 2022 at 17:42)</a>:</h4>
<p><code>∑ (a ∈ finset.range p),</code> is parsed by lean as <code>∑ a in (finset.univ : finset ℤ), ∑ a in (finset.univ : finset (a ∈ finset.range p)),</code></p>



<a name="278480608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480608">(Apr 10 2022 at 17:42)</a>:</h4>
<p><code>∑ (a in finset.range p), legendre_sym p a = 0</code> gives <code>invalid expression starting at ...</code></p>



<a name="278480613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480613">(Apr 10 2022 at 17:43)</a>:</h4>
<p>no parens</p>



<a name="278480618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480618">(Apr 10 2022 at 17:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278480235">said</a>:</p>
<blockquote>
<p>Probably <code>∑ a in finset.range p</code></p>
</blockquote>



<a name="278480630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480630">(Apr 10 2022 at 17:43)</a>:</h4>
<p>Please copy what we write literally. Syntax is demanding.</p>



<a name="278480635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480635">(Apr 10 2022 at 17:44)</a>:</h4>
<p>Now my proof breaks down... <span aria-label="disappointed" class="emoji emoji-1f61e" role="img" title="disappointed">:disappointed:</span></p>



<a name="278480689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480689">(Apr 10 2022 at 17:44)</a>:</h4>
<p>I was using <code>fintype.sum_bijective</code> (to reduce to the similar sum when <code>a</code> runs through <code>zmod p</code>).</p>



<a name="278480701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480701">(Apr 10 2022 at 17:45)</a>:</h4>
<p>That's okay. We have similar lemmas for the usual sums.</p>



<a name="278480714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480714">(Apr 10 2022 at 17:45)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_bij">docs#finset.sum_bij</a></p>



<a name="278480800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480800">(Apr 10 2022 at 17:47)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_bij">docs#finset.sum_bij</a> has lots of arguments; <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.sum_bijective">docs#fintype.sum_bijective</a> uses <code>bijective</code> directly...</p>



<a name="278480808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278480808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278480808">(Apr 10 2022 at 17:47)</a>:</h4>
<p>You can also use <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_subtype">docs#finset.sum_subtype</a>` to get to a different form</p>



<a name="278481162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278481162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278481162">(Apr 10 2022 at 17:54)</a>:</h4>
<p>I somehow find this difficult to use to get from the sum over <code>a in range p</code> to the original sum over <code>a : range p</code>.<br>
Sorry, I have not yet a lot of experience with how sums, sets, subtypes work.</p>



<a name="278481563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278481563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278481563">(Apr 10 2022 at 18:03)</a>:</h4>
<p>One thing to keep in mind is that these finite sums are <em>always</em> sums over some finset (in fact, these are notation for <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum">docs#finset.sum</a> ). That how I remember that <code>\sum a : X, ...</code> is shorthand for the sum over <code>finset.univ : finset X</code>, and <code>\sum a in S, ...</code> where <code>S</code> is a <code>finset X</code> is shorthand for the sum over the finset <code>S</code> itself.</p>



<a name="278481721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278481721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278481721">(Apr 10 2022 at 18:06)</a>:</h4>
<p>In terms of what I am summing over, I don't really see a difference between <code>univ (range n)</code> and <code>range n</code>.</p>



<a name="278481756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278481756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278481756">(Apr 10 2022 at 18:07)</a>:</h4>
<p>Is the only difference that in the first case, <code>range n</code> (or rather, the corresponding subtype) is considered to be the universe, and in the second case, the universe is <code>nat</code>?</p>



<a name="278481827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278481827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278481827">(Apr 10 2022 at 18:08)</a>:</h4>
<p>yes, they are equal, except that the type of the variable in the two cases is different so you need a <code>.1</code> or <code>\u</code> when using it in the body</p>



<a name="278481837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278481837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278481837">(Apr 10 2022 at 18:09)</a>:</h4>
<p>there is a theorem that says they are equal which you can use if you want to recover your old proof</p>



<a name="278482078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482078">(Apr 10 2022 at 18:14)</a>:</h4>
<p>Yes that's right, remember that a finset is a <em>term</em> not a type, and the type of the finset is different in each case</p>



<a name="278482112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482112">(Apr 10 2022 at 18:15)</a>:</h4>
<p>Is that <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_subtype">docs#finset.sum_subtype</a> mentioned by Eric Wieser? It is not obvious to me how to use that.</p>



<a name="278482136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482136">(Apr 10 2022 at 18:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278481827">said</a>:</p>
<blockquote>
<p>yes, they are equal, except that the type of the variable in the two cases is different so you need a <code>.1</code> or <code>\u</code> when using it in the body</p>
</blockquote>
<p>Is that <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_subtype">docs#finset.sum_subtype</a> mentioned by Eric Wieser? It is not obvious to me how to use that.</p>



<a name="278482137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482137">(Apr 10 2022 at 18:16)</a>:</h4>
<p><code>univ (range n)</code> has type <code>finset (probably some term coerced to a type)</code> and <code>finset.range n</code> has type <code>finset nat</code></p>



<a name="278482183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482183">(Apr 10 2022 at 18:16)</a>:</h4>
<p>There's this funny up-arrow which can coerce terms to types, so you can make a type out of a finset, but the question is whether it's a good idea!</p>



<a name="278482186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482186">(Apr 10 2022 at 18:17)</a>:</h4>
<p>Anyway, I am still stuck at the proof. Right now, it looks like this.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">legendre_sym_sum_zero</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">a</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">p</span><span class="o">,</span> <span class="n">legendre_sym</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">quadratic_char_sum_zero</span> <span class="n">p</span> <span class="n">hp</span><span class="o">],</span>
  <span class="k">let</span> <span class="n">red</span> <span class="o">:</span> <span class="n">finset.range</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">zmod</span> <span class="n">p</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">he</span> <span class="o">:=</span> <span class="n">range_to_zmod_bijective</span> <span class="n">p</span> <span class="o">(</span><span class="n">nat.prime.ne_zero</span> <span class="n">_inst_1.1</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">finset.range</span> <span class="n">p</span><span class="o">),</span> <span class="n">legendre_sym</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">quadratic_char</span> <span class="n">p</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">finset.sum_bij</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">_</span><span class="o">,</span> <span class="n">red</span> <span class="n">x</span><span class="o">)</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">_</span><span class="o">,</span> <span class="n">mem_univ</span> <span class="o">(</span><span class="n">red</span> <span class="n">x</span><span class="o">))</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">_</span><span class="o">,</span> <span class="n">h</span> <span class="n">x</span><span class="o">)</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">x'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">he.injective</span> <span class="n">h</span><span class="o">)</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">he.surjective</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">imp</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">mem_univ</span> <span class="n">_</span><span class="o">,</span> <span class="n">h.symm</span><span class="o">⟩),</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">coe_coe</span><span class="o">]</span> <span class="n">at</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">t</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="278482219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482219">(Apr 10 2022 at 18:18)</a>:</h4>
<p>The stuff in the <code>have t := ...</code>was copied from the source of <code>fintype.sum_bijective</code> (or rather, <code>...prod...</code>); I would not claim I do really understand what it does.</p>



<a name="278482273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482273">(Apr 10 2022 at 18:18)</a>:</h4>
<p>The goal I am left with at the last <code>sorry</code> is<br>
<code>∑ (a : ℕ) in range p, legendre_sym p ↑a = ∑ (x : ↥(range p)), legendre_sym p ↑↑x</code></p>



<a name="278482284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482284">(Apr 10 2022 at 18:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278482136">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278481827">said</a>:</p>
<blockquote>
<p>yes, they are equal, except that the type of the variable in the two cases is different so you need a <code>.1</code> or <code>\u</code> when using it in the body</p>
</blockquote>
<p>Is that <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_subtype">docs#finset.sum_subtype</a> mentioned by Eric Wieser? It is not obvious to me how to use that.</p>
</blockquote>
<p>No, the most direct theorem stating this is <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_finset_coe">docs#finset.sum_finset_coe</a></p>



<a name="278482295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482295">(Apr 10 2022 at 18:19)</a>:</h4>
<p>For some reason, a sum over something of the form <code>(x : &lt;type&gt;)</code> shows up again.</p>



<a name="278482303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482303">(Apr 10 2022 at 18:19)</a>:</h4>
<p>you can see from the number of up arrows involved in the theorem statement why we prefer the right hand side to the left side</p>



<a name="278482452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482452">(Apr 10 2022 at 18:22)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_coe_sort">docs#finset.sum_coe_sort</a> is likely a better fit</p>



<a name="278482491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482491">(Apr 10 2022 at 18:23)</a>:</h4>
<p>Apart from the order of arguments, they look the same to me.</p>



<a name="278482561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278482561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278482561">(Apr 10 2022 at 18:24)</a>:</h4>
<p>OK, now I have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">legendre_sym_sum_zero</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">a</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">p</span><span class="o">,</span> <span class="n">legendre_sym</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">quadratic_char_sum_zero</span> <span class="n">p</span> <span class="n">hp</span><span class="o">],</span>
  <span class="k">let</span> <span class="n">red</span> <span class="o">:</span> <span class="n">finset.range</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">zmod</span> <span class="n">p</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">finset.sum_finset_coe</span> <span class="o">((</span><span class="n">legendre_sym</span> <span class="n">p</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="bp">@</span><span class="n">coe</span> <span class="n">ℕ</span> <span class="n">ℤ</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="n">range</span> <span class="n">p</span><span class="o">),</span>
  <span class="n">refine</span> <span class="n">fintype.sum_bijective</span> <span class="n">red</span> <span class="o">(</span><span class="n">range_to_zmod_bijective</span> <span class="n">p</span> <span class="o">(</span><span class="n">nat.prime.ne_zero</span> <span class="n">_inst_1.1</span><span class="o">))</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">legendre_sym</span><span class="o">,</span> <span class="n">red</span><span class="o">,</span> <span class="n">coe_coe</span><span class="o">,</span> <span class="n">int.cast_coe_nat</span><span class="o">,</span> <span class="n">comp_app</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>
<p>which looks reasonable to me.</p>



<a name="278483896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278483896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278483896">(Apr 10 2022 at 18:57)</a>:</h4>
<p>What's the statement of <a href="https://leanprover-community.github.io/mathlib_docs/find/quadratic_char_sum_zero">docs#quadratic_char_sum_zero</a>?</p>



<a name="278484023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278484023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278484023">(Apr 10 2022 at 19:00)</a>:</h4>
<p>The above is not an MWE.</p>



<a name="278484094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278484094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278484094">(Apr 10 2022 at 19:01)</a>:</h4>
<p><code>quadratic_char_sum_zero</code> is a lemma further up in the file. The statement is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">quadratic_char_sum_zero</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">),</span> <span class="n">quadratic_char</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>and the definition of <code>quadratic_char</code> is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">quadratic_char</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="k">if</span>      <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span>           <span class="k">then</span>  <span class="mi">0</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">a</span> <span class="bp">^</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span>  <span class="mi">1</span>
                        <span class="k">else</span> <span class="bp">-</span><span class="mi">1</span>
</code></pre></div>



<a name="278484167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278484167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278484167">(Apr 10 2022 at 19:02)</a>:</h4>
<p>I assume writing the sum over <code>(a : zmod p)</code> is less of an issue here, since <code>zmod p</code> is finite ?</p>



<a name="278484242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278484242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278484242">(Apr 10 2022 at 19:04)</a>:</h4>
<p>Yes, I just wonder if it would be easier to prove the fin.range version first</p>



<a name="278484244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278484244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278484244">(Apr 10 2022 at 19:04)</a>:</h4>
<p>The alternative being <code>a in univ (zmod p)</code> ?</p>



<a name="278484252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278484252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278484252">(Apr 10 2022 at 19:04)</a>:</h4>
<p>They're identical, one is syntax for the other</p>



<a name="278484280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278484280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278484280">(Apr 10 2022 at 19:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278484242">said</a>:</p>
<blockquote>
<p>Yes, I just wonder if it would be easier to prove the fin.range version first</p>
</blockquote>
<p>I'm using the ring structure of <code>zmod p</code> in the proof.</p>



<a name="278484372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278484372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278484372">(Apr 10 2022 at 19:06)</a>:</h4>
<p>The idea is that there is some <code>b : zmod p</code> such that <code>quadratic_char p b = -1</code>; use multiplicativitiy of the character and the fact that multiplication by <code>b</code> is a permutation of <code>zmod p</code>.</p>



<a name="278500064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278500064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278500064">(Apr 11 2022 at 01:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278484094">said</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">quadratic_char</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="k">if</span>      <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span>           <span class="k">then</span>  <span class="mi">0</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">a</span> <span class="bp">^</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span>  <span class="mi">1</span>
                        <span class="k">else</span> <span class="bp">-</span><span class="mi">1</span>
</code></pre></div>
<p>If I were to define this I would just do <code>a^(p/2)</code> which mathlib knows is a monoid_hom (<a href="https://leanprover-community.github.io/mathlib_docs/find/pow_monoid_hom">docs#pow_monoid_hom</a>), then show its image lies in the submonoid {0,1,-1} ⊆ zmod p, so I get a monoid_hom to the submonoid (<a href="https://leanprover-community.github.io/mathlib_docs/find/monoid_hom.mrange_restrict">docs#monoid_hom.mrange_restrict</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/submonoid.inclusion">docs#submonoid.inclusion</a>), then compose with the monoid_hom {0,1,-1} →* ℤ (seems missing, but {0,1,-1} happens to be iso to sign_type and we have <a href="https://github.com/leanprover-community/mathlib/pull/12835/files#diff-2fa03f9bb4ca3adcc899c9a0e2eeb5413815e402ce17f64031939f84de58cce3R130">cast_hom</a> there).</p>



<a name="278567016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278567016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278567016">(Apr 11 2022 at 15:03)</a>:</h4>
<p>This would require <code>p</code> to be an odd prime to work, and I would like to avoid assuming this in the definition.</p>



<a name="278567265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278567265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278567265">(Apr 11 2022 at 15:04)</a>:</h4>
<p>Would it, though?</p>



<a name="278571432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278571432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278571432">(Apr 11 2022 at 15:30)</a>:</h4>
<p>Well, <code>a ^ (p /2)</code> would not in general be 0, 1, or -1. Consider, e.g., <code>p = 6</code>...</p>



<a name="278571524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278571524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278571524">(Apr 11 2022 at 15:30)</a>:</h4>
<p>And if <code>p = 2</code>, there is no difference between 1 and -1 in <code>zmod p</code>.</p>



<a name="278571527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278571527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278571527">(Apr 11 2022 at 15:30)</a>:</h4>
<p>But <code>p = 2</code> works as expected, right?</p>



<a name="278571866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278571866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278571866">(Apr 11 2022 at 15:32)</a>:</h4>
<p>Maybe. The submonoid {0,1,-1} is the same as {0,1} in <code>zmod 2</code>; I don't know if this would cause problems.</p>



<a name="278575742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278575742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278575742">(Apr 11 2022 at 15:59)</a>:</h4>
<p>I think you only intend to use it when p is a prime, right? Otherwise it's not a character (<code>if a ^ (p / 2) = 1 then  1</code> only do what you intend when p is a prime). So maybe just add <code>p.prime</code> as an argument of <code>quadratic_char</code>? I agree that <code>p=2</code> needs special treatment when defining the hom from the submonoid {0,1,-1} of zmod p to ℤ, but doing a if..else on <code>p</code> seems better than if..else on <code>a</code>.</p>



<a name="278576272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278576272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278576272">(Apr 11 2022 at 16:02)</a>:</h4>
<p>My impression was that it is preferred to define total functions, so that adding <code>p.prime</code> as an argument should be avoided.</p>



<a name="278576396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278576396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278576396">(Apr 11 2022 at 16:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278500064">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278484094">said</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">quadratic_char</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="k">if</span>      <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span>           <span class="k">then</span>  <span class="mi">0</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">a</span> <span class="bp">^</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span>  <span class="mi">1</span>
                        <span class="k">else</span> <span class="bp">-</span><span class="mi">1</span>
</code></pre></div>
<p>If I were to define this I would just do <code>a^(p/2)</code> which mathlib knows is a monoid_hom (<a href="https://leanprover-community.github.io/mathlib_docs/find/pow_monoid_hom">docs#pow_monoid_hom</a>), then show its image lies in the submonoid {0,1,-1} ⊆ zmod p, so I get a monoid_hom to the submonoid (<a href="https://leanprover-community.github.io/mathlib_docs/find/monoid_hom.mrange_restrict">docs#monoid_hom.mrange_restrict</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/submonoid.inclusion">docs#submonoid.inclusion</a>), then compose with the monoid_hom {0,1,-1} →* ℤ (seems missing, but {0,1,-1} happens to be iso to sign_type and we have <a href="https://github.com/leanprover-community/mathlib/pull/12835/files#diff-2fa03f9bb4ca3adcc899c9a0e2eeb5413815e402ce17f64031939f84de58cce3R130">cast_hom</a> there).</p>
</blockquote>
<p>(note that the sign stuff is merging today - we have <code>mul_equiv sign_type $ fin 3</code> but not the <code>zmod</code> version - this should be doable by composing the mul_equiv from zmod to fin, but I don't think that exists, especially with the right definitional equalities)</p>



<a name="278576487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278576487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278576487">(Apr 11 2022 at 16:04)</a>:</h4>
<p>At some point, one will have to show that <code>a ^ (p / 2)</code> is 1 or -1 when <code>a \ne 0</code> and <code>p</code> is a prime; the question is perhaps, when. I imagine it would be a bit awkward to do that within the definition...</p>



<a name="278576499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278576499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278576499">(Apr 11 2022 at 16:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278576272">said</a>:</p>
<blockquote>
<p>My impression was that it is preferred to define total functions, so that adding <code>p.prime</code> as an argument should be avoided.</p>
</blockquote>
<p>this is usually if it's more convenient; it seems here that it's less so, especially as we get less bundling</p>



<a name="278577578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278577578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278577578">(Apr 11 2022 at 16:12)</a>:</h4>
<p>"mul_equiv from zmod to fin" it's <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_equiv.refl">docs#mul_equiv.refl</a></p>



<a name="278577720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278577720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278577720">(Apr 11 2022 at 16:13)</a>:</h4>
<p>of course :)</p>



<a name="278578432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278578432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278578432">(Apr 11 2022 at 16:18)</a>:</h4>
<p>It's not necessarily a character when p is not prime but I guess we are fine with junk values :)</p>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278576487">said</a>:</p>
<blockquote>
<p>At some point, one will have to show that <code>a ^ (p / 2)</code> is 1 or -1 when <code>a \ne 0</code> and <code>p</code> is a prime; the question is perhaps, when. I imagine it would be a bit awkward to do that within the definition...</p>
</blockquote>
<p>I would first define the {0,1,-1} submonoid (and the hom to ℤ), then prove the lemma saying <code>pow_monoid_hom (p/2) a ∈ the submonoid</code> under the assumptions,  then the proof of the submonoid inclusion should be short enough to fit in <code>submonoid.inclusion (by { ... })</code>.</p>



<a name="278583970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278583970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278583970">(Apr 11 2022 at 16:57)</a>:</h4>
<p>Defining a monoid_hom from an arbitrary finite field F_q to ℂ would facilitate the definition of higher (cubic, etc.) characters, but it depends on the choice of a (q-1)th primitive root both in the finite field and in ℂ ...</p>



<a name="278584547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278584547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278584547">(Apr 11 2022 at 17:00)</a>:</h4>
<p>In some way, I guess this is <a href="https://leanprover-community.github.io/mathlib_docs/find/is_cyclotomic_extension.from_zeta_aut">docs#is_cyclotomic_extension.from_zeta_aut</a> composed with an algebra map... under our definition, <code>is_cyclotomic_extension \C \C S</code> for all S. We haven't made a <code>cyclotomic_extension</code> instance for either C or F_q (and I guess F_q is more work...)</p>



<a name="278584760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278584760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278584760">(Apr 11 2022 at 17:02)</a>:</h4>
<p>oh, we only need the F_q instances, but I digress</p>



<a name="278586254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278586254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278586254">(Apr 11 2022 at 17:12)</a>:</h4>
<p>What would be the advantage(s) of doing it the way Junyan Xu suggests over leaving the definition as is and proving suitable API lemmas (including</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">quadratic_char_hom</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span> <span class="bp">→*</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">quadratic_char</span> <span class="n">p</span><span class="o">,</span> <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">quadratic_char_one</span>  <span class="n">p</span><span class="o">,</span> <span class="n">map_mul'</span> <span class="o">:=</span> <span class="n">quadratic_char_mul</span> <span class="n">p</span> <span class="o">}</span>
</code></pre></div>
<p>)?</p>



<a name="278588160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278588160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278588160">(Apr 11 2022 at 17:27)</a>:</h4>
<p>I think the main difference is that if I understand the above correctly, the latter (with suitable conditions) lets you pick a definitionally nicer <code>to_fun</code> that avoids the need for the <code>if</code>s</p>



<a name="278588305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278588305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278588305">(Apr 11 2022 at 17:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278584547">said</a>:</p>
<blockquote>
<p>... <a href="https://leanprover-community.github.io/mathlib_docs/find/is_cyclotomic_extension.from_zeta_aut">docs#is_cyclotomic_extension.from_zeta_aut</a> composed with an algebra map... </p>
</blockquote>
<p>I don't think there can be an algebra_map from char p to char 0 ...</p>
<p>The current definition of <code>quadratic_char</code> may be fine if it's just a standalone thing, but it doesn't seem to fit in the big picture as a special case of multiplicative characters from (the multiplicative group) of a finite field to ℂ. With the current definition the proofs may be less reusable. I could see that quadratic character is indeed somewhat special though, as it's "unique" because {1,-1} has trivial automorphism group, and it fits in ℤ with no need of ℂ, so maybe it warrants special treatment.</p>



<a name="278588620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278588620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278588620">(Apr 11 2022 at 17:30)</a>:</h4>
<p>One could define <code>quadratic_char</code> for finite fields of odd characteristic (or maybe also define it as the indicator function of the nonzero elements when the characteristic is 2) as a <code>monoid_hom</code> into the integers. Maybe this is a suitable level of generality?</p>



<a name="278588847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278588847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278588847">(Apr 11 2022 at 17:32)</a>:</h4>
<p>ah, d'ah, there is I think somewhere an induced map to the <code>roots_of_unity</code>, but there was some issues with +/* mixing.</p>



<a name="278590547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278590547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278590547">(Apr 11 2022 at 17:42)</a>:</h4>
<p>I feel like I'm getting confused and talking about the wrong things right now, sorry. I feel like most of the glue is there, though.</p>



<a name="278590953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278590953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278590953">(Apr 11 2022 at 17:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278588305">said</a>:</p>
<blockquote>
<p>The current definition of <code>quadratic_char</code> may be fine if it's just a standalone thing, but it doesn't seem to fit in the big picture as a special case of multiplicative characters from (the multiplicative group) of a finite field to ℂ. With the current definition the proofs may be less reusable. I could see that quadratic character is indeed somewhat special though, as it's "unique" because {1,-1} has trivial automorphism group, and it fits in ℤ with no need of ℂ, so maybe it warrants special treatment.</p>
</blockquote>
<p>I think there should be multiplicative characters into any ring (or even monoid with zero). Why restrict to ℂ as the target?</p>



<a name="278591274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278591274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278591274">(Apr 11 2022 at 17:47)</a>:</h4>
<p>As a side question, is there a way to exress that <code>ψ</code> is an <em>additive</em> character from a field <code>F</code> into some ring (or mutiplicative monoid) <code>R</code>? I.e., <code>ψ(x+y) = ψ(x)*ψ(y)</code> for all <code>x y : F</code>.</p>



<a name="278591470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278591470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278591470">(Apr 11 2022 at 17:49)</a>:</h4>
<p>You have to use <a href="https://leanprover-community.github.io/mathlib_docs/find/multiplicative">docs#multiplicative</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/additive">docs#additive</a></p>



<a name="278591764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278591764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278591764">(Apr 11 2022 at 17:50)</a>:</h4>
<p>That looks a bit painful. In particular, since there are two possibilities and no obvious reason to prefer one over the other...</p>



<a name="278592521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278592521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278592521">(Apr 11 2022 at 17:56)</a>:</h4>
<p>Usually the choice is obvious, and we wrap the weaker of the two types in <code>multiplicative</code> or <code>additive</code></p>



<a name="278592650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278592650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278592650">(Apr 11 2022 at 17:57)</a>:</h4>
<p>In practice we tend not to use the bundled version as the canonical API for those cases though; but it's still useful for golfing proofs</p>



<a name="278598672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278598672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278598672">(Apr 11 2022 at 18:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278588305">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278584547">said</a>:</p>
<blockquote>
<p>... <a href="https://leanprover-community.github.io/mathlib_docs/find/is_cyclotomic_extension.from_zeta_aut">docs#is_cyclotomic_extension.from_zeta_aut</a> composed with an algebra map... </p>
</blockquote>
<p>I don't think there can be an algebra_map from char p to char 0 ...</p>
<p>The current definition of <code>quadratic_char</code> may be fine if it's just a standalone thing, but it doesn't seem to fit in the big picture as a special case of multiplicative characters from (the multiplicative group) of a finite field to ℂ. With the current definition the proofs may be less reusable. I could see that quadratic character is indeed somewhat special though, as it's "unique" because {1,-1} has trivial automorphism group, and it fits in ℤ with no need of ℂ, so maybe it warrants special treatment.</p>
</blockquote>
<p>the real answer to this is <a href="https://leanprover-community.github.io/mathlib_docs/find/is_primitive_root.power_basis">docs#is_primitive_root.power_basis</a> + <a href="https://leanprover-community.github.io/mathlib_docs/find/power_basis.lift">docs#power_basis.lift</a>, sorry about all the nonsense I wrote before</p>



<a name="278598782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278598782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278598782">(Apr 11 2022 at 18:39)</a>:</h4>
<p>I'm not sure if we ever figured out weaker conditions for <code>is_primitive_root.power_basis</code>, but I still need to write <code>power_basis.map_conjugate</code> (+ get back to flt regular...)</p>



<a name="278599006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278599006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278599006">(Apr 11 2022 at 18:40)</a>:</h4>
<p>wait, no, still wrong. do we not have something that just sends the generator of a power-basis to something, and then just says "yes that's good enough"? maybe just for <code>basis</code></p>



<a name="278601766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278601766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278601766">(Apr 11 2022 at 19:02)</a>:</h4>
<p>I am playing around with the following.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.finite.basic</span>

<span class="kn">namespace</span> <span class="n">char</span>

<span class="kd">def</span> <span class="n">quadratic_char</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="k">if</span> <span class="n">a</span><span class="bp">^</span><span class="o">((</span><span class="n">fintype.card</span> <span class="n">F</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">-</span><span class="mi">1</span>

<span class="kd">end</span> <span class="n">char</span>
</code></pre></div>
<p>but get the complaint that Lean doesn't know how to deduce that <code>a^((fintype.card F) / 2) = 1</code> is decidable.<br>
What is the best way to get around that?</p>



<a name="278602474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278602474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278602474">(Apr 11 2022 at 19:08)</a>:</h4>
<p>... and even <code>decidable (a = 0)</code>.</p>



<a name="278602719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278602719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278602719">(Apr 11 2022 at 19:11)</a>:</h4>
<p><code>decidable_eq F</code> or just <code>classical</code> or something</p>



<a name="278602998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278602998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278602998">(Apr 11 2022 at 19:13)</a>:</h4>
<p><code>[decidable_eq F]</code> seems to be working; thanks.</p>



<a name="278611708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278611708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278611708">(Apr 11 2022 at 20:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278590953">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278588305">said</a>:</p>
<blockquote>
<p>The current definition of <code>quadratic_char</code> may be fine if it's just a standalone thing, but it doesn't seem to fit in the big picture as a special case of multiplicative characters from (the multiplicative group) of a finite field to ℂ. With the current definition the proofs may be less reusable. I could see that quadratic character is indeed somewhat special though, as it's "unique" because {1,-1} has trivial automorphism group, and it fits in ℤ with no need of ℂ, so maybe it warrants special treatment.</p>
</blockquote>
<p>I think there should be multiplicative characters into any ring (or even monoid with zero). Why restrict to ℂ as the target?</p>
</blockquote>
<p>I guess this would just be a <code>monoid_with_zero_hom</code>?</p>



<a name="278631312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278631312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278631312">(Apr 11 2022 at 23:44)</a>:</h4>
<p>Note Ashvni's work on Dirichlet characters here: <a href="https://github.com/leanprover-community/mathlib/blob/p-adic/src/number_theory/dirichlet_character.lean">https://github.com/leanprover-community/mathlib/blob/p-adic/src/number_theory/dirichlet_character.lean</a> . I was telling her to PR it only today :-)</p>



<a name="278638616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278638616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278638616">(Apr 12 2022 at 01:47)</a>:</h4>
<p><code>monoid_with_zero_hom</code> would be the correct type; what I am concerned with (and I think Eric also) is how to construct terms of that type. I don't think it needs to involve power basis or cyclotomic extension; since the multiplicative group of F_q is cyclic of order (q-1) so given a generator of (F_q)ˣ and an element x of another monoid satisfying x^(q-1) = 1 there's a unique monoid_with_zero_hom sending the generator to x. In the quadratic case with q odd, x is -1, and it makes no difference which generator we choose. There are some API useful for constructing the hom from (F_q)ˣ (<a href="https://leanprover-community.github.io/mathlib_docs/find/is_primitive_root.zmod_equiv_zpowers">docs#is_primitive_root.zmod_equiv_zpowers</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/zmod.lift">docs#zmod.lift</a>), but they don't include the zero element, haven't been specialized to the case of cyclic groups, and necessitates going back and forth between multiplicative and additive monoids. Although this approach involves a superfluous generator, it can be relatively easily connected to the a^(q/2) definition: the character is of order n (here n = 2) iff the its image has order n, iff its kernel is the subgroup of order (q-1)/n; since a ↦ a^((q-1)/n) has the same kernel and image the nth roots of unity, the character factors as a ↦ a^((q-1)/n) composed with a hom from the nth roots of unity in the domain to the codomain (iso onto the image of the character). I admit this is maybe too complicated for the current purpose.</p>
<p>Dirichlet characters have domain zmod n (n not necessarily prime) instead of a finite field, so that work seems complementary to the current discussion.</p>



<a name="278667664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278667664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278667664">(Apr 12 2022 at 09:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278631312">said</a>:</p>
<blockquote>
<p>Note Ashvni's work on Dirichlet characters here: <a href="https://github.com/leanprover-community/mathlib/blob/p-adic/src/number_theory/dirichlet_character.lean">https://github.com/leanprover-community/mathlib/blob/p-adic/src/number_theory/dirichlet_character.lean</a> . I was telling her to PR itI only today :-)</p>
</blockquote>
<p>Is this going in the direction of Dirichlet's theorem on primes in arithmetic progressions? That would be great!</p>



<a name="278667980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278667980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278667980">(Apr 12 2022 at 09:26)</a>:</h4>
<p><span class="user-mention" data-user-id="398581">@Mantas Baksys</span>, you might be interested in this.</p>



<a name="278676763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278676763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278676763">(Apr 12 2022 at 11:03)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span> it's going in the direction of defining generalised Bernoulli numbers and showing that they're values of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>-adic L-functions! Interestingly, I have seen with my own eyes a proof of Dirichlet's theorem in Lean; it was written by a computer program Metamath 0, which translated the proof which they have in metamath into a 30 megabyte unreadable but compiling Lean proof.</p>



<a name="278686151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278686151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278686151">(Apr 12 2022 at 12:38)</a>:</h4>
<p>The relevant question is perhaps rather whether Dirichlet's theorem on primes in AP is in mathlib, so that one can use the statement in further work...</p>



<a name="278686933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278686933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278686933">(Apr 12 2022 at 12:45)</a>:</h4>
<p>Nope, the closest we have is <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.exists_prime_ge_modeq_one">docs#nat.exists_prime_ge_modeq_one</a> right now in mathlib unfortunately</p>



<a name="278687287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278687287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278687287">(Apr 12 2022 at 12:48)</a>:</h4>
<p>Do we have (classical, not p-adic) L-functions?</p>



<a name="278687587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278687587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278687587">(Apr 12 2022 at 12:51)</a>:</h4>
<p>Complex analysis didn't exist until a couple of months ago, so anything related to it is in very early stages</p>



<a name="278688025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278688025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278688025">(Apr 12 2022 at 12:55)</a>:</h4>
<p>Michael -- the joke is that we are going to end up with p-adic zeta functions before the Riemann zeta function! Unfortunately recent progress in complex analysis has made me more worried about whether I can pull this joke off :-/</p>



<a name="278688098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278688098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278688098">(Apr 12 2022 at 12:56)</a>:</h4>
<p>That's a bad joke, as far as I am concerned... <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="278688339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278688339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278688339">(Apr 12 2022 at 12:58)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span>, you have to click on the topic you want to respond to. Else, your message will just be lost in the stream of messages.</p>



<a name="278688419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278688419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278688419">(Apr 12 2022 at 12:59)</a>:</h4>
<p>I've moved the message.</p>



<a name="278688778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278688778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278688778">(Apr 12 2022 at 13:01)</a>:</h4>
<p>Sorry, I didn't notice I had another message in focus.</p>



<a name="278742205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278742205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278742205">(Apr 12 2022 at 19:31)</a>:</h4>
<p>I'm struggling with additive characters on a (finite) field <code>F</code> with values in a commutative ring <code>R</code>, which I try to define as <code>ψ : (multiplicative F) →* R</code>.<br>
Now, for <code>a : F</code> I would like to define the character that sends <code>x : F</code> to <code>ψ (a*x)</code> (where the multiplication is that of <code>F</code>).<br>
I have got this far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span> <span class="n">field_theory.finite.basic</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">F</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">mul_shift'</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">F</span><span class="o">)</span> <span class="bp">→*</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">F</span><span class="o">)</span> <span class="bp">→</span> <span class="n">R</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">let</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="k">in</span> <span class="n">ψ</span> <span class="n">y</span>

<span class="kd">lemma</span> <span class="n">mul_shift_one</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">F</span><span class="o">)</span> <span class="bp">→*</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">mul_shift'</span> <span class="n">F</span> <span class="n">R</span> <span class="n">ψ</span> <span class="n">a</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_shift'</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">h₀</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">multiplicative</span> <span class="n">F</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h₀</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="bp">←</span> <span class="n">h₀</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">ψ.map_one'</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">mul_shift_mul</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">F</span><span class="o">)</span> <span class="bp">→*</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">multiplicative</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">mul_shift'</span> <span class="n">F</span> <span class="n">R</span> <span class="n">ψ</span> <span class="n">a</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mul_shift'</span> <span class="n">F</span> <span class="n">R</span> <span class="n">ψ</span> <span class="n">a</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">mul_shift'</span> <span class="n">F</span> <span class="n">R</span> <span class="n">ψ</span> <span class="n">a</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_shift'</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="o">((</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h₁</span><span class="o">,</span> <span class="n">mul_add</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">ψ.map_mul'</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">y</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h₂</span> <span class="o">:</span> <span class="o">(((</span><span class="n">a</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">multiplicative</span> <span class="n">F</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="n">a</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="sd">/-- Define the multiplicative shift of an additive character -/</span>
<span class="kd">def</span> <span class="n">mul_shift</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">F</span><span class="o">)</span> <span class="bp">→*</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">F</span><span class="o">)</span> <span class="bp">→*</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">mul_shift'</span> <span class="n">F</span> <span class="n">R</span> <span class="n">ψ</span> <span class="n">a</span><span class="o">,</span> <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">mul_shift_one</span> <span class="n">F</span> <span class="n">R</span> <span class="n">ψ</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="n">mul_shift_mul</span> <span class="n">F</span> <span class="n">R</span> <span class="n">ψ</span> <span class="n">a</span> <span class="o">}</span>
</code></pre></div>
<p>I am having problems with getting the types in <code>h₂</code> right: all the "outer" multiplications should be the multiplication of <code>F</code>, whereas the "inner" one in the left should be that of <code>multiplicative F</code>. But it is very hard to do this, since Lean seems to convert very eagerly between the two -- I somehow cannot get it to interpret the inner multiplication correctly.<br>
Any suggestions?</p>



<a name="278742552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278742552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278742552">(Apr 12 2022 at 19:33)</a>:</h4>
<p>You should never cast between the two types, use <a href="https://leanprover-community.github.io/mathlib_docs/find/multiplicative.to_add">docs#multiplicative.to_add</a> (so <code>x.to_add</code> instead of <code>(x : F)</code>)</p>



<a name="278742703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278742703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278742703">(Apr 12 2022 at 19:35)</a>:</h4>
<p>and <a href="https://leanprover-community.github.io/mathlib_docs/find/multiplicative.of_add">docs#multiplicative.of_add</a> in the other direction</p>



<a name="278743095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278743095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278743095">(Apr 12 2022 at 19:38)</a>:</h4>
<p>I think in this case you just want <code>φ.comp (add_monoid_hom.mul_right a).to_multiplicative</code></p>



<a name="278743121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278743121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278743121">(Apr 12 2022 at 19:38)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.to_multiplicative">docs#add_monoid_hom.to_multiplicative</a></p>



<a name="278743356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278743356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278743356">(Apr 12 2022 at 19:41)</a>:</h4>
<p>Ah, that makes sense. I was doing things in an overly pedestrian way...</p>



<a name="278761121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/bijection%20%60range%20n%20%E2%86%92%20zmod%20n%60%3F/near/278761121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F.html#278761121">(Apr 12 2022 at 22:17)</a>:</h4>
<p>It has taken people quite a while to figure out how to make these things work effectively. There are all sorts of issues in the background involving whether definitions should be irreducible etc, and of course figuring out how to make it all work in one theorem prover might not give you answers about how best to do it in another one. These things are often just learnt by people asking here about how to do it.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
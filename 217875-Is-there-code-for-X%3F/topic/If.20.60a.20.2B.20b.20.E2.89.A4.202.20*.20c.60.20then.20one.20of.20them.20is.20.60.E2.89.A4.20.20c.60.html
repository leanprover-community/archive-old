---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html">If `a + b ≤ 2 * c` then one of them is `≤  c`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="315122095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315122095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315122095">(Dec 10 2022 at 19:59)</a>:</h4>
<p>Do we have anything resembling the following?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.order.lemmas</span>
<span class="kn">import</span> <span class="n">tactic.linarith</span>

<span class="kd">lemma</span> <span class="n">min_le_of_add_le_two_mul</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_exists_add_of_le</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">hab</span> <span class="n">hba</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">(</span><span class="n">min_le_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_add_of_le</span> <span class="n">hab</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="o">(</span><span class="n">add_le_add_left</span> <span class="n">hab</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">two_mul</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">le_of_mul_le_mul_left</span> <span class="n">this</span> <span class="n">zero_lt_two</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">(</span><span class="n">min_le_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_add_of_le</span> <span class="n">hba</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="o">(</span><span class="n">add_le_add_right</span> <span class="n">hba</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">two_mul</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">le_of_mul_le_mul_left</span> <span class="n">this</span> <span class="n">zero_lt_two</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>Is this the correct set of typeclasses? Or can it be made to work with <code>smul</code> instead of <code>mul</code>?</p>
<p>cc <span class="user-mention" data-user-id="224323">@Junyan Xu</span> (the context is <a href="https://github.com/leanprover-community/mathlib/pull/17743">#17743</a>) and <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> (this is order stuff)</p>



<a name="315123098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315123098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315123098">(Dec 10 2022 at 20:11)</a>:</h4>
<p>It reminds me of <a href="https://leanprover-community.github.io/mathlib_docs/find/add_le_add_iff_of_ge">docs#add_le_add_iff_of_ge</a></p>



<a name="315123219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315123219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315123219">(Dec 10 2022 at 20:13)</a>:</h4>
<p>Probably the correct thing to prove is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">min_le_max_of_mul_le_mul</span> <span class="o">[</span><span class="n">not_sure</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_exists_mul_of_le</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">max</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="315123310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315123310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315123310">(Dec 10 2022 at 20:14)</a>:</h4>
<p>Obviously the follow-up is the n-ary versions</p>



<a name="315123312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315123312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315123312">(Dec 10 2022 at 20:14)</a>:</h4>
<p>I think the key property you want is <code>a ^ 2 ≤ b ^ 2 → a ≤ b</code>. Then the proof is <code>(min a b) ^ 2 ≤ a * b ≤ c * d ≤ (max c d) ^ 2</code>.</p>



<a name="315123821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315123821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315123821">(Dec 10 2022 at 20:21)</a>:</h4>
<p>Indeed, if I prove <code>(h : a + b ≤ c + d) : min a b ≤ max c d</code> first them my lemmas falls out as special cases</p>



<a name="315124090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315124090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315124090">(Dec 10 2022 at 20:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">le_of_two_nsmul_le_two_nsmul</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">•</span> <span class="n">a</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">•</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">two_nsmul</span><span class="o">,</span> <span class="n">two_nsmul</span><span class="o">,</span> <span class="bp">←</span><span class="n">two_mul</span><span class="o">,</span> <span class="bp">←</span><span class="n">two_mul</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">le_of_mul_le_mul_left</span> <span class="n">h</span> <span class="n">zero_lt_two</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">min_le_max_of_add_le_add</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_exists_add_of_le</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">max</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">hab</span> <span class="n">hba</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">(</span><span class="n">min_le_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_add_of_le</span> <span class="n">hab</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">le_total</span> <span class="n">c</span> <span class="n">d</span> <span class="k">with</span> <span class="n">hcd</span> <span class="n">hdc</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">le_trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">le_max_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">d</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_add_of_le</span> <span class="n">hcd</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="o">((</span><span class="n">add_le_add_left</span> <span class="n">hab</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">add_le_add_right</span> <span class="n">hcd</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">two_nsmul</span><span class="o">,</span> <span class="bp">←</span><span class="n">two_nsmul</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">le_of_two_nsmul_le_two_nsmul</span> <span class="n">this</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">le_trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">le_max_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_add_of_le</span> <span class="n">hdc</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="o">((</span><span class="n">add_le_add_left</span> <span class="n">hab</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">add_le_add_left</span> <span class="n">hdc</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">two_nsmul</span><span class="o">,</span> <span class="bp">←</span><span class="n">two_nsmul</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">le_of_two_nsmul_le_two_nsmul</span> <span class="n">this</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">(</span><span class="n">min_le_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_add_of_le</span> <span class="n">hba</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">le_total</span> <span class="n">c</span> <span class="n">d</span> <span class="k">with</span> <span class="n">hcd</span> <span class="n">hdc</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">le_trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">le_max_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">d</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_add_of_le</span> <span class="n">hcd</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="o">((</span><span class="n">add_le_add_right</span> <span class="n">hba</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">add_le_add_right</span> <span class="n">hcd</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">two_nsmul</span><span class="o">,</span> <span class="bp">←</span><span class="n">two_nsmul</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">le_of_two_nsmul_le_two_nsmul</span> <span class="n">this</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">le_trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">le_max_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_add_of_le</span> <span class="n">hdc</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="o">((</span><span class="n">add_le_add_right</span> <span class="n">hba</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">add_le_add_left</span> <span class="n">hdc</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">two_nsmul</span><span class="o">,</span> <span class="bp">←</span><span class="n">two_nsmul</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">le_of_two_nsmul_le_two_nsmul</span> <span class="n">this</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">min_le_of_add_le_two_mul</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_exists_add_of_le</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">min_le_max_of_add_le_add</span> <span class="o">(</span><span class="n">h.trans_eq</span> <span class="bp">$</span> <span class="n">two_mul</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">le_max_of_add_le_two_mul</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_exists_add_of_le</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">max</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">min_le_max_of_add_le_add</span> <span class="o">((</span><span class="n">two_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.trans_le</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>



<a name="315124187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315124187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315124187">(Dec 10 2022 at 20:25)</a>:</h4>
<p>Can you first prove <code>a ^ 2 ≤ b ^ 2 → a ≤ b</code> as I suggested above?</p>



<a name="315124316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315124316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315124316">(Dec 10 2022 at 20:27)</a>:</h4>
<p>I doubt it, I expect we don't have any proof that can be additivized here without some new typeclasses</p>



<a name="315124338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315124338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315124338">(Dec 10 2022 at 20:27)</a>:</h4>
<p>We sure do. <code>linear_order</code> + monotonicity of multiplication is already enough.</p>



<a name="315124423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315124423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315124423">(Dec 10 2022 at 20:28)</a>:</h4>
<p>Something like <a href="https://leanprover-community.github.io/mathlib_docs/find/le_of_pow_le_pow">docs#le_of_pow_le_pow</a> (which is definitely a misnomer!)</p>



<a name="315124542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315124542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315124542">(Dec 10 2022 at 20:30)</a>:</h4>
<p>And of course you can generalise this to any strictly monotone function. So the real deal is <del>docs#strict_mono.reflect_le</del>. We only have <a href="https://leanprover-community.github.io/mathlib_docs/find/monotone.reflect_lt">docs#monotone.reflect_lt</a> <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span> .</p>



<a name="315124859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315124859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315124859">(Dec 10 2022 at 20:33)</a>:</h4>
<p>Edited the above to at least extract the lemma you asked for</p>



<a name="315124913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315124913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315124913">(Dec 10 2022 at 20:34)</a>:</h4>
<p>/me is writing a new proof</p>



<a name="315124923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315124923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315124923">(Dec 10 2022 at 20:34)</a>:</h4>
<p>These look easy by contradiction</p>



<a name="315125823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315125823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315125823">(Dec 10 2022 at 20:47)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">min_le_of_add_le_two_mul</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_exists_add_of_le</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">le_imp_le_of_lt_imp_lt</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h2</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">lt_min_iff.1</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">h3</span> <span class="n">h4</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">two_mul</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">add_lt_add</span> <span class="n">h3</span> <span class="n">h4</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">le_max_of_add_le_two_mul</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_exists_add_of_le</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">max</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">le_imp_le_of_lt_imp_lt</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h2</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">max_lt_iff.1</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">h3</span> <span class="n">h4</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">two_mul</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">add_lt_add</span> <span class="n">h3</span> <span class="n">h4</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="315126200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315126200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315126200">(Dec 10 2022 at 20:52)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.order.lemmas</span>
<span class="kn">import</span> <span class="n">tactic.linarith</span>

<span class="kd">lemma</span> <span class="n">min_le_max_of_add_le_add</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_exists_add_of_le</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">max</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">le_imp_le_of_lt_imp_lt</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h2</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">max_lt_iff</span><span class="o">,</span> <span class="n">lt_min_iff</span><span class="o">,</span> <span class="n">lt_min_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">h2</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">h3</span><span class="o">,</span> <span class="bp">-</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="bp">-</span><span class="o">,</span> <span class="n">h4</span><span class="o">⟩⟩,</span>
  <span class="n">exact</span> <span class="n">add_lt_add</span> <span class="n">h3</span> <span class="n">h4</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="315126303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315126303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315126303">(Dec 10 2022 at 20:54)</a>:</h4>
<p>Proving a conclusion <code>min a b &lt;= c</code> is annoying because you don't know which one will be the min. But having a hypothesis <code>c &lt; min a b</code> is really powerful because you can deduce c &lt; a and c &lt; b.</p>



<a name="315126357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315126357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315126357">(Dec 10 2022 at 20:54)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group_power.basic</span>
<span class="kn">import</span> <span class="n">algebra.order.monoid.lemmas</span>
<span class="kn">import</span> <span class="n">order.lattice</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">section</span> <span class="n">preorder</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span> <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="n">swap</span> <span class="o">(</span><span class="bp">+</span><span class="o">))</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span>

<span class="kd">lemma</span> <span class="n">strict_mono.nsmul</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">strict_mono</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">strict_mono</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">n</span> <span class="bp">•</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">hn</span> <span class="o">:=</span> <span class="o">(</span><span class="n">hn</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="n">hn</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simpa</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="n">hn</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp_rw</span> <span class="n">succ_nsmul</span> <span class="n">_</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">exact</span> <span class="n">hf.add</span> <span class="o">(</span><span class="n">strict_mono.nsmul</span> <span class="n">n.succ_ne_zero</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">preorder</span>

<span class="kn">section</span> <span class="n">preorder</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span> <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="n">swap</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">strict_mono.pow</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">strict_mono</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">strict_mono</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">hn</span> <span class="o">:=</span> <span class="o">(</span><span class="n">hn</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="n">hn</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simpa</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="n">hn</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp_rw</span> <span class="n">pow_succ</span> <span class="n">_</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">exact</span> <span class="n">hf.mul'</span> <span class="o">(</span><span class="n">strict_mono.pow</span> <span class="n">n.succ_ne_zero</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">strict_mono_pow</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">strict_mono</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">strict_mono_id.pow</span> <span class="n">hn</span>

<span class="kd">end</span> <span class="n">preorder</span>

<span class="kn">section</span> <span class="n">linear_order</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="n">swap</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">@[to_additive le_of_nsmul_le_nsmul]</span>
<span class="kd">lemma</span> <span class="n">le_of_pow_le_pow'</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">strict_mono_pow</span> <span class="n">hn</span><span class="o">)</span><span class="bp">.</span><span class="n">le_iff_le.1</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="n">swap</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">min_le_max_of_mul_le_mul</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">max</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:=</span>
<span class="n">le_of_pow_le_pow'</span> <span class="n">two_ne_zero</span> <span class="bp">$</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp_rw</span> <span class="n">pow_two</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">mul_le_mul'</span> <span class="n">inf_le_left</span>
  <span class="n">inf_le_right</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">h.trans</span> <span class="bp">$</span> <span class="n">mul_le_mul'</span> <span class="n">le_sup_left</span> <span class="n">le_sup_right</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">linear_order</span>
</code></pre></div>



<a name="315126379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315126379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315126379">(Dec 10 2022 at 20:54)</a>:</h4>
<p>This all follows what I said above.</p>



<a name="315126540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315126540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315126540">(Dec 10 2022 at 20:56)</a>:</h4>
<p>(btw I'm a bit horrified by the amount of imports I need to say "give me basic algebraic order theory". How come lattices not be imported by the algebraic order hierarchy?)</p>



<a name="315128366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315128366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315128366">(Dec 10 2022 at 21:19)</a>:</h4>
<p>Kevin's proof also works under these assumptions (don't even need to assume <code>[covariant_class α α (*) (≤)] [covariant_class α α (swap (*)) (≤)]</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.order.monoid.defs</span>
<span class="kn">import</span> <span class="n">order.min_max</span>

<span class="kd">lemma</span> <span class="n">min_le_max_of_add_le_add</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span> <span class="o">[</span><span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="n">function.swap</span> <span class="o">(</span><span class="bp">+</span><span class="o">))</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span>
  <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">max</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">min_le_iff</span><span class="o">,</span> <span class="n">le_max_iff</span><span class="o">],</span>
  <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">add_lt_add</span> <span class="n">h.1.1</span> <span class="n">h.2.2</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="315128489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315128489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315128489">(Dec 10 2022 at 21:21)</a>:</h4>
<p>Are the lt versions easy too, with either spelling?</p>



<a name="315128656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315128656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315128656">(Dec 10 2022 at 21:23)</a>:</h4>
<p>Note that <a href="https://leanprover-community.github.io/mathlib_docs/find/zpow_strict_mono">docs#zpow_strict_mono</a> already exists, so your name might need disambiguating somehow</p>



<a name="315128982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315128982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315128982">(Dec 10 2022 at 21:28)</a>:</h4>
<p>It's worrying that <a href="https://leanprover-community.github.io/mathlib_docs/find/zpow_strict_mono_left">docs#zpow_strict_mono_left</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/pow_strict_mono_left">docs#pow_strict_mono_left</a> aren't analogous facts ...</p>



<a name="315129006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315129006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315129006">(Dec 10 2022 at 21:28)</a>:</h4>
<p>I've been annoyed for a long at those names but it's really hard to come up with better names before you have all the lemmas.</p>



<a name="315129138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315129138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315129138">(Dec 10 2022 at 21:30)</a>:</h4>
<blockquote>
<p>Are the lt versions easy too, with either spelling?</p>
</blockquote>
<p>If you mean this, it holds with <code>(&lt;)</code> in the covariant hypotheses replaced by <code>(≤)</code>, or under the cleaner assumption <code>linear_ordered_add_comm_monoid</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">min_lt_max_of_add_lt_add</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_add_comm_monoid</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">max</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">min_lt_iff</span><span class="o">,</span> <span class="n">lt_max_iff</span><span class="o">],</span>
  <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">add_le_add</span> <span class="n">h.1.1</span> <span class="n">h.2.2</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="315129343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315129343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315129343">(Dec 10 2022 at 21:32)</a>:</h4>
<p>(I think the (≤) version doesn't necessarily hold for <code>linear_ordered_add_comm_monoid</code> because you can consider absorptive addition on {0,1,2} then you'd have <code>1 + 1 = 2 + 2 = 2</code> but <code>2 ≰ 1</code>.)</p>



<a name="315129641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315129641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315129641">(Dec 10 2022 at 21:36)</a>:</h4>
<p>Updated my snippet above to include the <code>&lt;</code> versions.</p>



<a name="315133838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315133838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315133838">(Dec 10 2022 at 22:36)</a>:</h4>
<p>Is the mathlib4 tide past the natural place to PR these yet?</p>



<a name="315138628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315138628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315138628">(Dec 10 2022 at 23:35)</a>:</h4>
<p>Mostly not, but it's very close to the border.</p>



<a name="315138836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315138836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315138836">(Dec 10 2022 at 23:38)</a>:</h4>
<p>Are you happy to PR the earlier mono lemmas?</p>



<a name="315196729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/If%20%60a%20%2B%20b%20%E2%89%A4%202%20%2A%20c%60%20then%20one%20of%20them%20is%20%60%E2%89%A4%20%20c%60/near/315196729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/If.20.60a.20.2B.20b.20.E2.89.A4.202.20*.20c.60.20then.20one.20of.20them.20is.20.60.E2.89.A4.20.20c.60.html#315196729">(Dec 11 2022 at 12:04)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/17895">#17895</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
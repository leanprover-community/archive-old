---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html">polynomial ext with degree bound</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="288712928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288712928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288712928">(Jul 06 2022 at 18:43)</a>:</h4>
<p>Is there a way to reduce an equality of polynomials that are both "obviously" of degree at most (say) 3, to a finite number of goals: proving equality of each of the coefficients up to three?</p>
<p>Concretely, say I have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.polynomial.basic</span>
<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">K</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">X</span> <span class="bp">^</span> <span class="mi">3</span> <span class="bp">+</span> <span class="n">C</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">X</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">q</span> <span class="bp">=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">X</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">X</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">admit</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Can I reduce this to the four goals</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">X</span> <span class="bp">^</span> <span class="mi">3</span> <span class="bp">+</span> <span class="n">C</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">X</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">i</span> <span class="bp">=</span> <span class="o">((</span><span class="n">X</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">X</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">X</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">i</span>
</code></pre></div>
<p>for <code>i</code> from 0 to 3?  (After this <code>simp [coeff_mul, coeff_one, coeff_C, pow_succ, finset.nat.antidiagonal_succ]</code> is enough to make the above goals more concrete.)</p>



<a name="288712951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288712951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288712951">(Jul 06 2022 at 18:43)</a>:</h4>
<p>Is this kind of thing the motivation for <span class="user-mention" data-user-id="321459">@Damiano Testa</span>'s polynomial-degree automation?</p>



<a name="288713561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288713561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288713561">(Jul 06 2022 at 18:48)</a>:</h4>
<p>Currently, the "compute_degree" tactics make the implicit assumption that the "visibly leading term" is unique.  While this is still the case in your example, it would not be true for the smaller degree terms.  This is of course easy to adapt.  However, it might be easier to follow this workflow:</p>
<ul>
<li>show that the degree is at most <code>n</code>;</li>
<li>prove that if the degree is at most <code>n</code>, then the polynomials coincide if and only if their coeffs up to <code>n</code> coincide;</li>
<li>bash away at the left-over cases.</li>
</ul>



<a name="288713577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288713577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288713577">(Jul 06 2022 at 18:48)</a>:</h4>
<p>This is still somewhat far from what the tactics can do!</p>



<a name="288713624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288713624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288713624">(Jul 06 2022 at 18:49)</a>:</h4>
<p>But is a good motivational example to keep in mind.  I already have a <code>guess_degree</code> function, which does "the obvious"!</p>



<a name="288713701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288713701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288713701">(Jul 06 2022 at 18:50)</a>:</h4>
<p>Thanks Damiano!</p>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/polynomial.20ext.20with.20degree.20bound/near/288713561">said</a>:</p>
<blockquote>
<ul>
<li>prove that if the degree is at most <code>n</code>, then the polynomials coincide if and only if their coeffs up to <code>n</code> coincide;</li>
</ul>
</blockquote>
<p>Is there existing code for this, do you know?</p>



<a name="288713865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288713865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288713865">(Jul 06 2022 at 18:51)</a>:</h4>
<p>Maybe written for <code>finsupp</code> rather than polynomial?</p>



<a name="288713932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288713932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288713932">(Jul 06 2022 at 18:52)</a>:</h4>
<p>This must be there, though I'm not at my computer now.</p>



<a name="288714074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288714074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288714074">(Jul 06 2022 at 18:53)</a>:</h4>
<p>Btw, the <code>compute_degree_le</code> tactic is already PRed: <a href="https://github.com/leanprover-community/mathlib/pull/14762">#14762</a>.</p>



<a name="288718084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288718084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288718084">(Jul 06 2022 at 19:25)</a>:</h4>
<p>Couldn't find a lemma for the second bullet, but not too hard to prove:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">max</span> <span class="n">p.nat_degree</span> <span class="n">q.nat_degree</span><span class="o">,</span> <span class="n">p.coeff</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">q.coeff</span> <span class="n">n</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">polynomial.ext_iff</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">forall_congr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩),</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">le_or_lt</span> <span class="n">n</span> <span class="o">(</span><span class="n">max</span> <span class="n">p.nat_degree</span> <span class="n">q.nat_degree</span><span class="o">))</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h'</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">polynomial.coeff_eq_zero_of_nat_degree_lt</span> <span class="o">((</span><span class="n">le_max_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="n">h'</span><span class="o">),</span>
    <span class="n">polynomial.coeff_eq_zero_of_nat_degree_lt</span> <span class="o">((</span><span class="n">le_max_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="n">h'</span><span class="o">)],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="288718252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288718252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288718252">(Jul 06 2022 at 19:27)</a>:</h4>
<p>I suspect <code>fin_cases</code> or <code>interval_cases</code> could take it from there?</p>



<a name="288722147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288722147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288722147">(Jul 06 2022 at 19:56)</a>:</h4>
<p>Probably, <code>semiring K</code> is enough?</p>



<a name="288723895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288723895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288723895">(Jul 06 2022 at 20:09)</a>:</h4>
<p>Yeah, I didn't check</p>



<a name="288759619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288759619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288759619">(Jul 07 2022 at 04:09)</a>:</h4>
<p>If you go to <a href="https://github.com/leanprover-community/mathlib/tree/adomani_poleq">branch#adomani_poleq</a> then this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.poleq</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">K</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">X</span> <span class="bp">^</span> <span class="mi">3</span> <span class="bp">+</span> <span class="n">C</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">X</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">q</span> <span class="bp">=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">X</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">X</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">show_deg_le</span><span class="o">,</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">K: Type ?</span>
<span class="cm">_inst_1: field K</span>
<span class="cm">p q a b c : K</span>
<span class="cm">i: ℕ</span>
<span class="cm">H: i ≤ 3</span>
<span class="cm">⊢ (X ^ 3 + ⇑C p * X - ⇑C q).coeff i = ((X - ⇑C a) * (X - ⇑C b) * (X - ⇑C c)).coeff i</span>
<span class="cm">-/</span>
  <span class="gr">admit</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="288759728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288759728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288759728">(Jul 07 2022 at 04:11)</a>:</h4>
<p>As you can imagine, the example above is almost the only test I made, so there are likely lots of bugs!</p>
<p>If you end up experimenting with this tactic, please report all the bugs that you find!</p>



<a name="288761810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288761810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288761810">(Jul 07 2022 at 04:51)</a>:</h4>
<p>A proof with a weaker hypothesis:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.polynomial.basic</span>
<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">p.support</span> <span class="bp">∪</span> <span class="n">q.support</span><span class="o">,</span> <span class="n">p.coeff</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">q.coeff</span> <span class="n">n</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">polynomial.ext_iff</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">forall_congr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩),</span>
  <span class="n">by_cases</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">p.support</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">finset.mem_union_left</span> <span class="n">_</span> <span class="n">hp</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">by_cases</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">q.support</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">finset.mem_union_right</span> <span class="n">_</span> <span class="n">hq</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">not_mem_support_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">hp</span> <span class="n">hq</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="288761890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288761890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288761890">(Jul 07 2022 at 04:52)</a>:</h4>
<p>For some concrete polynomials, <code>p.support</code> will be much sparser than <code>range p.nat_degree</code>.</p>



<a name="288763680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288763680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288763680">(Jul 07 2022 at 05:24)</a>:</h4>
<p>Certainly, but that statement seems harder to transform to individual goals than the degree one, no?</p>



<a name="288766003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288766003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288766003">(Jul 07 2022 at 06:08)</a>:</h4>
<p>Currently, I used this adaptation of Ruben's version:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat_degree_le_max</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">(</span><span class="n">pn</span> <span class="o">:</span> <span class="n">p.nat_degree</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">qn</span> <span class="o">:</span> <span class="n">q.nat_degree</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">,</span> <span class="n">p.coeff</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">q.coeff</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">iff.trans</span> <span class="n">_</span> <span class="n">ext_iff.symm</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">forall_congr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩),</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">le_or_lt</span> <span class="n">i</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">coeff_eq_zero_of_nat_degree_lt</span> <span class="o">(</span><span class="n">pn.trans_lt</span> <span class="n">k</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span>
    <span class="o">(</span><span class="n">coeff_eq_zero_of_nat_degree_lt</span> <span class="o">(</span><span class="n">qn.trans_lt</span> <span class="n">k</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span>
<span class="kd">end</span>
</code></pre></div>
<p>The advantage is that it bypasses having the <code>nat_degree</code> "alone", but only uses <code>nat_degree ≤</code>, which is easier to deal with.</p>



<a name="288766374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288766374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288766374">(Jul 07 2022 at 06:15)</a>:</h4>
<p>The tactic (really <code>compute_degree_le</code>) does not try to figure out which coefficients are zero or not: it simply assumes that everything is "generic" and guesses the degree.  For instance, this happens:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">C</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">X</span> <span class="bp">^</span> <span class="mi">100</span> <span class="bp">+</span> <span class="n">C</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">show_deg_le</span><span class="o">,</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">R: Type ?</span>
<span class="cm">_inst_1: semiring R</span>
<span class="cm">a: R</span>
<span class="cm">i: ℕ</span>
<span class="cm">H: i ≤ 100</span>
<span class="cm">⊢ (⇑C a).coeff i = (0 * X ^ 100 + ⇑C a).coeff i</span>
<span class="cm">-/</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>and note that the range for <code>i</code> is <code>i ≤ 100</code>.</p>



<a name="288766730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288766730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288766730">(Jul 07 2022 at 06:21)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> I think that if working with sparse polynomials is important, then they should probably get special support, not just from this tactic, but more generally.  I think that this is also what happens with computer algebra packages that sometimes have a special "class" of "sparse whatever" with optimized algorithms.</p>
<p>Another point: computing the actual support might be trickier than computing a superset of the union of the supports.</p>



<a name="288766764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288766764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288766764">(Jul 07 2022 at 06:21)</a>:</h4>
<p>Here's a pretty mechanical proof that is meant to be similar to what meta code would do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.polynomial.degree.definitions</span>
<span class="kn">import</span> <span class="n">tactic.swap_var</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">ext_support</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">p.support</span> <span class="bp">∪</span> <span class="n">q.support</span><span class="o">,</span> <span class="n">p.coeff</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">q.coeff</span> <span class="n">n</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">polynomial.ext_iff</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">forall_congr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩),</span>
  <span class="n">by_cases</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">p.support</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">finset.mem_union_left</span> <span class="n">_</span> <span class="n">hp</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">by_cases</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">q.support</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">finset.mem_union_right</span> <span class="n">_</span> <span class="n">hq</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">not_mem_support_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">hp</span> <span class="n">hq</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">support_add_eq</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="n">p.support</span> <span class="n">q.support</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">p</span> <span class="bp">+</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="bp">=</span> <span class="n">p.support</span> <span class="bp">∪</span> <span class="n">q.support</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">le_antisymm</span> <span class="n">support_add</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">coeff_add</span><span class="o">,</span> <span class="n">mem_support_iff</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.mem_union</span><span class="o">,</span> <span class="n">mem_support_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h</span> <span class="n">h</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">swap_var</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">q.coeff</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">not_mem_support_iff</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span><span class="n">mem_support_iff</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hd</span> <span class="o">(</span><span class="n">finset.mem_inter_of_mem</span> <span class="n">h</span> <span class="n">H</span><span class="o">)</span> <span class="bp">&lt;|&gt;</span> <span class="n">exact</span> <span class="n">hd</span> <span class="o">(</span><span class="n">finset.mem_inter_of_mem</span> <span class="n">H</span> <span class="n">h</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">C</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">monomial</span> <span class="mi">3</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">monomial</span> <span class="mi">5</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">monomial</span> <span class="mi">5</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">monomial</span> <span class="mi">3</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">C</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">hps</span> <span class="o">:</span> <span class="n">p.support</span> <span class="bp">⊆</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">},</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hqs</span> <span class="o">:</span> <span class="n">q.support</span> <span class="bp">⊆</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">},</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="n">any_goals</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">support_add_eq</span><span class="o">],</span>
    <span class="n">any_goals</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">support_add_eq</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">map_one</span><span class="o">,</span> <span class="n">finset.union_assoc</span><span class="o">,</span> <span class="n">finset.mem_union</span><span class="o">,</span> <span class="n">finset.mem_insert</span><span class="o">,</span>
                <span class="n">finset.mem_singleton</span><span class="o">],</span>
      <span class="n">rintro</span><span class="bp">?;</span>
      <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">singleton</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">support_monomial'</span> <span class="n">_</span> <span class="n">_</span> <span class="o">‹</span><span class="n">_</span><span class="o">›,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.mem_singleton</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
    <span class="n">try</span> <span class="o">{</span> <span class="n">any_goals</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.disjoint_union_left</span><span class="o">,</span> <span class="n">split</span> <span class="o">}</span> <span class="o">},</span>
    <span class="n">try</span> <span class="o">{</span> <span class="n">any_goals</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.disjoint_union_right</span><span class="o">,</span> <span class="n">split</span> <span class="o">}</span> <span class="o">},</span>
    <span class="n">any_goals</span> <span class="o">{</span> <span class="n">refine</span> <span class="n">finset.disjoint_of_subset_left</span> <span class="o">(</span><span class="n">support_monomial'</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
        <span class="n">refine</span> <span class="n">finset.disjoint_of_subset_right</span> <span class="o">(</span><span class="n">support_monomial'</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
        <span class="n">intro</span><span class="o">,</span>
        <span class="n">simp</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">ext_support</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">∈</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.mem_union</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hn</span> <span class="k">with</span> <span class="n">hn</span> <span class="n">hn</span><span class="bp">;</span>
    <span class="n">exact</span> <span class="n">hps</span> <span class="n">hn</span> <span class="bp">&lt;|&gt;</span> <span class="n">exact</span> <span class="n">hqs</span> <span class="n">hn</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.mem_insert</span><span class="o">,</span> <span class="n">finset.mem_singleton</span><span class="o">]</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">rcases</span><span class="bp">?</span> <span class="n">hn</span><span class="bp">;</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="o">,</span> <span class="n">coeff_monomial</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_left_comm</span><span class="o">]</span>
<span class="kd">end</span>
</code></pre></div>



<a name="288766832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288766832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288766832">(Jul 07 2022 at 06:22)</a>:</h4>
<p>Yes, I just did what your message ended on, used the superset of the union of supports.</p>



<a name="288766895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288766895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288766895">(Jul 07 2022 at 06:23)</a>:</h4>
<p>It is possible we are in a ring where the coefficient of one of the monomials is actually zero and we don't know.</p>



<a name="288766917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288766917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288766917">(Jul 07 2022 at 06:23)</a>:</h4>
<p>That's what I mean by superset here.</p>



<a name="288766918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288766918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288766918">(Jul 07 2022 at 06:24)</a>:</h4>
<p>Yes, for instance the zero ring...</p>



<a name="288766995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288766995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288766995">(Jul 07 2022 at 06:25)</a>:</h4>
<p>You can imagine a tactic that collects all the powers it sees. It then makes the <code>{0, 3, 5}</code> that I have, but with the powers it found. It uses the tactic proof I have here to show that this finset of powers is a superset of the union of the supports.</p>



<a name="288767035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288767035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288767035">(Jul 07 2022 at 06:25)</a>:</h4>
<p>The <code>rcases?</code> takes care of the "fin_cases" equivalent on that finset that we've constructed.</p>



<a name="288767214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288767214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288767214">(Jul 07 2022 at 06:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/polynomial.20ext.20with.20degree.20bound/near/288766995">said</a>:</p>
<blockquote>
<p>You can imagine a tactic that collects all the powers it sees. It then makes the <code>{0, 3, 5}</code> that I have, but with the powers it found. It uses the tactic proof I have here to show that this finset of powers is a superset of the union of the supports.</p>
</blockquote>
<p>Such a tactic essentially already exists in <a href="https://github.com/leanprover-community/mathlib/pull/14762">#14762</a>: it needs a small amount of glue, since I did not need the support.</p>



<a name="288767227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288767227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288767227">(Jul 07 2022 at 06:28)</a>:</h4>
<p>Btw, discounting optimizations, this also works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">C</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">monomial</span> <span class="mi">3</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">monomial</span> <span class="mi">5</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">monomial</span> <span class="mi">5</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">monomial</span> <span class="mi">3</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">C</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">show_deg_le</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">coeff_monomial</span><span class="o">,</span> <span class="n">coeff_one</span><span class="o">,</span> <span class="n">eq_nat_cast</span><span class="o">,</span> <span class="n">nat.cast_one</span><span class="o">,</span> <span class="n">coeff_add</span><span class="o">],</span>
  <span class="n">split_ifs</span><span class="bp">;</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="288767683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288767683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288767683">(Jul 07 2022 at 06:31)</a>:</h4>
<p>In <a href="https://github.com/leanprover-community/mathlib/pull/14762">#14762</a> there is the function <code>guess_degree</code> which does what you probably imagine.  Combining this with <code>list_binary_operands `((+))</code> (or whatever the right syntax for quoting is), you map <code>guess_degree</code> over the previous one and you obtain a list of degrees of the terms of your expression.</p>
<p>Still, there is no support for expanding products of sums, though.</p>



<a name="288785207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288785207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288785207">(Jul 07 2022 at 09:54)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> Would it make sense to bundle <code>interval_cases</code> or <code>fin_cases</code> into the tactic?  Presumably that will be the desired next step in almost every case.</p>



<a name="288785301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288785301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288785301">(Jul 07 2022 at 09:55)</a>:</h4>
<p>Actually, not in <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/polynomial.20ext.20with.20degree.20bound/near/288767227">this example</a> of yours, I guess.</p>



<a name="288785448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288785448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288785448">(Jul 07 2022 at 09:56)</a>:</h4>
<p>I think that this is one of the differences between the "sparse vs range" approach: for a range, you would enumerate everything up to the top degree, while for the sparse case, you would single out the terms that actually appear.</p>



<a name="288785471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/288785471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#288785471">(Jul 07 2022 at 09:57)</a>:</h4>
<p>I am happy either way: at the moment, the tactic simply calls <code>norm_num</code> on the range, to make it look pretty.</p>



<a name="301017479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/301017479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#301017479">(Sep 27 2022 at 14:26)</a>:</h4>
<p>There was some discussion in this thread about the following result</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.polynomial.basic</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">F</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">f.nat_degree</span> <span class="bp">≤</span> <span class="n">d</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">g.nat_degree</span> <span class="bp">≤</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">d</span> <span class="bp">→</span> <span class="n">f.coeff</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">g.coeff</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">d</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">coeff_eq_zero_of_nat_degree_lt</span><span class="o">,</span> <span class="n">coeff_eq_zero_of_nat_degree_lt</span><span class="o">],</span>
    <span class="n">linarith</span><span class="o">,</span> <span class="n">linarith</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>but it didn't seem like the result made it into <code>mathlib</code>. I would need something along these lines...</p>



<a name="301018575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/301018575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#301018575">(Sep 27 2022 at 14:31)</a>:</h4>
<p>I don't know if this is in mathlib, but you can surely golf the second part using <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.coeff_eq_zero_of_nat_degree_lt">docs#polynomial.coeff_eq_zero_of_nat_degree_lt</a></p>



<a name="301018656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/301018656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#301018656">(Sep 27 2022 at 14:32)</a>:</h4>
<p>Ops, you're already using it</p>



<a name="301018775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/301018775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#301018775">(Sep 27 2022 at 14:32)</a>:</h4>
<p>I mean that there is no need to use a powerful tactic as <code>linarith</code>, but it doesn't matter.</p>



<a name="301019330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/301019330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#301019330">(Sep 27 2022 at 14:35)</a>:</h4>
<p>In any case if it isn't around <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.coeff_eq_zero_of_nat_degree_lt">docs#polynomial.coeff_eq_zero_of_nat_degree_lt</a> I guess it's not there.</p>



<a name="301019372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/301019372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#301019372">(Sep 27 2022 at 14:35)</a>:</h4>
<p><a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/polynomial.20ext.20with.20degree.20bound/near/288766003">Further up</a> in this thread, there is a proof of the "iff" version of this result.  However, I think that the PR in which this is contained has not been merged.  Given that the PR introduces some new tactic, it may not get merged: if you need the result, feel free to PR it!</p>



<a name="301020004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/polynomial%20ext%20with%20degree%20bound/near/301020004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/polynomial.20ext.20with.20degree.20bound.html#301020004">(Sep 27 2022 at 14:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/polynomial.20ext.20with.20degree.20bound/near/301019372">said</a>:</p>
<blockquote>
<p><a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/polynomial.20ext.20with.20degree.20bound/near/288766003">Further up</a> in this thread, there is a proof of the "iff" version of this result.  However, I think that the PR in which this is contained has not been merged.  Given that the PR introduces some new tactic, it may not get merged: if you need the result, feel free to PR it!</p>
</blockquote>
<p>Indeed, I'll PR the "iff" version then. Thanks!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
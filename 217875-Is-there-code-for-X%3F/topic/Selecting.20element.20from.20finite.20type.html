---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html">Selecting element from finite type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="253596965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253596965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jure Taslak (Slovenia) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253596965">(Sep 16 2021 at 15:06)</a>:</h4>
<p>Let's say I have a finite type <code>α</code>. Is there a way to extract/select an element <code>x  : α</code>?<br>
I want to prove a lemma of the sort "Either <code>p x</code> holds, or we remove <code>x</code> from <code>α</code> and recursively try the procedure again. Because <code>α</code> is finite, the procedure must halt"</p>



<a name="253597158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253597158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253597158">(Sep 16 2021 at 15:07)</a>:</h4>
<p><span class="user-mention" data-user-id="439334">@Jure Taslak (Slovenia)</span> Do you know the type is nonempty?</p>



<a name="253598189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253598189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jure Taslak (Slovenia) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253598189">(Sep 16 2021 at 15:14)</a>:</h4>
<p>I know that the following holds: <code>∃ x, p x</code> but I need a way to extract such an <code>x</code></p>



<a name="253598353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253598353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253598353">(Sep 16 2021 at 15:15)</a>:</h4>
<p>Have you had a look at <a href="https://leanprover-community.github.io/mathlib_docs/init/classical.html#classical.some">https://leanprover-community.github.io/mathlib_docs/init/classical.html#classical.some</a> ?</p>



<a name="253598406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253598406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253598406">(Sep 16 2021 at 15:15)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.choose">docs#fintype.choose</a> if you know there is a unique element satisfying p</p>



<a name="253598470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253598470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253598470">(Sep 16 2021 at 15:16)</a>:</h4>
<p>Oh, it was finite!</p>



<a name="253598547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253598547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253598547">(Sep 16 2021 at 15:16)</a>:</h4>
<p><span class="user-mention" data-user-id="439334">@Jure Taslak (Slovenia)</span>  <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.some">docs#classical.some</a> helps in case of general types.</p>



<a name="253598609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253598609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jure Taslak (Slovenia) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253598609">(Sep 16 2021 at 15:17)</a>:</h4>
<p>Aha this choose should do it, thank you.<br>
Edit: aha, the issue is I don't know (and it might not be true) that the x is unique.</p>



<a name="253598635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253598635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253598635">(Sep 16 2021 at 15:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439334">Jure Taslak (Slovenia)</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Selecting.20element.20from.20finite.20type/near/253596965">said</a>:</p>
<blockquote>
<p>Let's say I have a finite type <code>α</code>. Is there a way to extract/select an element <code>x  : α</code>?<br>
I want to prove a lemma of the sort "Either <code>p x</code> holds, or we remove <code>x</code> from <code>α</code> and recursively try the procedure again. Because <code>α</code> is finite, the procedure must halt"</p>
</blockquote>
<p>It sounds like you're in a proof, so you don't need classical at all, and can just use <code>rcases h</code> where <code>h : ∃ x, p x</code></p>



<a name="253598664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253598664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jure Taslak (Slovenia) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253598664">(Sep 16 2021 at 15:17)</a>:</h4>
<p>Yes, I was working with finite types in particular.</p>



<a name="253598951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253598951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jure Taslak (Slovenia) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253598951">(Sep 16 2021 at 15:19)</a>:</h4>
<p>The problem is, I only have the exsistential quantifier and the rcases tactic gives me the error: "induction tactic failed, recursor 'Exists.dcases_on' can only eliminate into Prop"</p>



<a name="253599188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253599188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253599188">(Sep 16 2021 at 15:21)</a>:</h4>
<p>In that case, the <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#choose">tactic#choose</a> allows you to (noncomputably) get such an <code>x</code>.</p>



<a name="253600403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253600403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253600403">(Sep 16 2021 at 15:28)</a>:</h4>
<p>It sounds like you might not be proving a lemma after all, but defining a value?</p>



<a name="253600473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253600473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jure Taslak (Slovenia) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253600473">(Sep 16 2021 at 15:29)</a>:</h4>
<p>Ok using choose works, but it indeed makes the lemma noncomputable.<br>
But since my type <code>α</code> is finite, there should be something like fintype.choose, which doesn't require a unique element satisfying <code>p x</code> right?</p>



<a name="253600552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253600552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jure Taslak (Slovenia) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253600552">(Sep 16 2021 at 15:29)</a>:</h4>
<p>yes perhaps that is a better way to phrase it, I need a value, satisfying some predicate.</p>



<a name="253601478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253601478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253601478">(Sep 16 2021 at 15:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Selecting.20element.20from.20finite.20type/near/253600403">said</a>:</p>
<blockquote>
<p>It sounds like you might not be proving a lemma after all, but defining a value?</p>
</blockquote>
<p>Probably defining a value in the course of proving a lemma.</p>



<a name="253601731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253601731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253601731">(Sep 16 2021 at 15:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439334">Jure Taslak (Slovenia)</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Selecting.20element.20from.20finite.20type/near/253600473">said</a>:</p>
<blockquote>
<p>Ok using choose works, but it indeed makes the lemma noncomputable.<br>
But since my type <code>α</code> is finite, there should be something like fintype.choose, which doesn't require a unique element satisfying <code>p x</code> right?</p>
</blockquote>
<p>Lemmas can't be <code>noncomputable</code>. If lean is asking you to add the <code>noncomputable</code> keyword, then you should be in a <code>def</code>.</p>



<a name="253602030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253602030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jure Taslak (Slovenia) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253602030">(Sep 16 2021 at 15:39)</a>:</h4>
<p>I don't want things to be noncomputable, as I eventually want to use typeclasses to make lean compute some examples. But for that I need it to choose an element from a finite type.</p>



<a name="253602417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253602417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jure Taslak (Slovenia) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253602417">(Sep 16 2021 at 15:41)</a>:</h4>
<p>My naive thinking is to take the underlying set and give it an arbitrary linear order, then take the max element. But perhaps there is a much easier way of doing it.</p>



<a name="253606299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253606299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253606299">(Sep 16 2021 at 16:07)</a>:</h4>
<p>See <a href="https://leanprover-community.github.io/mathlib_docs/find/trunc_sigma_of_exists">docs#trunc_sigma_of_exists</a> and adjacent definitions</p>



<a name="253608468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Selecting%20element%20from%20finite%20type/near/253608468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Selecting.20element.20from.20finite.20type.html#253608468">(Sep 16 2021 at 16:21)</a>:</h4>
<p>Nice find! That should maybe cross-reference <code>fintype.choose</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
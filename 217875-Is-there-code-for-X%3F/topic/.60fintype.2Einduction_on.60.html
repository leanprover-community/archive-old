---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html">`fintype.induction_on`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="208401637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208401637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208401637">(Aug 28 2020 at 22:31)</a>:</h4>
<p>Is there something like <code>finset.induction_on</code> for <code>fintype</code>?</p>



<a name="208405501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208405501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208405501">(Aug 28 2020 at 23:33)</a>:</h4>
<p>There isn't a notion of <code>has_insert</code> for <code>fintype</code>, but you could use <code>finset.induction_on</code> to prove things about <code>finset.univ</code></p>



<a name="208407614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208407614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208407614">(Aug 29 2020 at 00:23)</a>:</h4>
<p>I see. Isn't there a way to proof something for an empty type then show that if it holds for a type with <code>n</code> elements it holds for a type with <code>n + 1</code> elements? Something like induction on <code>fintype.card</code>?</p>



<a name="208407654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208407654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208407654">(Aug 29 2020 at 00:24)</a>:</h4>
<p>It's not even true that if something holds for a type with <code>n</code> elements then it holds for another type with <code>n</code> elements</p>



<a name="208407754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208407754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208407754">(Aug 29 2020 at 00:26)</a>:</h4>
<p>I guess the inductive step could be if it holds for every type with <code>n</code> elements, then it holds for every type with <code>n+1</code> elements--this is just induction on the cardinality</p>



<a name="208408631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208408631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208408631">(Aug 29 2020 at 00:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/.60fintype.2Einduction_on.60/near/208407654">said</a>:</p>
<blockquote>
<p>It's not even true that if something holds for a type with <code>n</code> elements then it holds for another type with <code>n</code> elements</p>
</blockquote>
<p>Not sure about that, at least in a scenario where _all_ we know about the type is its cardinality. Then <code>α β : Type</code> with the same cardinality are pretty much indistinguishable.</p>



<a name="208408734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208408734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208408734">(Aug 29 2020 at 00:49)</a>:</h4>
<p>And yes, essentially, I would like to have induction on the cardinality. However, with <code>set n := fintype.card α with hn, induction n</code> the <code>induction</code> tactic fails to create a new goal and with <code>let n := fintype.card α, induction n</code> the meaning of <code>n = 0</code> or <code>n = k + 1</code> in the induction branches (apparently) gets lost.</p>



<a name="208408851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208408851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208408851">(Aug 29 2020 at 00:52)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="kn">example</span> <span class="o">[</span><span class="n">hα</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">set</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- The goal here is:</span>
    <span class="c1">-- `⊢ (let n : ℕ := fintype.card α in ∃ (k : ℕ) (H : k &gt; 0), f^[k] a = a) 0`</span>
    <span class="c1">-- Even the `sorry` tactic fails...</span>
    <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208408869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208408869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208408869">(Aug 29 2020 at 00:53)</a>:</h4>
<p>Also, its not the first time I end up with a goal of the form <code>(let something = something in ...)</code> and I have no clue what it's supposed to mean. Does it mean I did something wrong or I just don't know how to handle such goals?</p>



<a name="208408974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208408974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208408974">(Aug 29 2020 at 00:57)</a>:</h4>
<p>I just realized that the term <code>(let n : ℕ := fintype.card α in ∃ (k : ℕ) (H : k &gt; 0), f^[k] a = a) 0</code> in the goal is not even well typed... I am pretty sure this isn't supposed to happen, at least, it feels really weird.</p>



<a name="208409127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208409127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208409127">(Aug 29 2020 at 01:01)</a>:</h4>
<p>This may be a problem with the <code>induction</code> tactic I feel. Shouldn't it fail like in <code>set n := fintype.card α with hn, induction n</code> instead of creating an ill-typed goal?</p>



<a name="208409566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208409566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208409566">(Aug 29 2020 at 01:12)</a>:</h4>
<p>Well, after messing around in term mode a bit, I arrived at the following:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">α</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">rfl</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">k</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">α</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">n</span> <span class="n">ih</span> <span class="n">nh</span><span class="o">,</span>
    <span class="c1">-- The hypothesis `nh` is useless.</span>
    <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208409658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208409658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208409658">(Aug 29 2020 at 01:14)</a>:</h4>
<p>The example below is way more readable and generates the same goals.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">set</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">α</span> <span class="k">with</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">n</span> <span class="n">ih</span> <span class="n">nh</span><span class="o">,</span>
    <span class="c1">-- The hypothesis `nh` is useless.</span>
    <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208413039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208413039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Wong <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208413039">(Aug 29 2020 at 02:45)</a>:</h4>
<p>(deleted)</p>



<a name="208413953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208413953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208413953">(Aug 29 2020 at 03:09)</a>:</h4>
<p>You should not induct on a let bound variable</p>



<a name="208413960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208413960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208413960">(Aug 29 2020 at 03:09)</a>:</h4>
<p><code>induction</code> was apparently not built to handle it</p>



<a name="208414012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208414012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208414012">(Aug 29 2020 at 03:10)</a>:</h4>
<p>To do this kind of thing you should do <code>generalize hn : fintype.card α = n, induction n</code></p>



<a name="208414027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208414027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208414027">(Aug 29 2020 at 03:11)</a>:</h4>
<p>Actually this induction will be useless the IH will never apply</p>



<a name="208427769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208427769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208427769">(Aug 29 2020 at 10:39)</a>:</h4>
<p>One example of induction on the cardinality of a <code>fintype</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/euclidean_geometry.exists_unique_dist_eq_of_affine_independent/src">src#euclidean_geometry.exists_unique_dist_eq_of_affine_independent</a> (where the key part starting the induction is</p>
<div class="codehilite"><pre><span></span><code>  <span class="n">generalize&#39;</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">ι</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">unfreezingI</span> <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">m</span> <span class="n">hm</span> <span class="n">generalizing</span> <span class="n">ι</span> <span class="o">},</span>
</code></pre></div>


<p>and then later it has to compute the cardinality of a subtype <code>{x // x ≠ i}</code> to apply the induction hypothesis).</p>



<a name="208438693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208438693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208438693">(Aug 29 2020 at 15:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/.60fintype.2Einduction_on.60/near/208413953">said</a>:</p>
<blockquote>
<p>You should not induct on a let bound variable</p>
</blockquote>
<p>What is the difference between induction on a let bound variable and induction on the <code>generalize'</code> created <code>n</code>? Is it the <code>generalizing ι</code>?</p>



<a name="208438713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208438713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208438713">(Aug 29 2020 at 15:16)</a>:</h4>
<p>Also, shouldn't <code>induction</code> throw an error instead of producing an ill-typed goal? Sounds like a bug to me.</p>



<a name="208450297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208450297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208450297">(Aug 29 2020 at 19:38)</a>:</h4>
<p><span class="user-mention" data-user-id="298376">@Pedro Minicz</span> Compare the proof states after each. The variable created by <code>set</code> is a let bound variable, i.e. it appears in the context as <code>x : t := val</code> instead of the usual <code>x : t</code>. When this gets reverted, the state ends up being different than what <code>induction</code> was expecting and it misapplies the recursion theorem.</p>



<a name="208450306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208450306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208450306">(Aug 29 2020 at 19:39)</a>:</h4>
<p>Are you sure it's ill typed? I think it's just not useful</p>



<a name="208450375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208450375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208450375">(Aug 29 2020 at 19:40)</a>:</h4>
<p>I've seen these <code>let</code> expressions applied to arguments before and never really understood what was going on. Does it mean something other than applying the body of the <code>let</code> expression?</p>



<a name="208450380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208450380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208450380">(Aug 29 2020 at 19:40)</a>:</h4>
<p>also, yes this is a bug in <code>induction</code>, but unfortunately there are very few tactics that handle let bound variables correctly. I recall Jannis mentioned this in his <a href="https://limperg.de/posts/2020-08-19-lean-metaprogramming.html#local-definitions">review of lean 3 metaprogramming</a></p>



<a name="208450393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208450393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208450393">(Aug 29 2020 at 19:41)</a>:</h4>
<p>It could be that I was running into the same bug.</p>



<a name="208450406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208450406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208450406">(Aug 29 2020 at 19:41)</a>:</h4>
<p>What I usually do is reformulate the statement by hand in a way that tactics can't mess it up, e.g., explicitly quantifying over a variable <code>n : nat</code> with a hypothesis <code>n = fintype.card ι</code> or whatever</p>



<a name="208450451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208450451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208450451">(Aug 29 2020 at 19:42)</a>:</h4>
<p>and then manually apply to <code>_ rfl</code> in the final theorem</p>



<a name="208450454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208450454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208450454">(Aug 29 2020 at 19:42)</a>:</h4>
<p>Ah, you know what I think it did just revert, expect a pi, and try to use that as the motive</p>



<a name="208450456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208450456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208450456">(Aug 29 2020 at 19:42)</a>:</h4>
<p>it's not always pretty, but it works</p>



<a name="208450466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208450466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208450466">(Aug 29 2020 at 19:42)</a>:</h4>
<p>That's what <code>generalize</code> does</p>



<a name="208450490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60fintype.induction_on%60/near/208450490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60fintype.2Einduction_on.60.html#208450490">(Aug 29 2020 at 19:43)</a>:</h4>
<p>Usually you only need to write out the induction hyp explicitly if some occurrences of the variable are not being inducted</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
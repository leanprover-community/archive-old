---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html">Continuous bijective from compact to T1 implies homeomorphis</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="229652836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/229652836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#229652836">(Mar 10 2021 at 13:01)</a>:</h4>
<p>I guess that we have somewhere in mathlib the fact that a continuous bijection from a compact space to a separated space is an homeomorphism, but I am not able to find it... does someone know where is it?</p>



<a name="229653273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/229653273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#229653273">(Mar 10 2021 at 13:04)</a>:</h4>
<p>You have <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous.closed_embedding">docs#continuous.closed_embedding</a></p>



<a name="229655009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/229655009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#229655009">(Mar 10 2021 at 13:15)</a>:</h4>
<p>Thank's! It seems a little strange to me that we don't have the literal statement, but may I am missing some subtleties about this part of the library.</p>



<a name="229655992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/229655992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#229655992">(Mar 10 2021 at 13:20)</a>:</h4>
<p>I think there was a PR recently with a constructor for <code>homeo</code> that did just that. But maybe I misremember.</p>



<a name="261719300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/261719300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#261719300">(Nov 16 2021 at 22:52)</a>:</h4>
<p>I just wanted this and was about to ask here but Zulip pointed me to this thread when I was composing the title. I have the same question except I'm only smart enough to prove it for t2 spaces. Do we really not have either of these?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.homeomorph</span>

<span class="kd">theorem</span> <span class="n">foo</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span>
<span class="o">[</span><span class="n">compact_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">Y</span><span class="o">]</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">≃</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f.symm</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">continuous_iff_is_closed.mpr</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">C</span> <span class="n">hC</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hC2</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">C</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">library_search</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hC3</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">library_search</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hC4</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">library_search</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">hC4</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">tidy</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span>
<span class="o">[</span><span class="n">compact_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">Y</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">≃</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">≃ₜ</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">continuous_to_fun</span> <span class="o">:=</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">continuous_inv_fun</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">hf</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">f</span> <span class="o">}</span>
</code></pre></div>
<p>What I like about the proof of <code>foo</code> is that it's essentially the proof I'd write on the board.</p>



<a name="261719784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/261719784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#261719784">(Nov 16 2021 at 22:56)</a>:</h4>
<p>It's apparently not actually true for T1 spaces.</p>



<a name="261721496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/261721496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#261721496">(Nov 16 2021 at 23:12)</a>:</h4>
<p>If both <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>∪</mo><mo stretchy="false">{</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\mathbb{N}\cup\{\infty\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">∞</span><span class="mclose">}</span></span></span></span> as their points where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> is the one-point compactification of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> has the cofinite topology, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> is compact, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> is T1, the identity function is a continuous bijection, but it's not a homeomorphism.</p>



<a name="261722347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/261722347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#261722347">(Nov 16 2021 at 23:21)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/CompHaus.is_iso_of_bijective">docs#CompHaus.is_iso_of_bijective</a> should be a thing (I think)</p>



<a name="261722463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/261722463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#261722463">(Nov 16 2021 at 23:22)</a>:</h4>
<p>Oh perfect, that will do for me. Adam I'm still wrestling with that binary product thing ;-)</p>



<a name="261722535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/261722535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#261722535">(Nov 16 2021 at 23:23)</a>:</h4>
<p>I think we have a wrapper for Profinite too... Let's check <a href="https://leanprover-community.github.io/mathlib_docs/find/Profinite.is_iso_of_bijective">docs#Profinite.is_iso_of_bijective</a></p>



<a name="261754364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/261754364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#261754364">(Nov 17 2021 at 08:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis/near/261722347">said</a>:</p>
<blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/CompHaus.is_iso_of_bijective">docs#CompHaus.is_iso_of_bijective</a> should be a thing (I think)</p>
</blockquote>
<p>I think it's a bad idea to add mathematical content to the category theory part of mathlib. It should only wrap mathematical content. If the concrete lemma is missing I think you should add it first and then wrap it.</p>



<a name="261754432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/261754432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#261754432">(Nov 17 2021 at 08:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis/near/261721496">said</a>:</p>
<blockquote>
<p>If both <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>∪</mo><mo stretchy="false">{</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\mathbb{N}\cup\{\infty\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">∞</span><span class="mclose">}</span></span></span></span> as their points where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> is the one-point compactification of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> has the cofinite topology, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> is compact, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> is T1, the identity function is a continuous bijection, but it's not a homeomorphism.</p>
</blockquote>
<p>Don't hesitate to add this example right after proving the lemma. I think we should have more of those in mathlib.</p>



<a name="261798222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/261798222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#261798222">(Nov 17 2021 at 15:17)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.category.Compactum</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">Compactum_to_CompHaus.is_equivalence</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">reflects_isomorphisms</span> <span class="n">Compactum.forget</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">of_type_monad</span> <span class="n">ultrafilter</span><span class="o">)</span><span class="bp">.</span><span class="n">forget_reflects_iso</span>

<span class="kd">lemma</span> <span class="n">category_theory.reflects_isomorphisms_comp</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span>
  <span class="o">[</span><span class="n">category</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">⥤</span> <span class="n">E</span><span class="o">)</span> <span class="o">[</span><span class="n">reflects_isomorphisms</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">reflects_isomorphisms</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">reflects_isomorphisms</span> <span class="o">(</span><span class="n">F</span> <span class="bp">⋙</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">A</span> <span class="n">B</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">resetI</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">is_iso</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">resetI</span><span class="o">,</span> <span class="n">apply</span> <span class="n">is_iso_of_reflects_iso</span> <span class="n">f</span> <span class="n">F</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">is_iso_of_reflects_iso</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f</span><span class="o">)</span> <span class="n">G</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">reflects_isomorphisms</span> <span class="n">Compactum_to_CompHaus.inv</span> <span class="o">:=</span>
<span class="n">category_theory.of_full_and_faithful</span> <span class="n">Compactum_to_CompHaus.inv</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">reflects_isomorphisms</span> <span class="o">(</span><span class="n">Compactum_to_CompHaus.inv</span> <span class="bp">⋙</span> <span class="n">forget</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">category_theory.reflects_isomorphisms_comp</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">lemma</span> <span class="n">category_theory.reflects_isomorphisms_of_iso</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span>
  <span class="o">{</span><span class="n">F</span> <span class="n">G</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">}</span> <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">≅</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">reflects_isomorphisms</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">reflects_isomorphisms</span> <span class="n">F</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="n">A</span> <span class="n">B</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">⟩,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">is_iso</span> <span class="o">(</span><span class="n">G.map</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">η.inv.app</span> <span class="n">B</span> <span class="bp">≫</span> <span class="n">g</span> <span class="bp">≫</span> <span class="n">η.hom.app</span> <span class="n">A</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">reassoc_of</span> <span class="n">h1</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">category.assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">η.hom.naturality</span><span class="o">,</span> <span class="n">reassoc_of</span> <span class="n">h2</span><span class="o">],</span> <span class="n">simp</span> <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">is_iso_of_reflects_iso</span> <span class="n">f</span> <span class="n">G</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">reflects_isomorphisms</span> <span class="o">(</span><span class="n">forget</span> <span class="n">CompHaus</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">E</span> <span class="o">:</span> <span class="n">forget</span> <span class="n">CompHaus</span> <span class="bp">≅</span> <span class="n">Compactum_to_CompHaus.inv</span> <span class="bp">⋙</span> <span class="n">Compactum.forget</span> <span class="o">:=</span>
  <span class="n">iso_whisker_right</span> <span class="n">Compactum_to_CompHaus.as_equivalence.counit_iso.symm</span> <span class="o">(</span><span class="n">forget</span> <span class="n">_</span><span class="o">)</span> <span class="k">in</span>
<span class="n">category_theory.reflects_isomorphisms_of_iso</span> <span class="n">E</span>

<span class="kd">lemma</span> <span class="n">CompHaus.is_iso_of_bijective'</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">CompHaus</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.bijective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_iso</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">is_iso_iff_bijective</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">is_iso</span> <span class="o">((</span><span class="n">forget</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">resetI</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">is_iso_of_reflects_iso</span> <span class="n">f</span> <span class="o">(</span><span class="n">forget</span> <span class="n">_</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="266155044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/266155044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#266155044">(Dec 27 2021 at 08:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis/near/261754432">said</a>:</p>
<blockquote>
<p>Don't hesitate to add this example right after proving the lemma. I think we should have more of those in mathlib.</p>
</blockquote>
<p>I wasn't sure whether what <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> wrote made it into mathlib (at least I couldn't find the theorem statement), so I created <a href="https://github.com/leanprover-community/mathlib/pull/11072">#11072</a> just in case.</p>
<p>It also has a counterexample for the T1 generalization, written as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">homeo_of_equiv_compact_to_t2.t1_counterexample</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">Iα</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Iβ</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">β</span><span class="o">),</span> <span class="kd">by</span> <span class="n">exactI</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="n">compact_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">t1_space</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">),</span>
  <span class="bp">¬</span> <span class="n">continuous</span> <span class="n">f.symm</span>
</code></pre></div>
<p>though I probably should refactor the proof -- I basically reimplemented the one-point compactification, and I wasn't sure whether the cofinite topology already existed in some way so I implemented that for <code>nat</code> with the discrete topology, too.</p>



<a name="266176601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/266176601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#266176601">(Dec 27 2021 at 14:30)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I just opened <a href="https://github.com/leanprover-community/mathlib/pull/11076">#11076</a></p>



<a name="266176610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/266176610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#266176610">(Dec 27 2021 at 14:30)</a>:</h4>
<p>Sorry about all those missing pieces.</p>



<a name="266176652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/266176652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#266176652">(Dec 27 2021 at 14:31)</a>:</h4>
<p>I haven't included your counter-example, this is <em>your</em> reward.</p>



<a name="266176688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/266176688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#266176688">(Dec 27 2021 at 14:31)</a>:</h4>
<p>After that PR you'll be able to modify yours to use:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">homeo_of_equiv_compact_to_t2.t1_counterexample</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">Iα</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Iβ</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">β</span><span class="o">),</span> <span class="kd">by</span> <span class="n">exactI</span>
  <span class="n">compact_space</span> <span class="n">α</span> <span class="bp">∧</span> <span class="n">t1_space</span> <span class="n">β</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span><span class="o">,</span> <span class="n">continuous</span> <span class="n">f</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">continuous</span> <span class="n">f.symm</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">topα</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nhds_adjoint</span> <span class="mi">0</span> <span class="n">filter.cofinite</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">topβ</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">topological_space.cofinite</span> <span class="n">ℕ</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">ℕ</span> <span class="o">,</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">topα</span><span class="o">,</span> <span class="n">topβ</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">t1_space_cofinite</span><span class="o">,</span> <span class="n">equiv.refl</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">constructor</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">is_compact_iff_ultrafilter_le_nhds</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">f</span><span class="o">,</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="bp">↑</span><span class="n">f</span> <span class="bp">≤</span> <span class="bp">@</span><span class="n">nhds</span> <span class="n">_</span> <span class="n">topα</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">hf</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">f</span> <span class="bp">≤</span> <span class="bp">@</span><span class="n">nhds</span> <span class="n">_</span> <span class="n">topα</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">hf</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">h0U</span><span class="o">,</span> <span class="n">hU_fin</span><span class="o">,</span> <span class="n">hUf</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">∈</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">U</span><span class="bp">ᶜ.</span><span class="n">finite</span> <span class="bp">∧</span> <span class="n">U</span> <span class="bp">∉</span> <span class="n">f</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nhds_adjoint_nhds</span><span class="o">,</span> <span class="n">filter.le_def</span><span class="o">]</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
        <span class="n">push_neg</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
        <span class="n">simpa</span> <span class="o">[</span><span class="n">and_assoc</span><span class="o">]</span> <span class="n">using</span> <span class="n">hf</span> <span class="o">},</span>
      <span class="n">rw</span> <span class="bp">←</span> <span class="n">ultrafilter.compl_mem_iff_not_mem</span> <span class="n">at</span> <span class="n">hUf</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">hn'</span><span class="o">,</span> <span class="n">hn</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ultrafilter.eq_principal_of_finite_mem</span> <span class="n">hU_fin</span> <span class="n">hUf</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
      <span class="n">intros</span> <span class="n">s'</span> <span class="n">hns'</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">hn</span><span class="o">,</span>
      <span class="n">exact</span> <span class="bp">@</span><span class="n">mem_of_mem_nhds</span> <span class="n">_</span> <span class="n">topα</span> <span class="n">n</span> <span class="n">_</span> <span class="n">hns'</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">continuous_iff_coinduced_le</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">topα</span> <span class="bp">≤</span> <span class="n">topβ</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">gc_nhds</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">nhds_cofinite</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">h</span> <span class="o">:</span> <span class="n">topβ</span> <span class="bp">≤</span> <span class="n">topα</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">continuous_iff_coinduced_le</span><span class="o">,</span> <span class="n">coinduced_id</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">le_nhds_adjoint_iff</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span>  <span class="o">(</span><span class="n">finite_singleton</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">infinite_compl</span> <span class="o">(</span><span class="n">h.2</span> <span class="mi">1</span> <span class="n">one_ne_zero</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">mem_singleton</span> <span class="mi">1</span><span class="o">⟩)</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="266176910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/266176910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#266176910">(Dec 27 2021 at 14:35)</a>:</h4>
<p>Note this proof isn't much shorter if you take into account that the topology definitions have been removed, but it minimizes messing around with sets.</p>



<a name="266178412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/266178412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#266178412">(Dec 27 2021 at 14:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis/near/266176610">said</a>:</p>
<blockquote>
<p>Sorry about all those missing pieces.</p>
</blockquote>
<p>No need to apologize! I was happy doing this as an exercise, and it's nice that it helped drive more library development. (Thanks for implementing <code>eq_principal_of_finite_mem</code>, too.)</p>



<a name="266178609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/266178609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#266178609">(Dec 27 2021 at 14:59)</a>:</h4>
<p>Indeed counter-examples also have this library development role.</p>



<a name="266178702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/266178702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#266178702">(Dec 27 2021 at 15:00)</a>:</h4>
<p>The cofinite topology was a really unexpected hole.</p>



<a name="266178986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/266178986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#266178986">(Dec 27 2021 at 15:05)</a>:</h4>
<p>Is there a construction like <a href="https://leanprover-community.github.io/mathlib_docs/find/topological_space.nhds_adjoint">docs#topological_space.nhds_adjoint</a> that could specialize to <a href="https://leanprover-community.github.io/mathlib_docs/find/alexandroff.topological_space">docs#alexandroff.topological_space</a>?</p>



<a name="266180535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Continuous%20bijective%20from%20compact%20to%20T1%20implies%20homeomorphis/near/266180535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis.html#266180535">(Dec 27 2021 at 15:28)</a>:</h4>
<p>I guess we could cook up a definition giving both cases, but I'm not sure we would gain much.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
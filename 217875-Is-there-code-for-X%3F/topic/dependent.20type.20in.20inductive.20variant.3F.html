---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html">dependent type in inductive variant?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="213705756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213705756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213705756">(Oct 18 2020 at 13:09)</a>:</h4>
<p>Hello. I'm trying to fine-tune the parameters of an inductive variant but hit a type error. Is there a coersion trick I need?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Q</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="k">Pi</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">),</span> <span class="k">if</span> <span class="n">b</span> <span class="k">then</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">Q</span> <span class="k">else</span> <span class="n">Q</span>
</code></pre></div>

<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">ite</span> <span class="bp">↥</span><span class="n">b</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="n">Q</span>
<span class="n">term</span>
  <span class="n">Q</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Sort</span> <span class="bp">?</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="kt">Sort</span> <span class="o">(</span><span class="n">imax</span> <span class="mi">1</span> <span class="bp">?</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">imax</span> <span class="mi">1</span> <span class="bp">?</span><span class="o">)</span>
</code></pre></div>



<a name="213705826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213705826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213705826">(Oct 18 2020 at 13:11)</a>:</h4>
<p>I know I can do <code>inductive Q | a (b : bool) (c : if b then nat else unit)</code> but this doesn't suffice for my use case.</p>



<a name="213705895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213705895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213705895">(Oct 18 2020 at 13:14)</a>:</h4>
<p>I don't think this is valid in any schema for inductive types I've ever seen</p>



<a name="213706089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706089">(Oct 18 2020 at 13:18)</a>:</h4>
<p>what would the recursor look like?</p>



<a name="213706090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706090">(Oct 18 2020 at 13:18)</a>:</h4>
<p>You have to do <code>inductive Q | a (b : bool) (c : if b then nat else unit)</code>. But you can still define a wrapper function that has the type you want</p>



<a name="213706111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706111">(Oct 18 2020 at 13:19)</a>:</h4>
<p>My real code for reference. This works, but I want to encode that <code>rs3</code> isn't unit but doesn't exist for all other operations. Similarly, I want to inline <code>reg_imm</code> which is currently <code>inductive reg_imm | register reg | imm int</code>. But I'm fine either way on the <code>reg_imm</code> case because I can just <code>coe</code> reg and <code>int</code> to it respectively.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">|</span> <span class="n">arith</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">arith</span><span class="o">)</span> <span class="o">(</span><span class="n">rd</span> <span class="n">rs1</span> <span class="o">:</span> <span class="n">reg</span><span class="o">)</span>
  <span class="o">(</span><span class="n">rs2_imm</span> <span class="o">:</span> <span class="k">if</span> <span class="n">op</span> <span class="bp">∈</span> <span class="o">[</span><span class="n">xor</span><span class="o">,</span> <span class="n">or</span><span class="o">,</span> <span class="n">and</span><span class="o">,</span> <span class="n">shiftl</span><span class="o">,</span> <span class="n">shiftr</span><span class="o">,</span> <span class="n">add</span><span class="o">]</span> <span class="k">then</span> <span class="n">reg_imm</span> <span class="k">else</span> <span class="n">reg</span><span class="o">)</span>
  <span class="o">(</span><span class="n">rs3</span> <span class="o">:</span> <span class="k">if</span> <span class="n">op</span> <span class="bp">∈</span> <span class="o">[</span><span class="n">fmadd</span><span class="o">,</span> <span class="n">fnmadd</span><span class="o">,</span> <span class="n">fmsub</span><span class="o">,</span> <span class="n">fnmsub</span><span class="o">]</span> <span class="k">then</span> <span class="n">reg</span> <span class="k">else</span> <span class="n">unit</span><span class="o">)</span>
</code></pre></div>



<a name="213706224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706224">(Oct 18 2020 at 13:22)</a>:</h4>
<p>Could you elaborate about the wrapper function? Not sure if it'd apply here. The easiest hack I can see as sugar for the consumer is to use <code>opt_param unit ()</code> in place of <code>unit</code> but I still need to discard it when matching.</p>



<a name="213706227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706227">(Oct 18 2020 at 13:22)</a>:</h4>
<p>I'm perfectly fine to just discard it, I'm not matching it too many times. Just wanted to know if I could avoid it.</p>



<a name="213706290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706290">(Oct 18 2020 at 13:24)</a>:</h4>
<p>You could have <code>rs2</code> and <code>rs3</code> in a type like <code>arith_args : arith -&gt; Type</code> defined by pattern matching</p>



<a name="213706294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706294">(Oct 18 2020 at 13:24)</a>:</h4>
<p>this seems a little smelly though</p>



<a name="213706375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706375">(Oct 18 2020 at 13:26)</a>:</h4>
<p>Why not just pretend you're writing Haskell</p>



<a name="213706390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706390">(Oct 18 2020 at 13:27)</a>:</h4>
<p>and then try to factor out as much repetition as possible</p>



<a name="213706395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706395">(Oct 18 2020 at 13:27)</a>:</h4>
<p>I guess I'll go with the code above with <code>opt_param unit ()</code>. Thanks anyway.</p>



<a name="213706398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706398">(Oct 18 2020 at 13:27)</a>:</h4>
<p>I am trying to factor out the repetition here :)</p>



<a name="213706448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706448">(Oct 18 2020 at 13:28)</a>:</h4>
<p>e.g. <code>op</code> can have three variants depending on which kind of <code>rs2_imm</code> and <code>rs3</code> it takes</p>



<a name="213706453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706453">(Oct 18 2020 at 13:28)</a>:</h4>
<p>right, but you're using way too powerful features to do so. You skipped the step "pretend you're writing in Haskell"</p>



<a name="213706713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706713">(Oct 18 2020 at 13:35)</a>:</h4>
<p>I'm not sure what you're proposing here. I did start with less powerful tools. I'm trying to reduce repetition and have done so. The only caveat which remained is that the last parameter doesn't belong in most cases but doesn't deserve its own variant.</p>



<a name="213706883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706883">(Oct 18 2020 at 13:39)</a>:</h4>
<p>combine the <code>op</code> and <code>rs2_imm</code> and <code>rs3</code> fields into one type, with three constructors</p>



<a name="213706961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213706961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213706961">(Oct 18 2020 at 13:41)</a>:</h4>
<p>It just seems to me that with putting <code>if then else</code> in the middle of your types, the best case scenario is that the <code>if</code>s always reduce and you end up with something no harder to use than if you wrote something Haskell-style</p>



<a name="213707261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213707261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213707261">(Oct 18 2020 at 13:48)</a>:</h4>
<p>Or just throw everything into one <code>arg</code> type, that can be all of those things. That's what most assemblers do</p>



<a name="213707273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213707273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213707273">(Oct 18 2020 at 13:49)</a>:</h4>
<p>I had this earlier too but felt it too verbose.</p>



<a name="213708840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213708840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213708840">(Oct 18 2020 at 14:31)</a>:</h4>
<p>Hmm. This was unexpected to fail.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Q</span> <span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="k">if</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">ℕ</span> <span class="k">else</span> <span class="n">unit</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Q.a</span> <span class="mi">0</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="n">c</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Q.a</span> <span class="n">b</span> <span class="o">())</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">-- Lean doesn't know b /= 0</span>
</code></pre></div>



<a name="213708953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213708953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213708953">(Oct 18 2020 at 14:34)</a>:</h4>
<p>I expected the pattern matching to recognize that if a parameter's type is assumed, then the condition must hold, constraining in this case <code>b</code>. :/</p>



<a name="213708985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213708985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213708985">(Oct 18 2020 at 14:35)</a>:</h4>
<p>Even if you had a hypothesis <code>h : b /= 0</code> in the context, it would still fail</p>



<a name="213709029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709029">(Oct 18 2020 at 14:36)</a>:</h4>
<p>because <code>if b = 0 then ℕ else unit</code> would not be <em>definitionally</em> equal to <code>unit</code></p>



<a name="213709041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709041">(Oct 18 2020 at 14:36)</a>:</h4>
<p>so you would need to insert a cast along (a proof of) the propositional equality <code>(if b = 0 then ℕ else unit) = unit</code></p>



<a name="213709048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709048">(Oct 18 2020 at 14:37)</a>:</h4>
<p>and that cast will cause headaches when you want to prove things about it later</p>



<a name="213709115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709115">(Oct 18 2020 at 14:38)</a>:</h4>
<p>This issue only goes away when the <code>if then else</code> <em>reduces</em> to one of the branches--when precisely that happens depends on the <code>decidable</code> instance for the condition, but in your original example, it would only happen once <code>op</code> is a constructor</p>



<a name="213709142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709142">(Oct 18 2020 at 14:39)</a>:</h4>
<p>and at that point, you are basically forced to treat the type the same way as if it had a separate constructor for each value of <code>op</code>, since you had to do <code>cases</code> on <code>op</code> in order to get the types of the fields to reduce</p>



<a name="213709151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709151">(Oct 18 2020 at 14:39)</a>:</h4>
<p>That's why I said the best case scenario with this approach is that you get back what you would have had with the simple approach anyways</p>



<a name="213709158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709158">(Oct 18 2020 at 14:39)</a>:</h4>
<p>To be more specific; what I was trying to do was match <code>| (arith op rd rs1 (rs2 : reg) ())</code> which I expected should imply <code>(rs3 : unit)</code> and <code>op \in ..</code> for this branch.</p>



<a name="213709216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709216">(Oct 18 2020 at 14:40)</a>:</h4>
<p>This is exactly an IFF, lacking the inverse implication. :/</p>



<a name="213709246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709246">(Oct 18 2020 at 14:41)</a>:</h4>
<p>You could write a custom recursor which takes hypotheses of this form. But the application <code>arith op rd rs1 (rs2 : reg) ()</code> is <em>still ill-typed</em> even when you "know" that <code>op \in ...</code></p>



<a name="213709312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709312">(Oct 18 2020 at 14:42)</a>:</h4>
<p>If you replace the variable <code>op</code> by a specific constructor then it could be well-typed</p>



<a name="213709319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709319">(Oct 18 2020 at 14:43)</a>:</h4>
<p>(and you wouldn't need the <code>( _ : reg)</code> part)</p>



<a name="213709336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709336">(Oct 18 2020 at 14:44)</a>:</h4>
<p>Right, but then we're manually matching every case which is what I was trying to avoid. :/</p>



<a name="213709469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213709469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213709469">(Oct 18 2020 at 14:46)</a>:</h4>
<p>New plan; inline the op splits and call a helper. <em>shrugs</em></p>



<a name="213712711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213712711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213712711">(Oct 18 2020 at 16:01)</a>:</h4>
<p>You could have another sub-inductive type to chunk up the different classes of arith op</p>



<a name="213712719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213712719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213712719">(Oct 18 2020 at 16:01)</a>:</h4>
<p>or multiple arith variants in the top level instruction inductive type</p>



<a name="213713775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213713775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213713775">(Oct 18 2020 at 16:26)</a>:</h4>
<p>Each variation I try has more implications than I'd like... :/</p>



<a name="213714293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213714293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213714293">(Oct 18 2020 at 16:38)</a>:</h4>
<p>I have had and will just return to using two arith variants.</p>



<a name="213714688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213714688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213714688">(Oct 18 2020 at 16:49)</a>:</h4>
<p>You can also map your one inductive type to multiple inductive types for categorization along different axes</p>



<a name="213715600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213715600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213715600">(Oct 18 2020 at 17:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Current code -&gt; <a href="https://gist.github.com/4d56511885f5b44514b0fcf006a5546a">https://gist.github.com/4d56511885f5b44514b0fcf006a5546a</a></p>



<a name="213715646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213715646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213715646">(Oct 18 2020 at 17:10)</a>:</h4>
<p>Note the redundancies of <code>arith</code> <code>arith_f</code> and <code>atomic_op</code>.</p>



<a name="213715686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213715686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213715686">(Oct 18 2020 at 17:11)</a>:</h4>
<p>However, a really really neat detail of Lean which I didn't catch until just now is that names can be shared between types. I.e. <code>add</code> is defined in all of these, yet Lean knows which one to match based on the types. :)</p>



<a name="213715753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213715753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213715753">(Oct 18 2020 at 17:12)</a>:</h4>
<p>I mean, overlapping names in <code>open arith arith_f</code></p>



<a name="213715832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213715832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213715832">(Oct 18 2020 at 17:14)</a>:</h4>
<p>If only I could share the <code>arith</code> name inside the <code>inst</code> variants... the register types would distinguish the cases.</p>



<a name="213715839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213715839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213715839">(Oct 18 2020 at 17:14)</a>:</h4>
<p><code>arith_f</code> is fine though</p>



<a name="213715858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213715858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213715858">(Oct 18 2020 at 17:15)</a>:</h4>
<p>Wait. Can open rename bindings? If so, then this might be viable for consumers? :O</p>



<a name="213715869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213715869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213715869">(Oct 18 2020 at 17:15)</a>:</h4>
<p>I think the syntax is <code>open arith (renaming foo -&gt; bar)</code></p>



<a name="213715919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213715919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213715919">(Oct 18 2020 at 17:16)</a>:</h4>
<p><code>open inst (renaming arith_f -&gt; arith)</code> in this case.</p>



<a name="213715935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213715935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213715935">(Oct 18 2020 at 17:16)</a>:</h4>
<p>This looks like it might just work. :D</p>



<a name="213715956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213715956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213715956">(Oct 18 2020 at 17:17)</a>:</h4>
<p>And yeah, if the same name is available in multiple open namespaces then Lean will make some effort to infer which one is needed based on the types</p>



<a name="213716061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213716061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213716061">(Oct 18 2020 at 17:19)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">arith</span> <span class="n">arith_f</span> <span class="n">inst</span> <span class="o">(</span><span class="kn">renaming</span> <span class="n">arith_f</span> <span class="bp">→</span> <span class="n">arith</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">arith</span> <span class="n">add</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">reg</span> <span class="n">integer</span><span class="o">)</span> <span class="mi">0</span> <span class="mi">0</span>
</code></pre></div>

<p>Close! It doesn't know which to pick between <code>arith_f.add</code> and <code>arith.add</code>. Despite the register types forcing <code>arith.add</code>.</p>



<a name="213716147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213716147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213716147">(Oct 18 2020 at 17:21)</a>:</h4>
<p>I might revert to the clearly distinguished cases and just rename the variants to overload it. :)</p>



<a name="213716362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/dependent%20type%20in%20inductive%20variant%3F/near/213716362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/dependent.20type.20in.20inductive.20variant.3F.html#213716362">(Oct 18 2020 at 17:27)</a>:</h4>
<p>Yay. Moral of the story; match fat but simple. Overload the imports. :D</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
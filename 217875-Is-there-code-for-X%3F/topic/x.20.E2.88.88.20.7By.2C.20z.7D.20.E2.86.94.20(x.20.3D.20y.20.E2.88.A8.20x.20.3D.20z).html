---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html">x ∈ {y, z} ↔ (x = y ∨ x = z)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="291510244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291510244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291510244">(Jul 31 2022 at 20:16)</a>:</h4>
<p>I couldn't find anything like this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">}</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">library_search</span>
</code></pre></div>
<p>I'm not sure how to prove this either. Any tips?</p>



<a name="291510269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291510269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291510269">(Jul 31 2022 at 20:17)</a>:</h4>
<p><code>by simp</code>should do. Maybe it's even <code>refl</code>.</p>



<a name="291510725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291510725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291510725">(Jul 31 2022 at 20:26)</a>:</h4>
<p>For some reason, I'm getting a <code>don't know how to synthesize placeholder</code> error in the y of <code>x ∈ {y, z}</code>.</p>



<a name="291510811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291510811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291510811">(Jul 31 2022 at 20:28)</a>:</h4>
<p>You probably need to tell lean what type the {} is, like <code>({y, z} : set ...)</code></p>



<a name="291510853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291510853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291510853">(Jul 31 2022 at 20:30)</a>:</h4>
<p>Ah, that was it. Thanks.</p>



<a name="291511141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291511141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291511141">(Jul 31 2022 at 20:36)</a>:</h4>
<p>This seems not to exist, and it should! We could have <code>set.mem_pair_iff</code>, <code>finset.mem_pair_iff</code>, and <code>multiset.mem_pair_iff</code>.</p>



<a name="291511175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291511175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291511175">(Jul 31 2022 at 20:37)</a>:</h4>
<p>Yes because it's just <code>mem_insert</code> + <code>mem_singleton</code>.</p>



<a name="291511256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291511256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291511256">(Jul 31 2022 at 20:38)</a>:</h4>
<p>I'm adding it to my "extras".</p>



<a name="291511370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291511370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291511370">(Jul 31 2022 at 20:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20.28x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z.29/near/291511175">said</a>:</p>
<blockquote>
<p>Yes because it's just <code>mem_insert</code> + <code>mem_singleton</code>.</p>
</blockquote>
<p>True, but it's not any less useful because of this. Worth mentioning is that <code>multiset.mem_insert</code> doesn't exist, and we have mismatched names <code>finset.mem_insert</code> and <code>set.mem_insert_iff</code>, and <code>finset.mem_singleton</code> and <code>set.mem_singleton_iff</code>.</p>



<a name="291511590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291511590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291511590">(Jul 31 2022 at 20:46)</a>:</h4>
<p>But then you will also want to write <code>mem_triple</code>, <code>mem_quadruple</code>, etc... Consider lemmas as shortcuts to tactic calls. Here you're effectively suggesting to replace one tactic call by a countable number of lemmas. This is loosely analogous to how we don't write down all inequalities between any two natural numbers, but instead use <code>norm_num</code> to generate them. This is a time vs space tradeoff.</p>



<a name="291511630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291511630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291511630">(Jul 31 2022 at 20:47)</a>:</h4>
<p>I would imagine that pairs are much more common than triples or higher n-tuples.</p>



<a name="291511632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291511632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291511632">(Jul 31 2022 at 20:47)</a>:</h4>
<p>We can just stop at two</p>



<a name="291511713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291511713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291511713">(Jul 31 2022 at 20:48)</a>:</h4>
<p>I see no point in doing so, because you won't ever need the lemmas in reverse (as opposed to <a href="https://leanprover-community.github.io/mathlib_docs/find/Inf_pair">docs#Inf_pair</a> for example), so you can always just call one tactic that'll solve it.</p>



<a name="291511906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291511906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291511906">(Jul 31 2022 at 20:53)</a>:</h4>
<p>This reminds me of those associative/commutative lemmas that involve 2,3,4 variables. I didn't expect specialized versions for e.g. 4 variables - I was expected some generalized tactic that handles all cases, but I was wrong.</p>



<a name="291512072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291512072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291512072">(Jul 31 2022 at 20:56)</a>:</h4>
<p>If you're thinking about <code>op_op_op_comm</code> lemmas, we have them because this specific pattern shows up all the time when doing convexity (and surely other things) and it's not always true for the same reasons (eg the <code>sub</code> version needs special treatment, and the <code>add</code>-<code>tsub</code> one is even worse).</p>



<a name="291512142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291512142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291512142">(Jul 31 2022 at 20:58)</a>:</h4>
<p>However, we do not have <code>mul_assoc3 : ((a * b) * c) * d = a * (b * (c * d))</code> because this is always true for the same reasons and doesn't need a complicated rewriting scheme.</p>



<a name="291512188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291512188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291512188">(Jul 31 2022 at 20:59)</a>:</h4>
<p>All these special concesions makes things complicated in my opinion, but c'est la vie.</p>



<a name="291513160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291513160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291513160">(Jul 31 2022 at 21:20)</a>:</h4>
<p>For a left associative commutative op, like <code>and</code> or <code>add</code>, <code>simp [and.comm, and.assoc, and.left_assoc]</code> will normalize both sides of an equality</p>



<a name="291513781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/x%20%E2%88%88%20%7By%2C%20z%7D%20%E2%86%94%20%28x%20%3D%20y%20%E2%88%A8%20x%20%3D%20z%29/near/291513781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20(x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z).html#291513781">(Jul 31 2022 at 21:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="416322">Bernd Losert</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/x.20.E2.88.88.20.7By.2C.20z.7D.20.E2.86.94.20.28x.20.3D.20y.20.E2.88.A8.20x.20.3D.20z.29/near/291511906">said</a>:</p>
<blockquote>
<p>This reminds me of those associative/commutative lemmas that involve 2,3,4 variables. I didn't expect specialized versions for e.g. 4 variables - I was expected some generalized tactic that handles all cases, but I was wrong.</p>
</blockquote>
<p>We have <code>rw_assoc</code> but I've found it very finicky to use, and it doesn't deal with commutativity.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html">(commutative)-semirng</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="219768640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219768640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219768640">(Dec 13 2020 at 16:32)</a>:</h4>
<p>Is there already a definition of a type with two operations, addition and multiplication, that is just like a <code>semiring</code>, except that it does not need to have a unit for multiplication.  I do not mind if multiplication is commutative, although it is in my intended application.  I looked for <code>semirng</code> (as well as <code>semring</code> and <code>semrng</code>), but did not find anything.</p>



<a name="219768957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219768957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219768957">(Dec 13 2020 at 16:41)</a>:</h4>
<p>Nevermind, I think that <code>add_comm_monoid</code> is what I want.</p>



<a name="219768962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219768962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219768962">(Dec 13 2020 at 16:41)</a>:</h4>
<p>This doesn't have a multipication</p>



<a name="219769025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769025">(Dec 13 2020 at 16:42)</a>:</h4>
<p>Ah, so I am misunderstanding this definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- An additive commutative monoid is an additive monoid with commutative `(+)`. -/</span>
<span class="kd">@[protect_proj, ancestor add_monoid add_comm_semigroup]</span>
<span class="kd">class</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">add_monoid</span> <span class="n">M</span><span class="o">,</span> <span class="n">add_comm_semigroup</span> <span class="n">M</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="n">to_additive</span><span class="o">]</span> <span class="n">comm_monoid</span>
</code></pre></div>
<p>I thought that the <code>add_monoid</code> and <code>add_comm_semigroup</code> implied different operations.  Is this not the case?</p>



<a name="219769032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769032">(Dec 13 2020 at 16:43)</a>:</h4>
<p>(The doc_string seems contradicting what I think)</p>



<a name="219769112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769112">(Dec 13 2020 at 16:45)</a>:</h4>
<p>So, I guess that I would like two <code>add_comm</code> structures, one of which is a monoid, and a distributive law.</p>



<a name="219769114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769114">(Dec 13 2020 at 16:45)</a>:</h4>
<p>the <code>to_additive</code> thing is a metaprogramming trick that takes something like the class <code>comm_monoid</code> and automatically makes <code>add_comm_monoid</code>.</p>



<a name="219769115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769115">(Dec 13 2020 at 16:45)</a>:</h4>
<p>But a priori there is no relationship between <code>comm_monoid</code> and <code>add_comm_monoid</code>.</p>



<a name="219769181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769181">(Dec 13 2020 at 16:46)</a>:</h4>
<p>ah, so I could build one like what i want by piling up two <code>add</code> structures and if I <em>do not</em> put the <code>to_additive</code> they would be a <code>+</code> and a <code>*</code>?</p>



<a name="219769183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769183">(Dec 13 2020 at 16:46)</a>:</h4>
<p>E.g. look at the source for <a href="https://leanprover-community.github.io/mathlib_docs/find/comm_monoid/src">src#comm_monoid</a></p>



<a name="219769217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769217">(Dec 13 2020 at 16:47)</a>:</h4>
<p>I think what you want is a class that extends <code>add_comm_monoid</code> and the (nonexistent, as far as I know) <code>semigroup_with_zero</code> and the class that ensures distributivity of <code>+</code> and <code>*</code> that I can't remember the name of right now...</p>



<a name="219769276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769276">(Dec 13 2020 at 16:48)</a>:</h4>
<p><code>distrib</code> should be the distributive property:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- A typeclass stating that multiplication is left and right distributive</span>
<span class="sd">over addition. -/</span>
<span class="kd">@[protect_proj, ancestor has_mul has_add]</span>
<span class="kd">class</span> <span class="n">distrib</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">R</span><span class="o">,</span> <span class="n">has_add</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">left_distrib</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">))</span>
<span class="o">(</span><span class="n">right_distrib</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">))</span>
</code></pre></div>



<a name="219769349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769349">(Dec 13 2020 at 16:50)</a>:</h4>
<p>I am happy to assume comm_semigroup_with_zero, but I <em>really</em> do not have a unit for multiplication: I want to put this structure on <code>finset</code>s.</p>



<a name="219769351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769351">(Dec 13 2020 at 16:50)</a>:</h4>
<p>Oh, BTW my explanation of <code>to_additive</code> is probably not 100% correct. It looks like <code>add_comm_monoid</code> is actually declared explicitly with a <code>to_additive</code> declaration right after to connect it to <code>comm_monoid</code>. I guess <code>to_additive</code> makes some of the API for you.</p>



<a name="219769366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769366">(Dec 13 2020 at 16:50)</a>:</h4>
<p>semigroups don't have units IIRC</p>



<a name="219769382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769382">(Dec 13 2020 at 16:51)</a>:</h4>
<p>Ok, thanks for the correction: I know so little of this, at the moment, that I had filed it in my head as "there is a system to keep track of whether you call it <code>+</code> or <code>*</code>"!</p>



<a name="219769389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769389">(Dec 13 2020 at 16:51)</a>:</h4>
<p>That's not <code>to_additive</code>, that's this <code>add_</code> stuff</p>



<a name="219769441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769441">(Dec 13 2020 at 16:52)</a>:</h4>
<p>The classes with <code>add_</code> in their name are built on top of <code>+</code>, the ones without are built on <code>*</code></p>



<a name="219769444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769444">(Dec 13 2020 at 16:52)</a>:</h4>
<p>ok, so by default, an operation is <code>*</code>, unless is it declared with a <code>add_</code> and then it is a <code>+</code>, right?</p>



<a name="219769459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769459">(Dec 13 2020 at 16:53)</a>:</h4>
<p>I think <code>to_additive</code> takes lemmas of the form <code>mul_foo</code> and automatically makes lemmas of the form <code>add_foo</code>, if I understand what Reid is saying here...</p>



<a name="219769460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769460">(Dec 13 2020 at 16:53)</a>:</h4>
<p>I was typing my comment, while you were explaining yours, thanks!)</p>



<a name="219769479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769479">(Dec 13 2020 at 16:53)</a>:</h4>
<p>right, <code>to_additive</code> is some automation which means we don't have to duplicate everything between the additive and multiplicative versions by hand</p>



<a name="219769518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769518">(Dec 13 2020 at 16:54)</a>:</h4>
<p>so you have to tell lean that it should generate the <code>add_foo</code> lemmas for <code>add_comm_monoid</code> using the <code>mul_foo</code> lemmas for <code>comm_monoid</code>, and that's the <code>to_additive</code> declaration that we noticed above.</p>



<a name="219769533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769533">(Dec 13 2020 at 16:54)</a>:</h4>
<p>So, I think you want to extend <code>add_comm_group</code>, <code>semigroup</code> and <code>distrib</code>... that will imply <code>0 * x = x * 0 = 0</code> already, right?</p>



<a name="219769542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769542">(Dec 13 2020 at 16:55)</a>:</h4>
<p>I guess you can also add <code>monoid_with_zero</code> just in case</p>



<a name="219769552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769552">(Dec 13 2020 at 16:55)</a>:</h4>
<p>Yes. but he doesn't have negation and that's not true for additive monoids</p>



<a name="219769558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769558">(Dec 13 2020 at 16:55)</a>:</h4>
<p>oh I missed "semi"</p>



<a name="219769565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769565">(Dec 13 2020 at 16:55)</a>:</h4>
<p>Yes, negation I also want to avoid.</p>



<a name="219769569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769569">(Dec 13 2020 at 16:55)</a>:</h4>
<p>oh then there might not be any combination which does exactly what you want</p>



<a name="219769616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769616">(Dec 13 2020 at 16:56)</a>:</h4>
<p>You can't actually use <code>monoid_with_zero</code> because it implies <code>monoid</code></p>



<a name="219769618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769618">(Dec 13 2020 at 16:56)</a>:</h4>
<p>Yeah, this is why I was suggesting the <code>semigroup_with_zero</code> class <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="219769625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769625">(Dec 13 2020 at 16:56)</a>:</h4>
<p><code>semigroup</code> is such a hard name for category theorists <span aria-label="head bandage" class="emoji emoji-1f915" role="img" title="head bandage">:head_bandage:</span></p>



<a name="219769645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769645">(Dec 13 2020 at 16:57)</a>:</h4>
<p>well, if it is only the <code>with_zero</code> part that is missing, I can add the two axioms <code>zero_mul</code> and <code>mul_zero</code>, right?</p>



<a name="219769652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769652">(Dec 13 2020 at 16:57)</a>:</h4>
<p>oh <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_zero_class">docs#mul_zero_class</a></p>



<a name="219769692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769692">(Dec 13 2020 at 16:58)</a>:</h4>
<p>What goofy names... <code>mul_zero_class</code> and <code>distrib</code></p>



<a name="219769697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769697">(Dec 13 2020 at 16:58)</a>:</h4>
<p>so, <code>extends add_comm_monoid, semigroup, distrib, mul_zero_class</code>?</p>



<a name="219769713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769713">(Dec 13 2020 at 16:58)</a>:</h4>
<p>I will try it and see if I can pull it off!</p>



<a name="219769940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219769940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219769940">(Dec 13 2020 at 17:03)</a>:</h4>
<p>Just to avoid being stuck for silly reasons: proving the <code>instance</code> should simply be a matter of following my nose, right?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.basic</span>

<span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">class</span> <span class="n">semirng</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">,</span> <span class="n">semigroup</span> <span class="n">α</span><span class="o">,</span> <span class="n">distrib</span> <span class="n">α</span><span class="o">,</span> <span class="n">mul_zero_class</span> <span class="n">α</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">semirng</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>



<a name="219770014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770014">(Dec 13 2020 at 17:05)</a>:</h4>
<p>If all the other structures are on <code>finset</code> then it might be a matter of <code>by apply_instance</code>. If it isn't then you can make the other structures first. But this might be one of those places where some people don't want those instances, so maybe it should be a <code>def</code> instead.</p>



<a name="219770016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770016">(Dec 13 2020 at 17:05)</a>:</h4>
<p>I assume this is the semiring structure given by the lattice structure?</p>



<a name="219770018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770018">(Dec 13 2020 at 17:05)</a>:</h4>
<p>Yes, union=+ and intersection=*.</p>



<a name="219770062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770062">(Dec 13 2020 at 17:06)</a>:</h4>
<p>Umm... addition is symmetric difference no?</p>



<a name="219770067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770067">(Dec 13 2020 at 17:06)</a>:</h4>
<p>Ah, I had union in mind...</p>



<a name="219770073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770073">(Dec 13 2020 at 17:06)</a>:</h4>
<p>It is not the boolean-ish algebra that I want</p>



<a name="219770080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770080">(Dec 13 2020 at 17:07)</a>:</h4>
<p>If there are two natural choices for addition then probably you don't want anything to be an instance, because then everyone who wants the other one is stuck with it</p>



<a name="219770081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770081">(Dec 13 2020 at 17:07)</a>:</h4>
<p>This is essentially a direct sum of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Z</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\mathbf{Z}/2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">Z</span></span><span class="mord">/</span><span class="mord">2</span></span></span></span> indexed by the type</p>



<a name="219770087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770087">(Dec 13 2020 at 17:07)</a>:</h4>
<p>where you identify a finite set with its indicator function.</p>



<a name="219770128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770128">(Dec 13 2020 at 17:08)</a>:</h4>
<p>In what I want, once an element is in, it will never go out</p>



<a name="219770133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770133">(Dec 13 2020 at 17:08)</a>:</h4>
<p>(with addition, you can remove it with intersections, of course)</p>



<a name="219770136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770136">(Dec 13 2020 at 17:08)</a>:</h4>
<p>Is that distributive?</p>



<a name="219770149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770149">(Dec 13 2020 at 17:09)</a>:</h4>
<p>I thought that it was distributive "both ways"</p>



<a name="219770157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770157">(Dec 13 2020 at 17:09)</a>:</h4>
<p>Yeah you're probably right</p>



<a name="219770158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770158">(Dec 13 2020 at 17:09)</a>:</h4>
<p>This already basically exists as <code>distrib_lattice</code></p>



<a name="219770163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770163">(Dec 13 2020 at 17:09)</a>:</h4>
<p>it is according to wikipedia:<br>
<a href="https://en.wikipedia.org/wiki/Algebra_of_sets">https://en.wikipedia.org/wiki/Algebra_of_sets</a></p>



<a name="219770207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770207">(Dec 13 2020 at 17:10)</a>:</h4>
<p>Ah, I will look at distributive lattice then!</p>



<a name="219770210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770210">(Dec 13 2020 at 17:10)</a>:</h4>
<p>(the name sounds good)</p>



<a name="219770231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770231">(Dec 13 2020 at 17:11)</a>:</h4>
<p>Yeah it's clearly distribute. But I agree with what Kevin said above, because as far as I know the "standard" way to define a (semi)ring structure from a boolean algebra is by letting addition be the symmetric difference.</p>



<a name="219770301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770301">(Dec 13 2020 at 17:13)</a>:</h4>
<p>Ok, it is simply that for doing "induction", unions is what I need, rather than symmetric differences</p>



<a name="219770317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770317">(Dec 13 2020 at 17:13)</a>:</h4>
<p>I will not make an instance, and I will check out <code>distrib_lattice</code></p>



<a name="219770506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770506">(Dec 13 2020 at 17:18)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∪</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∩</span></span></span></span> are "builtin" notation for mathematicians when using sets, but lattice theory is a generalisation of this stuff and the notation used is these square <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">⊔</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊓</mo></mrow><annotation encoding="application/x-tex">\sqcap</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">⊓</span></span></span></span> stuff. It is actually a <strong>pain</strong> that set theory in Lean sticks to this set union and intersection notation. When ideals were defined and given a lattice structure, the lattice notation was used, and initially I was shocked that I was supposed to write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>≤</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">I\leq J</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span> instead of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>⊆</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">I\subseteq J</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span>, but now actually I see the benefits of this: we are using lots of different notations for lattice notation in various situations when we're dealing with lattices which we don't perceive as lattices, e.g. the subgroup generated by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> is just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>⊔</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">H\sqcup K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> in Lean. Sticking to lattice notation everywhere is a good convention, I think.</p>



<a name="219770520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770520">(Dec 13 2020 at 17:19)</a>:</h4>
<p>Good, I will follow the convention!  How do I type the square union and intersection?</p>



<a name="219770533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770533">(Dec 13 2020 at 17:19)</a>:</h4>
<p>(hovering in VSCode answers my question \lub)</p>



<a name="219770591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770591">(Dec 13 2020 at 17:21)</a>:</h4>
<p><del>So, I should define inclusion of sets, rather than union.  Have I understood correctly?</del>  I am slightly confused.</p>



<a name="219770680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770680">(Dec 13 2020 at 17:24)</a>:</h4>
<p>I agree with what Kevin said about the union intersection notation, but just one small comment. I would argue that addition being defined as symmetric difference is the only reasonable choice. For example if you work in a finite type, then the structure you get is a ring if you use symmetric difference, but not if you use union.</p>



<a name="219770793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770793">(Dec 13 2020 at 17:27)</a>:</h4>
<p>I thought that this would have worked, but Lean does not want me to use neither ⊔ nor ∪.  I suspect that you already told me what I should do, but I did not understand it...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.basic</span>

<span class="kd">def</span> <span class="n">finset_lattice</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">distrib_lattice</span> <span class="o">(</span><span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">use</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">⊔</span> <span class="n">b</span><span class="o">),</span>   <span class="c1">-- failed to instantiate goal with fun (a : 4._.40) (b : 4._.41), ((frozen_name has_sup.sup) a b)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219770808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770808">(Dec 13 2020 at 17:27)</a>:</h4>
<p>ooh, what a fun error message</p>



<a name="219770846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770846">(Dec 13 2020 at 17:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/(commutative)-semirng/near/219770680">said</a>:</p>
<blockquote>
<p>I agree with what Kevin said about the union intersection notation, but just one small comment. I would argue that addition being defined as symmetric difference is the only reasonable choice. For example if you work in a finite type, then the structure you get is a ring if you use symmetric difference, but not if you use union.</p>
</blockquote>
<p>Ok, I will use this "simple-minded union" structure sparingly!</p>



<a name="219770931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770931">(Dec 13 2020 at 17:31)</a>:</h4>
<p>Don't we have this? <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.distrib_lattice">docs#finset.distrib_lattice</a></p>



<a name="219770937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770937">(Dec 13 2020 at 17:31)</a>:</h4>
<p>note the <code>decidable_eq</code> requirement</p>



<a name="219770981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770981">(Dec 13 2020 at 17:32)</a>:</h4>
<p>Thanks!  I opened the classical locale and now Lean is having more <code>fun</code>: thanks!</p>



<a name="219770994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219770994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219770994">(Dec 13 2020 at 17:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/(commutative)-semirng/near/219770931">said</a>:</p>
<blockquote>
<p>Don't we have this? <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.distrib_lattice">docs#finset.distrib_lattice</a></p>
</blockquote>
<p>I will try to do it by hand first, and then compare with what is already in mathlib, just to get some practice.  Thanks for the pointer, though!</p>



<a name="219771535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219771535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219771535">(Dec 13 2020 at 17:47)</a>:</h4>
<p>My only issue with lattice notation is that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">⊔</span></span></span></span> is disjoint union in my mind. But I got used to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⊕</span></span></span></span></p>



<a name="219774094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219774094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219774094">(Dec 13 2020 at 18:47)</a>:</h4>
<p>Is it possible to see the name of each field that I am trying to prove?  For instance, the first one asks to produce something with type <code>finset X \to finset X \to finset X</code>.  I "guessed" that it was the union.  Others later on are similarly ambiguous.  Is there a way to know what name each property has?</p>



<a name="219774102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219774102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219774102">(Dec 13 2020 at 18:47)</a>:</h4>
<p>(instead of type-checking myself and second guessing what I see that I will need to prove later on!)</p>



<a name="219774178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219774178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219774178">(Dec 13 2020 at 18:49)</a>:</h4>
<p>If you type <code>{! }</code> where you are supposed to construct a structure, a little light bulb will show on. If you click on the light bulb and select <code>generate a skeleton for the structure under construction</code>, it will give you the name of the different fields.</p>



<a name="219774336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219774336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219774336">(Dec 13 2020 at 18:52)</a>:</h4>
<p>Wow: this is great!!!  Thank you <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> !</p>



<a name="219774569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219774569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219774569">(Dec 13 2020 at 18:58)</a>:</h4>
<p>Actually you can just use <code>_</code></p>



<a name="219774866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219774866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219774866">(Dec 13 2020 at 19:04)</a>:</h4>
<p>I had never thought of clickling the yellow light-bulbs<br>
<span aria-label="light bulb" class="emoji emoji-1f4a1" role="img" title="light bulb">:light_bulb:</span></p>



<a name="219810226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219810226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219810226">(Dec 14 2020 at 08:13)</a>:</h4>
<p>To get some practice, I thought that I would define a new structure <code>sus</code> on subsets of a set, just like <code>topological_space</code>, except that I drop the requirement of arbitrary unions and only allow finite unions.  (The definition only involves pairwise unions, although, as a mathematician, I still feel a bit funny having to specify this!  As a consequence, for those who, like me, think often about the empty set, this implies that I need to add the hypothesis that <code>∅</code> is in my collection of sets, since I can no longer take the empty union.)</p>
<p>Thus, <code>sus</code> with <code>+ = ∪</code> and <code>* = ∩</code> is a <code>comm_semiring</code>, which is where I am headed.  This <code>comm_semiring</code> structure is also the structure that I want to put on "<code>finsets with univ</code>".</p>
<p>I copied the beginning of the <code>topology/basic</code> file and started changing as needed.  When I got to </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">topological_space_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">},</span> <span class="n">f.is_open</span> <span class="bp">=</span> <span class="n">g.is_open</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">rfl</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>I got completely stuck.  I can understand the statement: if two instances of topological space on the same type have the same open sets, then they agree.  However, the proof in indecipherable to me.  Can anyone give me some guidance or even simply a proof?  Below is the code that I have so far.  Feel free to give more advice!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.filter.ultrafilter</span>
<span class="kn">import</span> <span class="n">order.filter.partial</span>

<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">classical</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">filter</span>

<span class="sd">/-- A `sus` on `α`. -/</span>
<span class="kd">@[protect_proj]</span> <span class="kd">structure</span> <span class="n">sus</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_su</span>       <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_su_univ</span>  <span class="o">:</span> <span class="n">is_su</span> <span class="n">univ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_su_empty</span> <span class="o">:</span> <span class="n">is_su</span> <span class="bp">∅</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_su_inter</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">is_su</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">is_su</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">is_su</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">))</span>
<span class="o">(</span><span class="n">is_su_union</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">is_su</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">is_su</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">is_su</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">))</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="kd">class</span><span class="o">]</span> <span class="n">sus</span>  <span class="c1">--I do not know what this does, but it was there</span>

<span class="sd">/-- A constructor for `sus` using complements of the given `sus` structure. -/</span>
<span class="c1">-- this definition is not relevant to what I care about: I simply say that if I have a ```sus```, then the collection of complements also forms a ```sus```</span>
<span class="kd">def</span> <span class="n">sus.comp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_su</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="n">f.is_su</span> <span class="n">X</span><span class="bp">ᶜ</span><span class="o">,</span>
  <span class="n">is_su_univ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">sus.is_su_empty</span><span class="o">],</span>
  <span class="n">is_su_empty</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">sus.is_su_univ</span><span class="o">],</span>
  <span class="n">is_su_inter</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span> <span class="n">hs</span> <span class="n">ht</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">compl_inter</span><span class="o">,</span> <span class="n">exact</span> <span class="n">sus.is_su_union</span> <span class="n">f</span> <span class="n">s</span><span class="bp">ᶜ</span> <span class="n">t</span><span class="bp">ᶜ</span> <span class="n">hs</span> <span class="n">ht</span> <span class="o">},</span>
  <span class="n">is_su_union</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span> <span class="n">hs</span> <span class="n">ht</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">compl_union</span><span class="o">,</span> <span class="n">exact</span> <span class="n">sus.is_su_inter</span> <span class="n">f</span> <span class="n">s</span><span class="bp">ᶜ</span> <span class="n">t</span><span class="bp">ᶜ</span> <span class="n">hs</span> <span class="n">ht</span> <span class="o">},</span>
<span class="o">}</span>

<span class="kn">section</span> <span class="n">sus</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">s₁</span> <span class="n">s₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>

<span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">sus_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span><span class="o">},</span> <span class="n">f.is_su</span> <span class="bp">=</span> <span class="n">g.is_su</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="c1">-- this was the proof for topological spaces</span>
<span class="c1">-- | ⟨a, _, _, _, _⟩ ⟨b, _, _, _, _⟩ rfl := rfl</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219810917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219810917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219810917">(Dec 14 2020 at 08:22)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">sus_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span><span class="o">},</span> <span class="n">f.is_su</span> <span class="bp">=</span> <span class="n">g.is_su</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="c1">-- this was the proof for topological spaces</span>
<span class="c1">-- | ⟨a, _, _, _, _⟩ ⟨b, _, _, _, _⟩ rfl := rfl</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">f_is_su</span><span class="o">,</span> <span class="n">f_is_su_univ</span><span class="o">,</span> <span class="n">f_is_su_empty</span><span class="o">,</span> <span class="n">f_is_su_inter</span><span class="o">,</span> <span class="n">f_is_su_union</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">g_is_su</span><span class="o">,</span>
 <span class="n">g_is_su_univ</span><span class="o">,</span>
 <span class="n">g_is_su_empty</span><span class="o">,</span>
 <span class="n">g_is_su_inter</span><span class="o">,</span>
 <span class="n">g_is_su_union</span><span class="o">⟩</span> <span class="o">⟨⟩,</span><span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219810934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219810934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219810934">(Dec 14 2020 at 08:22)</a>:</h4>
<p>The first part was generated by <code>rintros?</code></p>



<a name="219810972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219810972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219810972">(Dec 14 2020 at 08:23)</a>:</h4>
<p>Thanks!  I will try it!</p>



<a name="219811140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219811140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219811140">(Dec 14 2020 at 08:25)</a>:</h4>
<p>I am not sure if this makes it clearer or opaquer, but also what is below works.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">sus_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span><span class="o">},</span> <span class="n">f.is_su</span> <span class="bp">=</span> <span class="n">g.is_su</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨⟩,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219811295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219811295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219811295">(Dec 14 2020 at 08:28)</a>:</h4>
<p>If you do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[protect_proj, ext]</span> <span class="kd">structure</span> <span class="n">sus</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>lean will generate a lemma <code>sus.ext</code> and <code>sus.ext_iff</code> for you</p>



<a name="219811525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219811525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219811525">(Dec 14 2020 at 08:30)</a>:</h4>
<p>To prove two instances of a structure are equal, do cases on them. Look at how I prove the ext lemma for complex numbers in the complex number game. The equation compiler proof is just doing cases.</p>



<a name="219811830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219811830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219811830">(Dec 14 2020 at 08:33)</a>:</h4>
<p>Thank you both!</p>
<p>Indeed, with <br>
<code>@[protect_proj, ext] structure sus (α : Type*) :=</code><br>
the proof is simply <code>sus.ext</code>.</p>
<p>Otherwise, <code>cases</code> all the way reduces the proof to <code>refl</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">sus_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span><span class="o">},</span> <span class="n">f.is_su</span> <span class="bp">=</span> <span class="n">g.is_su</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219811953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219811953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219811953">(Dec 14 2020 at 08:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/(commutative)-semirng/near/219811525">said</a>:</p>
<blockquote>
<p>To prove two instances of a structure are equal, do cases on them. Look at how I prove the ext lemma for complex numbers in the complex number game. The equation compiler proof is just doing cases.</p>
</blockquote>
<p>What does "equation compiler" mean?  Is it what you see when you use <code>show_term</code>?</p>



<a name="219812534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219812534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219812534">(Dec 14 2020 at 08:40)</a>:</h4>
<p>The equation compiler proof is the first one you mentioned:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">topological_space_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">},</span> <span class="n">f.is_open</span> <span class="bp">=</span> <span class="n">g.is_open</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">rfl</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="219813187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219813187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219813187">(Dec 14 2020 at 08:48)</a>:</h4>
<p>Ah, thanks!  I am also seeing through this proof more.  However, now I do not understand why is what is below not a proof?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">sus_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span><span class="o">},</span> <span class="n">f.is_su</span> <span class="bp">=</span> <span class="n">g.is_su</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">⟨⟩</span> <span class="o">:=</span> <span class="n">rfl</span>  <span class="c1">-- invalid expression\\ command expected</span>
</code></pre></div>
<p>While this one is?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">sus_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span><span class="o">},</span> <span class="n">f.is_su</span> <span class="bp">=</span> <span class="n">g.is_su</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨⟩,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219813591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219813591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219813591">(Dec 14 2020 at 08:52)</a>:</h4>
<p>you probably need <code>rfl</code> instead of <code>⟨⟩</code> in the first version</p>



<a name="219813724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219813724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219813724">(Dec 14 2020 at 08:54)</a>:</h4>
<p>you can also use <code>⟨_⟩</code></p>



<a name="219813745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219813745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219813745">(Dec 14 2020 at 08:54)</a>:</h4>
<p>because the constructor of <code>eq</code> is <code>eq.refl</code> which has one explicit argument</p>



<a name="219813809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219813809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219813809">(Dec 14 2020 at 08:55)</a>:</h4>
<p><code>rintro</code> doesn't really care if you don't give it enough arguments:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">sus_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span><span class="o">},</span> <span class="n">f.is_su</span> <span class="bp">=</span> <span class="n">g.is_su</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩</span><span class="bp">;</span> <span class="n">refl</span>
</code></pre></div>



<a name="219814287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219814287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219814287">(Dec 14 2020 at 09:00)</a>:</h4>
<p>I tried with </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">sus_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span><span class="o">},</span> <span class="n">f.is_su</span> <span class="bp">=</span> <span class="n">g.is_su</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">rfl</span> <span class="o">:=</span> <span class="n">rfl</span>  <span class="c1">-- invalid expression \\ command expected</span>
</code></pre></div>
<p>and it does not work.  In any case, I have enough proofs of a completely trivial result that the computer can even figure out on its own!  I was just curious about the proof style with <code>|</code> that I had never seen before, hence my curiousity!</p>



<a name="219814446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219814446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219814446">(Dec 14 2020 at 09:02)</a>:</h4>
<p>The following compiles for me with no errors:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.filter.ultrafilter</span>
<span class="kn">import</span> <span class="n">order.filter.partial</span>

<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">classical</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">filter</span>

<span class="sd">/-- A `sus` on `α`. -/</span>
<span class="kd">@[protect_proj]</span> <span class="kd">structure</span> <span class="n">sus</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_su</span>       <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_su_univ</span>  <span class="o">:</span> <span class="n">is_su</span> <span class="n">univ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_su_empty</span> <span class="o">:</span> <span class="n">is_su</span> <span class="bp">∅</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_su_inter</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">is_su</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">is_su</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">is_su</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">))</span>
<span class="o">(</span><span class="n">is_su_union</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">is_su</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">is_su</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">is_su</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">))</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="kd">class</span><span class="o">]</span> <span class="n">sus</span>  <span class="c1">--I do not know what this does, but it was there</span>

<span class="sd">/-- A constructor for `sus` using complements of the given `sus` structure. -/</span>
<span class="c1">-- this definition is not relevant to what I care about: I simply say that if I have a ```sus```, then the collection of complements also forms a ```sus```</span>
<span class="kd">def</span> <span class="n">sus.comp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_su</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="n">f.is_su</span> <span class="n">X</span><span class="bp">ᶜ</span><span class="o">,</span>
  <span class="n">is_su_univ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">sus.is_su_empty</span><span class="o">],</span>
  <span class="n">is_su_empty</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">sus.is_su_univ</span><span class="o">],</span>
  <span class="n">is_su_inter</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span> <span class="n">hs</span> <span class="n">ht</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">compl_inter</span><span class="o">,</span> <span class="n">exact</span> <span class="n">sus.is_su_union</span> <span class="n">f</span> <span class="n">s</span><span class="bp">ᶜ</span> <span class="n">t</span><span class="bp">ᶜ</span> <span class="n">hs</span> <span class="n">ht</span> <span class="o">},</span>
  <span class="n">is_su_union</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span> <span class="n">hs</span> <span class="n">ht</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">compl_union</span><span class="o">,</span> <span class="n">exact</span> <span class="n">sus.is_su_inter</span> <span class="n">f</span> <span class="n">s</span><span class="bp">ᶜ</span> <span class="n">t</span><span class="bp">ᶜ</span> <span class="n">hs</span> <span class="n">ht</span> <span class="o">},</span>
<span class="o">}</span>

<span class="kn">section</span> <span class="n">sus</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">s₁</span> <span class="n">s₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>

<span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">sus_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">sus</span> <span class="n">α</span><span class="o">},</span> <span class="n">f.is_su</span> <span class="bp">=</span> <span class="n">g.is_su</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">rfl</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="219814490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219814490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219814490">(Dec 14 2020 at 09:02)</a>:</h4>
<p>Oh, you still have the <code>:=</code> on the first line</p>



<a name="219814524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219814524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219814524">(Dec 14 2020 at 09:03)</a>:</h4>
<p>when you use an equation compiler proof you have to take that off</p>



<a name="219814567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219814567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219814567">(Dec 14 2020 at 09:03)</a>:</h4>
<p>Ah, I was puzzled by the fact that yours compiled, while mine did not.  I had taken no notice of the <code>:=</code></p>



<a name="219814642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219814642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219814642">(Dec 14 2020 at 09:04)</a>:</h4>
<p>so then, why the <code>a</code> and <code>b</code>?</p>



<a name="219814656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219814656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219814656">(Dec 14 2020 at 09:04)</a>:</h4>
<p>it makes the intermediate state display a little nicer</p>



<a name="219814716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219814716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219814716">(Dec 14 2020 at 09:05)</a>:</h4>
<p>I see</p>



<a name="219814726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219814726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219814726">(Dec 14 2020 at 09:05)</a>:</h4>
<p>it's totally optional here</p>



<a name="219814869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219814869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219814869">(Dec 14 2020 at 09:07)</a>:</h4>
<p>Ok, I am understanding this proof a little better now.  At first, it looked like non-sense, now it suggests that the statement is entirely trivial!</p>



<a name="219817808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219817808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219817808">(Dec 14 2020 at 09:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/(commutative)-semirng/near/219811525">said</a>:</p>
<blockquote>
<p>To prove two instances of a structure are equal, do cases on them. Look at how I prove the ext lemma for complex numbers in the complex number game. The equation compiler proof is just doing cases.</p>
</blockquote>
<p>I am doing the Complex Numbers Game.  If you are interested, I found a couple of typos in <code>Level_00_basic.lean</code>.</p>



<a name="219818268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28commutative%29-semirng/near/219818268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(commutative)-semirng.html#219818268">(Dec 14 2020 at 09:43)</a>:</h4>
<p>Open an issue on github and I'll deal with it one day.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
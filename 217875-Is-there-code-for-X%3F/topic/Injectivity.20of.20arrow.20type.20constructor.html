---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html">Injectivity of arrow type constructor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="281009379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281009379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Keizer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281009379">(May 03 2022 at 13:02)</a>:</h4>
<p>Is the following provable (in Lean 4)?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">β'</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">=</span> <span class="n">β'</span> <span class="o">:=</span>
  <span class="kd">by</span>
    <span class="n">intro</span> <span class="n">h</span><span class="bp">;</span>
    <span class="gr">sorry</span>
</code></pre></div>
<p>Intuitively, it seems like it should be true, if every function into <code>\beta</code> can be cast to a function into <code>\beta'</code>, and vice-versa, the types should have exactly the same inhabitants, right? Can I prove that in Lean 4?</p>



<a name="281010105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281010105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281010105">(May 03 2022 at 13:08)</a>:</h4>
<p>It is not provable.</p>



<a name="281011035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281011035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281011035">(May 03 2022 at 13:16)</a>:</h4>
<p>It's actually much worse than "not provable". It's not a good question in the flavor of type theory that Lean (or Coq) is using. If you think that you need this result then there is an important mismatch about the intuition you have of those foundations and the way they are actually meant to be used.</p>



<a name="281011252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281011252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281011252">(May 03 2022 at 13:18)</a>:</h4>
<p>Also, this doesn't hold if you replace equalities by equivalences.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">≃</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">→</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">≃</span> <span class="n">fin</span> <span class="mi">3</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- impossible</span>
</code></pre></div>



<a name="281013593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281013593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Keizer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281013593">(May 03 2022 at 13:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Injectivity.20of.20arrow.20type.20constructor/near/281011035">said</a>:</p>
<blockquote>
<p>It's actually much worse than "not provable". It's not a good question in the flavor of type theory that Lean (or Coq) is using. If you think that you need this result then there is an important mismatch about the intuition you have of those foundations and the way they are actually meant to be used.</p>
</blockquote>
<p>To be fair, my intuition did feel like it might be reaching the edge of what I can answer in Lean, hence me asking whether it's provable.<br>
I'm not interested in this result per se, It just seemed very useful while trying to prove the following congruence lemma</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">heq_congr_fun</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">β'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">f'</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β'</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">HEq</span> <span class="n">f</span> <span class="n">f'</span> <span class="bp">→</span> <span class="n">HEq</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">by</span>
    <span class="n">intro</span> <span class="n">h</span><span class="bp">;</span>
    <span class="gr">sorry</span>
</code></pre></div>
<p>Luckily, there was some #XY going on, and I found another way to prove my end-goal that doesn't need the congruence after all.</p>



<a name="281014269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281014269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281014269">(May 03 2022 at 13:42)</a>:</h4>
<p>I think it was not really "luck".</p>



<a name="281016582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281016582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281016582">(May 03 2022 at 13:58)</a>:</h4>
<p>I agree with Reid that usually when you need a result like that, you've already gone in a wrong direction before.<br>
Your statement of <code>heq_congr_fun</code> is also not provable in Lean, since it implies your original example (at least for inhabited <code>β</code>). <br>
You need to also assume <code>β = β'</code> to make <code>heq_congr_fun</code> provable: <a href="https://github.com/leanprover/lean2/blob/8072fdf9a0b31abb9d43ab894d7a858639e20ed7/library/logic/cast.lean#L28">https://github.com/leanprover/lean2/blob/8072fdf9a0b31abb9d43ab894d7a858639e20ed7/library/logic/cast.lean#L28</a></p>



<a name="281017863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281017863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Keizer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281017863">(May 03 2022 at 14:06)</a>:</h4>
<p>Yeah, in my case <code>β = β'</code> does in fact hold, which is how I made it work. Thanks for pointing out where to look!</p>



<a name="281029417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281029417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281029417">(May 03 2022 at 15:22)</a>:</h4>
<p>In general, if <code>x : a</code> and <code>y : b</code>, a <code>HEq x y</code> is not useful unless you can already prove that <code>a = b</code>.</p>



<a name="281032775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281032775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281032775">(May 03 2022 at 15:44)</a>:</h4>
<p>huh? <a href="https://leanprover-community.github.io/mathlib_docs/find/type_eq_of_heq">docs#type_eq_of_heq</a></p>



<a name="281034123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281034123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281034123">(May 03 2022 at 15:53)</a>:</h4>
<p>Yeah, I'm not sure what Reid is referring to -- part of <code>HEq</code> is that the types of the two terms are equal. If there's a rule, I think it's that <code>HEq</code> is not useful unless you can somehow use the type equality to substitute out one type for another everywhere.</p>
<p>The <code>heq</code> version of <code>congr_arg</code> works, for example (but you need to have a more complicated dependent type for the function):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Lean 3</span>
<span class="kd">theorem</span> <span class="n">heq_congr_arg</span> <span class="o">{</span><span class="n">α</span> <span class="n">α'</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">},</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a'</span> <span class="o">:</span> <span class="n">α'</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">==</span> <span class="n">a'</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">he</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">he</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kd">end</span>
</code></pre></div>



<a name="281040372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281040372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281040372">(May 03 2022 at 16:34)</a>:</h4>
<p>I mean just knowing <code>a = b</code> is not useful except in a situation like <code>a = C i</code>, <code>b = C j</code>, and you have a proof of <code>i = j</code>. (Or if <code>a</code> and <code>b</code> are defeq but then you didn't need <code>HEq</code>.)</p>



<a name="281041407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281041407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281041407">(May 03 2022 at 16:41)</a>:</h4>
<p>Like you can derive <code>false</code> from <code>(0 : nat) == (1 : nat)</code>, but you can't derive <code>false</code> from <code>(0 : nat) == (1 : int)</code>, even though it implies that <code>nat = int</code>.</p>



<a name="281044812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281044812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281044812">(May 03 2022 at 17:04)</a>:</h4>
<p>I mean, it seems pretty sensible to me. If the underlying set is ℕ, and you encode ℤ as <code>{1, -1, 0, 2, -2, 3, -3, ...}</code>, that wouldn't be contradictory at all</p>



<a name="281045462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281045462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281045462">(May 03 2022 at 17:09)</a>:</h4>
<p>Right and that's why, unless you already had a way to prove the types equal, a <code>HEq</code> hypothesis is not useful</p>



<a name="281045878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281045878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281045878">(May 03 2022 at 17:12)</a>:</h4>
<p>Ah, maybe i'm being pedantic but do you mean sort of "how" they are equal? Whether the encoding is <code>id</code> or whatever</p>



<a name="281046445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281046445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281046445">(May 03 2022 at 17:16)</a>:</h4>
<p>I'm pretty sure I still mean what I said the first time: <code>h : x == y</code> is only ever useful if, <em>without using <code>h</code></em>, you can already prove <code>a = b</code></p>



<a name="281046475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281046475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281046475">(May 03 2022 at 17:16)</a>:</h4>
<p>However, this isn't meant to be a metatheorem, just an observation based on experience.</p>



<a name="281046753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281046753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281046753">(May 03 2022 at 17:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Injectivity.20of.20arrow.20type.20constructor/near/281045878">said</a>:</p>
<blockquote>
<p>Ah, maybe i'm being pedantic but do you mean sort of "how" they are equal? Whether the encoding is <code>id</code> or whatever</p>
</blockquote>
<p>It is somehow related to this because there is only a very limited set of ways to prove that two types are equal.</p>



<a name="281056923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Injectivity%20of%20arrow%20type%20constructor/near/281056923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Injectivity.20of.20arrow.20type.20constructor.html#281056923">(May 03 2022 at 18:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Injectivity.20of.20arrow.20type.20constructor/near/281046445">said</a>:</p>
<blockquote>
<p>I'm pretty sure I still mean what I said the first time: <code>h : x == y</code> is only ever useful if, <em>without using <code>h</code></em>, you can already prove <code>a = b</code></p>
</blockquote>
<p>Just to elaborate on this point: <code>h : x == y</code> really means we have <code>e : a = b</code> (where <code>x : a</code> and <code>y : b</code>)  together with <code>h' : eq.rec a e = b</code>. In general, if we don't know what <code>e</code> is, then we have no way to determine <code>eq.rec a e</code>, so <code>h'</code> isn't really useful. On the other hand, for any 'concrete' proof <code>e' : a = b</code>, we can evaluate <code>eq.rec a e'</code> explicitly. And <code>eq.rec a e' = eq.rec a e</code> by proof irrelevance. So in this case <code>h'</code> actually tells us something useful, namely that <code>eq.rec a e' = b</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
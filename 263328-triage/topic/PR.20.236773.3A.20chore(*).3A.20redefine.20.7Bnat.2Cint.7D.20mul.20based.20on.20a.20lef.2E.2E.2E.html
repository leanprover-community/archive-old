---
layout: archive
title: Zulip Chat Archive
permalink: /stream/263328-triage/topic/PR.20.236773.3A.20chore(*).3A.20redefine.20.7Bnat.2Cint.7D.20mul.20based.20on.20a.20lef.2E.2E.2E.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/263328-triage/index.html">triage</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/263328-triage/topic/PR.20.236773.3A.20chore(*).3A.20redefine.20.7Bnat.2Cint.7D.20mul.20based.20on.20a.20lef.2E.2E.2E.html">PR #6773: chore(*): redefine {nat,int} mul based on a lef...</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="233327278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/263328-triage/topic/PR%20%236773%3A%20chore%28%2A%29%3A%20redefine%20%7Bnat%2Cint%7D%20mul%20based%20on%20a%20lef.../near/233327278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Random Issue Bot <a href="https://leanprover-community.github.io/archive/stream/263328-triage/topic/PR.20.236773.3A.20chore(*).3A.20redefine.20.7Bnat.2Cint.7D.20mul.20based.20on.20a.20lef.2E.2E.2E.html#233327278">(Apr 06 2021 at 14:24)</a>:</h4>
<p>Today I chose PR 6773 for discussion!</p>
<p><strong><a href="https://github.com/leanprover-community/mathlib/issues/6773">chore(*): redefine {nat,int} mul based on a left-smul</a></strong><br>
Created by <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> (@pechersky) on 2021-03-19<br>
Labels: RFC, awaiting-review</p>
<p>Is this PR still relevant? Any recent updates? Anyone making progress?</p>



<a name="233342671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/263328-triage/topic/PR%20%236773%3A%20chore%28%2A%29%3A%20redefine%20%7Bnat%2Cint%7D%20mul%20based%20on%20a%20lef.../near/233342671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/263328-triage/topic/PR.20.236773.3A.20chore(*).3A.20redefine.20.7Bnat.2Cint.7D.20mul.20based.20on.20a.20lef.2E.2E.2E.html#233342671">(Apr 06 2021 at 15:42)</a>:</h4>
<p>Can I have a clarification about whether Sebastien's refactoring of add_comm_group bundling the nat and int actions will make this refactor redundant? I am concerned that this refactor makes Lean 3 and Lean 4 diverge.</p>



<a name="233343183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/263328-triage/topic/PR%20%236773%3A%20chore%28%2A%29%3A%20redefine%20%7Bnat%2Cint%7D%20mul%20based%20on%20a%20lef.../near/233343183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/263328-triage/topic/PR.20.236773.3A.20chore(*).3A.20redefine.20.7Bnat.2Cint.7D.20mul.20based.20on.20a.20lef.2E.2E.2E.html#233343183">(Apr 06 2021 at 15:45)</a>:</h4>
<p>I have no idea!</p>



<a name="233343529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/263328-triage/topic/PR%20%236773%3A%20chore%28%2A%29%3A%20redefine%20%7Bnat%2Cint%7D%20mul%20based%20on%20a%20lef.../near/233343529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/263328-triage/topic/PR.20.236773.3A.20chore(*).3A.20redefine.20.7Bnat.2Cint.7D.20mul.20based.20on.20a.20lef.2E.2E.2E.html#233343529">(Apr 06 2021 at 15:47)</a>:</h4>
<p>My understanding was that both this refactor and the "add the nat and int action to a group" refactor have the goal of killing a diamond, but I am unclear about whether these are different diamonds, or related, or what.</p>



<a name="233348889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/263328-triage/topic/PR%20%236773%3A%20chore%28%2A%29%3A%20redefine%20%7Bnat%2Cint%7D%20mul%20based%20on%20a%20lef.../near/233348889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/263328-triage/topic/PR.20.236773.3A.20chore(*).3A.20redefine.20.7Bnat.2Cint.7D.20mul.20based.20on.20a.20lef.2E.2E.2E.html#233348889">(Apr 06 2021 at 16:22)</a>:</h4>
<p>The "add the nat and int action to a group" refactor kills <del>all the diamonds</del> diamonds caused by composite types, this kills the diamond that the nat and int semimodules form with <a href="https://leanprover-community.github.io/mathlib_docs/find/monoid.to_mul_action">docs#monoid.to_mul_action</a></p>



<a name="233554996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/263328-triage/topic/PR%20%236773%3A%20chore%28%2A%29%3A%20redefine%20%7Bnat%2Cint%7D%20mul%20based%20on%20a%20lef.../near/233554996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/263328-triage/topic/PR.20.236773.3A.20chore(*).3A.20redefine.20.7Bnat.2Cint.7D.20mul.20based.20on.20a.20lef.2E.2E.2E.html#233554996">(Apr 07 2021 at 20:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> do you have any idea about this 2^17-1 business? <a href="https://github.com/leanprover-community/mathlib/pull/6773#discussion_r598949926">https://github.com/leanprover-community/mathlib/pull/6773#discussion_r598949926</a> . </p>
<p>I decided that I don't care if Lean 3 and Lean 4 diverge with their definitions of int. Am I right in thinking that if we don't like Lean 4 ints then we can just make our own? Leo hasn't even used <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> notation for Lean 4's Int.</p>



<a name="233555268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/263328-triage/topic/PR%20%236773%3A%20chore%28%2A%29%3A%20redefine%20%7Bnat%2Cint%7D%20mul%20based%20on%20a%20lef.../near/233555268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/263328-triage/topic/PR.20.236773.3A.20chore(*).3A.20redefine.20.7Bnat.2Cint.7D.20mul.20based.20on.20a.20lef.2E.2E.2E.html#233555268">(Apr 07 2021 at 20:25)</a>:</h4>
<p>I think that Sebastien has made some real breakthroughs recently with his observations about the interaction of nat and int with our other types. All these actions have built up organically because mathematicians have needed them, but now he has seen a new way to do it. I'm a little surprised that these sorts of issues have not shown up in the other dependent type theory provers.</p>



<a name="233563573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/263328-triage/topic/PR%20%236773%3A%20chore%28%2A%29%3A%20redefine%20%7Bnat%2Cint%7D%20mul%20based%20on%20a%20lef.../near/233563573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/263328-triage/topic/PR.20.236773.3A.20chore(*).3A.20redefine.20.7Bnat.2Cint.7D.20mul.20based.20on.20a.20lef.2E.2E.2E.html#233563573">(Apr 07 2021 at 21:12)</a>:</h4>
<p>There appears to be a change in the unfolding which is causing problems. Here's a MWE without using norm_num:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>

<span class="kd">set_option</span> <span class="n">pp.notation</span> <span class="n">false</span>
<span class="c1">-- set_option pp.numerals false</span>
<span class="kd">set_option</span> <span class="n">pp.implicit</span> <span class="n">true</span>
<span class="kd">set_option</span> <span class="n">trace.type_context.is_def_eq</span> <span class="n">true</span>
<span class="kd">set_option</span> <span class="n">trace.type_context.is_def_eq_detail</span> <span class="n">true</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">comm_semiring.mul</span> <span class="n">nat</span> <span class="n">nat.comm_semiring</span> <span class="mi">31</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">nat.mul</span> <span class="mi">31</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">...</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="mi">31</span><span class="bp">.</span><span class="n">mul</span> <span class="mi">1</span> <span class="bp">=?=</span> <span class="bp">@</span><span class="n">comm_semiring.mul</span> <span class="n">nat</span> <span class="n">nat.comm_semiring</span> <span class="mi">31</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="n">unfold</span> <span class="n">left</span><span class="o">:</span> <span class="n">nat.mul</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">]:</span> <span class="mi">31</span><span class="bp">.</span><span class="n">smul</span> <span class="mi">1</span> <span class="bp">=?=</span> <span class="bp">@</span><span class="n">comm_semiring.mul</span> <span class="n">nat</span> <span class="n">nat.comm_semiring</span> <span class="mi">31</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="n">unfold</span> <span class="n">left</span><span class="o">:</span> <span class="n">nat.smul</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">4</span><span class="o">]:</span> <span class="mi">31</span><span class="bp">.</span><span class="n">rec_on</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="n">rec</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">@</span><span class="n">has_add.add</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="mi">1</span> <span class="n">rec</span><span class="o">)</span> <span class="bp">=?=</span> <span class="bp">@</span><span class="n">comm_semiring.mul</span> <span class="n">nat</span> <span class="n">nat.comm_semiring</span> <span class="mi">31</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="n">after</span> <span class="n">whnf_core</span><span class="o">:</span> <span class="bp">@</span><span class="n">has_add.add</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="mi">1</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">nat.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat</span><span class="o">)</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="n">rec</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">@</span><span class="n">has_add.add</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="mi">1</span> <span class="n">rec</span><span class="o">)</span> <span class="o">(</span><span class="mi">30</span><span class="bp">.</span><span class="n">add</span> <span class="mi">0</span><span class="o">))</span> <span class="bp">=?=</span> <span class="bp">@</span><span class="n">comm_semiring.mul</span> <span class="n">nat</span> <span class="n">nat.comm_semiring</span> <span class="mi">31</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">5</span><span class="o">]:</span> <span class="mi">1</span><span class="bp">.</span><span class="n">add</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat</span><span class="o">)</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="n">rec</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">@</span><span class="n">has_add.add</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="mi">1</span> <span class="n">rec</span><span class="o">)</span> <span class="o">(</span><span class="mi">30</span><span class="bp">.</span><span class="n">add</span> <span class="mi">0</span><span class="o">))</span> <span class="bp">=?=</span> <span class="mi">31</span><span class="bp">.</span><span class="n">mul</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">6</span><span class="o">]:</span> <span class="mi">1</span><span class="bp">.</span><span class="n">add</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat</span><span class="o">)</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="n">rec</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">@</span><span class="n">has_add.add</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="mi">1</span> <span class="n">rec</span><span class="o">)</span> <span class="o">(</span><span class="mi">30</span><span class="bp">.</span><span class="n">add</span> <span class="mi">0</span><span class="o">))</span> <span class="bp">=?=</span> <span class="mi">31</span><span class="bp">.</span><span class="n">smul</span> <span class="mi">1</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">7</span><span class="o">]:</span> <span class="o">(</span><span class="mi">1</span><span class="bp">.</span><span class="n">add</span>
   <span class="o">(</span><span class="mi">1</span><span class="bp">.</span><span class="n">add</span>
      <span class="o">(</span><span class="mi">1</span><span class="bp">.</span><span class="n">add</span>
         <span class="o">(</span><span class="mi">1</span><span class="bp">.</span><span class="n">add</span>
            <span class="o">(</span><span class="mi">1</span><span class="bp">.</span><span class="n">add</span>
               <span class="o">(</span><span class="mi">1</span><span class="bp">.</span><span class="n">add</span>
                  <span class="o">(</span><span class="mi">1</span><span class="bp">.</span><span class="n">add</span>
<span class="bp">...</span>
</code></pre></div>



<a name="233565904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/263328-triage/topic/PR%20%236773%3A%20chore%28%2A%29%3A%20redefine%20%7Bnat%2Cint%7D%20mul%20based%20on%20a%20lef.../near/233565904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/263328-triage/topic/PR.20.236773.3A.20chore(*).3A.20redefine.20.7Bnat.2Cint.7D.20mul.20based.20on.20a.20lef.2E.2E.2E.html#233565904">(Apr 07 2021 at 21:23)</a>:</h4>
<p>A missing <a href="https://leanprover-community.github.io/mathlib_docs/find/id_rhs">docs#id_rhs</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/id_delta">docs#id_delta</a>?</p>



<a name="233566039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/263328-triage/topic/PR%20%236773%3A%20chore%28%2A%29%3A%20redefine%20%7Bnat%2Cint%7D%20mul%20based%20on%20a%20lef.../near/233566039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/263328-triage/topic/PR.20.236773.3A.20chore(*).3A.20redefine.20.7Bnat.2Cint.7D.20mul.20based.20on.20a.20lef.2E.2E.2E.html#233566039">(Apr 07 2021 at 21:24)</a>:</h4>
<p>The old definition inserted various markers as part of the equation compiler</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
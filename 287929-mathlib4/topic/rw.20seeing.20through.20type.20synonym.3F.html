---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html">rw seeing through type synonym?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="315887448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315887448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315887448">(Dec 14 2022 at 18:25)</a>:</h4>
<p>Yes this is very surprising to me. In Lean 3 the rewrite would fail. Here are examples on mathlib3 and mathlib4 master:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- lean 3</span>
<span class="kn">import</span> <span class="n">algebra.group.opposite</span>
<span class="kn">import</span> <span class="n">group_theory.group_action.defs</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">has_mul.to_has_opposite_smul</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_smul</span> <span class="n">α</span><span class="bp">ᵐᵒᵖ</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="k">fun</span> <span class="n">c</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">c.unop</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">MulOpposite.smul_eq_mul_unop</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="bp">ᵐᵒᵖ</span><span class="o">}</span> <span class="o">{</span><span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">a'</span> <span class="bp">=</span> <span class="n">a'</span> <span class="bp">*</span> <span class="n">a.unop</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- rw smul_eq_mul, -- fails</span>
  <span class="c1">-- rw @smul_eq_mul αᵐᵒᵖ -- fails</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- lean 4</span>
<span class="kn">import</span> <span class="n">Mathlib.Algebra.Group.Opposite</span>
<span class="kn">import</span> <span class="n">Mathlib.GroupTheory.GroupAction.Defs</span>

<span class="kd">instance</span> <span class="n">Mul.toHasOppositeSmul</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">SMul</span> <span class="n">α</span><span class="bp">ᵐᵒᵖ</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="k">fun</span> <span class="n">c</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">c.unop</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">MulOpposite.smul_eq_mul_unop</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="bp">ᵐᵒᵖ</span><span class="o">}</span> <span class="o">{</span><span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">a'</span> <span class="bp">=</span> <span class="n">a'</span> <span class="bp">*</span> <span class="n">a.unop</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="c1">-- the • in the goal is `@HSMul.hSMul αᵐᵒᵖ α α instHSMul a a' : α`</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">@</span><span class="n">smul_eq_mul</span> <span class="n">α</span><span class="bp">ᵐᵒᵖ</span><span class="o">]</span> <span class="c1">-- works! Even though `a'` does not have type `αᵐᵒᵖ`.</span>
  <span class="n">rfl</span>
</code></pre></div>
<p>Is this a change in the behaviour of <code>rw</code>?</p>



<a name="315887683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315887683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315887683">(Dec 14 2022 at 18:26)</a>:</h4>
<p>You should maybe change the title of the thread to "<code>rw</code> seeing through type synonym?" because this is kind of weird.</p>



<a name="315888036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315888036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315888036">(Dec 14 2022 at 18:28)</a>:</h4>
<p>Should we use a <code>structure</code> instead of a type synonym in Lean 4?</p>



<a name="315888191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315888191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315888191">(Dec 14 2022 at 18:29)</a>:</h4>
<p>With the new structure eta(?) <code>rfl</code>, we'll have both <code>op_unop</code> and <code>unop_op</code> as <code>rfl</code> lemmas.</p>



<a name="315895439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315895439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315895439">(Dec 14 2022 at 19:05)</a>:</h4>
<p>Here's a mathlib-free MWE: all the declarations are from mathlib.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- lean 4</span>

<span class="kd">class</span> <span class="n">SMul</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">smul</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>

<span class="kd">class</span> <span class="n">HSMul</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">w</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">hSMul</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span>

<span class="kd">infixr</span><span class="o">:</span><span class="mi">73</span> <span class="s2">" • "</span> <span class="bp">=&gt;</span> <span class="n">HSMul.hSMul</span>

<span class="kd">instance</span> <span class="n">instHSMul</span> <span class="o">[</span><span class="n">SMul</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">HSMul</span> <span class="n">α</span> <span class="n">β</span> <span class="n">β</span> <span class="n">where</span>
  <span class="n">hSMul</span> <span class="o">:=</span> <span class="n">SMul.smul</span>

<span class="c1">-- type synonym</span>
<span class="kd">def</span> <span class="n">MulOpposite</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
  <span class="n">α</span>

<span class="kd">postfix</span><span class="o">:</span><span class="n">max</span> <span class="s2">"ᵐᵒᵖ"</span> <span class="bp">=&gt;</span> <span class="n">MulOpposite</span>

<span class="kn">namespace</span> <span class="n">MulOpposite</span>

<span class="kd">def</span> <span class="n">unop</span> <span class="o">:</span> <span class="n">α</span><span class="bp">ᵐᵒᵖ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">id</span>

<span class="kd">def</span> <span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="bp">ᵐᵒᵖ</span> <span class="o">:=</span>
  <span class="n">id</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Mul</span> <span class="n">α</span><span class="bp">ᵐᵒᵖ</span> <span class="n">where</span> <span class="n">mul</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">op</span> <span class="o">(</span><span class="n">unop</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">unop</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">MulOpposite</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="mi">910</span><span class="o">)</span> <span class="n">Mul.toSMul</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">SMul</span> <span class="n">α</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="o">⟨(</span><span class="bp">·</span> <span class="bp">*</span> <span class="bp">·</span><span class="o">)⟩</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">smul_eq_mul</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">a'</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a'</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">instance</span> <span class="n">Mul.toHasOppositeSmul</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">SMul</span> <span class="n">α</span><span class="bp">ᵐᵒᵖ</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="k">fun</span> <span class="n">c</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">c.unop</span><span class="o">⟩</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">MulOpposite.smul_eq_mul_unop</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="bp">ᵐᵒᵖ</span><span class="o">}</span> <span class="o">{</span><span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">a'</span> <span class="bp">=</span> <span class="n">a'</span> <span class="bp">*</span> <span class="n">a.unop</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">@</span><span class="n">smul_eq_mul</span> <span class="n">α</span><span class="bp">ᵐᵒᵖ</span><span class="o">]</span> <span class="c1">-- wouldn't work in Lean 3</span>
  <span class="n">rfl</span>

<span class="c">/-</span><span class="cm"> The `simpNF` linter reports:</span>
<span class="cm">SOME SIMP LEMMAS ARE NOT IN SIMP-NORMAL FORM.</span>
<span class="cm">see note [simp-normal form] for tips how to debug this.</span>
<span class="cm">https://leanprover-community.github.io/mathlib_docs/notes.html#simp-normal%20form -/</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">MulOpposite.smul_eq_mul_unop</span> <span class="c">/-</span><span class="cm"> Left-hand side simplifies from</span>
<span class="cm">  a • a'</span>
<span class="cm">to</span>
<span class="cm">  a * a'</span>
<span class="cm">using</span>
<span class="cm">  simp only [smul_eq_mul]</span>
<span class="cm">Try to change the left-hand side to the simplified term!</span>
<span class="cm"> -/</span>
</code></pre></div>



<a name="315897395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315897395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315897395">(Dec 14 2022 at 19:15)</a>:</h4>
<p>Type synonyms like <code>opposite</code> were a big cause of weird leakage in Lean 3, which led to weird goals (which were super-hard to debug before widgets). More recently we learnt how to tame them in mathlib3, by making the API and then afterwards marking the declarations <code>irreducible</code>. This approach is no longer possible in Lean 4 because you cannot change the reducibility of a declaraction once it's been made (the autoporter rather annoyingly just ignores changes in transparency without flagging them as "something which is no longer possible just got skipped").</p>
<p>This is also a very weird goal above: it looks to me like we're being type-careful in the declarations, but the simplifier is breaking the abstraction. Here <code>a * a'</code> has a term of type <code>α</code> but the multiplication is the mul on <code>αᵐᵒᵖ</code> so <code>a'</code> has somehow been coerced to <code>αᵐᵒᵖ</code>. The fact that it's happening, and the fact that we also have this issue about being unable to change the transparency of a declaration after it's been made, make me tentatively agree with Yury that we should perhaps consider using a structure and hoping that eta for structures will mean that the pain incurred is not too bad. It would be great to get some expert opinion on this because this is a big call. <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="110087">@Scott Morrison</span> ?</p>



<a name="315924353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315924353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315924353">(Dec 14 2022 at 22:08)</a>:</h4>
<p>I guess Gabriel is probably for this, judging by <a href="https://github.com/leanprover/lean4/issues/777">https://github.com/leanprover/lean4/issues/777</a></p>



<a name="315925031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315925031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315925031">(Dec 14 2022 at 22:14)</a>:</h4>
<p>Yes, I think it is the right choice to turn most of these wrappers into structures, precisely because it's way to easy to break the abstraction otherwise.</p>



<a name="315925296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315925296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315925296">(Dec 14 2022 at 22:16)</a>:</h4>
<p>TODO: This advice needs to be added to the porting wiki.</p>



<a name="315925381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315925381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315925381">(Dec 14 2022 at 22:16)</a>:</h4>
<p>This is going to be a lot of API writing <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span> but I'm with you on this.</p>



<a name="315925562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315925562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315925562">(Dec 14 2022 at 22:18)</a>:</h4>
<p>Some of these wrappers (e.g., <code>mul_opposite</code>) are supposed to be irreducible. But some wrappers (e.g., <code>order_dual</code>) are often used to quickly get the order-dual lemma by forcing defeq.</p>



<a name="315925631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315925631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315925631">(Dec 14 2022 at 22:18)</a>:</h4>
<p><code>additive</code> is used in both ways.</p>



<a name="315925737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315925737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315925737">(Dec 14 2022 at 22:19)</a>:</h4>
<p>Do you suggest that we completely move away from the <code>order_dual</code>-style?</p>



<a name="315926024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315926024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315926024">(Dec 14 2022 at 22:21)</a>:</h4>
<p>Maybe we need a tactic supporting the proofs where we want to abuse <code>order_dual</code>.</p>



<a name="315926154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315926154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315926154">(Dec 14 2022 at 22:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/315263615">said</a>:</p>
<blockquote>
<p>My dream is still for a <code>to_additive</code>-like tactic to handle them all.</p>
</blockquote>
<p>More discussion above and below</p>



<a name="315926265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315926265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315926265">(Dec 14 2022 at 22:23)</a>:</h4>
<p>Maybe it's worth looking at the (now rotten) <a href="https://github.com/leanprover-community/mathlib/pull/6045">#6045</a>.  Turning <code>additive</code> into a structure is not <em>that</em> painful.  I don't think <code>order_dual</code> would be much worse.</p>



<a name="315926435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315926435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315926435">(Dec 14 2022 at 22:25)</a>:</h4>
<p>I mean, we would need to add a few thousands more lines of code <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="315926623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315926623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315926623">(Dec 14 2022 at 22:26)</a>:</h4>
<p>I don't see why that's the case. The "tactic" here is defining the recursor (unary, binary, tritary). We're already often changing lemma names. Including an "order_dual.rec_2 &lt;|" in various lines shouldn't be too bad.</p>



<a name="315926889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315926889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315926889">(Dec 14 2022 at 22:28)</a>:</h4>
<p>In the case where we make <code>order_dual</code> a structure without providing a <code>to_dual</code> attribute, I am firmly convinced we have to write about 10k more lines of code. In the case where we make <code>order_dual</code> a structure and provide a <code>to_dual</code> attribute, we might end up reducing the number of lines.</p>



<a name="315927230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315927230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315927230">(Dec 14 2022 at 22:31)</a>:</h4>
<p>I'm really not a fan of the <code>to_additive</code> proof method, that is, translating all the proofs from the bottom up. From a proof theory perspective this is very wasteful when you can just instantiate a structure and apply the old theorem, and from an automation perspective it's more brittle because you have to translate a bunch of internals, in addition to reading proofs out of the environment which is something we want to crack down on in the future</p>



<a name="315927466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315927466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315927466">(Dec 14 2022 at 22:33)</a>:</h4>
<p>I think <code>order_dual</code> is genuinely much worse than <code>additive</code> for two reasons:</p>
<ul>
<li>There's only one way of translating a multiplicative statement to an additive one (except a handful of edge cases), while there are 2^#types appearing in the statement ways of dualising.</li>
<li><code>order_dual</code> is used in a defeq-forcing manner much more pervasively than <code>additive</code></li>
</ul>



<a name="315927935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315927935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315927935">(Dec 14 2022 at 22:36)</a>:</h4>
<p>That's interesting, Mario. I always thought <code>to_additive</code> was the pinnacle of proof translation.</p>



<a name="315930903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315930903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315930903">(Dec 14 2022 at 23:00)</a>:</h4>
<p>From a UX standpoint <code>to_additive</code> is great, it's just the proof method that isn't great. I would rather have something like <code>to_additive</code> do its proof by translating the <em>statement</em> and using transfer theorems to turn everything into facts about <code>additive</code> of something and then applying the old theorem</p>



<a name="315931122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315931122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315931122">(Dec 14 2022 at 23:02)</a>:</h4>
<p>many of the proofs we're talking about are basically doing exactly that, but with defeq abuse in place of a transfer tactic</p>



<a name="315931547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315931547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315931547">(Dec 14 2022 at 23:05)</a>:</h4>
<p>Oh I understand now. Yeah, this would be the best of both worlds.</p>



<a name="315939603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315939603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315939603">(Dec 15 2022 at 00:19)</a>:</h4>
<p>wooah I changed the definition of <code>αᵐᵒᵖ</code> from <code>:= α</code> to a structure (i.e. I totally changed the definitions in the first few lines of <code>Mathlib.Algebra.Opposites</code>, and <em>the entire file still compiled</em> apart from one lemma which is arguably incorrect in mathlib3 anyway. See <a href="https://github.com/leanprover-community/mathlib4/pull/1036">mathlib4#1036</a> . I'm going to bed now, if anyone wants to push this any further. I'm unlikely to look at this for around 24 hours because I have a very busy day at work tomorrow.</p>



<a name="315940347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315940347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315940347">(Dec 15 2022 at 00:27)</a>:</h4>
<p>For types that were already irreducible in mathlib3, turning them into structures in Lean 4 shouldn't make much of a difference.  Except for shenanigans like <code>local attribute [semireducible] mul_opposite</code>.</p>



<a name="315945749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315945749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315945749">(Dec 15 2022 at 01:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F/near/315925562">said</a>:</p>
<blockquote>
<p>Some of these wrappers (e.g., <code>mul_opposite</code>) are supposed to be irreducible. But some wrappers (e.g., <code>order_dual</code>) are often used to quickly get the order-dual lemma by forcing defeq.</p>
</blockquote>
<p>Is this what was causing the instance issues for <a href="https://github.com/leanprover-community/mathlib4/pull/1001">mathlib4#1001</a>? (thread here: <a href="#narrow/stream/287929-mathlib4/topic/.231001.20failed.20to.20synthesize.20instance/near/315730442">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/.231001.20failed.20to.20synthesize.20instance/near/315730442</a>)</p>



<a name="315947214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315947214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315947214">(Dec 15 2022 at 01:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F/near/315925562">said</a>:</p>
<blockquote>
<p>Some of these wrappers (e.g., <code>mul_opposite</code>) are supposed to be irreducible. But some wrappers (e.g., <code>order_dual</code>) are often used to quickly get the order-dual lemma by forcing defeq.</p>
</blockquote>
<p><code>mul_opposite</code> is irreducible but <code>add_opposite</code> isn't!</p>



<a name="315947230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315947230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315947230">(Dec 15 2022 at 01:59)</a>:</h4>
<p>Note that there are places in mathlib that take advantage of the fact that  (pseudocode)<code>additive (quotient_group X) = quotient_add_group (multiplicative X)</code> to transfer results; in these places, we have to temporarily make <code>mul_opposite</code> semireducible again. We won't have that option if we make things a structure</p>



<a name="315947334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315947334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315947334">(Dec 15 2022 at 02:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F/near/315939603">said</a>:</p>
<blockquote>
<p>and <em>the entire file still compiled</em></p>
</blockquote>
<p>Of course, the real test is whether the entire set of yet-to-be-ported files still compile...</p>



<a name="315970043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/315970043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#315970043">(Dec 15 2022 at 07:03)</a>:</h4>
<p>There was some push a while ago to try to remove occurrences of <code>local attribute [semireducible]</code> from mathlib, right?</p>



<a name="316017936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/316017936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#316017936">(Dec 15 2022 at 11:41)</a>:</h4>
<p>I can see that this might be a good idea in the sense that (a) it would in theory help with porting and (b) it would make a bunch of lemmas be moved to more appropriate places (assuming the mathlib3 philosophy is "start with it semireducible, prove stuff, make it irreducible, and don't fiddle with it any more"). As it happens I do now have 30 minutes more to work on this stuff so I'd like to temporarily claim it back.</p>



<a name="316018421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/316018421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#316018421">(Dec 15 2022 at 11:44)</a>:</h4>
<p><a href="#narrow/stream/287929-mathlib4/topic/make.20.60MulOpposite.60.20a.20structure/near/316018381">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/make.20.60MulOpposite.60.20a.20structure/near/316018381</a></p>



<a name="316070277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/316070277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#316070277">(Dec 15 2022 at 15:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F/near/315930903">said</a>:</p>
<blockquote>
<p>From a UX standpoint <code>to_additive</code> is great, it's just the proof method that isn't great. I would rather have something like <code>to_additive</code> do its proof by translating the <em>statement</em> and using transfer theorems to turn everything into facts about <code>additive</code> of something and then applying the old theorem</p>
</blockquote>
<p>I am also not happy with the current implementation of <code>to_additive</code>. The fact that we have to also translate all this internal stuff is definitely a bad sign.<br>
However, your approach is only a partial fix, since proof terms can occur in a theorem statement. In that case, you will still have to translate proof terms (or at the very least a lemma name that is exactly that proof term)</p>



<a name="317784721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317784721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317784721">(Dec 25 2022 at 01:50)</a>:</h4>
<p>Should I try to turn <code>Multiplicative</code> and <code>Additive</code> into structures (in <code>mathlib 4</code>, not in <code>mathlib 3</code>)?</p>



<a name="317784827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317784827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317784827">(Dec 25 2022 at 01:53)</a>:</h4>
<p>I think so. They accepted my PR for <code>MulOpposite</code> because it seemed to be solving problems.</p>



<a name="317787198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317787198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317787198">(Dec 25 2022 at 02:38)</a>:</h4>
<p>Currently, <code>ofAdd</code> etc are <code>Equiv</code>s. If I define, e.g.,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Multiplicative</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ofAdd</span> <span class="o">::</span> <span class="n">toAdd</span> <span class="o">:</span> <span class="n">α</span>
</code></pre></div>
<p>then they're no longer <code>Equiv</code>s. What should I do?</p>
<ul>
<li>Define as above, add <code>Multiplicative.ofAddEquiv</code> and <code>Additive.ofMulEquiv</code>?</li>
<li>Define with some other names (e.g., <code>mk</code> and <code>out</code>) and add <code>ofAdd</code> and <code>toAdd</code> as <code>Equiv</code>s?</li>
</ul>



<a name="317787306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317787306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317787306">(Dec 25 2022 at 02:40)</a>:</h4>
<p>I prefer <code>ofAdd :: toAdd : α</code> but it may make porting harder.</p>



<a name="317804781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317804781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317804781">(Dec 25 2022 at 08:10)</a>:</h4>
<p>I think it's fine to make them undecorated functions, because there are many bundlings they could be.</p>



<a name="317806112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317806112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317806112">(Dec 25 2022 at 08:30)</a>:</h4>
<p>I'm worried we're setting ourselves up for trouble if we don't start by attempting to backport this first</p>



<a name="317807583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317807583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317807583">(Dec 25 2022 at 08:44)</a>:</h4>
<p>We can try to backport it, but I expect it be fine.</p>



<a name="317818412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317818412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317818412">(Dec 25 2022 at 10:44)</a>:</h4>
<p>When I tried an experimental version of this I gave the unequiv constructor/eliminator primed names</p>



<a name="317858789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317858789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317858789">(Dec 25 2022 at 17:15)</a>:</h4>
<p>I made mathlib4 compile with <code>structure</code>s for <code>Additive</code> and <code>Multiplicative</code>. But this is not free.</p>



<a name="317858810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317858810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317858810">(Dec 25 2022 at 17:15)</a>:</h4>
<p>We forced defeq here and there in mathlib3.</p>



<a name="317858962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317858962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317858962">(Dec 25 2022 at 17:16)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib4/pull/1213">https://github.com/leanprover-community/mathlib4/pull/1213</a></p>



<a name="317858996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317858996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317858996">(Dec 25 2022 at 17:17)</a>:</h4>
<p>I'll cherry-pick some changes that make sense any way to another branch.</p>



<a name="317878856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/317878856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#317878856">(Dec 25 2022 at 21:38)</a>:</h4>
<p>Yes I tried this and it was much harder than <code>MulOpposite</code></p>



<a name="321032296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/321032296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#321032296">(Jan 12 2023 at 20:53)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> do you think this should be backported to mathlib3?</p>



<a name="321032584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/321032584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#321032584">(Jan 12 2023 at 20:55)</a>:</h4>
<p>There's already a mathlib PR changing Additive/Multiplicative to structures.  <a href="https://github.com/leanprover-community/mathlib/pull/6045">#6045</a>  (slightly fermented)</p>



<a name="321047984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/321047984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#321047984">(Jan 12 2023 at 22:39)</a>:</h4>
<p>I'm not sure whether it should be backported: some Lean 4 <code>rfl</code>s are useful. But I can revive <a href="https://github.com/leanprover-community/mathlib/pull/6045">#6045</a> if needed.</p>



<a name="321714102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/rw%20seeing%20through%20type%20synonym%3F/near/321714102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/rw.20seeing.20through.20type.20synonym.3F.html#321714102">(Jan 16 2023 at 20:31)</a>:</h4>
<p>I guess the argument against backporting is that the mathlib4 PR might be solving problems which weren't present in mathlib3.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
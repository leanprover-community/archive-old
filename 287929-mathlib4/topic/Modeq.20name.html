---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Modeq.20name.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html">Modeq name</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="318669926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318669926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318669926">(Dec 31 2022 at 00:01)</a>:</h4>
<p>What would you want the name of modeq to be in Lean 4? <code>Modeq</code> or <code>ModEq</code>? I think the latter makes more since</p>
<p>Furthermore I'm having a little issue with the definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Modeq</span> <span class="o">(</span><span class="n">n</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">a</span> <span class="bp">%</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">%</span> <span class="n">n</span> <span class="n">deriving</span> <span class="n">Decidable</span>
</code></pre></div>
<p>It cannot derive <code>Decidable</code> do we want to treat this as a bug and fix it upstream in the compiler or shall I write a manual instance?</p>



<a name="318670950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318670950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318670950">(Dec 31 2022 at 00:15)</a>:</h4>
<p>delta deriving is still todo, it needs some upstream changes</p>



<a name="318671033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318671033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318671033">(Dec 31 2022 at 00:16)</a>:</h4>
<p>the workaround is to write the instances manually (with a <code>Porting note</code>), you probably can't just skip them since later things will need those instances</p>



<a name="318671337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318671337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318671337">(Dec 31 2022 at 00:21)</a>:</h4>
<p><code>ModEq</code> seems like a fine name to me</p>



<a name="318673234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318673234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318673234">(Dec 31 2022 at 00:46)</a>:</h4>
<p>Oh I also have to write a manual <code>Trans</code> instance. Could it be that we want a <code>abbrev ModEq</code> instead of a <code>def ModEq</code>?</p>



<a name="318674177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318674177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318674177">(Dec 31 2022 at 00:56)</a>:</h4>
<p>In mathlib3, for teaching, I actually used <code>attribute [irreducible]</code> on the def for <code>modeq</code>, because the definition is so unintuitive that I wanted to prevent the students from ever accidentally encountering it.</p>



<a name="318674350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318674350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318674350">(Dec 31 2022 at 00:58)</a>:</h4>
<p>The definition is unintuitive? This is the only definition i have ever been taught and can think of to be honest :D How would you go about defining this?</p>



<a name="318674358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318674358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318674358">(Dec 31 2022 at 00:59)</a>:</h4>
<p>So that's a vote in the opposite direction from <code>abbrev</code> -- I don't think we have any policy of taking teaching preferences into account for mathlib, though.</p>



<a name="318674509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318674509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318674509">(Dec 31 2022 at 01:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/287929-mathlib4/topic/Modeq.20name/near/318674350">said</a>:</p>
<blockquote>
<p>The definition is unintuitive? This is the only definition i have ever been taught and can think of to be honest :D How would you go about defining this?</p>
</blockquote>
<p>I'm thinking of <code>int.modeq</code> rather than <code>nat.modeq</code>, but the definition I <a href="https://github.com/hrmacbeth/math2001/blob/b102dd81ec31a77e3f4f5e20b9f2471009506b51/src/03_Parity_and_Divisibility/03_Modular_Arithmetic_Theory.lean#L7">teach in class</a> is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">int.modeq</span> <span class="o">(</span><span class="n">n</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">∣</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>



<a name="318674661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318674661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318674661">(Dec 31 2022 at 01:02)</a>:</h4>
<p>It's easier to reason about -- no case splits in proofs.</p>



<a name="318674846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318674846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318674846">(Dec 31 2022 at 01:04)</a>:</h4>
<p>Interesting. As a programmer I think of modeq as "the remainders are equivalent" which is exactly what the mathlib definition mirrors and when I explain students for example the RSA algorithm I can explain <code>a \equiv b \pmod n</code> as "This is just notation for putting the modulo on both sides" but I guess if you are building the mathematics up instead of just using all the nice modulo properties your approach might be easier.</p>



<a name="318674909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318674909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318674909">(Dec 31 2022 at 01:05)</a>:</h4>
<p>Indeed, I think in many mathematical theories there's a difference between what's easy when building the theory and what's easy when using it.</p>



<a name="318675064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318675064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318675064">(Dec 31 2022 at 01:08)</a>:</h4>
<p>Incidentally, there's no analogue of <code>attribute [irreducible]</code> in Lean 4, right?  Is there any other way to hide a definition post-facto?  (Maybe someone can point me to a previous discussion of this design decision?)</p>



<a name="318675205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318675205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318675205">(Dec 31 2022 at 01:09)</a>:</h4>
<p><code>attribute [irreducible] ModEq</code> would work out without any issues.</p>



<a name="318675281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318675281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318675281">(Dec 31 2022 at 01:10)</a>:</h4>
<p>Oh, great!  I wonder what I was thinking of?  I thought I had heard that it was no longer possible to mark definitions as irreducible after the fact.</p>



<a name="318675374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318675374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318675374">(Dec 31 2022 at 01:11)</a>:</h4>
<p>From what I have seen in this stream it seems like the <code>attribute</code> feature in Lean 4 is either equivalent or actually a teeny bit better than in Lean 3 in what it allows you to do. There are a few syntax changes but in general everything I've seen from Lean 3 with <code>attribute</code> so far should work in Lean 4 as well.</p>



<a name="318675445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318675445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318675445">(Dec 31 2022 at 01:12)</a>:</h4>
<p>Hmm ... do you know what Mario was referring to here?</p>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/local.20semireducible/near/314773704">said</a>:</p>
<blockquote>
<p>Like I said in the meeting, <code>attribute [irreducible]</code> is just plain not supported in lean 4</p>
</blockquote>



<a name="318675659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318675659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318675659">(Dec 31 2022 at 01:15)</a>:</h4>
<p>Hm no, when i applied attribute [irreducible] just now I actually saw some proofs failing such as the fact that the <code>Trans</code> instance of <code>Eq</code> can be trivially used to prove one for <code>ModEq</code> and so on. So it does work and have an effect as well.</p>



<a name="318676731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318676731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318676731">(Dec 31 2022 at 01:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  explained in the meeting that allowing declarations to become irreducible after the fact meant that some <code>dsimp</code> lemmas about the declarations would...now no longer typecheck...or something? So it was a bad idea?</p>



<a name="318676838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318676838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318676838">(Dec 31 2022 at 01:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/287929-mathlib4/topic/Modeq.20name/near/318669926">said</a>:</p>
<blockquote>
<p>What would you want the name of modeq to be in Lean 4? <code>Modeq</code> or <code>ModEq</code>? I think the latter makes more since</p>
<p>Furthermore I'm having a little issue with the definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Modeq</span> <span class="o">(</span><span class="n">n</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">a</span> <span class="bp">%</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">%</span> <span class="n">n</span> <span class="n">deriving</span> <span class="n">Decidable</span>
</code></pre></div>
<p>It cannot derive <code>Decidable</code> do we want to treat this as a bug and fix it upstream in the compiler or shall I write a manual instance?</p>
</blockquote>
<p>This definition is really crazy. Why on earth would anyone want to make this so complicated when the mathematical definition is so nice?</p>



<a name="318676844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318676844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318676844">(Dec 31 2022 at 01:34)</a>:</h4>
<p>Re <code>modeq</code> -- why not just prove <code>int.modeq_def (n a b : ℤ) : int.modeq n a b : ℤ &lt;-&gt; n ∣ (a - b) := ...</code> and tell them to rewrite the definition?</p>



<a name="318676880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318676880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318676880">(Dec 31 2022 at 01:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/287929-mathlib4/topic/Modeq.20name/near/318676838">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/287929-mathlib4/topic/Modeq.20name/near/318669926">said</a>:</p>
<blockquote>
<p>What would you want the name of modeq to be in Lean 4? <code>Modeq</code> or <code>ModEq</code>? I think the latter makes more since</p>
<p>Furthermore I'm having a little issue with the definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Modeq</span> <span class="o">(</span><span class="n">n</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">a</span> <span class="bp">%</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">%</span> <span class="n">n</span> <span class="n">deriving</span> <span class="n">Decidable</span>
</code></pre></div>
<p>It cannot derive <code>Decidable</code> do we want to treat this as a bug and fix it upstream in the compiler or shall I write a manual instance?</p>
</blockquote>
<p>This definition is really crazy. Why on earth would anyone want to make this so complicated when the mathematical definition is so nice?</p>
</blockquote>
<p>As explained above I would say the exact same to your definition <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="318676894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318676894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318676894">(Dec 31 2022 at 01:35)</a>:</h4>
<p>Seriously, we can't take the remainder thing as the definition. The fact that this definition works for natural number is a completely meaningless accident.</p>



<a name="318676896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318676896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318676896">(Dec 31 2022 at 01:35)</a>:</h4>
<p>Also another question, is there a particular reason that <code>Nat.mod_zero</code> is not <code>@[simp]</code> anymore?</p>



<a name="318676960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318676960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318676960">(Dec 31 2022 at 01:36)</a>:</h4>
<p>Oh I'm seeing it's a built-in theorem so I probably better ask the person that wrote it.</p>



<a name="318676970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318676970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318676970">(Dec 31 2022 at 01:36)</a>:</h4>
<p>Henrik, who did that to you? We need a name. Who inflicted that definition on you?</p>



<a name="318676995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318676995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318676995">(Dec 31 2022 at 01:37)</a>:</h4>
<p>The reason the computer scientists like the definition is that they constantly think of things as subsets, they have a fear of quotients because of implementation issues. They are just choosing a fixed "representative" element in each equivalence class and defining a pathological function taking each element to the representative of the equivalence class. Mathematicians find these functions weird because they are not at all canonical, they don't have natural properties like f(a+b)=f(a)+f(b) and we'd rather use quotients than these ugly representatives.</p>



<a name="318677019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677019">(Dec 31 2022 at 01:37)</a>:</h4>
<p>I understand that fear, but it isn't relevant here. When defining the relation you don't need anything like a quotient.</p>



<a name="318677040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677040">(Dec 31 2022 at 01:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/287929-mathlib4/topic/Modeq.20name/near/318676970">said</a>:</p>
<blockquote>
<p>Henrik, who did that to you? We need a name. Who inflicted that definition on you?</p>
</blockquote>
<p>That would be Professor Eich-Soellner. This nice looking lady: <a href="/user_uploads/3121/7YIX7ScBAE91_9Yl7KR7aYGw/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/7YIX7ScBAE91_9Yl7KR7aYGw/image.png" title="image.png"><img src="/user_uploads/3121/7YIX7ScBAE91_9Yl7KR7aYGw/image.png"></a></div>



<a name="318677216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677216">(Dec 31 2022 at 01:40)</a>:</h4>
<p>A relation on a type can be defined by a function from the type (two things are related if their images are equal), and they choose to define the relation this way via a "non-canonical" map from nat to nat sending each element in the equivalence class to the representative. This makes the non-canonical map kind of embedded in the definition, making it much more difficult to work with.</p>



<a name="318677223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677223">(Dec 31 2022 at 01:40)</a>:</h4>
<p>Isn't <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span> (really) a quotient of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>×</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N} \times \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7722em;vertical-align:-0.0833em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>?</p>



<a name="318677227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677227">(Dec 31 2022 at 01:40)</a>:</h4>
<p>I do not dare asking whether she defines divisibility using the remainder operation.</p>



<a name="318677350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677350">(Dec 31 2022 at 01:42)</a>:</h4>
<p>My lecture notes say no!<br>
<a href="/user_uploads/3121/ku-hAv8Af3nUG_0qvC0XYEqO/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/ku-hAv8Af3nUG_0qvC0XYEqO/image.png" title="image.png"><img src="/user_uploads/3121/ku-hAv8Af3nUG_0qvC0XYEqO/image.png"></a></div>



<a name="318677381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677381">(Dec 31 2022 at 01:43)</a>:</h4>
<p>I've worked through the definition of <code>Int</code> as a quotient of <code>Nat \times Nat</code> in Lean 3 and there is a terrifying 8-variable Grobner basis roblem in ring theory you need to do when proving something about multiplication, and <code>nlinarith</code> does it. But if you look at the term it generates, it uses mathlib's inbuilt <code>Int</code> which is presumably still the non-canonical definition. If the CS guys are happy to write the API and battle through the non-canonical functions like <code>of_neg_of_nat</code> then surely they can have any implementation they want?</p>



<a name="318677452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677452">(Dec 31 2022 at 01:44)</a>:</h4>
<p>That's a relief.</p>



<a name="318677467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677467">(Dec 31 2022 at 01:45)</a>:</h4>
<p>At least you'll be able to bring that bit to other rings.</p>



<a name="318677498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677498">(Dec 31 2022 at 01:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/Modeq.20name/near/318677381">said</a>:</p>
<blockquote>
<p>I've worked through the definition of <code>Int</code> as a quotient of <code>Nat \times Nat</code> in Lean 3 and there is a terrifying 8-variable Grobner basis roblem in ring theory you need to do when proving something about multiplication, and <code>nlinarith</code> does it. But if you look at the term it generates, it uses mathlib's inbuilt <code>Int</code> which is presumably still the non-canonical definition. If the CS guys are happy to write the API and battle through the non-canonical functions like <code>of_neg_of_nat</code> then surely they can have any implementation they want?</p>
</blockquote>
<p>As a cs guy that does not know what a Grobner basis is I would like to avoid that if possible maybe :P</p>



<a name="318677579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677579">(Dec 31 2022 at 01:46)</a>:</h4>
<p>It was a problem of the form "a,b,c,d,e,f,g,h are nats, and a+b=c+d and e+f=g+h and <code>a*b+c*d+</code>blah blah blah = <code>c * f + d * e +</code> ..., and other polynomial identities are also true, and the goal is some other random equality of polynomials"</p>



<a name="318677825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677825">(Dec 31 2022 at 01:50)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> One of the issues with using a remainder-after-division to define modulo-equality is that you need to choose which remainder to use for normalization. For nat/int this is relatively clear what to use, but modulo congruence still is meaningful for other rings where you don't have a good way to normalize your div/mod.</p>
<p>Even in CS there are confusions about div/mod, since there are two main conventions: is division from rounding toward zero or toward negative infinity? The Lean <code>%</code> operator uses the second convention, but C uses the first. Haskell has functions for both.</p>



<a name="318677908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677908">(Dec 31 2022 at 01:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/287929-mathlib4/topic/Modeq.20name/near/318677825">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> One of the issues with using a remainder-after-division to define modulo-equality is that you need to choose which remainder to use for normalization. For nat/int this is relatively clear what to use, but modulo congruence still is meaningful for other rings where you don't have a good way to normalize your div/mod.</p>
<p>Even in CS there are confusions about div/mod, since there are two main conventions: is division from rounding toward zero or toward negative infinity? The Lean <code>%</code> operator uses the second convention, but C uses the first. Haskell has functions for both.</p>
</blockquote>
<p>My math classes trivially solve this issue by not telling us that a ring is a thing even :(</p>



<a name="318677980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677980">(Dec 31 2022 at 01:52)</a>:</h4>
<p>It would be great if eventually the modeq for <code>Int</code> was just <code>n ∣ (a - b)</code> (that's practically better two -- just one division rather than two to implement!)</p>
<p>When I've thought about this before (and I think this is what Heather is referring to), for <code>Nat</code> you can't get much better than <code>a % n = b % n</code> since we have truncating subtraction. You could do <code>n ∣ (max a b - min a b)</code> at least...</p>



<a name="318677987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318677987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318677987">(Dec 31 2022 at 01:52)</a>:</h4>
<p>natural and integer division are also pathological functions (they don't satisfy nice theorems because of rounding errors) and the identity is not a pathological function, and neither is multplication, therefore the remainder function must also be pathological because a=(a/b)*b+a%b</p>



<a name="318678021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318678021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318678021">(Dec 31 2022 at 01:53)</a>:</h4>
<p>They're implementation issues and shouldn't be exposed ;-)</p>



<a name="318678026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318678026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318678026">(Dec 31 2022 at 01:53)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> That doesn't solve the issue since you still have to choose your division rounding convention for normalization <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>
<p>At least they all satisfy <code>a = div a b * b + mod a b</code> for whatever choices of <code>div</code> and <code>mod</code>. (Given the <code>div</code>, you define <code>mod</code> this way)</p>



<a name="318678098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318678098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318678098">(Dec 31 2022 at 01:54)</a>:</h4>
<p>I can't remember ever choosing a rounding convention even, we kinda just...went with it?</p>



<a name="318678118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318678118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318678118">(Dec 31 2022 at 01:54)</a>:</h4>
<p>The definition should be <code>(n : \Z) | a - b</code> ;-)</p>



<a name="318678139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318678139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318678139">(Dec 31 2022 at 01:55)</a>:</h4>
<p>When you assert that <code>0 &lt;= mod a b &lt; abs b</code> you've said you're rounding to negative infinity since that means <code>a &gt;= div a b * b</code></p>



<a name="318678201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318678201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318678201">(Dec 31 2022 at 01:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/287929-mathlib4/topic/Modeq.20name/near/318678098">said</a>:</p>
<blockquote>
<p>I can't remember ever choosing a rounding convention even, we kinda just...went with it?</p>
</blockquote>
<p>Henrik do you know about the issue where a random change in convention for integer division from Lean 3 to Lean 4 caused problems for mathlib4?</p>



<a name="318678269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318678269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318678269">(Dec 31 2022 at 01:57)</a>:</h4>
<p>Yes I did see the chats about it.</p>



<a name="318678273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318678273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318678273">(Dec 31 2022 at 01:57)</a>:</h4>
<p>So, do you suggest that we define <code>int.modeq</code> first, then define <code>nat.modeq</code> using <code>int.modeq</code>?</p>



<a name="318678345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318678345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318678345">(Dec 31 2022 at 01:58)</a>:</h4>
<p>I'm not denying all of this is an issue or saying that you are wrong with your ideas of how to do things don't get me wrong^^ I'm just explaining the way I was taught. I'm very much aware that most of the mathematics I'm being taught in the style they are by my university is far far away from anything close to the rigor you would expect.</p>



<a name="318678380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318678380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318678380">(Dec 31 2022 at 01:59)</a>:</h4>
<p>Which is part of the reason I'm doing mathlib porting work in the first place to be honest.</p>



<a name="318678622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318678622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318678622">(Dec 31 2022 at 02:02)</a>:</h4>
<p>To be honest I have only recently started paying attention to the way logic and mathematics are taught to computer scientists, and I was really surprised by some of the things I saw.</p>



<a name="318679116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318679116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318679116">(Dec 31 2022 at 02:10)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> I first learned about the modulo operator in QBasic and then used that intuition when learning about modulo congruence, which gave me the same sort of operational understanding, where <code>int.modeq n a b</code> is something you evaluate by modulo reducing <code>a</code> and <code>b</code> then checking equality. It took awhile before I really got that in math it's fine having relations that don't need to have computational content, which moving toward <code>n ∣ (a - b)</code> (or "there exists a <code>k</code> such that <code>a = b + k * n</code>") helped me with.</p>



<a name="318679240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318679240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318679240">(Dec 31 2022 at 02:12)</a>:</h4>
<p>The latter point of view also makes it more obvious that the "point" of congruence is that it's that you're wanting to work with numbers ignoring differences by multiples of the modulus, which the operational point of view obscures.</p>



<a name="318679257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318679257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318679257">(Dec 31 2022 at 02:13)</a>:</h4>
<p>Oh I'm perfectly content with these types of definitions. I can actually remember kind of intuitively using the 2nd one a couple of times while writing proofs.</p>



<a name="318679277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318679277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318679277">(Dec 31 2022 at 02:14)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Your idea about defining <code>nat.modeq</code> in terms of <code>int.modeq</code> made me wonder if we need <code>nat.modeq</code> at all. I can't immediately think of a reason for it that can't be served by just writing <code>Nat</code>-specialized lemmas for <code>int.modeq</code>.</p>



<a name="318679570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318679570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318679570">(Dec 31 2022 at 02:18)</a>:</h4>
<p>Ha ha yeah that would be an interesting refactor! That's kind of weird that the way which seems to me to be more natural involves doing int before nat. It wouldn't surprise me if it ended up cleaner, a non-pathological subtraction makes proofs much easier.</p>



<a name="318680285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318680285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318680285">(Dec 31 2022 at 02:31)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib4/pull/1274">https://github.com/leanprover-community/mathlib4/pull/1274</a></p>



<a name="318692732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318692732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318692732">(Dec 31 2022 at 06:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/Modeq.20name/near/318679570">said</a>:</p>
<blockquote>
<p>Ha ha yeah that would be an interesting refactor! That's kind of weird that the way which seems to me to be more natural involves doing int before nat. It wouldn't surprise me if it ended up cleaner, a non-pathological subtraction makes proofs much easier.</p>
</blockquote>
<p>Especially if we reuse general theory about, e.g., <a href="https://leanprover-community.github.io/mathlib_docs/find/con">docs#con</a>.</p>



<a name="318694276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318694276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318694276">(Dec 31 2022 at 06:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/Modeq.20name/near/318678201">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/287929-mathlib4/topic/Modeq.20name/near/318678098">said</a>:</p>
<blockquote>
<p>I can't remember ever choosing a rounding convention even, we kinda just...went with it?</p>
</blockquote>
<p>Henrik do you know about the issue where a random change in convention for integer division from Lean 3 to Lean 4 caused problems for mathlib4?</p>
</blockquote>
<p>In fact, if the <code>%</code> definition is used for <code>int.modeq</code> with the Lean 4 core definition of <code>%</code>, then the definition is simply wrong (positive and negative numbers won't be <code>modeq</code> modulo anything).</p>



<a name="318694345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318694345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318694345">(Dec 31 2022 at 06:36)</a>:</h4>
<p>Oh unless they happen to be divisible by the modulus.</p>



<a name="318694628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318694628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318694628">(Dec 31 2022 at 06:41)</a>:</h4>
<p>So, <code>a % n</code> is incompatible between Lean 3 and Lean 4?</p>



<a name="318694677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318694677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318694677">(Dec 31 2022 at 06:42)</a>:</h4>
<p>(for integer <code>a n</code>)</p>



<a name="318694701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318694701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318694701">(Dec 31 2022 at 06:42)</a>:</h4>
<p>Yes but mathlib4 fixes this by overriding the appropriate instance (and the hope is to merge the change into Lean 4 eventually).</p>



<a name="318699232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318699232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318699232">(Dec 31 2022 at 08:01)</a>:</h4>
<p>I would be happy with a refactor wiping <code>nat.modeq</code> out of existence in favor of <code>int.modeq</code>, but isn't there a more general <code>ideal.modeq</code> to be had?</p>



<a name="318699328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318699328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318699328">(Dec 31 2022 at 08:02)</a>:</h4>
<p>Or are we deciding to draw the line between theory building and simplicity of definition there?</p>



<a name="318700172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318700172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318700172">(Dec 31 2022 at 08:14)</a>:</h4>
<p>We don't have <code>subgroup.modeq</code>...</p>



<a name="318704247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318704247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318704247">(Dec 31 2022 at 09:03)</a>:</h4>
<p>For the record, defining <code>int.modeq</code> in terms of subgroups is far worse for teaching than defining it in terms of <code>%</code> ...</p>



<a name="318704296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318704296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318704296">(Dec 31 2022 at 09:03)</a>:</h4>
<p>Sub<em>groups</em>? you probably won't be so lucky...</p>



<a name="318712752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318712752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318712752">(Dec 31 2022 at 10:31)</a>:</h4>
<p>I want to define it in terms of divisibility and I've taught it like that and it worked out great.</p>



<a name="318749194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318749194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318749194">(Dec 31 2022 at 14:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/287929-mathlib4/topic/Modeq.20name/near/318694701">said</a>:</p>
<blockquote>
<p>(and the hope is to merge the change into Lean 4 eventually).</p>
</blockquote>
<p>I hope so! I didn't realize Lean 4 switched from the "Python convention" to the "C convention." The Python convention is (in just my opinion) the correct one, in that it always gives a modulus in the range <code>0, 1, ..., n-1</code> when <code>n</code> is positive, so you can for example write <code>a[i % len(a)]</code> no matter what the integer <code>i</code> is.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="o">(</span><span class="bp">-</span><span class="mi">5</span><span class="o">)</span> <span class="bp">%</span> <span class="mi">3</span>
<span class="c1">-- -2</span>
</code></pre></div>
<p>Of course this also means that division is rounding toward zero rather than negative infinity:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="o">(</span><span class="bp">-</span><span class="mi">5</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">3</span>
<span class="c1">--- -1</span>
</code></pre></div>
<p>I believe we should have both div/mod conventions in some capacity. It's just a question of what convention the operators <code>/</code> and <code>%</code> use.</p>



<a name="318750160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318750160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318750160">(Dec 31 2022 at 15:03)</a>:</h4>
<p>As a case study, Haskell chose to have two pairs of functions for integers: <code>div</code>/<code>mod</code> for the "Python convention", and <code>quot</code>/<code>rem</code> for the "C convention." It doesn't supply operators for these, but Haskell also has a feature for using two-argument functions as binary operators, for example <code>5 `div` 3</code> for <code>div 5 3</code>.</p>



<a name="318752276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Modeq%20name/near/318752276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Modeq.20name.html#318752276">(Dec 31 2022 at 15:21)</a>:</h4>
<p><a href="#narrow/stream/341532-lean4-dev/topic/.5BRFC.5D.20Int.2Ediv.20convention/near/296956937">https://leanprover.zulipchat.com/#narrow/stream/341532-lean4-dev/topic/.5BRFC.5D.20Int.2Ediv.20convention/near/296956937</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
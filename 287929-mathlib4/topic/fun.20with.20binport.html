---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/fun.20with.20binport.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html">fun with binport</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="248283176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248283176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248283176">(Aug 03 2021 at 21:24)</a>:</h4>
<p>This compiles in Lean4, importing binported oleans:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.RingTheory.Nullstellensatz</span>

<span class="kn">namespace</span> <span class="n">MvPolynomial.Playground</span>
<span class="kn">open</span> <span class="n">Ideal</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">instField</span> <span class="o">:</span> <span class="n">Field</span> <span class="n">k</span><span class="o">]</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
<span class="kd">variable</span> <span class="o">[</span><span class="n">instIAC</span> <span class="o">:</span> <span class="n">IsAlgClosed</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">instF</span> <span class="o">:</span> <span class="n">Fintype</span> <span class="n">σ</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">vanishing_ideal_zero_locus_eq_radical</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">Ideal</span> <span class="o">(</span><span class="n">MvPolynomial</span> <span class="n">σ</span> <span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="n">vanishingIdeal</span> <span class="o">(</span><span class="n">ZeroLocus</span> <span class="n">I</span><span class="o">)</span> <span class="bp">=</span> <span class="n">I.radical</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">I.radical_eq_jacobson</span><span class="o">]</span>
  <span class="n">refine</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">le_Inf</span> <span class="bp">?</span><span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">@λ</span> <span class="n">p</span> <span class="n">hp</span> <span class="n">x</span> <span class="n">hx</span> <span class="bp">=&gt;</span> <span class="bp">?</span><span class="n">y</span><span class="o">)</span>
  <span class="n">case</span> <span class="n">x</span> <span class="bp">=&gt;</span>
    <span class="n">intro</span> <span class="n">J</span> <span class="o">⟨</span><span class="n">hJI</span><span class="o">,</span> <span class="n">hJ</span><span class="o">⟩</span>
    <span class="k">let</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">is_maximal_iff_eq_vanishing_ideal_singleton</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hJ</span>
    <span class="n">refine</span> <span class="n">hx.symm</span> <span class="bp">▸</span> <span class="n">vanishing_ideal_anti_mono</span> <span class="o">(</span><span class="bp">@λ</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">p</span> <span class="n">hp</span> <span class="bp">=&gt;</span> <span class="bp">?</span><span class="n">z</span><span class="o">)</span>
    <span class="n">case</span> <span class="n">z</span> <span class="bp">=&gt;</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">mem_vanishing_ideal_singleton_iff</span><span class="o">,</span> <span class="n">Set.mem_singleton_iff.1</span> <span class="n">hy</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hx</span><span class="o">]</span>
      <span class="n">refine</span> <span class="n">hJI</span> <span class="n">hp</span>
  <span class="n">case</span> <span class="n">y</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">mem_vanishing_ideal_singleton_iff</span> <span class="n">x</span> <span class="n">p</span><span class="o">]</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">mem_Inf.mp</span> <span class="n">hp</span><span class="o">)</span> <span class="o">⟨</span><span class="bp">@</span><span class="n">le_trans</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">le_vanishing_ideal_zero_locus</span> <span class="o">(</span><span class="n">I</span> <span class="o">:=</span> <span class="n">I</span><span class="o">))</span>
      <span class="o">(</span><span class="n">vanishing_ideal_anti_mono</span> <span class="o">(</span><span class="bp">@λ</span> <span class="n">y</span> <span class="n">hy</span> <span class="bp">=&gt;</span> <span class="n">hy.symm</span> <span class="bp">▸</span> <span class="n">hx</span><span class="o">)),</span>
        <span class="n">MvPolynomial.vanishing_ideal_singleton_is_maximal</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="n">MvPolynomial.Playground</span>
</code></pre></div>
<p>It is very close to what synport would produce automatically.</p>



<a name="248287211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248287211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248287211">(Aug 03 2021 at 22:06)</a>:</h4>
<p>Just curious, what would synport product automatically?</p>



<a name="248287715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248287715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248287715">(Aug 03 2021 at 22:12)</a>:</h4>
<p>For comparison, <a href="https://github.com/leanprover-community/mathlib/blob/85025718208922ba937e5ec6352f04c7c90ae931/src/ring_theory/nullstellensatz.lean#L155-L170">here</a> is the Lean 3 code.</p>



<a name="248288228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248288228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248288228">(Aug 03 2021 at 22:20)</a>:</h4>
<p>oof, it tripped on the <code>rintros</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- error: Mathport/Syntax/Translate/Basic.lean:221:16: unsupported tactic `rintros</span>
<span class="sd">/-- Main statement of the Nullstellensatz -/</span>
<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">vanishing_ideal_zero_locus_eq_radical</span>
<span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="bp">«</span><span class="n">expr</span> <span class="bp">=</span> <span class="bp">»</span><span class="o">(</span><span class="n">vanishing_ideal</span> <span class="o">(</span><span class="n">zero_locus</span> <span class="n">I</span><span class="o">),</span> <span class="n">I.radical</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">I.radical_eq_jacobson</span><span class="o">]</span> <span class="o">[],</span>
  <span class="n">refine</span> <span class="o">[</span><span class="n">le_antisymm</span> <span class="o">(</span><span class="n">le_Inf</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">hp</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">_</span><span class="o">)],</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">[</span><span class="n">J</span><span class="o">,</span> <span class="s2">"⟨"</span><span class="o">,</span> <span class="n">hJI</span><span class="o">,</span> <span class="s2">","</span><span class="o">,</span> <span class="n">hJ</span><span class="o">,</span> <span class="s2">"⟩"</span><span class="o">],</span>
    <span class="n">obtain</span> <span class="o">[</span><span class="s2">"⟨"</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="s2">","</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="s2">"⟩"</span><span class="o">,</span> <span class="s2">":="</span><span class="o">,</span> <span class="o">(</span><span class="n">is_maximal_iff_eq_vanishing_ideal_singleton</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hJ</span><span class="o">],</span>
    <span class="n">refine</span> <span class="o">[</span><span class="bp">«</span><span class="n">expr</span> <span class="bp">▸</span> <span class="bp">»</span><span class="o">(</span><span class="n">hx.symm</span><span class="o">,</span> <span class="n">vanishing_ideal_anti_mono</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">p</span> <span class="n">hp</span><span class="o">,</span> <span class="n">_</span><span class="o">))],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="s2">"["</span><span class="o">,</span> <span class="s2">"&lt;-"</span><span class="o">,</span> <span class="n">mem_vanishing_ideal_singleton_iff</span><span class="o">,</span> <span class="s2">","</span><span class="o">,</span> <span class="n">set.mem_singleton_iff.1</span> <span class="n">hy</span><span class="o">,</span> <span class="s2">","</span><span class="o">,</span> <span class="s2">"&lt;-"</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="s2">"]"</span><span class="o">]</span> <span class="o">[],</span>
    <span class="n">refine</span> <span class="o">[</span><span class="n">hJI</span> <span class="n">hp</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="s2">"&lt;-"</span><span class="o">,</span> <span class="n">mem_vanishing_ideal_singleton_iff</span> <span class="n">x</span> <span class="n">p</span><span class="o">]</span> <span class="o">[],</span>
    <span class="n">refine</span> <span class="o">[</span><span class="n">mem_Inf.mp</span> <span class="n">hp</span> <span class="o">⟨</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">le_vanishing_ideal_zero_locus</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">vanishing_ideal_anti_mono</span> <span class="o">(</span><span class="bp">λ</span>
        <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="bp">«</span><span class="n">expr</span> <span class="bp">▸</span> <span class="bp">»</span><span class="o">(</span><span class="n">hy.symm</span><span class="o">,</span> <span class="n">hx</span><span class="o">))),</span> <span class="n">mv_polynomial.vanishing_ideal_singleton_is_maximal</span><span class="o">⟩]</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>might be a while before we have full coverage on these proofs</p>



<a name="248288275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248288275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248288275">(Aug 03 2021 at 22:21)</a>:</h4>
<p>what you see there is the reconstructed lean 3 syntax, which is what it prints on a fatal error</p>



<a name="248302987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248302987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248302987">(Aug 04 2021 at 01:53)</a>:</h4>
<p>After adding the <code>rcases</code>/<code>rintros</code>/<code>obtain</code> parsers, synport makes it through this proof. Here's what it looks like without editing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Main statement of the Nullstellensatz -/</span>
<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">vanishing_ideal_zero_locus_eq_radical</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">k</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">«</span><span class="n">expr</span> <span class="bp">=</span> <span class="bp">»</span> <span class="o">(</span><span class="n">vanishing_ideal</span> <span class="o">(</span><span class="n">zero_locus</span> <span class="n">I</span><span class="o">))</span> <span class="n">I.radical</span> <span class="o">:=</span>
  <span class="kd">by</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">I.radical_eq_jacobson</span><span class="o">]</span>
    <span class="n">refine'</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">le_Inf</span> <span class="n">_</span><span class="o">)</span> <span class="k">fun</span> <span class="n">p</span> <span class="n">hp</span> <span class="n">x</span> <span class="n">hx</span> <span class="bp">=&gt;</span> <span class="n">_</span>
    <span class="bp">·</span>
      <span class="n">rintro</span> <span class="n">J</span> <span class="o">⟨</span><span class="n">hJI</span><span class="o">,</span> <span class="n">hJ</span><span class="o">⟩</span>
      <span class="n">obtain</span><span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">is_maximal_iff_eq_vanishing_ideal_singleton</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hJ</span>
      <span class="n">refine'</span> <span class="bp">«</span><span class="n">expr</span> <span class="bp">▸</span> <span class="bp">»</span> <span class="n">hx.symm</span> <span class="o">(</span><span class="n">vanishing_ideal_anti_mono</span> <span class="k">fun</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">p</span> <span class="n">hp</span> <span class="bp">=&gt;</span> <span class="n">_</span><span class="o">)</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">mem_vanishing_ideal_singleton_iff</span><span class="o">,</span> <span class="n">set.mem_singleton_iff.1</span> <span class="n">hy</span><span class="o">,</span> <span class="bp">←</span><span class="n">hx</span><span class="o">]</span>
      <span class="n">refine'</span> <span class="n">hJI</span> <span class="n">hp</span>
    <span class="bp">·</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">mem_vanishing_ideal_singleton_iff</span> <span class="n">x</span> <span class="n">p</span><span class="o">]</span>
      <span class="n">refine'</span>
        <span class="n">mem_Inf.mp</span> <span class="n">hp</span>
          <span class="o">⟨</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">le_vanishing_ideal_zero_locus</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">vanishing_ideal_anti_mono</span> <span class="k">fun</span> <span class="n">y</span> <span class="n">hy</span> <span class="bp">=&gt;</span> <span class="bp">«</span><span class="n">expr</span> <span class="bp">▸</span> <span class="bp">»</span> <span class="n">hy.symm</span> <span class="n">hx</span><span class="o">),</span>
            <span class="n">mv_polynomial.vanishing_ideal_singleton_is_maximal</span><span class="o">⟩</span>
</code></pre></div>



<a name="248303078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248303078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248303078">(Aug 04 2021 at 01:54)</a>:</h4>
<p>actually the <code>«expr = » </code> in the statement is because I'm too lazy to run this on all previous files to build up the set of notations. Daniel's been running the full builds, which should resolve those so that it appears like normal</p>



<a name="248308086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248308086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248308086">(Aug 04 2021 at 03:46)</a>:</h4>
<p>Could somebody please recommend a few Mathlib theorems for me to play with using binport that will stress-test either typeclass resolution or the simplifier?</p>



<a name="248309430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248309430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248309430">(Aug 04 2021 at 04:20)</a>:</h4>
<p>The old way of proving the formula for a 2x2 det:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.matrix.notation</span>
<span class="kn">import</span> <span class="n">linear_algebra.determinant</span>
<span class="kn">import</span> <span class="n">group_theory.perm.fin</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">matrix.det</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">]]</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- TODO: can we make this require less steering?</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">matrix.det_apply'</span><span class="o">,</span> <span class="n">finset.univ_perm_fin_succ</span><span class="o">,</span> <span class="bp">←</span><span class="n">finset.univ_product_univ</span><span class="o">,</span> <span class="n">finset.sum_product</span><span class="o">,</span>
        <span class="n">fin.sum_univ_succ</span><span class="o">,</span> <span class="n">fin.prod_univ_succ</span><span class="o">],</span>
  <span class="n">ring</span>
<span class="kd">end</span>
</code></pre></div>
<p>and the new way for a 3x3:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span> <span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
        <span class="n">matrix.det</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">f</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="n">g</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">i</span><span class="o">]]</span> <span class="bp">=</span>
          <span class="n">a</span> <span class="bp">*</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">-</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">f</span> <span class="bp">*</span> <span class="n">h</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">f</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">h</span> <span class="bp">-</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">matrix.det_succ_row_zero</span><span class="o">,</span> <span class="n">fin.sum_univ_succ</span><span class="o">],</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  Try this: simp only [det_succ_row_zero, fin.sum_univ_succ, neg_mul_eq_neg_mul_symm, cons_append,</span>
<span class="cm">  mul_one, fin.default_eq_zero, fin.coe_zero, cons_vec_bit0_eq_alt0, one_mul, cons_val_one,</span>
<span class="cm">  cons_vec_alt0, fin.succ_succ_above_one, fin.coe_succ, univ_unique, minor_apply, pow_one,</span>
<span class="cm">  fin.zero_succ_above, fin.succ_zero_eq_one, fin.succ_succ_above_zero, nat.neg_one_sq,</span>
<span class="cm">  finset.sum_singleton, cons_val_zero, cons_val_succ, det_fin_zero, head_cons, pow_zero]</span>
<span class="cm">   -/</span>
  <span class="n">ring</span>
<span class="kd">end</span>
</code></pre></div>



<a name="248309496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248309496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248309496">(Aug 04 2021 at 04:22)</a>:</h4>
<p>For type-class inference maybe  <a href="https://leanprover-community.github.io/mathlib_docs/find/units.is_scalar_tower'">docs#units.is_scalar_tower'</a> (at least there are a lot of type-class assumptions)<br>
For simp, I mostly think of the manifold and category theory library. Maybe <a href="https://leanprover-community.github.io/mathlib_docs/find/structure_groupoid.compatible_of_mem_maximal_atlas">docs#structure_groupoid.compatible_of_mem_maximal_atlas</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_inverse_obj">docs#Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_inverse_obj</a>.<br>
Others might have better suggestions.</p>



<a name="248309612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248309612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248309612">(Aug 04 2021 at 04:26)</a>:</h4>
<p>There are several heavy simps in <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.simple_func.exists_le_lower_semicontinuous_lintegral_ge">docs#measure_theory.simple_func.exists_le_lower_semicontinuous_lintegral_ge</a>, for example</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">hs</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">lt_top_iff_ne_top</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">simple_func.coe_const</span><span class="o">,</span> <span class="n">function.const_apply</span><span class="o">,</span>
  <span class="n">lintegral_const</span><span class="o">,</span> <span class="n">ennreal.coe_indicator</span><span class="o">,</span> <span class="n">set.univ_inter</span><span class="o">,</span> <span class="n">ennreal.coe_ne_top</span><span class="o">,</span>
  <span class="n">measurable_set.univ</span><span class="o">,</span> <span class="n">with_top.mul_eq_top_iff</span><span class="o">,</span> <span class="n">simple_func.const_zero</span><span class="o">,</span> <span class="n">or_false</span><span class="o">,</span>
  <span class="n">lintegral_indicator</span><span class="o">,</span> <span class="n">ennreal.coe_eq_zero</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">simple_func.coe_zero</span><span class="o">,</span>
  <span class="n">set.piecewise_eq_indicator</span><span class="o">,</span> <span class="n">simple_func.coe_piecewise</span><span class="o">,</span> <span class="n">false_and</span><span class="o">,</span> <span class="n">restrict_apply</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span>
</code></pre></div>



<a name="248317264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248317264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248317264">(Aug 04 2021 at 07:08)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/exists_extension_norm_eq">docs#exists_extension_norm_eq</a> has hit typeclass timeouts for me in multiple attempted refactors</p>



<a name="248420238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248420238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248420238">(Aug 04 2021 at 23:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/fun.20with.20binport/near/248317264">said</a>:</p>
<blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/exists_extension_norm_eq">docs#exists_extension_norm_eq</a> has hit typeclass timeouts for me in multiple attempted refactors</p>
</blockquote>
<p>This is perfect, thank you. Just trying to elaborate the type exposed another issue :)</p>



<a name="248420337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248420337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248420337">(Aug 04 2021 at 23:08)</a>:</h4>
<p>If you want more timeouts, I have plenty of stale refactor branches that I could update to match master to get fresh timeouts on</p>



<a name="248420638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248420638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248420638">(Aug 04 2021 at 23:12)</a>:</h4>
<p>Timeouts are a luxury I rarely have yet -- there are still a lot of relatively fast elaboration errors. There are many complicated dynamics that only emerge deep in mathlib, and so we are just hitting them for the first time in lean4.</p>



<a name="248447547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248447547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248447547">(Aug 05 2021 at 07:46)</a>:</h4>
<p>If you want to try out a weird behavior, you can have a look at <code>measure_theory/arithmetic.lean</code>, especially the proof of the lemma <code>has_measurable_gpow</code> where Lean 3 does something crazy (there is probably a bug lurking somewhere): replacing the last line of the proof of this lemma <code>exact has_measurable_gpow_aux G</code> with the proof of the auxiliary lemma <code>has_measurable_gpow_aux</code> fails badly, for no reason I can understand. If Lean 4 could behave more properly on this one, this would be pretty nice!</p>



<a name="248599487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/248599487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#248599487">(Aug 06 2021 at 11:35)</a>:</h4>
<p>Some other weird typeclass behavior is in <a href="https://github.com/leanprover-community/mathlib/issues/8547">#8547</a>. Does lean4 require this instance that PR adds in order to remove the <code>@</code>s in the other part of the PR?</p>



<a name="249642080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/249642080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#249642080">(Aug 16 2021 at 20:20)</a>:</h4>
<p>Good news: I added lean-liquid to the mathport pipeline and it worked fine. I will include liquid in the uploads from now on (<a href="https://github.com/dselsam/mathport/releases/tag/v0.0.0.0">https://github.com/dselsam/mathport/releases/tag/v0.0.0.0</a>). There is still a long way to go before the binaries can be used effectively, but at least the proof-term porting seems very robust now.</p>



<a name="249658015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/249658015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#249658015">(Aug 16 2021 at 22:44)</a>:</h4>
<p>I had only recently internalised that porting large-ish projects which depended on mathlib like this one was on your radar. This is really good news!</p>



<a name="249658693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/249658693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#249658693">(Aug 16 2021 at 22:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/fun.20with.20binport/near/249658015">said</a>:</p>
<blockquote>
<p>I had only recently internalised that porting large-ish projects which depended on mathlib like this one was on your radar. This is really good news!</p>
</blockquote>
<p>Yes, there is no obstacle to applying <code>mathport</code> to any lean3 project that depends on an up-to-date mathlib. Mathport takes a list of modules to port, e.g. <code> ./mathport config.json Lean3::all Mathlib::all Liquid::all</code>.</p>



<a name="249665148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/249665148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#249665148">(Aug 17 2021 at 00:26)</a>:</h4>
<p>No library left behind!</p>



<a name="249665183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/249665183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#249665183">(Aug 17 2021 at 00:27)</a>:</h4>
<p>The alternative take on this is that it increases moral hazard, encouraging people to do maths outside of mathlib. :-)</p>



<a name="251466613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/251466613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#251466613">(Aug 31 2021 at 21:55)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> If you are interested in another gruesome type-class problem, here is one that takes 8.6 to fail on yesterday's mathlib (it is supposed to fail):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">--after running scripts/mk_all.sh</span>
<span class="kn">import</span> <span class="n">all</span> <span class="c1">-- import all files of mathlib</span>

<span class="kn">open</span> <span class="n">topological_space</span> <span class="n">measure_theory</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">m0</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">}</span> <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">[</span><span class="n">measurable_space</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">borel_space</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">second_countable_topology</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">hp</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">≤</span> <span class="n">p</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">complete_space</span> <span class="o">(</span><span class="n">measure_theory.Lp</span> <span class="n">E</span> <span class="n">p</span> <span class="n">μ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>
<p>I tried to port this to the binported mathlib you posted a while back.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.All</span>

<span class="kn">open</span> <span class="n">MeasureTheory</span> <span class="n">TopologicalSpace</span>

<span class="c1">-- this should succeed</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">m0</span> <span class="o">:</span> <span class="n">MeasurableSpace</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">Ennreal</span><span class="o">}</span> <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">Measure</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">[</span><span class="n">MeasurableSpace</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">NormedGroup</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">BorelSpace</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">SecondCountableTopology</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">hp</span> <span class="o">:</span> <span class="n">Fact</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">≤</span> <span class="n">p</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">UniformSpace</span> <span class="o">(</span><span class="n">lp</span> <span class="n">E</span> <span class="n">p</span> <span class="n">μ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">inferInstance</span>

<span class="c1">-- this should fail</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">m0</span> <span class="o">:</span> <span class="n">MeasurableSpace</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">Ennreal</span><span class="o">}</span> <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">Measure</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">[</span><span class="n">MeasurableSpace</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">NormedGroup</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">BorelSpace</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">SecondCountableTopology</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">hp</span> <span class="o">:</span> <span class="n">Fact</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">≤</span> <span class="n">p</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">CompleteSpace</span> <span class="o">(</span><span class="n">lp</span> <span class="n">E</span> <span class="n">p</span> <span class="n">μ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">inferInstance</span>
</code></pre></div>
<p>However, I'm getting some type-class problems, that are caused by the redefinition of <a href="https://leanprover-community.github.io/mathlib_docs/find/coe_trans">docs#coe_trans</a>, which makes instances like <a href="https://leanprover-community.github.io/mathlib_docs/find/add_units.has_coe">docs#add_units.has_coe</a> looping. Can I disable instances locally (the equivalent of Lean 3's <code>local attribute [-instance]</code>)?</p>



<a name="251471253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/251471253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#251471253">(Aug 31 2021 at 22:34)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> Thanks for looking into this stuff. I just pushed support for temporarily disabling instances. Here is an example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foo</span> <span class="n">where</span>
  <span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span>

<span class="kd">instance</span> <span class="n">fooAdd</span> <span class="o">:</span> <span class="n">Add</span> <span class="n">Foo</span> <span class="n">where</span>
  <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x.a</span> <span class="bp">+</span> <span class="n">y.a</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">f1</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Foo</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="c1">-- Works</span>

<span class="kn">section</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="kd">instance</span><span class="o">]</span> <span class="n">fooAdd</span>

<span class="kd">def</span> <span class="n">f2</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Foo</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="c1">-- Error</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">f3</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Foo</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="c1">-- Works</span>
</code></pre></div>



<a name="251471493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/fun%20with%20binport/near/251471493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/fun.20with.20binport.html#251471493">(Aug 31 2021 at 22:37)</a>:</h4>
<p>Thanks!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
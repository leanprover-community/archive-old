---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Type.20synonyms.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html">Type synonyms</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="314912552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314912552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314912552">(Dec 09 2022 at 14:56)</a>:</h4>
<p>In <a href="https://github.com/leanprover-community/mathlib4/pull/903">mathlib4#903</a>, a whole bunch of proofs involving type synonyms (<code>Additive</code>, <code>Multiplicative</code>, <code>OrderDual</code>) are just completely broken.  I've fixed them with a bunch of @, but it seems like this really should be debugged; we'll hit it again.  Does anyone have time to look at this?</p>
<p><a href="https://github.com/leanprover-community/mathlib4/pull/903/commits/ad2c22008b3bf1bcfae0ea9962ac4bd775891dec">Here</a>'s the commit adding a bunch of @, so look at the branch in its state before this.</p>



<a name="314913642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314913642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314913642">(Dec 09 2022 at 15:01)</a>:</h4>
<p>Is this the same as <a href="#narrow/stream/270676-lean4/topic/What.20type.20annotation.20can.20do/near/314660799">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What.20type.20annotation.20can.20do/near/314660799</a> ?</p>



<a name="314914051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314914051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314914051">(Dec 09 2022 at 15:03)</a>:</h4>
<p>I think probably not, but it's possible.</p>



<a name="314914100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314914100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314914100">(Dec 09 2022 at 15:03)</a>:</h4>
<p>There were no type synonyms in that one.</p>



<a name="314914441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314914441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314914441">(Dec 09 2022 at 15:04)</a>:</h4>
<p>Interestingly, in the issue here, all the cases are actually a type synonym of a type synonym!   Like <code>Multiplicative αᵒᵈ</code>.</p>



<a name="314915009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314915009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314915009">(Dec 09 2022 at 15:07)</a>:</h4>
<p><code>zero := Multiplicative.ofAdd (⊤ : α)</code> should probably be <code>zero := Multiplicative.ofAdd $ toDual (⊤ : α)</code></p>



<a name="314915040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314915040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314915040">(Dec 09 2022 at 15:07)</a>:</h4>
<p>But maybe <code>toDual</code> is not imported yet there</p>



<a name="314915115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314915115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314915115">(Dec 09 2022 at 15:08)</a>:</h4>
<p>If it's not, make it be. It's part of the basic API.</p>



<a name="314915213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314915213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314915213">(Dec 09 2022 at 15:08)</a>:</h4>
<p>Sure, but it might be too late if half the order stuff is already ported to mathlib4</p>



<a name="314915395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314915395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314915395">(Dec 09 2022 at 15:09)</a>:</h4>
<p>To check, you're saying that Lean 3 was cleverer, and you could sometimes omit the boilerplate <code>toDual</code>/<code>ofDual</code>; Lean 4 requires this all be there explicitly?</p>



<a name="314915526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314915526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314915526">(Dec 09 2022 at 15:09)</a>:</h4>
<p>I'm saying that the code you're porting is somewhat sloppy, and it's possible that writing it in a less sloppy way would be less confusing to Lean 4. It's also entirely possible that my suggestion makes no difference</p>



<a name="314915701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314915701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314915701">(Dec 09 2022 at 15:10)</a>:</h4>
<p>I think the <code>@</code>s there are probably  ok.</p>



<a name="314915745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314915745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314915745">(Dec 09 2022 at 15:10)</a>:</h4>
<p>I'm curious; does <code>@top_add _ (_)</code> work instead of <code>@top_add α _</code>?</p>



<a name="314915803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314915803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314915803">(Dec 09 2022 at 15:10)</a>:</h4>
<p>I would much prefer <code>toDual</code> over the <code>@</code>. It's less sloppy, as you said.</p>



<a name="314915898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314915898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314915898">(Dec 09 2022 at 15:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/314915213">said</a>:</p>
<blockquote>
<p>Sure, but it might be too late if half the order stuff is already ported to mathlib4</p>
</blockquote>
<p>Not sure what you mean. It's a matter of adding one import.</p>



<a name="314916405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314916405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314916405">(Dec 09 2022 at 15:13)</a>:</h4>
<p>In any case, this doesn't seem to be the issue.  Before:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">LinearOrderedAddCommMonoidWithTop</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
    <span class="n">LinearOrderedCommMonoidWithZero</span> <span class="o">(</span><span class="n">Multiplicative</span> <span class="n">α</span><span class="bp">ᵒᵈ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">Multiplicative.orderedCommMonoid</span><span class="o">,</span> <span class="n">Multiplicative.linearOrder</span> <span class="k">with</span>
    <span class="n">zero</span> <span class="o">:=</span> <span class="n">Multiplicative.ofAdd</span> <span class="o">(</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">zero_mul</span> <span class="o">:=</span> <span class="n">top_add</span> <span class="c1">-- failed to synthesize instance LinearOrderedAddCommMonoidWithTop (Multiplicative αᵒᵈ)</span>
    <span class="bp">&lt;</span><span class="n">snip</span><span class="bp">&gt;</span> <span class="o">}</span>
</code></pre></div>
<p>After:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">LinearOrderedAddCommMonoidWithTop</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
    <span class="n">LinearOrderedCommMonoidWithZero</span> <span class="o">(</span><span class="n">Multiplicative</span> <span class="n">α</span><span class="bp">ᵒᵈ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">Multiplicative.orderedCommMonoid</span><span class="o">,</span> <span class="n">Multiplicative.linearOrder</span> <span class="k">with</span>
    <span class="n">zero</span> <span class="o">:=</span> <span class="n">Multiplicative.ofAdd</span> <span class="o">(</span><span class="n">OrderDual.toDual</span> <span class="o">(</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">α</span><span class="o">))</span>
    <span class="n">zero_mul</span> <span class="o">:=</span> <span class="n">top_add</span> <span class="c1">-- failed to synthesize instance LinearOrderedAddCommMonoidWithTop (Multiplicative αᵒᵈ)</span>
    <span class="bp">&lt;</span><span class="n">snip</span><span class="bp">&gt;</span> <span class="o">}</span>
</code></pre></div>



<a name="314916958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314916958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314916958">(Dec 09 2022 at 15:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/314915745">said</a>:</p>
<blockquote>
<p>I'm curious; does <code>@top_add _ (_)</code> work instead of <code>@top_add α _</code>?</p>
</blockquote>
<p>How about this suggestion? GitPod is taking a while to build up to <code>WithZero</code> for me</p>



<a name="314917223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314917223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314917223">(Dec 09 2022 at 15:17)</a>:</h4>
<p>Interesting.  Yes, that one works.  Still worse than Lean 3's simple <code>top_add</code>, of course.</p>



<a name="314919394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314919394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314919394">(Dec 09 2022 at 15:26)</a>:</h4>
<p>Then it sounds like this is <a href="#narrow/stream/270676-lean4/topic/.60.28_.29.60.20vs.20.60_.60.20syntax/near/313936557">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.60.28_.29.60.20vs.20.60_.60.20syntax/near/313936557</a> again</p>



<a name="314922656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314922656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314922656">(Dec 09 2022 at 15:41)</a>:</h4>
<p>Then it seems my comment there was prescient!</p>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/270676-lean4/topic/.60.28_.29.60.20vs.20.60_.60.20syntax/near/314586601">said</a>:</p>
<blockquote>
<p>This might be painful for e.g. <code>OrderDual</code>, <code>MulOpposite</code>.</p>
</blockquote>



<a name="314922931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314922931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314922931">(Dec 09 2022 at 15:42)</a>:</h4>
<p>I think probably for now we should use the <code>@top_add _ (_)</code> spelling instead of <code>@top_add α _</code>, since that flags that lean4 already knows how to work out all the arguments and it's just being stubborn</p>



<a name="314923217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314923217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314923217">(Dec 09 2022 at 15:44)</a>:</h4>
<p>OK, that seems like a good reason.  I'll make the change throughout.</p>



<a name="314924614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314924614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314924614">(Dec 09 2022 at 15:50)</a>:</h4>
<p>Hmm, there are two places in the file where <code>α _</code> works and <code>_ (_)</code> doesn't.  I've pushed the rest of the changes so maybe someone can take a look.</p>



<a name="314925329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314925329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314925329">(Dec 09 2022 at 15:54)</a>:</h4>
<p>Can you link to the line where that happened?</p>



<a name="314925439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314925439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314925439">(Dec 09 2022 at 15:54)</a>:</h4>
<p>The only two <code>α _</code> in the file, one sec ...</p>



<a name="314925552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314925552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314925552">(Dec 09 2022 at 15:55)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib4/blob/cf027a53e0dbd91e30c0361451d0502160f8ea66/Mathlib/Algebra/Order/WithZero.lean#L114">https://github.com/leanprover-community/mathlib4/blob/cf027a53e0dbd91e30c0361451d0502160f8ea66/Mathlib/Algebra/Order/WithZero.lean#L114</a><br>
<a href="https://github.com/leanprover-community/mathlib4/blob/cf027a53e0dbd91e30c0361451d0502160f8ea66/Mathlib/Algebra/Order/WithZero.lean#L292">https://github.com/leanprover-community/mathlib4/blob/cf027a53e0dbd91e30c0361451d0502160f8ea66/Mathlib/Algebra/Order/WithZero.lean#L292</a></p>



<a name="314925884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314925884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314925884">(Dec 09 2022 at 15:56)</a>:</h4>
<p>In mathlib3 we also had a different spelling there</p>



<a name="314925887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314925887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314925887">(Dec 09 2022 at 15:56)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/src/algebra/order/with_zero.lean#L109">https://github.com/leanprover-community/mathlib/blob/master/src/algebra/order/with_zero.lean#L109</a></p>



<a name="314926108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314926108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314926108">(Dec 09 2022 at 15:57)</a>:</h4>
<p>Ah, you're right, I introduced both of these during my <a href="https://github.com/leanprover-community/mathlib4/pull/903/commits/ad2c22008b3bf1bcfae0ea9962ac4bd775891dec">@-fest</a>.</p>



<a name="314926523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314926523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314926523">(Dec 09 2022 at 16:00)</a>:</h4>
<p>They were also both broken, and also fixable by @, but the error is presumably different.</p>



<a name="314927555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314927555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314927555">(Dec 09 2022 at 16:05)</a>:</h4>
<p>The first one: mathport <code>fun a ↦ (zero_mul a : (0 : α) * a = 0)</code>, error </p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>failed to synthesize instance HMul α (Additive αᵒᵈ) ?m.26677
</code></pre></div>
<p>valid replacement is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">zero_mul</span> <span class="n">α</span> <span class="n">_</span>
</code></pre></div>



<a name="314927775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314927775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314927775">(Dec 09 2022 at 16:06)</a>:</h4>
<p>The second: mathport <code>fun a ha ↦ mul_inv_cancel ha</code>, error</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>type mismatch
  mul_inv_cancel ?m.71933
has type
  @Eq ?m.71275 (?m.71277 * ?m.71277⁻¹) 1 : Prop
but is expected to have type
  @Eq (Additive αᵒᵈ) (a + -a) 0 : Prop
</code></pre></div>
<p>fixed by</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">mul_inv_cancel</span> <span class="n">α</span> <span class="n">_</span>
</code></pre></div>



<a name="314932574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314932574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314932574">(Dec 09 2022 at 16:31)</a>:</h4>
<p><code>fun a ↦ zero_mul (Additive.to_mul a)</code> is the less hacky proof of the first one</p>



<a name="314932713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314932713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314932713">(Dec 09 2022 at 16:32)</a>:</h4>
<p>(<code>a.to_mul</code> is also not allowed in Lean4 which is a separate problem)</p>



<a name="314939463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314939463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314939463">(Dec 09 2022 at 17:05)</a>:</h4>
<p>Indeed.  But the analogue doesn't work for the second!</p>



<a name="314940309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314940309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314940309">(Dec 09 2022 at 17:09)</a>:</h4>
<p><code>fun a ha ↦ mul_inv_cancel (id ha : Additive.toMul a ≠ 0)</code> works for the second</p>



<a name="314942118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314942118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314942118">(Dec 09 2022 at 17:19)</a>:</h4>
<p>Can you confirm that you recommend these versions over the <code>@mul_inv_cancel α _</code> versions?  Again because of</p>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/314922931">said</a>:</p>
<blockquote>
<p>since that flags that lean4 already knows how to work out all the arguments and it's just being stubborn</p>
</blockquote>
<p>?  If so I'll make those changes.</p>



<a name="314943585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314943585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314943585">(Dec 09 2022 at 17:27)</a>:</h4>
<p>Heather, does a different type annotation work for <code>zero_mul</code>? Like <code>0 * (a : α) = 0</code> or <code>(0 * a : α) = 0</code> or <code>(0 : α) * (a : α) = 0</code>?</p>



<a name="314943806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314943806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314943806">(Dec 09 2022 at 17:28)</a>:</h4>
<p>It seems that Lean is getting confused because <code>*</code> is now actually heterogeneous and it is failing to unify the types appropriately during elaboration.</p>



<a name="314944305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314944305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314944305">(Dec 09 2022 at 17:30)</a>:</h4>
<p>Even putting a type annotation on everything doesn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">zero_mul</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">))</span>
</code></pre></div>



<a name="314953794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314953794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314953794">(Dec 09 2022 at 18:18)</a>:</h4>
<p>If <code>a</code> is of a type defeq to <code>α</code>, then the type annotation is a no-op. You would have to use the <code>id</code> trick. Coes between defeq types generally seem like a problematic idea, it would be better to make <code>Additive</code> a structure. But I assume that is not desired in other contexts.</p>



<a name="314955571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314955571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314955571">(Dec 09 2022 at 18:27)</a>:</h4>
<blockquote>
<p>Can you confirm that you recommend these versions over the @mul_inv_cancel α _ versions? </p>
</blockquote>
<p>The <code>@</code> versions are what Kevin would call "defeq abuse", but they're what we used in mathlib3 so <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span>. Either spelling is fine</p>



<a name="314955779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314955779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314955779">(Dec 09 2022 at 18:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span>, the goal is not to make a coercion happen, but to force <code>zero_mul</code> to elaborate with the annotated type with no information of the expected type at that point in the expression</p>



<a name="314963684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314963684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314963684">(Dec 09 2022 at 19:10)</a>:</h4>
<p>Actually Eric, I think Lean knows the expected type here. That's why it's getting it wrong. We are trying to force it to instead use a defeq type, which is why it can be considered defeq abuse.</p>



<a name="314966384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314966384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314966384">(Dec 09 2022 at 19:24)</a>:</h4>
<p>We're trying to locally change the expected type</p>



<a name="314966617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314966617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314966617">(Dec 09 2022 at 19:26)</a>:</h4>
<p>In Lean3, we could say to Lean "I know you want type <code>B</code>, but I'm going to write <code>(foo : A)</code> and you're going to forget that we're actually trying to produce a <code>B</code> until you're completely done with <code>foo</code>". In Lean 4 some of the elaboration seems to be postponed until we're looking at a goal of <code>B</code> again</p>



<a name="314968599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314968599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314968599">(Dec 09 2022 at 19:37)</a>:</h4>
<p>Here's something that does work in place of <code>fun a ha ↦ mul_inv_cancel ha</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">fun</span> <span class="n">a</span> <span class="n">ha</span> <span class="bp">↦</span> <span class="o">((</span><span class="n">id</span> <span class="o">(</span><span class="n">mul_inv_cancel</span> <span class="n">ha</span><span class="o">)</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>



<a name="314968789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314968789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314968789">(Dec 09 2022 at 19:38)</a>:</h4>
<p>Also</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">fun</span> <span class="n">a</span> <span class="n">ha</span> <span class="bp">↦</span> <span class="o">(</span><span class="n">mul_inv_cancel</span> <span class="o">(</span><span class="n">id</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">≠</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>
<p>Edit: I guess these are cheating because I provide <code>α</code> explicitly and we're trying to avoid that hint.</p>



<a name="314969706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314969706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314969706">(Dec 09 2022 at 19:43)</a>:</h4>
<p>The <code>(e :)</code> elaborator has a special hack to deal with this postponement issue</p>



<a name="314969959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314969959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314969959">(Dec 09 2022 at 19:45)</a>:</h4>
<p>Yes, that's why it occurred to me that this might work.</p>



<a name="314970046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314970046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314970046">(Dec 09 2022 at 19:46)</a>:</h4>
<p>Let me make a version of <code>(e : ty)</code> that forces no postponing...</p>



<a name="314970768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314970768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314970768">(Dec 09 2022 at 19:50)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>
<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab</span> <span class="n">Term</span>
<span class="n">elab</span> <span class="s2">"("</span> <span class="n">e</span><span class="o">:</span><span class="n">term</span> <span class="s2">":!"</span> <span class="n">ty</span><span class="o">:</span><span class="n">term</span> <span class="s2">")"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">ty</span> <span class="bp">←</span> <span class="n">elabType</span> <span class="n">ty</span>
  <span class="n">withSynthesize</span> <span class="o">(</span><span class="n">mayPostpone</span> <span class="o">:=</span> <span class="n">false</span><span class="o">)</span> <span class="bp">&lt;|</span> <span class="n">elabTerm</span> <span class="n">e</span> <span class="n">ty</span>
</code></pre></div>
<p>No one posted an MWE though so I don't have a good test case</p>



<a name="314982929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314982929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314982929">(Dec 09 2022 at 21:09)</a>:</h4>
<p>Note that this is missing the coercion insertion code from the standard type annotations. Actually I'm wondering whether that should really be done when expected and given type are non-defeq <em>at <code>reducible</code> level</em> since that is the level coercion resolution works on. Then <code>(a : α)</code> would have generated a coercion and affected resolution at <code>*</code>.</p>



<a name="314983615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314983615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314983615">(Dec 09 2022 at 21:14)</a>:</h4>
<p>What exactly is the postponement issue? The expected type shouldn't just get lost during postponement.</p>



<a name="314985130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314985130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314985130">(Dec 09 2022 at 21:24)</a>:</h4>
<p>I'll work on minimizing, but here's a version with imports:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Algebra.GroupWithZero.Basic</span>
<span class="kn">import</span> <span class="n">Mathlib.Algebra.Order.Monoid.WithZero.Defs</span>
<span class="kn">import</span> <span class="n">Mathlib.Algebra.Order.Group.Instances</span>
<span class="kn">import</span> <span class="n">Mathlib.Algebra.Order.Monoid.TypeTags</span>


<span class="kd">class</span> <span class="n">LinearOrderedCommGroupWithZero</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">LinearOrderedCommMonoidWithZero</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">CommGroupWithZero</span> <span class="n">α</span>

<span class="kd">variable</span> <span class="o">[</span><span class="n">LinearOrderedCommMonoidWithZero</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">LinearOrderedAddCommMonoidWithTop</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="bp">ᵒᵈ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">Additive.orderedAddCommMonoid</span><span class="o">,</span> <span class="n">Additive.linearOrder</span> <span class="k">with</span>
    <span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">top_add'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">zero_mul</span> <span class="n">a</span> <span class="c1">-- failed to synthesize instance MulZeroClass (Additive αᵒᵈ)</span>
    <span class="n">le_top</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>
<p>It works with <code>fun a =&gt; zero_mul (Additive.toMul a)</code>.</p>



<a name="314987379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/314987379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#314987379">(Dec 09 2022 at 21:40)</a>:</h4>
<p>reduced a little more (edit: and more):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Algebra.GroupWithZero.Defs</span>
<span class="kn">import</span> <span class="n">Mathlib.Algebra.Group.TypeTags</span>
<span class="kn">import</span> <span class="n">Mathlib.Algebra.Order.Monoid.Defs</span>
<span class="kn">import</span> <span class="n">Mathlib.Order.Synonym</span>


<span class="kd">instance</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">LE</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">LE</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">LT</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">LT</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h</span>
<span class="kd">instance</span> <span class="n">Additive.partialOrder</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">PartialOrder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">PartialOrder</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h</span>
<span class="kd">instance</span> <span class="n">Additive.linearOrder</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">LinearOrder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">LinearOrder</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h</span>

<span class="kd">instance</span> <span class="n">Additive.orderedAddCommMonoid</span> <span class="o">[</span><span class="n">OrderedCommMonoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
    <span class="n">OrderedAddCommMonoid</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">Additive.partialOrder</span><span class="o">,</span> <span class="n">Additive.addCommMonoid</span> <span class="k">with</span>
    <span class="n">add_le_add_left</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>


<span class="kd">instance</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Mul</span> <span class="n">α</span><span class="bp">ᵒᵈ</span> <span class="o">:=</span> <span class="n">h</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">Zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Zero</span> <span class="n">α</span><span class="bp">ᵒᵈ</span> <span class="o">:=</span> <span class="n">h</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">MulZeroClass</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">MulZeroClass</span> <span class="n">α</span><span class="bp">ᵒᵈ</span> <span class="o">:=</span> <span class="n">h</span>
<span class="kd">instance</span> <span class="n">inst</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">CommMonoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">CommMonoid</span> <span class="n">α</span><span class="bp">ᵒᵈ</span> <span class="o">:=</span> <span class="n">h</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">LinearOrderedCommMonoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">LinearOrderedCommMonoid</span> <span class="n">α</span><span class="bp">ᵒᵈ</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">OrderDual.instLinearOrderOrderDual</span> <span class="n">α</span><span class="o">,</span> <span class="n">inst</span> <span class="k">with</span>
    <span class="n">mul_le_mul_left</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>

<span class="kd">class</span> <span class="n">LinearOrderedCommMonoidWithZero</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">LinearOrderedCommMonoid</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">CommMonoidWithZero</span> <span class="n">α</span>

<span class="kd">variable</span> <span class="o">[</span><span class="n">LinearOrderedCommMonoidWithZero</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">LinearOrderedAddCommMonoidWithTop</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="bp">ᵒᵈ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">Additive.orderedAddCommMonoid</span><span class="o">,</span> <span class="n">Additive.linearOrder</span> <span class="k">with</span>
    <span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">top_add'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">zero_mul</span> <span class="o">(</span><span class="n">Additive.toMul</span> <span class="n">a</span><span class="o">)</span>
    <span class="n">le_top</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>



<a name="315207351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315207351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315207351">(Dec 11 2022 at 13:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I think the following should be a MWE for this issue.  Can you test it with your proposed no-postponing feature?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Bot</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span> <span class="n">bot</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">class</span> <span class="n">Top</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span> <span class="n">top</span> <span class="o">:</span> <span class="n">α</span>

<span class="kd">notation</span> <span class="s2">"⊥"</span> <span class="bp">=&gt;</span> <span class="n">Bot.bot</span>
<span class="kd">notation</span> <span class="s2">"⊤"</span> <span class="bp">=&gt;</span> <span class="n">Top.top</span>

<span class="kd">class</span> <span class="n">MulBotClass</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">Bot</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">bot_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">⊥</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">⊥</span>

<span class="kn">export</span> <span class="n">MulBotClass</span> <span class="o">(</span><span class="n">bot_mul</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">AddTopClass</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">α</span><span class="o">,</span> <span class="n">Top</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">top_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">⊤</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">⊤</span>

<span class="sd">/-- a type synonym -/</span>
<span class="kd">def</span> <span class="n">Additive</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="n">α</span>

<span class="sd">/-- identification with type synonym -/</span>
<span class="kd">def</span> <span class="n">Additive.toMul</span> <span class="o">:</span> <span class="n">Additive</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">instance</span> <span class="n">Additive.add</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Add</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">@</span><span class="n">Mul.mul</span> <span class="n">α</span> <span class="n">_</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">MulBotClass</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">AddTopClass</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">Additive.add</span> <span class="k">with</span>
    <span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">top_add</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">bot_mul</span> <span class="n">a</span> <span class="o">}</span> <span class="c1">-- failed to synthesize instance MulBotClass (Additive α)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">MulBotClass</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">AddTopClass</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">Additive.add</span> <span class="k">with</span>
    <span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">top_add</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">bot_mul</span> <span class="o">(</span><span class="n">Additive.toMul</span> <span class="n">a</span><span class="o">)</span> <span class="o">}</span> <span class="c1">-- works</span>
</code></pre></div>



<a name="315241975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315241975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315241975">(Dec 11 2022 at 18:26)</a>:</h4>
<p>It's a bit weird that <code>top := (⊥ : α)</code> works! </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">top_add</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="n">bot_mul</span> <span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)))</span> <span class="o">:</span> <span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">))</span> <span class="bp">*</span> <span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">))))</span> <span class="o">}</span> <span class="c1">-- failed to synthesize instance MulBotClass (Additive α)</span>
</code></pre></div>
<p>Somehow in Lean 4 you're committed to type <code>Additive α</code> by the time Lean is trying to unify the <code>_</code> in <code>fun a =&gt; _</code>, and no amount of tricks will persuade Lean that a has another type.</p>



<a name="315242027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315242027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315242027">(Dec 11 2022 at 18:27)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="n">top_add</span> <span class="o">:=</span> <span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">bot_mul</span> <span class="n">a</span> <span class="o">}</span> <span class="c1">-- works!</span>
</code></pre></div>
<p>But I don't think that this will solve the general problem.</p>



<a name="315246950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315246950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315246950">(Dec 11 2022 at 19:13)</a>:</h4>
<p>In any case, I oversimplified a bit: the example I posted is susceptible to the <code>@bot_mul _ (_)</code> trick.  I think the following should be a real example.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Bot</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span> <span class="n">bot</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">class</span> <span class="n">Top</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span> <span class="n">top</span> <span class="o">:</span> <span class="n">α</span>

<span class="kd">notation</span> <span class="s2">"⊥"</span> <span class="bp">=&gt;</span> <span class="n">Bot.bot</span>
<span class="kd">notation</span> <span class="s2">"⊤"</span> <span class="bp">=&gt;</span> <span class="n">Top.top</span>

<span class="kd">class</span> <span class="n">MulBotClass</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">Bot</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">bot_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">⊥</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">⊥</span>

<span class="kn">export</span> <span class="n">MulBotClass</span> <span class="o">(</span><span class="n">bot_mul</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">Mul₂</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Mul</span> <span class="n">α</span>

<span class="kd">class</span> <span class="n">MulBotClass₂</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Mul₂</span> <span class="n">α</span><span class="o">,</span> <span class="n">MulBotClass</span> <span class="n">α</span>

<span class="kd">class</span> <span class="n">AddTopClass₂</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">α</span><span class="o">,</span> <span class="n">Top</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">top_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">⊤</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">⊤</span>

<span class="sd">/-- a type synonym -/</span>
<span class="kd">def</span> <span class="n">Additive</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="n">α</span>

<span class="sd">/-- identification with type synonym -/</span>
<span class="kd">def</span> <span class="n">Additive.toMul</span> <span class="o">:</span> <span class="n">Additive</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">MulBotClass₂</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">AddTopClass₂</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">Mul.mul</span> <span class="n">α</span> <span class="n">_</span>
    <span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">top_add</span> <span class="o">:=</span> <span class="n">bot_mul</span> <span class="o">}</span> <span class="c1">-- type mismatch</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">MulBotClass₂</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">AddTopClass₂</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">Mul.mul</span> <span class="n">α</span> <span class="n">_</span>
    <span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">top_add</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">bot_mul</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">}</span> <span class="c1">-- type mismatch</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">MulBotClass₂</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">AddTopClass₂</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">Mul.mul</span> <span class="n">α</span> <span class="n">_</span>
    <span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">top_add</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">bot_mul</span> <span class="n">a</span> <span class="o">}</span> <span class="c1">-- failed to synthesize instance</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">MulBotClass₂</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">AddTopClass₂</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">Mul.mul</span> <span class="n">α</span> <span class="n">_</span>
    <span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">top_add</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">bot_mul</span> <span class="o">(</span><span class="n">Additive.toMul</span> <span class="n">a</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="315247232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315247232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315247232">(Dec 11 2022 at 19:16)</a>:</h4>
<p>Again</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="n">top_add</span> <span class="o">:=</span> <span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">bot_mul</span> <span class="n">a</span> <span class="o">}</span>
</code></pre></div>
<p>also works</p>



<a name="315248183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315248183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315248183">(Dec 11 2022 at 19:27)</a>:</h4>
<p>Here is something specifically that worked in Lean 3 and doesn't work in Lean 4.  In Lean 3, translating <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/315246950">my example</a> using <code>old_structure_cmd</code>, the following works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">top_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">bot_mul</span> <span class="n">a</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span>
</code></pre></div>
<p>In Lean 4,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">top_add</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">bot_mul</span> <span class="n">a</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span>
</code></pre></div>
<p>fails with two errors,</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>failed to synthesize instance MulBotClass (Additive α)
failed to synthesize instance HMul α (Additive α) ?m.13158
</code></pre></div>



<a name="315248326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315248326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315248326">(Dec 11 2022 at 19:28)</a>:</h4>
<p>This reminds me of <a href="#narrow/stream/287929-mathlib4/topic/elaboration.20failure.20in.20algebra.2Eorder.2Egroup.2Eunits">another example I posted</a>.  In both cases, in Lean 3 we helped Lean in a tricky situation by providing a type annotation, and that particular type annotation is no longer helpful in Lean 4.</p>



<a name="315250727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315250727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315250727">(Dec 11 2022 at 19:55)</a>:</h4>
<p>And here is a second import-free example, mimicking one of the other errors in the same file.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Bot</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span> <span class="n">bot</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">class</span> <span class="n">Top</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span> <span class="n">top</span> <span class="o">:</span> <span class="n">α</span>

<span class="kd">notation</span> <span class="s2">"⊥"</span> <span class="bp">=&gt;</span> <span class="n">Bot.bot</span>
<span class="kd">notation</span> <span class="s2">"⊤"</span> <span class="bp">=&gt;</span> <span class="n">Top.top</span>

<span class="kd">class</span> <span class="n">MulBotClass</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Mul</span> <span class="n">α</span><span class="o">,</span>  <span class="n">Bot</span> <span class="n">α</span>

<span class="kd">theorem</span> <span class="n">mul_inv_cancel</span> <span class="o">[</span><span class="n">MulBotClass</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="bp">⊥</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">class</span> <span class="n">Mul₂</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Mul</span> <span class="n">α</span>

<span class="kd">class</span> <span class="n">MulBotClass₂</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Mul₂</span> <span class="n">α</span><span class="o">,</span> <span class="n">MulBotClass</span> <span class="n">α</span>

<span class="kd">class</span> <span class="n">AddTopClass₂</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">α</span><span class="o">,</span> <span class="n">Top</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">add_neg_cancel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="bp">⊤</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="bp">⊤</span>

<span class="sd">/-- a type synonym -/</span>
<span class="kd">def</span> <span class="n">Additive</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="n">α</span>

<span class="sd">/-- identification with type synonym -/</span>
<span class="kd">def</span> <span class="n">Additive.toMul</span> <span class="o">:</span> <span class="n">Additive</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">MulBotClass₂</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">AddTopClass₂</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">Mul.mul</span> <span class="n">α</span> <span class="n">_</span>
    <span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">add_neg_cancel</span> <span class="o">:=</span> <span class="n">mul_inv_cancel</span> <span class="o">}</span> <span class="c1">-- type mismatch</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">MulBotClass₂</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">AddTopClass₂</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">Mul.mul</span> <span class="n">α</span> <span class="n">_</span>
    <span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">add_neg_cancel</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">mul_inv_cancel</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">}</span> <span class="c1">-- type mismatch</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">MulBotClass₂</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">AddTopClass₂</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">Mul.mul</span> <span class="n">α</span> <span class="n">_</span>
    <span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">add_neg_cancel</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">a</span> <span class="n">ha</span> <span class="bp">=&gt;</span> <span class="n">mul_inv_cancel</span> <span class="n">_</span> <span class="o">(</span><span class="n">id</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">Additive.toMul</span> <span class="n">a</span> <span class="bp">≠</span> <span class="bp">⊥</span><span class="o">)</span> <span class="o">}</span> <span class="c1">-- works</span>
</code></pre></div>



<a name="315250733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315250733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315250733">(Dec 11 2022 at 19:55)</a>:</h4>
<p>The working proof </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">add_neg_cancel</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">a</span> <span class="n">ha</span> <span class="bp">=&gt;</span> <span class="n">mul_inv_cancel</span> <span class="n">_</span> <span class="o">(</span><span class="n">id</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">Additive.toMul</span> <span class="n">a</span> <span class="bp">≠</span> <span class="bp">⊥</span><span class="o">)</span>
</code></pre></div>
<p>at the end was suggested by Eric <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/314940309">above</a>.  But in Lean 3,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">add_neg_cancel</span> <span class="o">:=</span> <span class="n">mul_inv_cancel</span>
</code></pre></div>
<p>works!</p>



<a name="315260816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315260816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315260816">(Dec 11 2022 at 22:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="n">add_neg_cancel</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">mul_inv_cancel</span> <span class="n">α</span> <span class="n">_</span> <span class="o">}</span> <span class="c1">-- works</span>
</code></pre></div>
<p>but I agree it's not as good as the Lean 3 version!</p>



<a name="315262527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315262527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315262527">(Dec 11 2022 at 22:35)</a>:</h4>
<p>I think it's worth remember that a lot of these spellings which work in Lean3 are things that are golfed to oblivion because no-one cares about them being readable or easy for the compiler. It's annoying to have to fix them in the port, but I don't think it's any great loss to lean4 for not supporting the type of nonsense we've historically written for these proofs</p>



<a name="315262642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315262642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315262642">(Dec 11 2022 at 22:36)</a>:</h4>
<p>At the extreme, this probably means that in many places where we currently write <code>@some_lemma (order_dual X) _ _ _</code> we'd be forced to write something more like <code>fun x =&gt; some_lemma (to_dual x)</code> etc.</p>



<a name="315262797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315262797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315262797">(Dec 11 2022 at 22:39)</a>:</h4>
<p>I think that more reliance on "transfer" across homs could reduce boilerplate even more, instead of having to give these mirage-proofs</p>



<a name="315263615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315263615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315263615">(Dec 11 2022 at 22:49)</a>:</h4>
<p>My dream is still for a <code>to_additive</code>-like tactic to handle them all.</p>



<a name="315263716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315263716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315263716">(Dec 11 2022 at 22:50)</a>:</h4>
<p>All this defeq abuse is doing could be done by a script working on the proof term from the original proof.</p>



<a name="315264510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315264510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315264510">(Dec 11 2022 at 23:00)</a>:</h4>
<p>Note there are some cases where the type alias is under an internal binder where it really is useful that the types are defeq; I think these come up in some quotient things that probably haven't been reached by the port yet</p>



<a name="315311492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315311492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315311492">(Dec 12 2022 at 08:28)</a>:</h4>
<p>Yes, it will be <em>really</em> hard to hygienise all type synonyms if we don't have automation to do so. Given the pain we've seen in this stream over type synonyms these past weeks, I foresee that we'll be forced to write the automation sooner than later.</p>



<a name="315321669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315321669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315321669">(Dec 12 2022 at 09:30)</a>:</h4>
<p>I'm still curious to see whether <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>'s <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/314970046">proposed new Lean feature</a> would solve these.</p>



<a name="315321923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315321923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315321923">(Dec 12 2022 at 09:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/315262642">said</a>:</p>
<blockquote>
<p>At the extreme, this probably means that in many places where we currently write <code>@some_lemma (order_dual X) _ _ _</code> we'd be forced to write something more like <code>fun x =&gt; some_lemma (to_dual x)</code> etc.</p>
</blockquote>
<p>This gets awkward when all the <code>x : X</code> in <code>some_lemma</code> are implicit (because there are hypotheses involving them which are explicit).  That was the case <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/314940309">here</a>.</p>



<a name="315321949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315321949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315321949">(Dec 12 2022 at 09:31)</a>:</h4>
<p>It's not a proposed new feature, it's a simple macro which was given</p>



<a name="315322034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315322034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315322034">(Dec 12 2022 at 09:32)</a>:</h4>
<p>I am not exactly sure where to slot it into the example from your last ping</p>



<a name="315322101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315322101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315322101">(Dec 12 2022 at 09:32)</a>:</h4>
<p>but this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">MulBotClass</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">AddTopClass</span> <span class="o">(</span><span class="n">Additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">Additive.add</span> <span class="k">with</span>
    <span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
    <span class="n">top_add</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">bot_mul</span> <span class="o">(</span><span class="n">α</span> <span class="o">:=</span> <span class="n">α</span><span class="o">)</span> <span class="n">a</span> <span class="o">}</span>
</code></pre></div>



<a name="315322590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315322590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315322590">(Dec 12 2022 at 09:35)</a>:</h4>
<p><code>bot_mul (by exact a : α)</code> also works</p>



<a name="315322694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315322694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315322694">(Dec 12 2022 at 09:35)</a>:</h4>
<p><code>bot_mul (a :! α)</code> does not work, since it seems the postponing is being done from outside the scope of the <code>:!</code></p>



<a name="315326886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Type%20synonyms/near/315326886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Type.20synonyms.html#315326886">(Dec 12 2022 at 09:59)</a>:</h4>
<p>It's certainly nice that Lean 4 provides this other spelling <code>bot_mul (α := α)</code> of <code>@bot_mul α _</code>.  That was actually how I was <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/314912552">originally solving</a> these failures, but Eric <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/314922931">pointed out</a> that with this spelling, in some cases we are giving more help to Lean 4 (the <code>α</code>) than it needed in Lean 3.  My <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/315250727">second import-free example</a> was one of these cases, and I think we still haven't found a Lean 4 proof there that doesn't contain the hint about <code>α</code> or at least about passing between a type and its additivization.</p>
<p><a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/315248183">My first import-free example</a>, the one you were looking at here, was solved in Lean 3 with an elaborate type annotation,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">top_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">bot_mul</span> <span class="n">a</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span>
</code></pre></div>
<p>It's certainly not necessary that we get this ugly proof working in Lean 4; <code>bot_mul (α := α)</code> is strictly nicer in my opinion.  But I would have thought that this was exactly the use case of your <code>:!</code> macro and it's surprising to me that it doesn't work here.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
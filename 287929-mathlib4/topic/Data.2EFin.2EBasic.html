---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html">Data.Fin.Basic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="316372563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316372563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316372563">(Dec 16 2022 at 22:32)</a>:</h4>
<p>I have a decent start on <code>Data.Fin.Basic</code> at <a href="https://github.com/leanprover-community/mathlib4/pull/1084">mathlib4#1084</a>, but it's a monster file. I won't be able to work on it any more tonight, so if anyone else wants to jump in that's fine, just say so here so people don't duplicate work. A few notes:</p>
<ol>
<li>I have included a few things from the ad hoc ported file, which I have labeled with <code>section from_ad_hoc</code>. I felt these things might be necessary / helpful.</li>
<li>There are some hiccups in several places because <del>(a) <code>Fin</code> is now a structure rather than a subtype and (b)</del> numerals work differently in Lean 4. This has caused some <code>rfl</code> proofs to break.</li>
<li>There are some syntactically duplicated lemmas (because coercions are unfolded) which I have left in for the moment, but we can perhaps remove them (with <code>#align</code>s to the other version) before finishing the PR.</li>
</ol>



<a name="316373356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316373356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316373356">(Dec 16 2022 at 22:39)</a>:</h4>
<p><code>fin</code> being a structure has been backported to mathlib by Gabriel.</p>



<a name="316373399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316373399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316373399">(Dec 16 2022 at 22:39)</a>:</h4>
<p>So it would be interested to figure out exactly why the refls broke.</p>



<a name="316373470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316373470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316373470">(Dec 16 2022 at 22:40)</a>:</h4>
<p>the <code>rfl</code>s broke because of numerals I think, not the structure.</p>



<a name="316373520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316373520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316373520">(Dec 16 2022 at 22:40)</a>:</h4>
<p>Sorry, I got confused because the structure fields in mathlib3 are <code>val</code> and <code>property</code>, so I just thought it was a <code>subtype</code>.</p>



<a name="316373539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316373539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316373539">(Dec 16 2022 at 22:40)</a>:</h4>
<p>Ah okay, that would make sense.</p>



<a name="316391059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316391059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316391059">(Dec 17 2022 at 01:54)</a>:</h4>
<p>I've fixed a couple of errors, but my Lean time is up for today (maybe a I do a bit more in the evening).</p>



<a name="316436288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316436288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316436288">(Dec 17 2022 at 11:06)</a>:</h4>
<p>I've removed the <code>{a b : Fin n}</code> and added the hypotheses where necessary as it caused really weird errors</p>



<a name="316436617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316436617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316436617">(Dec 17 2022 at 11:07)</a>:</h4>
<p>also I've changed quite a few proofs from <code>rfl</code> or <code>ext rfl</code> to <code>ext; simp</code>. This is might be bad for performance, but since we have to port this file, I think it is acceptable for now</p>



<a name="316449545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316449545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316449545">(Dec 17 2022 at 12:34)</a>:</h4>
<p>I think simp is the right way to go here because things just aren't rfl anymore. As for a, b, did you see the Zulip thread about this?</p>



<a name="316455732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316455732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316455732">(Dec 17 2022 at 13:15)</a>:</h4>
<p>What was <code>rfl</code> and is no longer <code>rfl</code>?</p>



<a name="316469453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316469453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316469453">(Dec 17 2022 at 14:49)</a>:</h4>
<p>Not at my machine, but search the file for "was" and you should see some examples.</p>



<a name="316508002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316508002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316508002">(Dec 17 2022 at 20:35)</a>:</h4>
<p>Whatever this means:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">section</span> <span class="n">from_ad_hoc</span>
<span class="c1">-- porting note: this comes from the ad hoc port of this file</span>
<span class="kd">variable</span> <span class="o">[</span><span class="n">Nonempty</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span><span class="o">)]</span>

<span class="kd">@[to_additive_fixed_numeral]</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">x</span> <span class="n">where</span>
  <span class="n">ofNat</span> <span class="o">:=</span> <span class="n">Fin.ofNat'</span> <span class="n">x</span> <span class="n">Fin.size_positive'</span>
</code></pre></div>
<p>, it has the property that <code>(0 : Fin n).val = 0</code> is no longer <code>rfl</code>.</p>



<a name="316508270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316508270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316508270">(Dec 17 2022 at 20:38)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Lean 3</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">%</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Lean 4 (quoting from core)</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">zero_mod</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">%</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mod_eq</span><span class="o">]</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">intro</span> <span class="o">⟨</span><span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩</span>
    <span class="n">simp_all</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span>
</code></pre></div>
<p>That's the problem.</p>



<a name="316508362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316508362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316508362">(Dec 17 2022 at 20:39)</a>:</h4>
<p>Any chance we can get rid of the weird mod stuff in <code>Fin</code>?</p>



<a name="316508675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316508675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316508675">(Dec 17 2022 at 20:43)</a>:</h4>
<p>This is also in core Lean 4:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">ofNat</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n.succ</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">a</span> <span class="bp">%</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">Nat.mod_lt</span> <span class="n">_</span> <span class="o">(</span><span class="n">Nat.zero_lt_succ</span> <span class="n">_</span><span class="o">)⟩</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">ofNat'</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">a</span> <span class="bp">%</span> <span class="n">n</span><span class="o">,</span> <span class="n">Nat.mod_lt</span> <span class="n">_</span> <span class="n">h</span><span class="o">⟩</span>

<span class="bp">...</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">Fin</span> <span class="o">(</span><span class="n">no_index</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="n">i</span> <span class="n">where</span>
  <span class="n">ofNat</span> <span class="o">:=</span> <span class="n">Fin.ofNat</span> <span class="n">i</span>
</code></pre></div>



<a name="316509789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316509789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316509789">(Dec 17 2022 at 20:57)</a>:</h4>
<p>It would be nice if numeric literals were just an error if they cannot be proved to be in range--is that possible in Lean 4?</p>



<a name="316510510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316510510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316510510">(Dec 17 2022 at 21:05)</a>:</h4>
<p>it is kind of possible, but we are really limited by the fact that you can't call tactics in typeclass search</p>



<a name="316515386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316515386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316515386">(Dec 17 2022 at 22:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, the stuff from the ad hoc port didn't break <code>rfl</code>, it was already broken (most likely by the stuff in core).</p>



<a name="316521340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/316521340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#316521340">(Dec 17 2022 at 23:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="197836">Jireh Loreaux</span> <a href="#narrow/stream/287929-mathlib4/topic/Data.2EFin.2EBasic/near/316449545">said</a>:</p>
<blockquote>
<p>I think simp is the right way to go here because things just aren't rfl anymore. As for a, b, did you see the Zulip thread about this?</p>
</blockquote>
<p>No I did not. I saw that there was a zulip thread linked in the source, but I just went ahead and fixed the errors <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="317432650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/317432650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#317432650">(Dec 22 2022 at 18:58)</a>:</h4>
<p>Is there a reason mod can't be defined in a way that makes this rfl?</p>



<a name="317436243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/317436243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#317436243">(Dec 22 2022 at 19:21)</a>:</h4>
<p>Lean 3 says that there is no reason why it can't be done, but maybe that's not the question you mean.</p>



<a name="317450264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/317450264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#317450264">(Dec 22 2022 at 20:55)</a>:</h4>
<p>Is that true? Lean 3 didn't use mod here so it was irrelevant how it was defined</p>



<a name="317450643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/317450643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#317450643">(Dec 22 2022 at 20:58)</a>:</h4>
<p>But defining ofNat casewise on 0 1 and n.succ.succ would presumably solve this for 0 and 1</p>



<a name="317451777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/317451777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#317451777">(Dec 22 2022 at 21:05)</a>:</h4>
<p>Oh I think I misunderstood what "this" referred to.</p>



<a name="319165797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319165797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319165797">(Jan 03 2023 at 10:40)</a>:</h4>
<p>In this file there is a well-founded definition that no longer works. In the current state of the file we see:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[elab_as_elim]</span>
<span class="kd">def</span> <span class="n">reverseInduction</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">Fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">}</span> <span class="o">(</span><span class="n">hlast</span> <span class="o">:</span> <span class="n">C</span> <span class="o">(</span><span class="n">Fin.last</span> <span class="n">n</span><span class="o">))</span>
    <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">C</span> <span class="n">i.succ</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">castSucc</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">C</span> <span class="n">i</span>
  <span class="bp">|</span> <span class="n">i</span> <span class="bp">=&gt;</span>
    <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">Fin.last</span> <span class="n">n</span> <span class="k">then</span> <span class="n">_root_.cast</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">C</span> <span class="n">hi.symm</span><span class="o">)</span> <span class="n">hlast</span>
    <span class="k">else</span> <span class="kd">by</span>
      <span class="n">set</span> <span class="n">j</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">lt_of_le_of_ne</span> <span class="o">(</span><span class="n">Nat.le_of_lt_succ</span> <span class="n">i.2</span><span class="o">)</span> <span class="k">fun</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">hi</span> <span class="o">(</span><span class="n">Fin.ext</span> <span class="n">h</span><span class="o">)⟩</span> <span class="k">with</span> <span class="n">hj</span>
      <span class="k">have</span> <span class="n">wf</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">j.succ</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">i</span> <span class="o">:=</span> <span class="kd">by</span>
        <span class="k">have</span> <span class="o">:=</span> <span class="n">Fin.eta</span> <span class="n">i</span> <span class="n">i.isLt</span>
        <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">this</span><span class="o">]</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">tsub_lt_tsub_iff_left_of_le</span><span class="o">]</span>
        <span class="bp">·</span> <span class="n">simp</span> <span class="o">[</span><span class="n">succ_mk</span><span class="o">,</span> <span class="n">lt_add_iff_pos_right</span><span class="o">,</span> <span class="n">Nat.succ_le_iff</span><span class="o">]</span>
        <span class="bp">·</span> <span class="n">rw</span> <span class="o">[</span><span class="n">succ_mk</span><span class="o">,</span> <span class="n">add_le_add_iff_right</span><span class="o">]</span>
          <span class="n">exact</span> <span class="n">j.isLt.le</span>
      <span class="k">have</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">Fin.castSucc</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">Fin.ext</span> <span class="n">rfl</span>
      <span class="n">exact</span> <span class="n">_root_.cast</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">C</span> <span class="n">hi.symm</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="n">_</span> <span class="o">(</span><span class="n">reverseInduction</span> <span class="n">hlast</span> <span class="n">hs</span> <span class="n">j.succ</span><span class="o">))</span>
<span class="n">termination_by'</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">measure_wf</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">i</span><span class="o">⟩</span>
</code></pre></div>
<p>with errors on the last two lines. I tried as a blind fix to change the last line to <code>termination_by' ⟨_, (measure fun i : Fin (n + 1) =&gt; n + 1 - i).wf⟩</code> which does get rid of the error on the last line, but still doesn't satisfy the termination checker.</p>



<a name="319278394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319278394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319278394">(Jan 03 2023 at 20:55)</a>:</h4>
<p>The syntax for termination_by is now a bit different.  You can just write <code>termination_by _ =&gt; n + 1 - i</code> now (and don't need to use <code>measure</code> etc.).</p>



<a name="319278496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319278496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319278496">(Jan 03 2023 at 20:56)</a>:</h4>
<p>I've pushed a fixed version of <code>reverseInduction</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[elab_as_elim]</span>
<span class="kd">def</span> <span class="n">reverseInduction</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">Fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">}</span> <span class="o">(</span><span class="n">hlast</span> <span class="o">:</span> <span class="n">C</span> <span class="o">(</span><span class="n">Fin.last</span> <span class="n">n</span><span class="o">))</span>
    <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">C</span> <span class="n">i.succ</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">castSucc</span> <span class="n">i</span><span class="o">))</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">i</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">Fin.last</span> <span class="n">n</span> <span class="k">then</span> <span class="n">_root_.cast</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">C</span> <span class="n">hi.symm</span><span class="o">)</span> <span class="n">hlast</span>
  <span class="k">else</span>
    <span class="k">let</span> <span class="n">j</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">lt_of_le_of_ne</span> <span class="o">(</span><span class="n">Nat.le_of_lt_succ</span> <span class="n">i.2</span><span class="o">)</span> <span class="k">fun</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">hi</span> <span class="o">(</span><span class="n">Fin.ext</span> <span class="n">h</span><span class="o">)⟩</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">i</span> <span class="o">:=</span>
      <span class="n">lt_of_eq_of_lt</span> <span class="o">(</span><span class="n">Nat.add_sub_add_right</span> <span class="bp">..</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
        <span class="o">(</span><span class="n">Nat.sub_lt_sub_left</span> <span class="n">i.2</span> <span class="o">(</span><span class="n">Nat.lt_succ_self</span> <span class="n">i</span><span class="o">))</span>
    <span class="k">have</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">Fin.castSucc</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">Fin.ext</span> <span class="n">rfl</span>
    <span class="n">_root_.cast</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">C</span> <span class="n">hi.symm</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="n">_</span> <span class="o">(</span><span class="n">reverseInduction</span> <span class="n">hlast</span> <span class="n">hs</span> <span class="n">j.succ</span><span class="o">))</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">i</span>
</code></pre></div>



<a name="319282566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319282566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319282566">(Jan 03 2023 at 21:24)</a>:</h4>
<p>Thanks Gabriel!</p>



<a name="319579579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319579579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319579579">(Jan 05 2023 at 12:55)</a>:</h4>
<p>I proposed a fix for <code>addCases</code> at <a href="https://github.com/leanprover-community/mathlib4/pull/1084#discussion_r1062398734">https://github.com/leanprover-community/mathlib4/pull/1084#discussion_r1062398734</a> . Regarding <code>succAbove_zero</code> no longer being <code>refl</code>, it can be proved by <code>simp [succAbove]</code>, but is the issue that we want it to be <code>rfl</code> or has that ship sailed?</p>



<a name="319679847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319679847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319679847">(Jan 05 2023 at 21:57)</a>:</h4>
<p>Adding this to the top of the <code>Data.Fin.Basic</code> file seems to restore the old semantics of 0 and 1:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- we do not want this instance, and want `instOfNat`, the one that goes via `AddMonoidWithOne`, instead</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="kd">instance</span><span class="o">]</span> <span class="n">Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Zero</span> <span class="o">(</span><span class="n">Fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">succ_pos</span> <span class="n">_</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">One</span> <span class="o">(</span><span class="n">Fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="n">Fin.ofNat</span> <span class="mi">1</span>
</code></pre></div>
<p>cc <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>.</p>



<a name="319679908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319679908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319679908">(Jan 05 2023 at 21:58)</a>:</h4>
<p>what is that instance?</p>



<a name="319679983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319679983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319679983">(Jan 05 2023 at 21:58)</a>:</h4>
<p>is that from core?</p>



<a name="319679993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319679993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319679993">(Jan 05 2023 at 21:58)</a>:</h4>
<p>You mean it's not obvious from the name? <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>
<p><a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat#doc">docs4#Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat</a></p>



<a name="319679995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319679995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319679995">(Jan 05 2023 at 21:58)</a>:</h4>
<p>Yes</p>



<a name="319680044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319680044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319680044">(Jan 05 2023 at 21:58)</a>:</h4>
<p>I see, is there something we can do with priorities to avoid it?</p>



<a name="319680099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319680099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319680099">(Jan 05 2023 at 21:59)</a>:</h4>
<p><code>attribute [-instance]</code> doesn't really work, that's local-only</p>



<a name="319680137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319680137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319680137">(Jan 05 2023 at 21:59)</a>:</h4>
<p><del>Where's the instance implied by <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddMonoidWithOne?#doc">docs4#AddMonoidWithOne?</a></del> <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instOfNat#doc">docs4#instOfNat</a></p>



<a name="319680157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319680157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319680157">(Jan 05 2023 at 21:59)</a>:</h4>
<p>We should add <code>superCaliFragilisticExpialiDocious</code> to the end of every instance name, just because we can.</p>



<a name="319680412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319680412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319680412">(Jan 05 2023 at 22:01)</a>:</h4>
<p>What's the Lean4 syntax for instance priority?</p>



<a name="319680648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Fin.Basic/near/319680648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2EFin.2EBasic.html#319680648">(Jan 05 2023 at 22:02)</a>:</h4>
<p><code>instance (priority := high)</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
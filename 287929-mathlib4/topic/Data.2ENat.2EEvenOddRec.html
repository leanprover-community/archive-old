---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html">Data.Nat.EvenOddRec</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="317147194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317147194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317147194">(Dec 21 2022 at 12:31)</a>:</h4>
<p>I noticed that <code>Nat.odd_even_rec</code> has not been taken up yet. I'd like to take it up. Is there anything I should know (for e.g. : this file being on the "not to be ported" list?)</p>



<a name="317147826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317147826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317147826">(Dec 21 2022 at 12:35)</a>:</h4>
<p>Fixed:  <del>Also I don't see <code>data.nat.bits</code> and <code>init.data.nat.bitwise</code> in master yet. I thought this was already merged (see: <a href="https://github.com/leanprover-community/mathlib4/pull/1095">mathlib4#1095</a></del></p>



<a name="317150349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317150349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317150349">(Dec 21 2022 at 12:49)</a>:</h4>
<p>PR <a href="https://github.com/leanprover-community/mathlib4/pull/1148">mathlib4#1148</a></p>



<a name="317190263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317190263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317190263">(Dec 21 2022 at 15:52)</a>:</h4>
<p>I looked at it briefly --- it uses <code>bit1</code>, <code>bit0</code> and theorems about <code>bit</code> and <code>bit0/1</code>heavily so probably wants some design thought to use a more sensible definition of parity or blaze on.</p>



<a name="317191074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317191074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317191074">(Dec 21 2022 at 15:55)</a>:</h4>
<p>Is this something that needs to be done during or after the port?</p>



<a name="317191583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317191583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317191583">(Dec 21 2022 at 15:58)</a>:</h4>
<p>it's best to just translate as is for now; deprecate anything with <code>bit0</code>/<code>bit1</code> in the statement and put a TODO on any proofs that require referencing deprecated definitions (but otherwise translate them as normal), and do it all in a <code>section deprecated</code> where you turn off the linter (and put another TODO on that)</p>



<a name="317198765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317198765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317198765">(Dec 21 2022 at 16:33)</a>:</h4>
<p>In addition, the purpose of this file is to give users the option to avoid using <code>bit0</code> and <code>bit1</code>. So it seems like a good idea to port it. I will try to finish by tonight (CET)</p>



<a name="317272745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317272745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317272745">(Dec 22 2022 at 00:37)</a>:</h4>
<p>So, I just started making the non-trivial fixes. In doing so there was a problem with lean not being able to fill in the implicit parameters of binary_rec_eq. So I supplied them. I got one of the strangest errors I have seen thus far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Hb</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">),</span> <span class="n">brecPind</span> <span class="n">false</span> <span class="mi">0</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span>
<span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">binary_rec_eq</span> <span class="o">(</span><span class="n">Hb</span> <span class="n">h0</span><span class="o">)</span>
<span class="n">argument</span>
  <span class="n">Hb</span> <span class="n">h0</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">Eq</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">bit</span> <span class="n">false</span> <span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">brecPind</span> <span class="n">false</span> <span class="mi">0</span> <span class="n">h0</span><span class="o">)</span> <span class="n">h0</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">Eq</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">bit</span> <span class="n">false</span> <span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">brecPind</span> <span class="n">false</span> <span class="mi">0</span> <span class="n">h0</span><span class="o">)</span> <span class="n">h0</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>



<a name="317272891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317272891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317272891">(Dec 22 2022 at 00:39)</a>:</h4>
<p>(deleted)</p>



<a name="317273069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317273069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317273069">(Dec 22 2022 at 00:41)</a>:</h4>
<p>Here's the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Data.Nat.Basic</span>
<span class="kn">import</span> <span class="n">Mathlib.Init.Data.Nat.Bitwise</span>


<span class="kn">namespace</span> <span class="n">Nat</span>


<span class="kd">@[elab_as_elim]</span>
<span class="kd">def</span> <span class="n">evenOddRec</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">}</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">),</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">),</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">refine'</span> <span class="n">binaryRec</span> <span class="n">h0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">b</span> <span class="n">i</span> <span class="n">hi</span> <span class="bp">=&gt;</span> <span class="n">_</span><span class="o">)</span> <span class="n">n</span>
  <span class="n">cases</span> <span class="n">b</span>
  <span class="bp">·</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">bit</span><span class="o">,</span> <span class="n">bit0_val</span> <span class="n">i</span><span class="o">]</span> <span class="n">using</span> <span class="n">h_even</span> <span class="n">i</span> <span class="n">hi</span>
  <span class="bp">·</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">bit</span><span class="o">,</span> <span class="n">bit1_val</span> <span class="n">i</span><span class="o">]</span> <span class="n">using</span> <span class="n">h_odd</span> <span class="n">i</span> <span class="n">hi</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">nat.even_odd_rec</span> <span class="n">Nat.evenOddRec</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">even_odd_rec_zero</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="bp">@</span><span class="n">evenOddRec</span> <span class="n">_</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">h0</span> <span class="o">:=</span>
  <span class="n">binary_rec_zero</span> <span class="n">_</span> <span class="n">_</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">nat.even_odd_rec_zero</span> <span class="n">Nat.even_odd_rec_zero</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">even_odd_rec_even</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">h_even</span> <span class="mi">0</span> <span class="n">h0</span> <span class="bp">=</span> <span class="n">h0</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">@</span><span class="n">evenOddRec</span> <span class="n">_</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h_even</span> <span class="n">n</span> <span class="o">(</span><span class="n">evenOddRec</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">bit_val_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">bit</span> <span class="n">false</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">intro</span>
    <span class="n">rw</span><span class="o">[</span><span class="n">bit_val</span><span class="o">,</span> <span class="n">cond</span><span class="o">]</span>
    <span class="n">simp</span>
  <span class="k">have</span> <span class="n">bit_val_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">bit</span> <span class="n">true</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">intro</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">bit_val</span><span class="o">,</span> <span class="n">cond</span><span class="o">]</span>
  <span class="k">let</span> <span class="n">brecPind</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="o">(</span><span class="n">bit</span> <span class="n">b</span> <span class="n">n</span><span class="o">):=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h_n</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
    <span class="n">cases</span> <span class="n">b</span>
    <span class="n">case</span> <span class="n">false</span> <span class="bp">=&gt;</span>
        <span class="k">have</span> <span class="n">h_2n</span> <span class="o">:</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h_even</span> <span class="n">n</span> <span class="n">h_n</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">bit_val_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">h_2n</span>
        <span class="n">exact</span> <span class="n">h_2n</span>
    <span class="n">case</span> <span class="n">true</span> <span class="bp">=&gt;</span>
        <span class="k">have</span> <span class="n">h_2n_1</span> <span class="o">:</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h_odd</span> <span class="n">n</span> <span class="n">h_n</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">bit_val_one</span><span class="o">]</span> <span class="n">at</span> <span class="n">h_2n_1</span>
        <span class="n">exact</span> <span class="n">h_2n_1</span>
  <span class="k">have</span> <span class="n">Hb</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">brecPind</span> <span class="n">false</span> <span class="mi">0</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="gr">sorry</span>
  <span class="n">refine</span> <span class="bp">@</span><span class="n">binary_rec_eq</span> <span class="n">P</span> <span class="n">h0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">b</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">Hb</span> <span class="n">h0</span><span class="o">)</span> <span class="n">false</span> <span class="n">n</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="o">(</span><span class="n">bit0_eq_two_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="o">(</span><span class="n">bit0_eq_two_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
  <span class="bp">·</span> <span class="n">apply</span> <span class="n">heq_of_cast_eq</span>
    <span class="n">rfl</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="n">H</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">even_odd_rec_odd</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">h_even</span> <span class="mi">0</span> <span class="n">h0</span> <span class="bp">=</span> <span class="n">h0</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">@</span><span class="n">evenOddRec</span> <span class="n">_</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h_odd</span> <span class="n">n</span> <span class="o">(</span><span class="n">evenOddRec</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">convert</span> <span class="n">binary_rec_eq</span> <span class="n">_</span> <span class="n">true</span> <span class="n">n</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="o">(</span><span class="n">bit0_eq_two_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="o">(</span><span class="n">bit0_eq_two_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
  <span class="bp">·</span> <span class="n">apply</span> <span class="n">heq_of_cast_eq</span>
    <span class="n">rfl</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="n">H</span>


<span class="kd">end</span> <span class="n">Nat</span>
</code></pre></div>



<a name="317273097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317273097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317273097">(Dec 22 2022 at 00:41)</a>:</h4>
<p>You can see the other theorem in its pristine lean3 form for comparison. The proofs are almost entirely identical</p>



<a name="317273223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317273223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317273223">(Dec 22 2022 at 00:43)</a>:</h4>
<p>The question is, how does this error even make sense?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">argument</span>
  <span class="n">Hb</span> <span class="n">h0</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">Eq</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">bit</span> <span class="n">false</span> <span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">brecPind</span> <span class="n">false</span> <span class="mi">0</span> <span class="n">h0</span><span class="o">)</span> <span class="n">h0</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">Eq</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">bit</span> <span class="n">false</span> <span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">brecPind</span> <span class="n">false</span> <span class="mi">0</span> <span class="n">h0</span><span class="o">)</span> <span class="n">h0</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>



<a name="317273338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317273338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317273338">(Dec 22 2022 at 00:45)</a>:</h4>
<p>If you switch <code>pp.all</code> on you'll see they're different.</p>



<a name="317273565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317273565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317273565">(Dec 22 2022 at 00:47)</a>:</h4>
<p>But <code>@Eq</code> seems to suggest that all implicit parameters are already in there</p>



<a name="317273647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317273647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317273647">(Dec 22 2022 at 00:48)</a>:</h4>
<p>yeah you're right, I don't see why they can't match.</p>



<a name="317273678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317273678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317273678">(Dec 22 2022 at 00:48)</a>:</h4>
<p>Oh but pp.all shows more than just the implicit parameters -- everything has to match -- but I don't see why it won't match.</p>



<a name="317274150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317274150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317274150">(Dec 22 2022 at 00:54)</a>:</h4>
<p>Ok I think I fixed it.</p>



<a name="317274287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317274287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317274287">(Dec 22 2022 at 00:56)</a>:</h4>
<p>Nice. I would really not recommend doing what you're doing though: you're defining <code>brecPind</code> in tactic mode with <code>rw</code> so there will be random stuck <code>eq.rec</code>s in your definition and it will be hell to work with.</p>



<a name="317274348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317274348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317274348">(Dec 22 2022 at 00:57)</a>:</h4>
<p>What's the cleaner method?</p>



<a name="317274368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317274368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317274368">(Dec 22 2022 at 00:57)</a>:</h4>
<p>I don't know enough about Lean 4 to answer this :-(</p>



<a name="317274472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317274472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317274472">(Dec 22 2022 at 00:59)</a>:</h4>
<p>But this approach is not being used in the Lean 3 file. Did you have to diverge from the autoported file for some reason?</p>



<a name="317274551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317274551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317274551">(Dec 22 2022 at 01:00)</a>:</h4>
<p>Yeah<br>
You can see the proof of the theorem after. These two proofs are exactly identical (except true vs false)</p>



<a name="317274567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317274567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317274567">(Dec 22 2022 at 01:00)</a>:</h4>
<p><code>even_odd_rec_odd</code></p>



<a name="317274615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317274615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317274615">(Dec 22 2022 at 01:01)</a>:</h4>
<p>The error you get there is <br>
<code>don't know how to synthesize implicit argument</code><br>
<code>@binary_rec_eq ?m.5713 ?m.5714 ?m.5715 ?m.5716 true n</code></p>



<a name="317274737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317274737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317274737">(Dec 22 2022 at 01:03)</a>:</h4>
<p>The second one is the mathlib3 version with the minor corrections necessary for mathlib4 (tt =&gt; true, ff =&gt; false)</p>



<a name="317274827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317274827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317274827">(Dec 22 2022 at 01:04)</a>:</h4>
<p>I would be tempted to <code>convert @binary_rec_eq _ _ _ _ true n</code> and then try and fill in the blanks</p>



<a name="317274908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317274908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317274908">(Dec 22 2022 at 01:05)</a>:</h4>
<p>Doesn't work. The first two blanks are easy to fill. This still leaves the blank for the parameter <code>f</code> which is where <code>brecPind</code> comes in</p>



<a name="317275303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317275303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317275303">(Dec 22 2022 at 01:11)</a>:</h4>
<p>Also, I am learning that unfold looks for names only in <code>_root_.</code>. It wont unfold <code>brecPind</code></p>



<a name="317275604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317275604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317275604">(Dec 22 2022 at 01:15)</a>:</h4>
<p>yeah this sort of thing is hell, and a very long way from my area of expertise (I'm a mathematician).</p>



<a name="317275689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317275689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317275689">(Dec 22 2022 at 01:16)</a>:</h4>
<p>Here's a funny goal when I use brecPind: <code>instMulNat = { mul := Nat.add }</code></p>



<a name="317275725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317275725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317275725">(Dec 22 2022 at 01:17)</a>:</h4>
<p>I am beginning to think lean4 believes <code>2+2 = potato</code></p>



<a name="317276374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317276374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317276374">(Dec 22 2022 at 01:27)</a>:</h4>
<p>Lean 3 <code>convert</code> seems more powerful than Lean 4 <code>convert</code> here?</p>



<a name="317276606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317276606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317276606">(Dec 22 2022 at 01:30)</a>:</h4>
<p>or probably even broken</p>



<a name="317276640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317276640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317276640">(Dec 22 2022 at 01:31)</a>:</h4>
<p>As far as I know this is false. In another <code>case</code> it asked me to show <code>n=2</code>, without any relevant additional hypothesis.</p>



<a name="317276740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317276740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317276740">(Dec 22 2022 at 01:33)</a>:</h4>
<p>My limited understanding of lean tactics is that they make sound transformations</p>



<a name="317276836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317276836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317276836">(Dec 22 2022 at 01:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="466334">Shreyas Srinivas</span> <a href="#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317275303">said</a>:</p>
<blockquote>
<p>Also, I am learning that unfold looks for names only in <code>_root_.</code>. It wont unfold <code>brecPind</code></p>
</blockquote>
<p>You could try defining it outside the proof. In Lean 3 we use a trick called <code>eq_to_hom</code> which given a proof that <code>a = b</code> will give you a map from <code>P a</code> to <code>P b</code>, and we have a bunch of API around it.</p>



<a name="317276895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317276895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317276895">(Dec 22 2022 at 01:35)</a>:</h4>
<p>I don't think that works in this case. We will have to parametrise on the predicate <code>P</code>. This will bring us back to square one</p>



<a name="317276946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317276946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317276946">(Dec 22 2022 at 01:36)</a>:</h4>
<p>In any case, I worked around the <code>unfold</code> limitation`</p>



<a name="317276966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317276966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317276966">(Dec 22 2022 at 01:36)</a>:</h4>
<p><code>convert</code>'s doc-string says it is actually an improved version of <code>refine</code> which means it is less strict about providing complete terms. So it is odd that it cannot handle implicit terms that lean3's version can, or that it can produce absurd looking goals.</p>



<a name="317277031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277031">(Dec 22 2022 at 01:38)</a>:</h4>
<p>it's not odd that <code>convert</code> will produce false goals sometimes, this usually means it has gone too deep and you need to use <code>convert ... using 1</code> or so</p>



<a name="317277213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277213">(Dec 22 2022 at 01:41)</a>:</h4>
<p>The issue is that <code>convert</code> refuses to eat <code>binary_rec_eq _ true n</code> in Lean 4 whereas it did so in Lean 3 -- the tactic fails in Lean 4.</p>



<a name="317277293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277293">(Dec 22 2022 at 01:42)</a>:</h4>
<p>would be nice if there was an MWE that didn't require me to pull the branch...</p>



<a name="317277303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277303">(Dec 22 2022 at 01:42)</a>:</h4>
<p>You can see the problem in the MWE posted above. Forget about the long broken proof: the proof after is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">even_odd_rec_odd</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">h_even</span> <span class="mi">0</span> <span class="n">h0</span> <span class="bp">=</span> <span class="n">h0</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">@</span><span class="n">evenOddRec</span> <span class="n">_</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h_odd</span> <span class="n">n</span> <span class="o">(</span><span class="n">evenOddRec</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">convert</span> <span class="n">binary_rec_eq</span> <span class="n">_</span> <span class="n">true</span> <span class="n">n</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="o">(</span><span class="n">bit0_eq_two_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="o">(</span><span class="n">bit0_eq_two_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
  <span class="bp">·</span> <span class="n">apply</span> <span class="n">heq_of_cast_eq</span>
    <span class="n">rfl</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="n">H</span>
</code></pre></div>
<p>This is what the autoporter produced. But the <code>convert</code> fails and I've just spent an hour trying to make it not fail, and failed.</p>



<a name="317277313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277313">(Dec 22 2022 at 01:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="466334">Shreyas Srinivas</span> <a href="#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317273069">said</a>:</p>
<blockquote>
<p>Here's the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Data.Nat.Basic</span>
<span class="kn">import</span> <span class="n">Mathlib.Init.Data.Nat.Bitwise</span>


<span class="kn">namespace</span> <span class="n">Nat</span>


<span class="kd">@[elab_as_elim]</span>
<span class="kd">def</span> <span class="n">evenOddRec</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">}</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">),</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">),</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">refine'</span> <span class="n">binaryRec</span> <span class="n">h0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">b</span> <span class="n">i</span> <span class="n">hi</span> <span class="bp">=&gt;</span> <span class="n">_</span><span class="o">)</span> <span class="n">n</span>
  <span class="n">cases</span> <span class="n">b</span>
  <span class="bp">·</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">bit</span><span class="o">,</span> <span class="n">bit0_val</span> <span class="n">i</span><span class="o">]</span> <span class="n">using</span> <span class="n">h_even</span> <span class="n">i</span> <span class="n">hi</span>
  <span class="bp">·</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">bit</span><span class="o">,</span> <span class="n">bit1_val</span> <span class="n">i</span><span class="o">]</span> <span class="n">using</span> <span class="n">h_odd</span> <span class="n">i</span> <span class="n">hi</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">nat.even_odd_rec</span> <span class="n">Nat.evenOddRec</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">even_odd_rec_zero</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="bp">@</span><span class="n">evenOddRec</span> <span class="n">_</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">h0</span> <span class="o">:=</span>
  <span class="n">binary_rec_zero</span> <span class="n">_</span> <span class="n">_</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">nat.even_odd_rec_zero</span> <span class="n">Nat.even_odd_rec_zero</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">even_odd_rec_even</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">h_even</span> <span class="mi">0</span> <span class="n">h0</span> <span class="bp">=</span> <span class="n">h0</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">@</span><span class="n">evenOddRec</span> <span class="n">_</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h_even</span> <span class="n">n</span> <span class="o">(</span><span class="n">evenOddRec</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">bit_val_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">bit</span> <span class="n">false</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">intro</span>
    <span class="n">rw</span><span class="o">[</span><span class="n">bit_val</span><span class="o">,</span> <span class="n">cond</span><span class="o">]</span>
    <span class="n">simp</span>
  <span class="k">have</span> <span class="n">bit_val_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">bit</span> <span class="n">true</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">intro</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">bit_val</span><span class="o">,</span> <span class="n">cond</span><span class="o">]</span>
  <span class="k">let</span> <span class="n">brecPind</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="o">(</span><span class="n">bit</span> <span class="n">b</span> <span class="n">n</span><span class="o">):=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h_n</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
    <span class="n">cases</span> <span class="n">b</span>
    <span class="n">case</span> <span class="n">false</span> <span class="bp">=&gt;</span>
        <span class="k">have</span> <span class="n">h_2n</span> <span class="o">:</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h_even</span> <span class="n">n</span> <span class="n">h_n</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">bit_val_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">h_2n</span>
        <span class="n">exact</span> <span class="n">h_2n</span>
    <span class="n">case</span> <span class="n">true</span> <span class="bp">=&gt;</span>
        <span class="k">have</span> <span class="n">h_2n_1</span> <span class="o">:</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h_odd</span> <span class="n">n</span> <span class="n">h_n</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">bit_val_one</span><span class="o">]</span> <span class="n">at</span> <span class="n">h_2n_1</span>
        <span class="n">exact</span> <span class="n">h_2n_1</span>
  <span class="n">refine</span> <span class="bp">@</span><span class="n">binary_rec_eq</span> <span class="n">P</span> <span class="n">h0</span> <span class="n">brecPind</span> <span class="n">H</span> <span class="n">false</span> <span class="n">n</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="o">(</span><span class="n">bit0_eq_two_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="o">(</span><span class="n">bit0_eq_two_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
  <span class="bp">·</span> <span class="n">apply</span> <span class="n">heq_of_cast_eq</span>
    <span class="n">rfl</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="n">H</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">even_odd_rec_odd</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">h_even</span> <span class="mi">0</span> <span class="n">h0</span> <span class="bp">=</span> <span class="n">h0</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">@</span><span class="n">evenOddRec</span> <span class="n">_</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h_odd</span> <span class="n">n</span> <span class="o">(</span><span class="n">evenOddRec</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">convert</span> <span class="n">binary_rec_eq</span> <span class="n">_</span> <span class="n">true</span> <span class="n">n</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="o">(</span><span class="n">bit0_eq_two_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="o">(</span><span class="n">bit0_eq_two_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
  <span class="bp">·</span> <span class="n">apply</span> <span class="n">heq_of_cast_eq</span>
    <span class="n">rfl</span>
  <span class="bp">·</span> <span class="n">exact</span> <span class="n">H</span>


<span class="kd">end</span> <span class="n">Nat</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Here</p>



<a name="317277317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277317">(Dec 22 2022 at 01:42)</a>:</h4>
<p>It's the entire file because I wanted to show multiple things</p>



<a name="317277344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277344">(Dec 22 2022 at 01:43)</a>:</h4>
<p>Made some changes</p>



<a name="317277517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277517">(Dec 22 2022 at 01:46)</a>:</h4>
<ol>
<li>The lean3 proof of <code>even_odd_rec_odd</code> and <code>even_odd_rec_even</code> are identical </li>
<li>If you open the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> now. In <code>even_odd_rec_even</code> I had to insert explicit arguments (same as <code>even_odd_rec_odd</code>, but I left it untouched for reference). These produced absurd case distinctions.</li>
</ol>



<a name="317277524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277524">(Dec 22 2022 at 01:46)</a>:</h4>
<p>this MWE shouldn't need any imports at all</p>



<a name="317277534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277534">(Dec 22 2022 at 01:46)</a>:</h4>
<p>You need <code>binaryRec</code></p>



<a name="317277551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277551">(Dec 22 2022 at 01:47)</a>:</h4>
<p>then state it</p>



<a name="317277554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277554">(Dec 22 2022 at 01:47)</a>:</h4>
<p>It compiles fine on mathlib master and building the imports is also super-quick</p>



<a name="317277556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277556">(Dec 22 2022 at 01:47)</a>:</h4>
<p>Bitwise is necessary. binaryRec, binary_rec_eq, and all basic Nat stuff</p>



<a name="317277567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277567">(Dec 22 2022 at 01:47)</a>:</h4>
<p>It also works quickly on the lean4 playground</p>



<a name="317277576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277576">(Dec 22 2022 at 01:48)</a>:</h4>
<p>I've been building since 5 minutes ago -_-</p>



<a name="317277635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277635">(Dec 22 2022 at 01:48)</a>:</h4>
<p>you need <code>bodd</code> and all the other stuff Shreyas has been porting over the last few days. A mathlib-free MWE would be horrible</p>



<a name="317277640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277640">(Dec 22 2022 at 01:48)</a>:</h4>
<p>switching branches is super painful because of the nightly bumps</p>



<a name="317277643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277643">(Dec 22 2022 at 01:48)</a>:</h4>
<p>Is it possible to make tools to make MWEs?</p>



<a name="317277649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277649">(Dec 22 2022 at 01:48)</a>:</h4>
<p><a href="/user_uploads/3121/M5w7pNW_OGgTF_vVoUEziJED/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/M5w7pNW_OGgTF_vVoUEziJED/image.png" title="image.png"><img src="/user_uploads/3121/M5w7pNW_OGgTF_vVoUEziJED/image.png"></a></div>



<a name="317277659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277659">(Dec 22 2022 at 01:49)</a>:</h4>
<p>I tried that and failed on the imports</p>



<a name="317277660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277660">(Dec 22 2022 at 01:49)</a>:</h4>
<p>You can open this on the playground</p>



<a name="317277668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277668">(Dec 22 2022 at 01:49)</a>:</h4>
<p>because I was on a branch from yesterday I guess</p>



<a name="317277674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277674">(Dec 22 2022 at 01:50)</a>:</h4>
<p>but for an MWE there are way too many lines</p>



<a name="317277720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277720">(Dec 22 2022 at 01:50)</a>:</h4>
<p>I used the playground button on the screenshot</p>



<a name="317277769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277769">(Dec 22 2022 at 01:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317277668">said</a>:</p>
<blockquote>
<p>because I was on a branch from yesterday I guess</p>
</blockquote>
<p>It's one def, one trivial theorem, and two nearly identical theorems. At best, the first trivial theorem could be removed, but that might also cause problems. The other two theorems depend on the def.</p>



<a name="317277828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277828">(Dec 22 2022 at 01:52)</a>:</h4>
<p>And both these theorems have the same issue.</p>
<ol>
<li>In the first one, I show what happens when you give explicit arguments to the convert line.</li>
<li>In the second one, I leave the lean3 version of the proof as is, so you can see the issue with the mathlib3 version of the proof.</li>
</ol>



<a name="317277833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277833">(Dec 22 2022 at 01:52)</a>:</h4>
<p>I don't see any meaningful ways to reduce this.</p>



<a name="317277933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277933">(Dec 22 2022 at 01:54)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Data.Nat.Basic</span>

<span class="kd">def</span> <span class="n">bit</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">cond</span> <span class="n">b</span> <span class="n">bit1</span> <span class="n">bit0</span>
<span class="kd">theorem</span> <span class="n">bit0_val</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">bit0</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">theorem</span> <span class="n">bit1_val</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">bit1</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">binaryRec</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">C</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span> <span class="n">n</span><span class="o">,</span> <span class="n">C</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">bit</span> <span class="n">b</span> <span class="n">n</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">C</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">binary_rec_eq</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">C</span> <span class="mi">0</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span> <span class="n">n</span><span class="o">,</span> <span class="n">C</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">bit</span> <span class="n">b</span> <span class="n">n</span><span class="o">)}</span>
    <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="n">false</span> <span class="mi">0</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">binaryRec</span> <span class="n">z</span> <span class="n">f</span> <span class="o">(</span><span class="n">bit</span> <span class="n">b</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span> <span class="n">n</span> <span class="o">(</span><span class="n">binaryRec</span> <span class="n">z</span> <span class="n">f</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">@[elab_as_elim]</span>
<span class="kd">def</span> <span class="n">evenOddRec</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">}</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">),</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">),</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">refine'</span> <span class="n">binaryRec</span> <span class="n">h0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">b</span> <span class="n">i</span> <span class="n">hi</span> <span class="bp">=&gt;</span> <span class="n">_</span><span class="o">)</span> <span class="n">n</span>
  <span class="n">cases</span> <span class="n">b</span>
  <span class="bp">·</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">bit</span><span class="o">,</span> <span class="n">bit0_val</span> <span class="n">i</span><span class="o">]</span> <span class="n">using</span> <span class="n">h_even</span> <span class="n">i</span> <span class="n">hi</span>
  <span class="bp">·</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">bit</span><span class="o">,</span> <span class="n">bit1_val</span> <span class="n">i</span><span class="o">]</span> <span class="n">using</span> <span class="n">h_odd</span> <span class="n">i</span> <span class="n">hi</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">even_odd_rec_odd</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">h_even</span> <span class="mi">0</span> <span class="n">h0</span> <span class="bp">=</span> <span class="n">h0</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">@</span><span class="n">evenOddRec</span> <span class="n">_</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h_odd</span> <span class="n">n</span> <span class="o">(</span><span class="n">evenOddRec</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">convert</span> <span class="n">binary_rec_eq</span> <span class="n">_</span> <span class="n">true</span> <span class="n">n</span>
</code></pre></div>



<a name="317277959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317277959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317277959">(Dec 22 2022 at 01:55)</a>:</h4>
<p>you can get rid of nat.basic too if you remove the <code>\N</code> syntax, but we don't need to go full mathlib-free here since <code>convert</code> is a mathlib tactic anyway</p>



<a name="317278406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317278406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317278406">(Dec 22 2022 at 02:02)</a>:</h4>
<p>yeah but you've sorried a bunch of data now, so if you get the <code>convert</code> working then it might not work in the actual use case?</p>



<a name="317278429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317278429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317278429">(Dec 22 2022 at 02:03)</a>:</h4>
<p>true, if definition unfolding is involved then you should provide the bodies of defs</p>



<a name="317278762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317278762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317278762">(Dec 22 2022 at 02:09)</a>:</h4>
<p>In this case it would take a lot longer to make the mwe (with only proofs sorried) than it would take you to compile Data.Nat.Basic :-( It can take a super-long time to make mathlib-free mwes now, this is why I was asking about auto-generating them (apparently they can do it in Coq?)</p>



<a name="317278779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317278779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317278779">(Dec 22 2022 at 02:09)</a>:</h4>
<p>Auto-generating MWEs would be very cool</p>



<a name="317278786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317278786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317278786">(Dec 22 2022 at 02:09)</a>:</h4>
<p>I think there are a couple levels we have to unlock before we can get there though</p>



<a name="317278847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317278847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317278847">(Dec 22 2022 at 02:10)</a>:</h4>
<p>But the set of things that come to bear on a single line of proof is generally approximately constant</p>



<a name="317278883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317278883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317278883">(Dec 22 2022 at 02:11)</a>:</h4>
<p>(unless it's a really bad definition-unfolding proof or a typeclass problem)</p>



<a name="317278945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317278945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317278945">(Dec 22 2022 at 02:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317278779">said</a>:</p>
<blockquote>
<p>Auto-generating MWEs would be very cool</p>
</blockquote>
<p>Could this not be hard to debug though? Especially in tactic heavy proofs</p>



<a name="317278950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317278950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317278950">(Dec 22 2022 at 02:12)</a>:</h4>
<p>why?</p>



<a name="317278962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317278962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317278962">(Dec 22 2022 at 02:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317278406">said</a>:</p>
<blockquote>
<p>yeah but you've sorried a bunch of data now, so if you get the <code>convert</code> working then it might not work in the actual use case?</p>
</blockquote>
<p>This for example</p>



<a name="317278963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317278963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317278963">(Dec 22 2022 at 02:12)</a>:</h4>
<p>the other tactics in the proof are hopefully not relevant and can be removed</p>



<a name="317278990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317278990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317278990">(Dec 22 2022 at 02:13)</a>:</h4>
<p>As long as <code>convert</code> doesn't unfold the definition, it doesn't matter what's behind it</p>



<a name="317279006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317279006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317279006">(Dec 22 2022 at 02:13)</a>:</h4>
<p>In this case I belatedly realized you are unfolding <code>evenOddRec</code> to <code>binaryRec</code> in this line of proof so we need that definition, but not the stack leading up to <code>binaryRec</code></p>



<a name="317280093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317280093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317280093">(Dec 22 2022 at 02:31)</a>:</h4>
<p>In broad terms: Tactics are doing very useful, but invisible work behind the scenes . It takes time to hone one's understanding about their exact behaviour. So one can only make educated guesses about what causes the error one observes using the tactic state output (and maybe pp). For example, if Kevin had not pointed out that sorrying out things might remove errors in downstream tactic uses, I would assume that such an example is in fact adequate.</p>



<a name="317280192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317280192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317280192">(Dec 22 2022 at 02:32)</a>:</h4>
<p>I think it's fine to start with aggressive sorrying and re-add stuff if it turns out it was oversimplified</p>



<a name="317280348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317280348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317280348">(Dec 22 2022 at 02:34)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[elab_as_elim]</span>
<span class="kd">def</span> <span class="n">evenOddRec</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">}</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">),</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">),</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="o">:=</span>
  <span class="n">binaryRec</span> <span class="n">h0</span> <span class="o">(</span><span class="k">fun</span>
    <span class="bp">|</span> <span class="n">false</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">hi</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">bit0_val</span> <span class="n">i</span> <span class="bp">▸</span> <span class="n">h_even</span> <span class="n">i</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">P</span> <span class="o">(</span><span class="n">bit0</span> <span class="n">i</span><span class="o">))</span>
    <span class="bp">|</span> <span class="n">true</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">hi</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">bit1_val</span> <span class="n">i</span> <span class="bp">▸</span> <span class="n">h_odd</span> <span class="n">i</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">P</span> <span class="o">(</span><span class="n">bit1</span> <span class="n">i</span><span class="o">)))</span> <span class="n">n</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">even_odd_rec_even</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">h_even</span> <span class="mi">0</span> <span class="n">h0</span> <span class="bp">=</span> <span class="n">h0</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">@</span><span class="n">evenOddRec</span> <span class="n">_</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h_even</span> <span class="n">n</span> <span class="o">(</span><span class="n">evenOddRec</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">bit</span> <span class="n">false</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">HEq</span> <span class="o">(</span><span class="bp">@</span><span class="n">evenOddRec</span> <span class="n">_</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="n">a</span><span class="o">)</span> <span class="n">_</span>
    <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">evenOddRec</span><span class="o">,</span> <span class="n">binary_rec_eq</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">eq_rec_heq</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">H</span>
  <span class="n">eq_of_heq</span> <span class="o">(</span><span class="n">this</span> <span class="n">_</span> <span class="o">(</span><span class="n">bit0_val</span> <span class="n">_</span><span class="o">))</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">even_odd_rec_odd</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h_even</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">h_even</span> <span class="mi">0</span> <span class="n">h0</span> <span class="bp">=</span> <span class="n">h0</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">@</span><span class="n">evenOddRec</span> <span class="n">_</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h_odd</span> <span class="n">n</span> <span class="o">(</span><span class="n">evenOddRec</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">bit</span> <span class="n">true</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">HEq</span> <span class="o">(</span><span class="bp">@</span><span class="n">evenOddRec</span> <span class="n">_</span> <span class="n">h0</span> <span class="n">h_even</span> <span class="n">h_odd</span> <span class="n">a</span><span class="o">)</span> <span class="n">_</span>
    <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">evenOddRec</span><span class="o">,</span> <span class="n">binary_rec_eq</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">eq_rec_heq</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">H</span>
  <span class="n">eq_of_heq</span> <span class="o">(</span><span class="n">this</span> <span class="n">_</span> <span class="o">(</span><span class="n">bit1_val</span> <span class="n">_</span><span class="o">))</span>
</code></pre></div>



<a name="317280735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317280735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317280735">(Dec 22 2022 at 02:40)</a>:</h4>
<p>okay that worked wow!</p>



<a name="317280752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317280752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317280752">(Dec 22 2022 at 02:40)</a>:</h4>
<p>I will commit this as is, but I am going to spend some time understanding this afterwards</p>



<a name="317282156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317282156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317282156">(Dec 22 2022 at 03:03)</a>:</h4>
<p>So in this proof you used heterogeneous equality, which I am guessing coerces equality between values of different types. Is there like a comprehensive list of ways this can go wrong (apart from the <code>congr</code> issue)? It seems quite handy for functional programmers, so I can see this getting wrongly used</p>



<a name="317282440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317282440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317282440">(Dec 22 2022 at 03:07)</a>:</h4>
<p><code>Data.Nat.EvenOddRec</code> passed all checks and is ready to merge.</p>



<a name="317283900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317283900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317283900">(Dec 22 2022 at 03:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="466334">Shreyas Srinivas</span> <a href="#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317282156">said</a>:</p>
<blockquote>
<p>So in this proof you used heterogeneous equality, which I am guessing coerces equality between values of different types. Is there like a comprehensive list of ways this can go wrong (apart from the <code>congr</code> issue)? It seems quite handy for functional programmers, when dealing with representation issues, so I can potentially see this getting wrongly used</p>
</blockquote>
<p>This sort of thing is what we call "DTT hell". It hopefully doesn't come up that often, but this is the standard trick for dealing with it: do induction on some equality with a carefully chosen "motive" (that is, the type of the <code>have</code> statement in this example) to do dependent rewrites. Most of lean's tactics will not handle this situation well, either complaining "the motive is not type correct" or doing nothing at all, so you have to do it manually in this way.</p>



<a name="317283972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317283972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317283972">(Dec 22 2022 at 03:32)</a>:</h4>
<p>the heterogeneous equality is needed to make the motive typecheck, since the LHS has type <code>P a</code> and the RHS has type <code>P (2 * n)</code></p>



<a name="317284072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317284072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317284072">(Dec 22 2022 at 03:35)</a>:</h4>
<p>I'm not sure exactly what you mean by ways this can go wrong. This is a proof technique, it has a limited range of applicability but if it works then it works</p>



<a name="317284778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317284778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317284778">(Dec 22 2022 at 03:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317283900">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="466334">Shreyas Srinivas</span> <a href="#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317282156">said</a>:</p>
<blockquote>
<p>So in this proof you used heterogeneous equality, which I am guessing coerces equality between values of different types. Is there like a comprehensive list of ways this can go wrong (apart from the <code>congr</code> issue)? It seems quite handy for functional programmers, when dealing with representation issues, so I can potentially see this getting wrongly used</p>
</blockquote>
<p>This sort of thing is what we call "DTT hell". It hopefully doesn't come up that often, but this is the standard trick for dealing with it: do induction on some equality with a carefully chosen "motive" (that is, the type of the <code>have</code> statement in this example) to do dependent rewrites. Most of lean's tactics will not handle this situation well, either complaining "the motive is not type correct" or doing nothing at all, so you have to do it manually in this way.</p>
</blockquote>
<p>By "going wrong" I am referring to the note of caution inside <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HEq#doc">docs4#HEq</a></p>



<a name="317284872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317284872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317284872">(Dec 22 2022 at 03:49)</a>:</h4>
<p>But I think I get the gist</p>



<a name="317284877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317284877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317284877">(Dec 22 2022 at 03:49)</a>:</h4>
<p>Thanks</p>



<a name="317436955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317436955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317436955">(Dec 22 2022 at 19:25)</a>:</h4>
<p>Hi,<br>
I noticed that <a href="https://github.com/leanprover-community/mathlib4/pull/1148">mathlib4#1148</a> has not been merged yet. Is there some issue with this PR that needs fixing?</p>



<a name="317437788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317437788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317437788">(Dec 22 2022 at 19:30)</a>:</h4>
<p>It has no reviews and at the time of writing it doesn't even have a green tick. We don't yet know if there are issues with this PR that need fixing because it looks like nobody got round to looking at it yet other than Reid, who fixed some naming. Wel'l get there. Is this file on the critical line to any of the standard targets like data.real.basic ? Usually when I review I start at the top of <a href="https://bit.ly/3cKk3ld">#queue4</a> and probably when you get the green tick back you'll be at the bottom of that queue? I'm not sure about how the order works to be honest.</p>



<a name="317438402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317438402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317438402">(Dec 22 2022 at 19:33)</a>:</h4>
<p>Ah okay, I noticed a fresh commit from <span class="user-mention" data-user-id="110032">@Reid Barton</span></p>



<a name="317438499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317438499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317438499">(Dec 22 2022 at 19:34)</a>:</h4>
<p>Some names were fixed to meet the lean4 style. As I recall it, it was green last night.</p>



<a name="317442214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Data.Nat.EvenOddRec/near/317442214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec.html#317442214">(Dec 22 2022 at 19:59)</a>:</h4>
<p>Feel free to review other PRs on <a href="https://bit.ly/3cKk3ld">#queue4</a> ; this will get yours to the top quicker.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
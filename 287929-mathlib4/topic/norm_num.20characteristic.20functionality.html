---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html">norm_num characteristic functionality</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="321293076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321293076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321293076">(Jan 14 2023 at 02:39)</a>:</h4>
<p>While the functionality for rational numbers now works (yay!), the given example in <a href="https://github.com/leanprover-community/mathlib4/pull/1102">mathlib4#1102</a> (<code>example {α} [DivisionRing α] [CharZero α] : (-1:α) ≠ 2 := by norm_num</code>) still doesn't, because characteristic functionality is something else. Maybe there should be a new issue for that? <span class="user-mention" data-user-id="260507">@Heather Macbeth</span> how time-sensitive is support for characteristics vs., say, <code>ring</code>?</p>



<a name="321301078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321301078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321301078">(Jan 14 2023 at 05:03)</a>:</h4>
<p>(Or, actually—would this count as <code>≠</code> functionality? <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span>)</p>



<a name="321301336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321301336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321301336">(Jan 14 2023 at 05:06)</a>:</h4>
<p>yes</p>



<a name="321301347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321301347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321301347">(Jan 14 2023 at 05:06)</a>:</h4>
<p>we need inequalities, including !=</p>



<a name="321302813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321302813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321302813">(Jan 14 2023 at 05:28)</a>:</h4>
<p>tracking issue for inequalities: <a href="https://github.com/leanprover-community/mathlib4/pull/1567">mathlib4#1567</a></p>



<a name="321302826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321302826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321302826">(Jan 14 2023 at 05:28)</a>:</h4>
<p>open PR for <code>≠</code> in particular: <a href="https://github.com/leanprover-community/mathlib4/pull/1568">mathlib4#1568</a></p>



<a name="321401756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321401756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321401756">(Jan 14 2023 at 19:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="548935">Thomas Murrills</span> <a href="#narrow/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality/near/321293076">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> how time-sensitive is support for characteristics vs., say, <code>ring</code>?</p>
</blockquote>
<p>cross-ref to <a href="#narrow/stream/287929-mathlib4/topic/Rat.20in.20norm_num/near/321399782">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat.20in.20norm_num/near/321399782</a> for further discussion of Thomas' questions about priorities.</p>



<a name="321414611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321414611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321414611">(Jan 14 2023 at 22:29)</a>:</h4>
<p>Am I right in thinking we’ll need something like <code>.isProp typeExpr proof</code> as a constructor for <code>Result</code>(<code>'</code>)? or possibly <code>.isNe α proof</code>, <code>.isLe α proof</code>, etc.?</p>
<p>If so is one of these obviously better? And if the latter, what about e.g. <code>.isNe α lhs rhs proof</code> instead for results lhs and rhs? I’m wondering about the latter in case any later tactics will need to actually string these results together somehow, and I’m wondering if they might need some extra info from a result.</p>



<a name="321415076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321415076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321415076">(Jan 14 2023 at 22:35)</a>:</h4>
<p>(We could also do something like <code>isRel α rel lhs rhs proof</code> with <code>rel</code> representing the (name of the) relation somehow, e.g. tokens <code>.le</code>, <code>.ne</code> or something if we wanted to cut down on how many constructors we have for <code>Result</code>.)</p>



<a name="321453079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321453079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321453079">(Jan 15 2023 at 08:02)</a>:</h4>
<p>I think I’ve got an idea for how to structure things in the move to give <code>norm_num</code> the ability to prove props.</p>
<p>so, there are really only two possible purposes of any given norm_num extension: it’s either constructing a literal value (a number) or proving a <code>Prop</code>. We know its purpose in advance.</p>
<p>So the thought is: what if we added a(n essentially boolean) parameter to <code>Result</code> and <code>NormNumExt</code> to keep track of which kind of thing they’re doing? This would make the code easier to handle since we could keep the two cases separate. <code>.isRat</code> etc. would construct values of <code>Result .num e</code>, whereas e.g. <code>.isLe</code> (or however exactly we did it) would construct values of <code>Result .prop e</code>. That should mean we wouldn’t be matching on constructors in extension code that didn’t make sense to match on. We’d also know e.g. whether it made sense to extract a literal from a <code>Result</code> based on the type (though I guess that’s not too much of an issue since we work in <code>Option</code> and can have things just fail, but still).</p>
<p>This might mean maintaining two discrimination trees, one for <code>NormNumExt .prop</code> and one for <code>NormNumExt .num</code>—not sure. <code>derive</code> would get an extra argument like this as well, saying whether it should try to derive a number or a prop. (We’d need to infer the kind of result we wanted from the expression at the beginning of the outermost norm_num process, but it’s easy to test an expression for <code>Prop</code>hood, iirc?)</p>
<p>I think it would keep the code cleaner, but what I don’t know is whether it would be good for performance. Keeping the two discrimination trees separate might be good for performance, or it could be negligible; likewise for matching on less constructors and the opposite for having more arguments in Result.</p>
<p>Giving <code>norm_num</code> the ability to handle <code>Prop</code>s will mean refactoring/updating code in one place or another, and this is the least annoying way I can think of—it lets us leave basically all of our number-handling code as-is at the cost of a little change to the infrastructure. Plus we get useful information in the type.</p>
<p>If this sounds good lmk and I’ll have fun implementing it!</p>



<a name="321515134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321515134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321515134">(Jan 15 2023 at 17:51)</a>:</h4>
<p><span class="user-mention" data-user-id="548935">@Thomas Murrills</span> I pushed some changes to your branch to set up inequality proving and I tried to do one of everything so that there are enough clues to do the rest. For <code>ne</code>, the proof approach which is used in mathlib3 is to prove either <code>lt</code> or <code>gt</code> depending on which one we can establish, so the main work is on <code>le</code>/<code>lt</code>.</p>



<a name="321522040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321522040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321522040">(Jan 15 2023 at 19:03)</a>:</h4>
<p>Sounds great! I see we went with the “add another constructor to <code>Result</code>” approach, and we just treat them as boolean literals.</p>
<p>All that I don’t get is why we return a proof of the negation of a prop even when we’re apparently trying to prove the prop. (the <code>else</code> branch at the end of <code>&lt;</code>). Does this yield useful error messages or something? Or does it work differently?</p>



<a name="321522253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321522253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321522253">(Jan 15 2023 at 19:05)</a>:</h4>
<p>(Also, just as a disclaimer, the weekends are when I have the least amount of time to actually code—I might have a bit of time today, but if I can’t finish it today, I will tomorrow.)</p>



<a name="321522409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321522409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321522409">(Jan 15 2023 at 19:07)</a>:</h4>
<p>When <code>norm_num</code> is given an inequality like <code>2 &lt; 5</code> or <code>4 &lt; 1</code>, it's supposed to <em>normalize</em> it, to <code>True</code> or <code>False</code> (that is to say, prove or disprove it). This is important for three reasons: (1) when used as a non-goal-closing normalization it's supposed to replace subterms like <code>2 &lt; 5</code> with <code>True</code> even if it's not at the top level, (2) reducing a goal to <code>False</code> is a way to communicate that norm_num didn't just fail but actually disproved the claim, and (3) <code>norm_num at h</code> can close goals by reducing them to <code>False</code></p>



<a name="321522554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321522554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321522554">(Jan 15 2023 at 19:09)</a>:</h4>
<p>Remember that in all other cases when we are given an expression like <code>2 + 3</code> we are supposed to return a normal form expression which is provably equal to the input. For <code>2 &lt; 3</code> it's the same thing, the normal form expression provably equal to that is <code>True</code></p>



<a name="321522704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321522704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321522704">(Jan 15 2023 at 19:11)</a>:</h4>
<p>That makes sense!</p>



<a name="321522771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321522771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321522771">(Jan 15 2023 at 19:11)</a>:</h4>
<p>No problem if you can't get to it soon, I just wanted to make sure I got the architecture stuff in first :)</p>



<a name="321934239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321934239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321934239">(Jan 17 2023 at 22:02)</a>:</h4>
<p>Ok, finally working on it! Schedule's clear, thought about it when I could, and I hope to finish it today.</p>



<a name="321934266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321934266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321934266">(Jan 17 2023 at 22:02)</a>:</h4>
<p>Two technical questions about the setup:</p>



<a name="321934398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321934398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321934398">(Jan 17 2023 at 22:03)</a>:</h4>
<ol>
<li>Why is the setup for <code>&lt;</code> different than for <code>≠</code>? For <code>&lt;</code> we do</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">let</span> <span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="bp">.</span><span class="n">app</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="bp">←</span> <span class="n">whnfR</span> <span class="n">e</span> <span class="bp">|</span> <span class="n">failure</span>
  <span class="k">let</span> <span class="o">⟨</span><span class="bp">.</span><span class="n">succ</span> <span class="n">u</span><span class="o">,</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span><span class="o">⟩</span> <span class="bp">←</span> <span class="n">inferTypeQ</span> <span class="n">a</span> <span class="bp">|</span> <span class="n">failure</span>
  <span class="k">have</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Q</span><span class="o">(</span><span class="bp">$</span><span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">b</span>
</code></pre></div>
<p>but for <code>≠</code> we do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="bp">.</span><span class="n">app</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Q</span><span class="o">(</span><span class="bp">$</span><span class="n">α</span><span class="o">)))</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Q</span><span class="o">(</span><span class="bp">$</span><span class="n">α</span><span class="o">))</span> <span class="bp">←</span> <span class="n">withReducible</span> <span class="o">(</span><span class="n">whnf</span> <span class="n">e</span><span class="o">)</span> <span class="bp">|</span> <span class="n">failure</span>
</code></pre></div>



<a name="321934689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321934689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321934689">(Jan 17 2023 at 22:05)</a>:</h4>
<ol start="2">
<li><del>Why do we wait so long to check if it's <code>lt</code> (<code>guard &lt;|← withNewMCtxDepth &lt;| isDefEq f q(LT.lt (α := $α))</code>) compared to the other extensions? Seems like we only do it in the nat arm right now. Presumably we'll do it in all arms once implemented, but why wait til we're inside the arms? Guess: because somehow the ordered semiring instance <code>_i</code> inferred right before bears on it invisibly</del> EDIT: Oh, I get it, we need to synthesize the instance for <code>LT</code>.</li>
</ol>



<a name="321964044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321964044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321964044">(Jan 18 2023 at 02:37)</a>:</h4>
<p>Is there a reason we don't have a <code>norm_num</code> extension for <code>Eq</code>? It seems kind of asymmetric. Shouldn't we be able to normalize <code>2 = 2</code> to <code>True</code>?</p>



<a name="321964148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321964148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321964148">(Jan 18 2023 at 02:38)</a>:</h4>
<p>(I'm going to make one given that I have (a good chunk of) <code>≠</code> and if it explodes it explodes...)</p>



<a name="321965433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321965433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321965433">(Jan 18 2023 at 02:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="548935">Thomas Murrills</span> <a href="#narrow/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality/near/321964044">said</a>:</p>
<blockquote>
<p>Is there a reason we don't have a <code>norm_num</code> extension for <code>Eq</code>? It seems kind of asymmetric. Shouldn't we be able to normalize <code>2 = 2</code> to <code>True</code>?</p>
</blockquote>
<p>Not an expert, but indeed I do think this should exist.  It was there in Lean 3:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.norm_num</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">ℝ</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">4</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num1</span>
</code></pre></div>



<a name="321989102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321989102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321989102">(Jan 18 2023 at 07:39)</a>:</h4>
<p><span class="user-mention" data-user-id="548935">@Thomas Murrills</span> <a href="#narrow/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality/near/321934398">said</a>:</p>
<blockquote>
<ol>
<li>Why is the setup for <code>&lt;</code> different than for <code>≠</code>? For <code>&lt;</code> we do</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">let</span> <span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="bp">.</span><span class="n">app</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="bp">←</span> <span class="n">whnfR</span> <span class="n">e</span> <span class="bp">|</span> <span class="n">failure</span>
  <span class="k">let</span> <span class="o">⟨</span><span class="bp">.</span><span class="n">succ</span> <span class="n">u</span><span class="o">,</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span><span class="o">⟩</span> <span class="bp">←</span> <span class="n">inferTypeQ</span> <span class="n">a</span> <span class="bp">|</span> <span class="n">failure</span>
  <span class="k">have</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Q</span><span class="o">(</span><span class="bp">$</span><span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">b</span>
</code></pre></div>
<p>but for <code>≠</code> we do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="bp">.</span><span class="n">app</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Q</span><span class="o">(</span><span class="bp">$</span><span class="n">α</span><span class="o">)))</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Q</span><span class="o">(</span><span class="bp">$</span><span class="n">α</span><span class="o">))</span> <span class="bp">←</span> <span class="n">withReducible</span> <span class="o">(</span><span class="n">whnf</span> <span class="n">e</span><span class="o">)</span> <span class="bp">|</span> <span class="n">failure</span>
</code></pre></div>
</blockquote>
<p>That's because I didn't look carefully at the ne code, it needs to do the same thing as the other relations. You can't use alpha here because alpha is the type of the relation itself, which is <code>Prop</code></p>



<a name="321989279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321989279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321989279">(Jan 18 2023 at 07:40)</a>:</h4>
<p>the purpose of those lines in the le code is to find the alpha we actually care about</p>



<a name="321989993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321989993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321989993">(Jan 18 2023 at 07:45)</a>:</h4>
<p>Makes sense! I managed to figure it out and <code>≠</code> functionality is done up to two <code>Rat</code>-related sorries. I did it via <code>=</code> and <code>Not</code>, though—is that alright? (I kept around some early <code>≠</code>-specific versions from an earlier draft in case it's not) I also didn't use the mathlib3 approach, since we don't have order in the general case; I just used congruence or {injectivity given <code>CharZero</code>} directly.</p>



<a name="321990283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321990283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321990283">(Jan 18 2023 at 07:48)</a>:</h4>
<p>Still left to do is <code>&lt;</code> and <code>≤</code> (and subtraction for natural numbers, apparently, which I found out when refining the tests; <code>simp</code> had been taking care of those tests)</p>



<a name="321990452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321990452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321990452">(Jan 18 2023 at 07:49)</a>:</h4>
<p>(personally, I consider nat subtraction very low priority, something that could wait for a future version)</p>



<a name="321990835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321990835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321990835">(Jan 18 2023 at 07:52)</a>:</h4>
<p>Cool! Teaching priorities are definitely the guide here :)</p>



<a name="321990912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321990912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321990912">(Jan 18 2023 at 07:52)</a>:</h4>
<p>I hope to finish <code>&lt;</code> and <code>≤</code> tomorrow (if they don't get done in the meantime)—the infrastructure is in place (thanks to Mario! :) ) and I just need to go through the motions. I'm going to change the <code>≠</code> PR title/description to cover all of them.</p>



<a name="321992090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/321992090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#321992090">(Jan 18 2023 at 08:01)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib4/pull/1568">mathlib4#1568</a> now updated</p>



<a name="322188693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322188693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322188693">(Jan 19 2023 at 02:13)</a>:</h4>
<p>Is the smallest thing that's a division ring and has a (compatible) order a <code>LinearOrderedField</code>? (If so is this a mathematical fact or just a mathlib fact?)</p>



<a name="322188941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322188941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322188941">(Jan 19 2023 at 02:16)</a>:</h4>
<p>I don't know, but that is certainly good enough for practical purposed!</p>



<a name="322198142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322198142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322198142">(Jan 19 2023 at 04:28)</a>:</h4>
<p>As for the mathematical question, it seems that there are non-commutative ordered division rings: see <span class="user-mention" data-user-id="127136">@Alex J. Best</span> answer <a href="https://math.stackexchange.com/questions/743975/example-of-an-ordered-noncommutative-division-ring">here</a>.</p>



<a name="322201566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322201566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322201566">(Jan 19 2023 at 05:24)</a>:</h4>
<p>We should have an instance for <code>Nontrivial</code> given <code>CharZero</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">[</span><span class="n">AddMonoidWithOne</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">CharZero</span> <span class="n">α</span><span class="o">]</span>
<span class="bp">#</span><span class="n">synth</span> <span class="n">Nontrivial</span> <span class="n">α</span> <span class="c1">-- failed to synthesize instance Nontrivial α</span>
</code></pre></div>
<p>(<code>&lt;</code> lemmas depend on <code>Nontrivial</code>, not <code>CharZero</code>, but often I'd imagine we have the latter)</p>
<p>Does this exist but just in a weird place?</p>
<p>If not, where should it go?</p>



<a name="322201785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322201785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322201785">(Jan 19 2023 at 05:28)</a>:</h4>
<p>Also, what about the other way when we have enough structure? Specifically, an instance for <code>CharZero</code> given a <code>Nontrivial</code> <code>OrderedRing</code>?</p>



<a name="322201833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322201833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322201833">(Jan 19 2023 at 05:28)</a>:</h4>
<p>In Lean3 there are <a href="https://leanprover-community.github.io/mathlib_docs/find/char_zero.infinite">docs#char_zero.infinite</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/infinite.nontrivial">docs#infinite.nontrivial</a>.</p>



<a name="322202315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322202315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322202315">(Jan 19 2023 at 05:33)</a>:</h4>
<p>If it's easier you can stick to <code>LinearOrderedRing</code>, which is automatically <code>Nontrivial</code> and <code>CharZero</code>.</p>



<a name="322202573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322202573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322202573">(Jan 19 2023 at 05:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality/near/322202315">said</a>:</p>
<blockquote>
<p>If it's easier you can stick to <code>LinearOrderedRing</code>, which is automatically <code>Nontrivial</code> and <code>CharZero</code>.</p>
</blockquote>
<p>Okay, all tests work for <code>LinearOrderedRing</code> currently! It's just the case where we have <code>OrderedRing</code> and <code>CharZero</code> where e.g. <code>-1 &lt; 2</code> will fail, because it needs <code>Nontrivial</code>.</p>



<a name="322202654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322202654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322202654">(Jan 19 2023 at 05:38)</a>:</h4>
<p>I'm sure someone, someday, will demand that functionality! :-). But it's rather low priority.</p>



<a name="322202695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322202695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322202695">(Jan 19 2023 at 05:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality/near/322201833">said</a>:</p>
<blockquote>
<p>In Lean3 there are <a href="https://leanprover-community.github.io/mathlib_docs/find/char_zero.infinite">docs#char_zero.infinite</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/infinite.nontrivial">docs#infinite.nontrivial</a>.</p>
</blockquote>
<p>Interesting, I guess it hasn't been ported yet. Would it make sense to put a direct instance in either the file that defines <code>CharZero</code> or <code>Nontrivial</code>, whichever comes "second" (if either)? Or do we need to avoid diamonds (well, here a triangle) for when <code>infinite</code> stuff gets ported? (I would hope not with <code>Prop</code>s, but...)</p>



<a name="322203842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322203842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322203842">(Jan 19 2023 at 05:54)</a>:</h4>
<p><code>CharZero</code> and <code>Nontrivial</code> are both props, so there's no danger of diamonds.</p>



<a name="322203867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322203867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322203867">(Jan 19 2023 at 05:55)</a>:</h4>
<p>Great, that's what I hoped!</p>



<a name="322205544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322205544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322205544">(Jan 19 2023 at 06:11)</a>:</h4>
<p>There are also a few "shortcut" instances in mathlib, similar to the one that you are proposing.</p>



<a name="322205549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322205549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322205549">(Jan 19 2023 at 06:11)</a>:</h4>
<p>My view is that, if it makes stuff work, definitely go for it!</p>



<a name="322357601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322357601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322357601">(Jan 19 2023 at 19:08)</a>:</h4>
<p>Hmm, is <code>OrderedRing</code> sufficient to prove <code>na * ⅟da ≤ nb * ⅟db</code> given <code>na * db ≤ nb * da</code>? <code>OrderedRing</code> tells us that <code>0 ≤ 1</code>, addition preserves <code>≤</code>, and that the set of nonnegative elements is closed under multiplication (by each other). We only demand a partial order.</p>
<p>It seems to me like ℤ with 1/2 adjoined keeping only <code>≤</code> relations among integers (and all half-odd integers not related to anything but each other) might be fine. We can't have 1/2 ≤ 0, otherwise 0 ≤ -1/2 and multiplying by 2 gets us 0 ≤ -1—not allowed since the ring is nontrivial. But keeping it unrelated to 0 might be ok.</p>
<p>For now I'm going to use <code>LinearOrderedRing</code> for rat functionality since we need an instance of that in most cases anyway, but I was still just wondering.</p>



<a name="322360247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322360247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322360247">(Jan 19 2023 at 19:22)</a>:</h4>
<p>What about na=nb=da=1, db=-1?</p>



<a name="322360920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322360920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322360920">(Jan 19 2023 at 19:26)</a>:</h4>
<p>Ah, sorry, I forgot to specify: <code>da</code> and <code>db</code> are natural numbers here</p>



<a name="322384263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322384263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322384263">(Jan 19 2023 at 21:38)</a>:</h4>
<p>Ok, I proved the last <code>sorry</code>! It all works (and I made a bunch more tests to check), and <a href="https://github.com/leanprover-community/mathlib4/pull/1568">mathlib4#1568</a> has a green check. :)</p>



<a name="322384295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322384295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322384295">(Jan 19 2023 at 21:38)</a>:</h4>
<p>However, I might have made some questionable choices surrounding the definitions I chose and some instance management. <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, want to take a look when you get a chance? I left comments labeled with <code>!!</code> where I thought there might be an issue with what I did.</p>



<a name="322411256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322411256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322411256">(Jan 20 2023 at 01:07)</a>:</h4>
<p>I pushed some changes and addressed all the <code>!!</code> open questions</p>



<a name="322411464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322411464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322411464">(Jan 20 2023 at 01:09)</a>:</h4>
<p>One thing I wanted to remark: for the "rationals are equal" case, it suffices to just have numerator and denominator the same syntactically, we don't have to check that they are multiples of each other because we maintain an invariant that the rationals are reduced and expressions are in canonical form, so if the rational values are equal then the normalized expressions are syntactically equal</p>



<a name="322415180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322415180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322415180">(Jan 20 2023 at 01:49)</a>:</h4>
<p>Nice! I scrolled through the latest commit; really nice minimizations in general! Should I change the PR’s label to awaiting-review? EDIT: I read through it once more and it looked good to me, so I put it on the queue!</p>



<a name="322456507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/norm_num%20characteristic%20functionality/near/322456507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality.html#322456507">(Jan 20 2023 at 08:51)</a>:</h4>
<p>Re na/da&lt;=nb/db: Yes I think you're right. Z[1/2] (note that this contains 1/4 and 1/2^{100} because it's a ring; the general element is of the form a/2^n with a an integer and n a natural) with the order defined by a&lt;=b iff b-a is a natural, seems to be an ordered ring as far as mathlib is concerned, and 0/2=0&lt;=1/2 is false whereas 0&lt;=2 is true.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html">logic.equiv.basic mathlib4#631</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="311723831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311723831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311723831">(Nov 22 2022 at 22:50)</a>:</h4>
<p>We're very close on logic.equiv.basic.</p>



<a name="311723893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311723893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311723893">(Nov 22 2022 at 22:50)</a>:</h4>
<p>The remaining problem is the simpNF linter is unhappy with lemmas like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">sumCompl_apply_symm_of_pos</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">DecidablePred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">sumCompl</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">Sum.inl</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span>
  <span class="n">dif_pos</span> <span class="n">h</span>
</code></pre></div>



<a name="311723917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311723917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311723917">(Nov 22 2022 at 22:50)</a>:</h4>
<p>It doesn't explain why, and just says you'll have to debug it yourself.</p>



<a name="311723960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311723960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311723960">(Nov 22 2022 at 22:50)</a>:</h4>
<p>The current PR has just removed the <code>@[simp]</code> on this lemma (and three others like it), but I'm as yet unconvinced.</p>



<a name="311723990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311723990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311723990">(Nov 22 2022 at 22:51)</a>:</h4>
<p>As long as <code>simp</code> can prove <code>p a</code> itself, it seems this is a perfectly reasonable <code>simp</code> lemma.</p>



<a name="311724046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311724046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311724046">(Nov 22 2022 at 22:51)</a>:</h4>
<p>Or am I forgetting that something about <code>simp</code> has changed in Lean 4, and it is less aggressive about solving side-conditions?</p>



<a name="311724183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311724183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311724183">(Nov 22 2022 at 22:52)</a>:</h4>
<p>can you make a MWE version (no mathlib)?</p>



<a name="311725012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311725012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311725012">(Nov 22 2022 at 22:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Tactic.Lint</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">Sum.elim</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Sum</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">Sum.casesOn</span> <span class="n">x</span> <span class="n">f</span> <span class="n">g</span>

<span class="kd">structure</span> <span class="n">Equiv</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
  <span class="n">invFun</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span>

<span class="kd">infixl</span><span class="o">:</span><span class="mi">25</span> <span class="s2">" ≃ "</span> <span class="bp">=&gt;</span> <span class="n">Equiv</span>

<span class="kn">namespace</span> <span class="n">Equiv</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">CoeFun</span> <span class="o">(</span><span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span><span class="o">)</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">toFun</span><span class="o">⟩</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">symm</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">≃</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">e.invFun</span><span class="o">,</span> <span class="n">e.toFun</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">sumCompl</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">DecidablePred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span>
    <span class="n">Sum</span> <span class="o">{</span> <span class="n">a</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">a</span> <span class="o">}</span> <span class="o">{</span> <span class="n">a</span> <span class="bp">//</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">a</span> <span class="o">}</span> <span class="bp">≃</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="o">:=</span> <span class="n">Sum.elim</span> <span class="n">Subtype.val</span> <span class="n">Subtype.val</span>
  <span class="n">invFun</span> <span class="n">a</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span> <span class="k">then</span> <span class="n">Sum.inl</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="k">else</span> <span class="n">Sum.inr</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">sumCompl_apply_symm_of_pos</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">DecidablePred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">sumCompl</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">Sum.inl</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span>
  <span class="n">dif_pos</span> <span class="n">h</span>

<span class="bp">#</span><span class="n">lint</span>
<span class="c">/-</span><span class="cm"> The `simpNF` linter reports:</span>
<span class="cm">SOME SIMP LEMMAS ARE NOT IN SIMP-NORMAL FORM.</span>
<span class="cm">see note [simp-normal form] for tips how to debug this.</span>
<span class="cm">https://leanprover-community.github.io/mathlib_docs/notes.html#simp-normal%20form -/</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">sumCompl_apply_symm_of_pos</span> <span class="c">/-</span><span class="cm"> Left-hand side does not simplify.</span>
<span class="cm">You need to debug this yourself using `set_option trace.Meta.Tactic.simp.rewrite true` -/</span>
</code></pre></div>



<a name="311726779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311726779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311726779">(Nov 22 2022 at 23:13)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">DecidablePred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">sumCompl</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">Sum.inl</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="c1">-- fails :-(</span>
</code></pre></div>
<p>I can't even make <code>set_option trace.Meta.Tactic.simp.rewrite true</code> do anything. Where am I supposed to be writing this and/or looking at the output?</p>



<a name="311727302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311727302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311727302">(Nov 22 2022 at 23:17)</a>:</h4>
<p>The error message is saying that <code>simp</code> does not rewrite with the simp lemma</p>



<a name="311727358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311727358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311727358">(Nov 22 2022 at 23:18)</a>:</h4>
<p>so <code>set_option trace.Meta.Tactic.simp.rewrite true</code> will predictably be empty</p>



<a name="311727914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311727914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311727914">(Nov 22 2022 at 23:23)</a>:</h4>
<p>fixed in <a href="https://github.com/leanprover/std4/commit/68581a4685ce2ae8906f237651b3381d1aaa8b41"><code>68581a4</code></a></p>



<a name="311727946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311727946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311727946">(Nov 22 2022 at 23:23)</a>:</h4>
<p>Oh, it is saying that it can't simplify the LHS, even using the simp lemma itself? I assumed it was about not simplifying with other simp lemmas.</p>



<a name="311728131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311728131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311728131">(Nov 22 2022 at 23:24)</a>:</h4>
<p>not simplifying with other simp lemmas is the <em>good</em> case</p>



<a name="311728224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311728224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311728224">(Nov 22 2022 at 23:25)</a>:</h4>
<p>simp lemma LHSs should not simplify when using everything else in the simp set, and they should simplify when using the simp lemma itself</p>



<a name="311728377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311728377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311728377">(Nov 22 2022 at 23:26)</a>:</h4>
<p>Could we change the error message for when they do not simplify when using the simp lemma itself?</p>



<a name="311728403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311728403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311728403">(Nov 22 2022 at 23:27)</a>:</h4>
<p>To be explicit that this is the test that is failing? I missed that in this case.</p>



<a name="311729115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311729115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311729115">(Nov 22 2022 at 23:32)</a>:</h4>
<p>Weird,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">coe_fn_mk</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">Equiv.mk</span> <span class="n">f</span> <span class="n">g</span> <span class="n">l</span> <span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span>
<span class="n">rfl</span>
</code></pre></div>
<p>was omitted in <code>Logic.Equiv.Defs</code>...</p>



<a name="311729375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311729375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311729375">(Nov 22 2022 at 23:35)</a>:</h4>
<p>Where is this simp lemma supposed to find h by the way?</p>



<a name="311729623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311729623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311729623">(Nov 22 2022 at 23:37)</a>:</h4>
<p>it's a conditional rewrite rule, it would normally be proved by recursive application of simp, possibly including hypotheses passed to the original invocation</p>



<a name="311729651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311729651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311729651">(Nov 22 2022 at 23:37)</a>:</h4>
<p>the bug here was that it failed to detect that this was a conditional rewrite rule</p>



<a name="311729722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311729722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311729722">(Nov 22 2022 at 23:38)</a>:</h4>
<p>Okay, <code>Logic.Equiv.Basic</code> now compiles and lints locally.</p>



<a name="311729728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311729728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311729728">(Nov 22 2022 at 23:38)</a>:</h4>
<p>Review would be great.</p>



<a name="311742966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311742966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311742966">(Nov 23 2022 at 02:03)</a>:</h4>
<p>Hmm, we're not there yet. My fixes for duplicate Coe instances in <code>Logic.Equiv.Defs</code> has broken things in other places.</p>



<a name="311743063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311743063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311743063">(Nov 23 2022 at 02:05)</a>:</h4>
<p>in <code>Order.Monotone</code>,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">monotone_toDual_comp_iff</span> <span class="o">:</span> <span class="n">Monotone</span> <span class="o">(</span><span class="n">toDual</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">Antitone</span> <span class="n">f</span> <span class="o">:=</span>
  <span class="n">Iff.rfl</span>
</code></pre></div>
<p>is now failing with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">Iff.rfl</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">Monotone</span> <span class="o">(</span><span class="n">FunLike.coe</span> <span class="n">toDual</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">Monotone</span> <span class="o">(</span><span class="n">FunLike.coe</span> <span class="n">toDual</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">Monotone</span> <span class="o">(</span><span class="n">FunLike.coe</span> <span class="n">toDual</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">Antitone</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>
<p>I neither understand why the <code>FunLike.coe</code> is printing here, nor why <code>Iff.rfl</code> doesn't work... :-(</p>



<a name="311743237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311743237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311743237">(Nov 23 2022 at 02:07)</a>:</h4>
<p>I think the <code>FunLike.coe</code> printing might be because it is an under-application? Can you make a MWE? (I think functions with the right arity and implicitness for <code>FunLike.coe</code> and <code>toDual</code> should suffice)</p>



<a name="311743354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311743354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311743354">(Nov 23 2022 at 02:09)</a>:</h4>
<p>for the iff.rfl proof it might help to look at <code>set_option trace.Meta.isDefEq true</code></p>



<a name="311744939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311744939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311744939">(Nov 23 2022 at 02:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I took a look at this issue, and the reason the iff.rfl proof fails is because <code>Monotone</code> has inferred the original order on beta, not the dual one</p>



<a name="311745331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311745331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311745331">(Nov 23 2022 at 02:42)</a>:</h4>
<p><span aria-label="racecar" class="emoji emoji-1f3ce" role="img" title="racecar">:racecar:</span>, yes</p>



<a name="311745343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311745343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311745343">(Nov 23 2022 at 02:42)</a>:</h4>
<p>Curiously before I took away the duplicate Coe instance for Equiv, this proof was working.</p>



<a name="311745364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311745364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311745364">(Nov 23 2022 at 02:43)</a>:</h4>
<p>Perhaps because the duplicate one was not a coercion to a dependently typed function.</p>



<a name="311745376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311745376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311745376">(Nov 23 2022 at 02:43)</a>:</h4>
<p>And this made it easier for Lean to get the type right?</p>



<a name="311745500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311745500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311745500">(Nov 23 2022 at 02:45)</a>:</h4>
<p>I can add type ascriptions, but it feels like a work-around rather than a solution.</p>



<a name="311745701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311745701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311745701">(Nov 23 2022 at 02:48)</a>:</h4>
<p>Could we have a higher priority <code>CoeFun</code> for <code>FunLike</code>s indexed by a constant type family?</p>



<a name="311746932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311746932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311746932">(Nov 23 2022 at 03:07)</a>:</h4>
<p>MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">MyFunLike</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">&lt;|</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">coe</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span>

<span class="kd">inductive</span> <span class="n">Secret</span>
<span class="kd">def</span> <span class="n">Wrapper</span> <span class="o">:=</span> <span class="n">Secret</span>
<span class="kd">inductive</span> <span class="n">Bla</span> <span class="bp">|</span> <span class="n">z</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">MyFunLike</span> <span class="n">Bla</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Wrapper</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="mi">100</span><span class="o">)</span> <span class="o">{</span><span class="n">F</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">MyFunLike</span> <span class="n">F</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">CoeFun</span> <span class="n">F</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span> <span class="n">where</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">MyFunLike.coe</span>

<span class="k">#check</span> <span class="n">Bla.z</span> <span class="mi">0</span> <span class="c1">-- MyFunLike.coe Bla.z 0 : (fun x =&gt; Wrapper) 0</span>
<span class="kd">set_option</span> <span class="n">trace.Meta.isDefEq</span> <span class="n">true</span> <span class="k">in</span>
<span class="k">#check</span> <span class="n">Bla.z</span> <span class="bp">∘</span> <span class="n">id</span> <span class="c1">-- MyFunLike.coe Bla.z ∘ id : ℤ → Secret</span>
</code></pre></div>



<a name="311747197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311747197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311747197">(Nov 23 2022 at 03:11)</a>:</h4>
<p>So you think this is something that should be fixed in core?</p>



<a name="311747260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311747260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311747260">(Nov 23 2022 at 03:12)</a>:</h4>
<p>yes, there is at least one core bug here</p>



<a name="311823998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311823998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311823998">(Nov 23 2022 at 13:19)</a>:</h4>
<p>In <a href="https://github.com/leanprover-community/mathlib4/pull/631">mathlib4#631</a>, I have just worked around this issue for now (and left a note pointing to this thread).</p>



<a name="311824146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311824146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311824146">(Nov 23 2022 at 13:20)</a>:</h4>
<p>Shall I post your MWE as a Lean 4 issue, or is it still in your court?</p>



<a name="311824218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311824218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311824218">(Nov 23 2022 at 13:20)</a>:</h4>
<p>Separately, <a href="https://github.com/leanprover-community/mathlib4/pull/631">mathlib4#631</a> now has a green tick, so if someone would like to have a look and/or merge that would be great.</p>



<a name="311839357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311839357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311839357">(Nov 23 2022 at 14:40)</a>:</h4>
<p>(looking now)</p>



<a name="311863513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311863513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311863513">(Nov 23 2022 at 16:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, <span class="user-mention" data-user-id="284160">@Eric Rodriguez</span>, <span class="user-mention" data-user-id="307953">@Ruben Van de Velde</span>, thanks for all the review comments. Would you mind, where possible, just making the changes? It's twice as much work to have conversations about things.</p>



<a name="311863618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311863618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311863618">(Nov 23 2022 at 16:42)</a>:</h4>
<p>I'll make my changes, all of which are trivial.</p>



<a name="311863835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311863835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311863835">(Nov 23 2022 at 16:43)</a>:</h4>
<p>Thanks.</p>



<a name="311865293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311865293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311865293">(Nov 23 2022 at 16:51)</a>:</h4>
<p>I'll deal with min now, unless you already started, <span class="user-mention" data-user-id="110087">@Scott Morrison</span></p>



<a name="311869050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311869050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311869050">(Nov 23 2022 at 17:10)</a>:</h4>
<p>I think I got them.</p>



<a name="311869098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311869098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311869098">(Nov 23 2022 at 17:11)</a>:</h4>
<p>Here's the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> extracted from this branch:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span><span class="o">:</span><span class="n">arg</span> <span class="s2">"⟦"</span> <span class="n">a</span> <span class="s2">"⟧"</span> <span class="bp">=&gt;</span> <span class="n">Quotient.mk</span> <span class="n">_</span> <span class="n">a</span>

<span class="kn">namespace</span> <span class="n">Function</span>

<span class="kd">def</span> <span class="n">LeftInverse</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">RightInverse</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">LeftInverse</span> <span class="n">f</span> <span class="n">g</span>

<span class="kd">theorem</span> <span class="n">hfunext</span> <span class="o">{</span><span class="n">α</span> <span class="n">α'</span><span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">β'</span> <span class="o">:</span> <span class="n">α'</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">f'</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">a</span><span class="o">,</span> <span class="n">β'</span> <span class="n">a</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">α'</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">a</span> <span class="n">a'</span><span class="o">,</span> <span class="n">HEq</span> <span class="n">a</span> <span class="n">a'</span> <span class="bp">→</span> <span class="n">HEq</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">a'</span><span class="o">))</span> <span class="o">:</span> <span class="n">HEq</span> <span class="n">f</span> <span class="n">f'</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">subst</span> <span class="n">hα</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">a</span><span class="o">,</span> <span class="n">HEq</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">h</span> <span class="n">a</span> <span class="n">a</span> <span class="o">(</span><span class="n">HEq.refl</span> <span class="n">a</span><span class="o">)</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">=</span> <span class="n">β'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">funext</span> <span class="n">a</span>
                      <span class="n">exact</span> <span class="n">type_eq_of_heq</span> <span class="o">(</span><span class="n">this</span> <span class="n">a</span><span class="o">)</span>
  <span class="n">subst</span> <span class="n">this</span>
  <span class="n">apply</span> <span class="n">heq_of_eq</span>
  <span class="n">funext</span> <span class="n">a</span>
  <span class="n">exact</span> <span class="n">eq_of_heq</span> <span class="o">(</span><span class="n">this</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">Function</span>

<span class="kn">namespace</span> <span class="n">Subtype</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>

<span class="kn">protected</span> <span class="kd">theorem</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a1</span> <span class="n">a2</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span> <span class="o">}},</span> <span class="o">(</span><span class="n">a1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a2</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">a1</span> <span class="bp">=</span> <span class="n">a2</span>
  <span class="bp">|</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">rfl</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">ext_val</span> <span class="o">{</span><span class="n">a1</span> <span class="n">a2</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span> <span class="o">}}</span> <span class="o">:</span> <span class="n">a1.1</span> <span class="bp">=</span> <span class="n">a2.1</span> <span class="bp">→</span> <span class="n">a1</span> <span class="bp">=</span> <span class="n">a2</span> <span class="o">:=</span>
  <span class="n">Subtype.ext</span>

<span class="kd">end</span> <span class="n">Subtype</span>

<span class="kn">open</span> <span class="n">Function</span>

<span class="kd">structure</span> <span class="n">Equiv</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
  <span class="n">invFun</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="n">left_inv</span> <span class="o">:</span> <span class="n">LeftInverse</span> <span class="n">invFun</span> <span class="n">toFun</span>
  <span class="n">right_inv</span> <span class="o">:</span> <span class="n">RightInverse</span> <span class="n">invFun</span> <span class="n">toFun</span>

<span class="kd">infixl</span><span class="o">:</span><span class="mi">25</span> <span class="s2">" ≃ "</span> <span class="bp">=&gt;</span> <span class="n">Equiv</span>

<span class="kd">def</span> <span class="n">subtypeQuotientEquivQuotientSubtype</span> <span class="o">(</span><span class="n">p₁</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">s₁</span> <span class="o">:</span> <span class="n">Setoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">s₂</span> <span class="o">:</span> <span class="n">Setoid</span> <span class="o">(</span><span class="n">Subtype</span> <span class="n">p₁</span><span class="o">)]</span>
    <span class="o">(</span><span class="n">p₂</span> <span class="o">:</span> <span class="n">Quotient</span> <span class="n">s₁</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">p₁</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">p₂</span> <span class="bp">⟦</span><span class="n">a</span><span class="bp">⟧</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Subtype</span> <span class="n">p₁</span><span class="o">,</span> <span class="bp">@</span><span class="n">Setoid.r</span> <span class="n">_</span> <span class="n">s₂</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">≈</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">{</span> <span class="n">x</span> <span class="bp">//</span> <span class="n">p₂</span> <span class="n">x</span> <span class="o">}</span> <span class="bp">≃</span> <span class="n">Quotient</span> <span class="n">s₂</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="n">a</span> <span class="o">:=</span>
    <span class="n">Quotient.hrecOn</span> <span class="n">a.1</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="bp">⟦</span><span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">hp₂</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h</span><span class="o">⟩</span><span class="bp">⟧</span><span class="o">)</span>
      <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span> <span class="bp">=&gt;</span> <span class="n">hfunext</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">Quotient.sound</span> <span class="n">hab</span><span class="o">])</span> <span class="k">fun</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">_</span> <span class="bp">=&gt;</span>
        <span class="n">heq_of_eq</span> <span class="o">(</span><span class="n">Quotient.sound</span> <span class="o">((</span><span class="n">h</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">hab</span><span class="o">)))</span>
      <span class="n">a.2</span>
  <span class="n">invFun</span> <span class="n">a</span> <span class="o">:=</span>
    <span class="n">Quotient.liftOn</span> <span class="n">a</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="o">(⟨</span><span class="bp">⟦</span><span class="n">a.1</span><span class="bp">⟧</span><span class="o">,</span> <span class="o">(</span><span class="n">hp₂</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a.2</span><span class="o">⟩</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">//</span> <span class="n">p₂</span> <span class="n">x</span> <span class="o">}))</span> <span class="k">fun</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span> <span class="bp">=&gt;</span>
      <span class="n">Subtype.ext_val</span> <span class="o">(</span><span class="n">Quotient.sound</span> <span class="o">((</span><span class="n">h</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hab</span><span class="o">))</span>
  <span class="c1">-- This fails (but worked in Lean 3), but the next line using `rcases` succeeds:</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="k">fun</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="n">Quotient.inductionOn</span> <span class="n">a</span> <span class="o">(</span><span class="k">fun</span> <span class="n">b</span> <span class="n">hb</span> <span class="bp">=&gt;</span> <span class="n">rfl</span><span class="o">)</span> <span class="n">ha</span>
  <span class="c1">-- Needs `import Std.Tactic.RCases`:</span>
  <span class="c1">-- left_inv t := by rcases t with ⟨a, ha⟩; exact Quotient.inductionOn a (fun b hb =&gt; rfl) ha</span>
  <span class="n">right_inv</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">Quotient.inductionOn</span> <span class="n">a</span> <span class="k">fun</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
</code></pre></div>



<a name="311869129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311869129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311869129">(Nov 23 2022 at 17:11)</a>:</h4>
<p>(Sorry, it's not super minimal...)</p>



<a name="311869253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311869253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311869253">(Nov 23 2022 at 17:12)</a>:</h4>
<p>Unless someone has an idea I will post an issue on the Lean 4 repository. If anyone wants to further minimise first, that would be great.</p>



<a name="311869341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311869341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311869341">(Nov 23 2022 at 17:12)</a>:</h4>
<p>For now I'll just put a link to this message at the regression in <a href="https://github.com/leanprover-community/mathlib4/pull/631">mathlib4#631</a>, but let's not otherwise wait.</p>



<a name="311875020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311875020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311875020">(Nov 23 2022 at 17:46)</a>:</h4>
<p>I think in that MWE that <code>left_inv t</code> is meant to be <code>left_inv</code></p>



<a name="311875196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311875196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311875196">(Nov 23 2022 at 17:47)</a>:</h4>
<p>I tried using <code>intro</code> with a pattern match, and it creates two goals. I used <code>Quotient.sound</code> to handle one of them, but then it lead to there being an error on a random other line...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">subtypeQuotientEquivQuotientSubtype</span> <span class="o">(</span><span class="n">p₁</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">s₁</span> <span class="o">:</span> <span class="n">Setoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">s₂</span> <span class="o">:</span> <span class="n">Setoid</span> <span class="o">(</span><span class="n">Subtype</span> <span class="n">p₁</span><span class="o">)]</span>
    <span class="o">(</span><span class="n">p₂</span> <span class="o">:</span> <span class="n">Quotient</span> <span class="n">s₁</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">p₁</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">p₂</span> <span class="bp">⟦</span><span class="n">a</span><span class="bp">⟧</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Subtype</span> <span class="n">p₁</span><span class="o">,</span> <span class="bp">@</span><span class="n">Setoid.r</span> <span class="n">_</span> <span class="n">s₂</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">≈</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">{</span> <span class="n">x</span> <span class="bp">//</span> <span class="n">p₂</span> <span class="n">x</span> <span class="o">}</span> <span class="bp">≃</span> <span class="n">Quotient</span> <span class="n">s₂</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="n">a</span> <span class="o">:=</span>
    <span class="n">Quotient.hrecOn</span> <span class="n">a.1</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="bp">⟦</span><span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">hp₂</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h</span><span class="o">⟩</span><span class="bp">⟧</span><span class="o">)</span>
      <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span> <span class="bp">=&gt;</span> <span class="n">hfunext</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">Quotient.sound</span> <span class="n">hab</span><span class="o">])</span> <span class="k">fun</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="c1">-- why is there now an error on `rw`??</span>
        <span class="n">heq_of_eq</span> <span class="o">(</span><span class="n">Quotient.sound</span> <span class="o">((</span><span class="n">h</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">hab</span><span class="o">)))</span>
      <span class="n">a.2</span>
  <span class="n">invFun</span> <span class="n">a</span> <span class="o">:=</span>
    <span class="n">Quotient.liftOn</span> <span class="n">a</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="o">(⟨</span><span class="bp">⟦</span><span class="n">a.1</span><span class="bp">⟧</span><span class="o">,</span> <span class="o">(</span><span class="n">hp₂</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a.2</span><span class="o">⟩</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">//</span> <span class="n">p₂</span> <span class="n">x</span> <span class="o">}))</span> <span class="k">fun</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span> <span class="bp">=&gt;</span>
      <span class="n">Subtype.ext_val</span> <span class="o">(</span><span class="n">Quotient.sound</span> <span class="o">((</span><span class="n">h</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hab</span><span class="o">))</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="c1">--fun ⟨a, ha⟩ =&gt; Quotient.inductionOn a (fun b hb =&gt; rfl) ha</span>
    <span class="c1">-- Workaround:</span>
    <span class="kd">by</span>
      <span class="n">intro</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span>
      <span class="bp">·</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Quotient.sound</span> <span class="n">hab</span><span class="o">]</span>
      <span class="n">exact</span> <span class="n">Quotient.inductionOn</span> <span class="n">a</span> <span class="o">(</span><span class="k">fun</span> <span class="n">b</span> <span class="n">hb</span> <span class="bp">=&gt;</span> <span class="n">rfl</span><span class="o">)</span> <span class="n">ha</span>
  <span class="n">right_inv</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">Quotient.inductionOn</span> <span class="n">a</span> <span class="k">fun</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
</code></pre></div>



<a name="311892199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic%20mathlib4%23631/near/311892199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631.html#311892199">(Nov 23 2022 at 19:09)</a>:</h4>
<p>I think this is a just a typical elaboration order / metavariables not instantiated yet kind of issue.  If you insert a <code>by exact</code> after <code>left_inv</code> it works.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
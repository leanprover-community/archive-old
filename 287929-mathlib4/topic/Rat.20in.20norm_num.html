---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Rat.20in.20norm_num.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html">Rat in norm_num</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="320354059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320354059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320354059">(Jan 09 2023 at 23:56)</a>:</h4>
<p>Is the definition of <code>IsRat</code> correct? Currently it seems to posit (given mouseovers and <code>pp.all true</code>) that <code>denom</code> is <code>Invertible</code> in <code>Nat</code>, which won't ever happen. (Or does it?)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">IsRat</span> <span class="o">[</span><span class="n">Ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">num</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">denom</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">where</span>
  <span class="sd">/-- The denominator is invertible. -/</span>
  <span class="n">inv</span> <span class="o">:</span> <span class="n">Invertible</span> <span class="n">denom</span>
  <span class="sd">/-- The element is equal to the fraction with the specified numerator and denominator. -/</span>
  <span class="n">eq</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">num</span> <span class="bp">*</span> <span class="bp">⅟</span><span class="n">denom</span>
</code></pre></div>



<a name="320354273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320354273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320354273">(Jan 09 2023 at 23:58)</a>:</h4>
<p>I think it is supposed to mean that <code>Invertible (denom : \alpha)</code>.</p>



<a name="320354664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320354664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320354664">(Jan 10 2023 at 00:01)</a>:</h4>
<p>That works, afaict; nice. I was also wondering, though, if this is an artifact of some earlier time in the port, and if <code>isRat</code> should be rewritten to <code>IsRat [Ring α] (a : α) (q : ℚ)</code>.</p>



<a name="320354791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320354791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320354791">(Jan 10 2023 at 00:02)</a>:</h4>
<p>Why is that? Ah, right, Mario wanted to have it all be passing around <code>ℚ</code></p>



<a name="320354918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320354918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320354918">(Jan 10 2023 at 00:03)</a>:</h4>
<p>Neat, I'll change it. :)</p>



<a name="320355117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320355117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320355117">(Jan 10 2023 at 00:05)</a>:</h4>
<p>Oops, I mean <code>IsRat [DivisionRing α] (a : α) (q : ℚ)</code>.</p>



<a name="320356604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320356604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320356604">(Jan 10 2023 at 00:19)</a>:</h4>
<p>New question: what's the "right" way to write rationals in terms of numerators and denominators? Say I want to construct the most "general" form of a rational for use in e.g. matching.</p>
<p>Is it<code>/</code>? It seems a little high-level, but maybe it gets elaborated away or something. For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">IsRat.to_isNat</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">DivisionRing</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span>
    <span class="n">IsRat</span> <span class="n">a</span> <span class="o">((</span><span class="n">Int.ofNat</span> <span class="n">n</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">IsNat</span> <span class="n">a</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p><em>works</em>, but feels heavy-handed.</p>



<a name="320356743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320356743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320356743">(Jan 10 2023 at 00:20)</a>:</h4>
<p>Should I go down to the structure level (<code>{ num := n, den := 1, den_nz := ... }</code>)? (<code>/.</code> syntax rings a bell, too, but I don't seem to have access to it in this file/know where it is.)</p>



<a name="320356859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320356859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320356859">(Jan 10 2023 at 00:21)</a>:</h4>
<p>Yes, I'd use <code>/</code>.  And don't use <code>Int.ofNat</code>.  Use coercions (or <code>Int.cast</code>) directly.</p>



<a name="320356932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320356932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320356932">(Jan 10 2023 at 00:22)</a>:</h4>
<p>In this case you should be able to write <code>IsRat a n</code>.</p>



<a name="320357027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320357027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320357027">(Jan 10 2023 at 00:23)</a>:</h4>
<p>Ah, okay, great, thanks.</p>



<a name="320357058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320357058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320357058">(Jan 10 2023 at 00:23)</a>:</h4>
<p>Btw, I was patterning the <code>ofNat</code> bit off of the pre-existing <code>IsInt.to_isNat</code> above—is the use of <code>ofNat</code> there still okay, or should it be similarly changed?</p>



<a name="320357384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320357384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320357384">(Jan 10 2023 at 00:26)</a>:</h4>
<p>Yes, I'd avoid <code>Int.ofNat</code> where possible.</p>



<a name="320358686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320358686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320358686">(Jan 10 2023 at 00:39)</a>:</h4>
<p>Hmm, just to be sure before I change the whole file: was it written this way because it has something to do with using literals in this context? All of the functions here in <code>norm_num</code> are meant to be passing around literals, I think, and I have a small note from a little while back written down saying "ofNat is for literals that lean uses; Nat.cast is for variables". Have things changed since this file was written such that casting is now preferred everywhere?</p>



<a name="320358813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320358813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320358813">(Jan 10 2023 at 00:40)</a>:</h4>
<p><code>OfNat.ofNat</code> is something entirely different.  It's only for numeric literals.  (and the argument should always be a nat_lit)  <code>OfNat.ofNat</code> is ok.</p>



<a name="320358827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320358827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320358827">(Jan 10 2023 at 00:40)</a>:</h4>
<p><code>Int.ofNat</code> is the one that shouldn't be there imho.</p>



<a name="320358857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320358857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320358857">(Jan 10 2023 at 00:40)</a>:</h4>
<p>Interesting...that clarifies things a bit, thanks.</p>



<a name="320368752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320368752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320368752">(Jan 10 2023 at 02:41)</a>:</h4>
<p>The purpose of the <code>IsNat</code> and <code>IsInt</code> functions is to say <code>a = n</code> where <code>n</code> is a <code>Nat</code> or <code>Int</code>, but written using as few expr operators as possible: <code>n</code> is "raw" here. In the case of <code>Nat</code>, it's a raw nat literal, and in the case of <code>Int</code> it is a "raw int literal", which means a raw nat literal wrapped in <code>Int.ofNat</code> or <code>Int.negOfNat</code>. With <code>IsRat</code> the idea was to have a "raw rat literal" be represented as a numerator and denominator in separate arguments, where the numerator is a raw int literal and the denominator is a raw nat literal. This is the form that norm_num uses internally for subproofs to avoid the overhead of building all the typeclass arguments associated with numeral construction.</p>
<p>There are two ways to get out of this representation, depending on how it is being used.</p>
<ul>
<li>Some tactics are still using numbers internally but can't deal with <code>IsNat</code> at the head, they want it to be <code>=</code> there so they can put the resulting expression in a subterm. In that case we apply <code>Result.toRawEq</code> , which produces a "raw nat cast expression" which is like an <code>OfNat.ofNat</code> application but with simplified typeclass arguments.</li>
<li>For the final result of the tactic to be seen by end-users, such as the result of <code>norm_num</code> after it has done normalization but has not closed the goal, we want to produce "canonical" numeral terms using the same constructors as users would normally use. This is done by the <code>Result.toSimpResult</code> function, which constructs a <code>OfNat.ofNat</code> term with the right typeclass arguments. For negative numbers, it applies <code>-</code> to an <code>ofNat</code>, and for rationals it uses <code>/</code> applied to two numerals. The result is expressions like <code>2</code>, <code>-2</code>, <code>0</code>, <code>1 / 2</code> and <code>-(2 / 3)</code> exactly like what you would get if you wrote those in a lean file (where the expected type is <code>α</code>).</li>
</ul>



<a name="320369592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320369592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320369592">(Jan 10 2023 at 02:55)</a>:</h4>
<p>I don't think we need to change the definition of <code>IsRat</code>, except to fix the bug you noted about <code>Invertible (denom : α)</code>. It does not take a <code>Rat</code> and this is intentional. Since the invertibility assumption is inside the structure, it doesn't affect most theorem statements: you can prove that you can add and multiply <code>IsRat</code> terms without assuming anything beyond <code>Ring α</code>. The only time you need a division ring assumption is to prove that the denominator is invertible, and if we search directly for <code>Invertible denom</code> in that case, with a fallback using <code>DivisionRing α</code> if it doesn't already work out of the box, then we get the ability to work in characteristic-n rings almost for free. (There is a bit more work to make the division operator work without assuming <code>DivisionRing</code>, so I'm fine if v1 just assumes <code>DivisionRing</code> in this lemma and doesn't bother with the invertible stuff.)</p>



<a name="320369594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320369594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320369594">(Jan 10 2023 at 02:55)</a>:</h4>
<p>Ohhkay, cool! So, just so I can get a better picture of things:</p>
<ol>
<li>what’s the underlying motivation for trying to reduce the number of expr operators? (performance somehow?)</li>
<li>what counts as an expr operator? casting counts, I’m guessing, from context…but in general, what’s that mean? (elaboration-stage manipulation?)</li>
</ol>
<p>As for how to proceed:</p>
<ol start="3">
<li>I won’t change the <code>ofNat</code>s, I’m guessing—just want to confirm we’re sticking with the original general approach.</li>
<li>Likewise, should we stick with the original <code>isRat</code>? This is less clear to me—having a <code>Rat</code> guarantees the arguments are well-formed, and the literals seem like they’re still “there”.</li>
</ol>
<p>However…I’m wondering if the previous-ish method of <code>Invertible (d : α)</code> ensured that the cast to <code>α</code>works for division rings that aren’t char zero, and this feels like it might be important.</p>



<a name="320369608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320369608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320369608">(Jan 10 2023 at 02:55)</a>:</h4>
<p>Oops, sent at the same time, let me read that.</p>



<a name="320369718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320369718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320369718">(Jan 10 2023 at 02:57)</a>:</h4>
<blockquote>
<p>what’s the underlying motivation for trying to reduce the number of expr operators? (performance somehow?)</p>
</blockquote>
<p>Yes, performance. The expr construction is the main bottleneck when constructing huge norm_num proofs (and the performance of norm_num is quite often the limiting factor on numerical proofs like proving the first n digits of pi correct).</p>



<a name="320369815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320369815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320369815">(Jan 10 2023 at 02:58)</a>:</h4>
<blockquote>
<p>what counts as an expr operator? casting counts, I’m guessing, from context…but in general, what’s that mean? (elaboration-stage manipulation?)</p>
</blockquote>
<p>There is no elaboration-stage manipulation here, these terms are handed directly to the kernel. I'm talking about the number of calls to <code>Expr.app</code> and friends.</p>



<a name="320369870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320369870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320369870">(Jan 10 2023 at 02:59)</a>:</h4>
<p>It is essentially the size of the expression you would see if you <code>pp.all</code> the term, except long names mostly don't count against you because they are shared.</p>



<a name="320369931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320369931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320369931">(Jan 10 2023 at 03:00)</a>:</h4>
<p>Ahh, ok, gotcha!</p>



<a name="320370005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370005">(Jan 10 2023 at 03:01)</a>:</h4>
<p><code>OfNat.ofNat</code> has the big problem that <code>OfNat</code> is dependent, which means you need a different typeclass argument for every single number so they can't be shared. This basically doubles the number of terms we have to construct</p>



<a name="320370105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370105">(Jan 10 2023 at 03:02)</a>:</h4>
<p>So <code>IsNat</code> uses a <code>CommSemiring α</code> argument which is cached so it can be used in each subterm and shared</p>



<a name="320370232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370232">(Jan 10 2023 at 03:04)</a>:</h4>
<p>Hmm, ok…I’ll need to get back to my computer and look at the types of these to see where the dependence flows! Does lean cache automatically when it can?</p>



<a name="320370249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370249">(Jan 10 2023 at 03:04)</a>:</h4>
<p>When you pass the same expr in multiple places, you construct a term with internal sharing</p>



<a name="320370274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370274">(Jan 10 2023 at 03:05)</a>:</h4>
<p>like if I do <code>(fun a =&gt; (a, a)) 17</code> there is only one <code>17</code> expr in memory and both members of the pair point to it</p>



<a name="320370288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370288">(Jan 10 2023 at 03:05)</a>:</h4>
<p>Oh, that’s great</p>



<a name="320370290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370290">(Jan 10 2023 at 03:05)</a>:</h4>
<p>If I do <code>(17, 17)</code>  (i.e. elaborating <code>17</code> twice) there may or may not be two <code>17</code>'s in memory</p>



<a name="320370313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370313">(Jan 10 2023 at 03:06)</a>:</h4>
<p>May not? <span aria-label="eyes" class="emoji emoji-1f440" role="img" title="eyes">:eyes:</span></p>



<a name="320370362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370362">(Jan 10 2023 at 03:06)</a>:</h4>
<p>Like in the case where 17 is actually a generic expression, so to speak?</p>



<a name="320370405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370405">(Jan 10 2023 at 03:07)</a>:</h4>
<p>Lean is not hash-consed, if that's what you mean: we do not have the guarantee that identical subterms are always shared</p>



<a name="320370426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370426">(Jan 10 2023 at 03:07)</a>:</h4>
<p>so unless you do something in particular to cause the same expression to be copied around you can't rely on them being pointer-equal</p>



<a name="320370493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370493">(Jan 10 2023 at 03:08)</a>:</h4>
<p>Oh, yeah, that’s what I expected: I was wondering how they <em>could</em> wind up shared if input separately (not appearing as intermediate terms)</p>



<a name="320370497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370497">(Jan 10 2023 at 03:08)</a>:</h4>
<p>There is the <code>shareCommon</code> function in <code>Init</code> which will maximally deduplicate an expression, so if you gave it <code>(17, 17)</code> it would ensure that both components of the pair point to the same object</p>



<a name="320370531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370531">(Jan 10 2023 at 03:09)</a>:</h4>
<p>Lean does have a variety of elaboration caches though so it is possible for things to become shared in the course of elaboration</p>



<a name="320370542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370542">(Jan 10 2023 at 03:09)</a>:</h4>
<p>I don't think <code>shareCommon</code> is used in the elaborator</p>



<a name="320370563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370563">(Jan 10 2023 at 03:09)</a>:</h4>
<p>and it's a linear time operation so not very usable for a program like <code>norm_num</code> to run after each operation</p>



<a name="320370650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370650">(Jan 10 2023 at 03:11)</a>:</h4>
<p>I seeee, very cool…yeah, it felt possibly expensive-enough to be “opt-in only” even not knowing that it was linear-time, lol</p>



<a name="320370959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320370959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320370959">(Jan 10 2023 at 03:15)</a>:</h4>
<p>So when we have a nat literal, there’s some magic to make it not a chain of <code>succ</code> applications, right? Assuming so, do induction proofs/definitions break that, or is there magic to deal with matching on <code>succ</code> too?</p>



<a name="320371141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320371141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320371141">(Jan 10 2023 at 03:18)</a>:</h4>
<p>yes, raw nat literals are a concept core to lean itself, there is a constructor <code>Expr.lit</code> that has support for literal <code>Nat</code> and <code>String</code>, and the kernel uses bignum computation to do <code>Nat.add</code>/<code>Nat.mul</code>. This is really cool, it means that we don't have to do things one <code>bit0</code> at a time anymore and it's also a lot faster. So <code>norm_num</code> is now delegated to handling all the other number arithmetic that isn't special cased by the kernel, and arithmetic on other types like <code>Real</code> where the kernel will do something really stupid if you just ask it to prove it by <code>rfl</code></p>



<a name="320371387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320371387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320371387">(Jan 10 2023 at 03:22)</a>:</h4>
<p>Okay, gotcha, that is really cool! Makes sense!</p>



<a name="320534510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320534510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320534510">(Jan 10 2023 at 20:01)</a>:</h4>
<blockquote>
<p>Result.toRawEq , which produces a "raw nat cast expression" which is like an OfNat.ofNat application but with simplified typeclass arguments.</p>
</blockquote>
<p>So, okay...I'm trying to write the analogous <code>rawCast</code> expression for rationals. Thing is, it seems to depend on info stored in the <code>IsRat</code> structure, namely, that <code>denom</code> is invertible. Should these be instance arguments? E.g.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">_root_.Rat.rawCast</span> <span class="o">[</span><span class="n">Ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Invertible</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">)]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span>  <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">*</span> <span class="bp">⅟</span><span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>
<p>As-is, though, this fails with a "failed to synthesize instance <code>Invertible ↑d</code>" message which I find unusual—it's right there!</p>
<p>Or, am I totally misinterpreting what a <code>rawCast</code> is?</p>



<a name="320534648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320534648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320534648">(Jan 10 2023 at 20:02)</a>:</h4>
<p>Also, what's that <code>_root_</code> doing there in all these <code>rawCast</code>s?</p>



<a name="320575129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320575129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320575129">(Jan 11 2023 at 01:13)</a>:</h4>
<p>It's to put the function in the <code>Nat</code> namespace</p>



<a name="320575437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320575437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320575437">(Jan 11 2023 at 01:16)</a>:</h4>
<p>The function should not take extra arguments, that would cause other problems. It could be a noncomputable definition, that is <code>if h : Invertible (d : A) then n * ⅟(d : α) else 0</code>, since it's only used in the middle of a proof where we don't care about computation</p>



<a name="320575673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/320575673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#320575673">(Jan 11 2023 at 01:19)</a>:</h4>
<p>actually it's probably best to just use <code>n / d</code> in a division ring for the definition of <code>rawCast</code>. The aforementioned expression does not have nice properties without more specific invertibility assumptions anyway. (That is, if you had two of those conditional expressions for different n,d it is not the case that <code>rawCast n1 d1 + rawCast n2 d2 = rawCast (n1 * d2 + n2 * d1) (d1 * d2)</code> without additional assumptions.)</p>



<a name="321285774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321285774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321285774">(Jan 14 2023 at 00:54)</a>:</h4>
<p>norm_num now works with rationals! <a href="https://github.com/leanprover-community/mathlib4/pull/1441">mathlib4#1441</a></p>



<a name="321286757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321286757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321286757">(Jan 14 2023 at 01:05)</a>:</h4>
<p>Mario and I spent a few hours today hammering it out; we sorried the proofs of the internal theorems given that the functionality is time-critical, but the actual tactic nonetheless now works as expected with rationals. I’ll try to respond to the just-incoming review comments asap. :)</p>



<a name="321304666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321304666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321304666">(Jan 14 2023 at 06:01)</a>:</h4>
<p>I have a question for the mathematicians: Is it true in a ring <code>A</code> that if <code>((a : Nat) : A)</code> is invertible and <code>b</code> divides <code>a</code> then <code>((b : Nat) : A)</code> is also invertible? I think the answer is yes but there isn't anything obviously applicable from mathlib. This is needed for <code>norm_num</code> to reduce rational number expressions</p>



<a name="321305428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321305428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321305428">(Jan 14 2023 at 06:14)</a>:</h4>
<p>yes, by associativity for each side, e.g. 1 = a⁻¹a = a⁻¹(kb) = (a⁻¹k)b, yielding a⁻¹k as a left inverse and ka⁻¹ as a right one; then a⁻¹k = ka⁻¹ because natural numbers commute with everything in the ring</p>



<a name="321305686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321305686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321305686">(Jan 14 2023 at 06:19)</a>:</h4>
<p>oh interesting, that argument doesn't need k to be nonzero</p>



<a name="321305747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321305747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321305747">(Jan 14 2023 at 06:20)</a>:</h4>
<p>so the <code>Nat.succ g</code> in our lemmas isn't needed after all</p>



<a name="321306286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321306286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321306286">(Jan 14 2023 at 06:28)</a>:</h4>
<p>well…it <em>kind</em> of does, because if k is 0, you can’t get that it times anything is equal to 1 and that first chain of equalities doesn’t work anymore 🙃 but if we’re allowing contradictory hypotheses (as might be the case with <code>g</code>, idk)…</p>



<a name="321306344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321306344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321306344">(Jan 14 2023 at 06:29)</a>:</h4>
<p>(ok, unless you’re in the zero ring.)</p>



<a name="321307036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321307036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321307036">(Jan 14 2023 at 06:41)</a>:</h4>
<p>sure, but that's not "kind of works", that is "works". The hypotheses are the hypotheses, the whole point is that you don't have to think about whether they are true or not since you are assuming they are</p>



<a name="321307168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321307168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321307168">(Jan 14 2023 at 06:43)</a>:</h4>
<p>the reason it doesn't result in nonsense in the norm_num application is that we have a bundled invertibility assumption which implies that all denominators are nonzero (as natural numbers), so <code>g</code> is provably nonzero even if we don't take it as an assumption</p>



<a name="321308838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321308838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321308838">(Jan 14 2023 at 07:09)</a>:</h4>
<p>yeah, absolutely—all I mean by “doesn’t work” is that if k = 0 (and A is not the zero ring) the argument blows up and you’re not in any real situation (well, we hope…)</p>



<a name="321316268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321316268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321316268">(Jan 14 2023 at 08:39)</a>:</h4>
<p>If A is the zero ring however then k=0 is fine and the nat a doesn't have to be zero</p>



<a name="321316382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321316382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321316382">(Jan 14 2023 at 08:40)</a>:</h4>
<p>cool, I incorporated this proof into <a href="https://github.com/leanprover-community/mathlib4/pull/1572">mathlib4#1572</a> which kills all the remaining sorries</p>



<a name="321316552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321316552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321316552">(Jan 14 2023 at 08:42)</a>:</h4>
<p>probably the core pieces of those proofs should go somewhere in mathlib proper, it's a bit weird for those lemmas to actually have mathematical content beyond a library lemma</p>



<a name="321316981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321316981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321316981">(Jan 14 2023 at 08:47)</a>:</h4>
<p>I assume we already have <a href="https://leanprover-community.github.io/mathlib_docs/find/is_unit_of_mul">docs#is_unit_of_mul</a>? Edit: <a href="https://leanprover-community.github.io/mathlib_docs/find/is_unit_of_dvd_unit">docs#is_unit_of_dvd_unit</a></p>



<a name="321317036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321317036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321317036">(Jan 14 2023 at 08:47)</a>:</h4>
<p>Oh, this is interesting: norm_num is now unable to prove theorems like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">[</span><span class="n">Field</span> <span class="n">α</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">-</span> <span class="bp">-</span> <span class="o">(</span><span class="mi">16</span> <span class="bp">/</span> <span class="o">((</span><span class="mi">11</span> <span class="bp">/</span> <span class="o">(</span><span class="bp">-</span> <span class="bp">-</span> <span class="o">(</span><span class="mi">6</span> <span class="bp">*</span> <span class="mi">19</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">12</span><span class="o">))</span> <span class="bp">*</span> <span class="mi">21</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">96</span><span class="bp">/</span><span class="mi">11</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num</span>
</code></pre></div>
<p>because the denominators are not necessarily invertible unless you assume that alpha is CharZero</p>



<a name="321317216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321317216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321317216">(Jan 14 2023 at 08:49)</a>:</h4>
<p>Speaking of <code>is_unit</code>, why do we even have <code>invertible</code> since it's basically the same thing?</p>



<a name="321317308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321317308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321317308">(Jan 14 2023 at 08:50)</a>:</h4>
<p>The latter is constructive</p>



<a name="321317583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321317583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321317583">(Jan 14 2023 at 08:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Rat.20in.20norm_num/near/321317036">said</a>:</p>
<blockquote>
<p>Oh, this is interesting: norm_num is now unable to prove theorems like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">[</span><span class="n">Field</span> <span class="n">α</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">-</span> <span class="bp">-</span> <span class="o">(</span><span class="mi">16</span> <span class="bp">/</span> <span class="o">((</span><span class="mi">11</span> <span class="bp">/</span> <span class="o">(</span><span class="bp">-</span> <span class="bp">-</span> <span class="o">(</span><span class="mi">6</span> <span class="bp">*</span> <span class="mi">19</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">12</span><span class="o">))</span> <span class="bp">*</span> <span class="mi">21</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">96</span><span class="bp">/</span><span class="mi">11</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num</span>
</code></pre></div>
<p>because the denominators are not necessarily invertible unless you assume that alpha is CharZero</p>
</blockquote>
<p>Specifically, norm_num will reduce the goal to <code>16 / (11 / 126 * 21) = 96 / 11</code> and then stop because it can't prove that <code>126</code> is invertible so it doesn't know how to clear the denominator</p>



<a name="321317769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321317769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321317769">(Jan 14 2023 at 08:55)</a>:</h4>
<p>I'm confused how this ever worked</p>



<a name="321318141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321318141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321318141">(Jan 14 2023 at 08:59)</a>:</h4>
<p>Aha, it's an issue in the translation of the test - the original lean 3 test file was assuming <code>LinearOrderedField α</code></p>



<a name="321323493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321323493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321323493">(Jan 14 2023 at 09:43)</a>:</h4>
<p>Ideally, we’d be able to look for the characteristic of the division ring, check coprimality to it, and if we have it (or if the characteristic is zero—not sure what convention is used) get an <code>Invertible</code> term, right? (I’m guessing we’d also want to normalize mod the characteristic, but I’d think this should be done in some basic evaluator way before the one for <code>/</code> if possible, and apply everywhere, not just when looking at inverses.)</p>
<p>But, I guess this would only be possible if we had either <code>Char m α</code> (is that how we spell it?) for some literal m, <code>CharZero α</code>, or found a way to make use of assumptions about <code>m</code> in the context, like if it was some unknown prime or something (but maybe we have special ways of spelling that too?)—but I don’t know if all that searching would be performant. Though, if we could find the relevant info once and keep it, maybe it wouldn’t be too bad. Just thinking out loud.</p>



<a name="321324032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321324032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321324032">(Jan 14 2023 at 09:48)</a>:</h4>
<p>I was thinking that (assuming there is no <code>CharZero</code> instance) you could look up and cache invertible instances for all the prime factors of the number. For the common case where you would want this kind of thing, it's always going to be 2 and/or 3 that you are searching for</p>



<a name="321324328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321324328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321324328">(Jan 14 2023 at 09:50)</a>:</h4>
<p>although I suppose for a ring of known characteristic that's less efficient than your approach if there are a lot of big primes being inverted</p>



<a name="321324811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321324811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321324811">(Jan 14 2023 at 09:55)</a>:</h4>
<p>It's basically two complementary situations you could be working in: if you have a known characteristic than everything is invertible except a fixed list of primes, or you might be working in a ring of "any characteristic except 2 or 3" in which case you know 2 and 3 are invertible but nothing else</p>



<a name="321325112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321325112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321325112">(Jan 14 2023 at 09:57)</a>:</h4>
<p>Oh interesting! How do we phrase that the ring has characteristic unequal to 2 or 3? Do we have some special way of writing it, or do we just have a hypothesis somewhere saying e.g. <code>m &gt; 2</code> or something? I’m wondering how we’ll tell which situation we’re in.</p>



<a name="321325504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321325504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321325504">(Jan 14 2023 at 10:00)</a>:</h4>
<p>(Also, nitpick: everything except a fixed list of *multiples of primes! unless I’m misinterpreting?)</p>



<a name="321326932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321326932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321326932">(Jan 14 2023 at 10:10)</a>:</h4>
<blockquote>
<p>How do we phrase that the ring has characteristic unequal to 2 or 3?</p>
</blockquote>
<p><code>[Invertible (2 : R)] [Invertible (3 : R)]</code> I think</p>



<a name="321327073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321327073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321327073">(Jan 14 2023 at 10:11)</a>:</h4>
<p>That says a lot more—that it doesn’t have even characteristic/characteristic which is a multiple of 3</p>



<a name="321327270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321327270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuyang Zhao <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321327270">(Jan 14 2023 at 10:13)</a>:</h4>
<p><code>[NeZero (2 : R)]</code> <code>[NeZero (3 : R)]</code>?</p>



<a name="321327323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321327323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321327323">(Jan 14 2023 at 10:13)</a>:</h4>
<p>In mathlib I think this is what is used, anyways. I don't think people are overly concerned about the non-ID case</p>



<a name="321328537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321328537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321328537">(Jan 14 2023 at 10:21)</a>:</h4>
<p>If they aren’t already, some people will be eventually (hopefully!), so I feel like we ought to know what to do about it—it might also make other things easier indirectly if we’re able to know facts about the characteristic somehow</p>



<a name="321328755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321328755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321328755">(Jan 14 2023 at 10:23)</a>:</h4>
<p><code>NeZero</code> is interesting! I wonder though if instead of looking for instances we can simply access outer hypotheses from within norm_num (without passing them in explicitly). Doing a single check through the context for relevant ones at one point might be useful.</p>



<a name="321330131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321330131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321330131">(Jan 14 2023 at 10:32)</a>:</h4>
<p>I guess basically what we’d be looking for in this case are explicit inequalities constraining the characteristic or primality/divisibility facts. I can’t think of much else that would be useful for this kind of normalization…</p>



<a name="321341753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321341753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321341753">(Jan 14 2023 at 11:44)</a>:</h4>
<p><code>ne_zero</code> is only useful in the presence of <code>is_domain</code> or whatever it's called. Then you can cancel nonzero things because ax=ay implies a(x-y)=0 so x-y=0</p>



<a name="321347329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321347329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321347329">(Jan 14 2023 at 12:17)</a>:</h4>
<p>If you are dividing by things then they should be invertible of course.</p>



<a name="321350913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321350913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321350913">(Jan 14 2023 at 12:42)</a>:</h4>
<p>yeah I think <code>invertible</code> is superior to <code>ne_zero</code> in this situation since being zero or not is only really interesting in domains and fields, whereas invertibility is what matters for rings</p>



<a name="321392179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321392179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321392179">(Jan 14 2023 at 18:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/287929-mathlib4/topic/Rat.20in.20norm_num/near/321347329">said</a>:</p>
<blockquote>
<p>If you are dividing by things then they should be invertible of course.</p>
</blockquote>
<p>See, that’s what I thought! It’s still so weird to me that a potential divide-by-zero expression even typechecks. I get why it’s good for functions to be total and not have to take extra assumptions as arguments, but…it also seems like we’re missing out on something types are usually meant to help with, right? I feel like mathlib’s convention of having <code>x / 0 = 0</code> will somehow lead to human mistakes…</p>



<a name="321393224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321393224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321393224">(Jan 14 2023 at 18:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Rat.20in.20norm_num/near/321350913">said</a>:</p>
<blockquote>
<p>yeah I think <code>invertible</code> is superior to <code>ne_zero</code> in this situation since being zero or not is only really interesting in domains and fields, whereas invertibility is what matters for rings</p>
</blockquote>
<p>I think this is backwards: invertibility tells you what you need to know about the characteristic for integral domains and fields, since the characteristic is necessarily prime and therefore saying that e.g. 2 is invertible only eliminates the case that the characteristic is 2.</p>
<p>But for rings, saying that 2 is invertible says that the characteristic is even, not that it’s not 2. If you want to make a statement about a general ring not having characteristic 2, you can’t do it with invertibility.</p>



<a name="321393538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321393538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321393538">(Jan 14 2023 at 18:13)</a>:</h4>
<blockquote>
<p>But for rings, saying that 2 is invertible says that the characteristic is even, not that it’s not 2. If you want to make a statement about a general ring not having characteristic 2, you can’t do it with invertibility.</p>
</blockquote>
<p>In this case I think the scenario would actually be even characteristic then, because the usual reason that kind of hypothesis pops up is because you want to invert 2.</p>



<a name="321393654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321393654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321393654">(Jan 14 2023 at 18:14)</a>:</h4>
<p>I'm thinking of stuff like the quadratic / cubic formula here, where you have to put 2 in the denominators of things and so you need an assumption that says that this is meaningful</p>



<a name="321393834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321393834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321393834">(Jan 14 2023 at 18:16)</a>:</h4>
<p>elliptic curve parameterization also involves a case split on the characteristic. I'm pretty sure in one of the cases we want to divide by 2 and not simply know that it is nonzero</p>



<a name="321393897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321393897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321393897">(Jan 14 2023 at 18:17)</a>:</h4>
<p>Yeah, that’s fair! Maybe knowing the characteristic is not one specific number is not really ever important for rings. All I can think of is the case where we know it’s not 2 because the ring doesn’t have some property char-2 rings have, but even then, knowing this doesn’t really help us normalize numbers.</p>



<a name="321399782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321399782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321399782">(Jan 14 2023 at 19:15)</a>:</h4>
<p>Wow, a lot has happened in 24 hours!  Thank you so much <span class="user-mention" data-user-id="548935">@Thomas Murrills</span>, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> and <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span>.</p>
<p>Regarding your questions about the features of <code>norm_num</code> that I personally would like to use immediately:</p>
<ul>
<li>I would need it to work for <code>Real</code>, so <strong>yes</strong>, I need the functionality to assess denominators using either a <code>CharZero</code> instance or (if it's easier) a <code>LinearOrderedField</code> instance.</li>
<li><strong>no</strong>, I will never use fields of nonzero characteristic or general rings in which certain numbers like 2 or 3 are known to be invertible</li>
<li><strong>yes</strong>, I would need it to cope with ≤, &lt;, and ≠.</li>
<li>since it would be used for problems assessed by an autograder, there need to be no sorries in the supporting lemmas.  But I can work on the sorries myself.</li>
</ul>
<p>I am still reading through the various PRs and haven't caught up yet on exactly which of this functionality you've implemented already.</p>



<a name="321409403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321409403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321409403">(Jan 14 2023 at 21:13)</a>:</h4>
<p>9 messages were moved from this topic to <a class="stream-topic" data-stream-id="287929" href="/#narrow/stream/287929-mathlib4/topic/false.20alarm.20about.20norm_num">#mathlib4 &gt; false alarm about norm_num</a> by <span class="user-mention silent" data-user-id="260507">Heather Macbeth</span>.</p>



<a name="321413688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321413688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321413688">(Jan 14 2023 at 22:16)</a>:</h4>
<p>Regarding the autograder, you could potentially add the missing theorems as axioms (and add them to your list of allowed axioms)</p>



<a name="321414877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat%20in%20norm_num/near/321414877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Rat.20in.20norm_num.html#321414877">(Jan 14 2023 at 22:32)</a>:</h4>
<p>True, although it seems unprincipled to make a change like that to mathlib for one person's purposes.  But in any case the sorries should be gone after <a href="https://github.com/leanprover-community/mathlib4/pull/1572">mathlib4#1572</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
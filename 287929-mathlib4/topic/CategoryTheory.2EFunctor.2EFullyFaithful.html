---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html">CategoryTheory.Functor.FullyFaithful</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="316182255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316182255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316182255">(Dec 16 2022 at 03:23)</a>:</h4>
<p>I was hoping to help with the Category theory port effort, and it looks like most of the work is blocked by <a href="https://github.com/leanprover-community/mathlib4/pull/846">mathlib4#846</a> opened by <span class="user-mention" data-user-id="560559">@Richard Osborn</span> .</p>
<p>I'm happy to help with the file if the help is welcome... I've fixed a couple of the errors, and made progress on a couple more.</p>



<a name="316182635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316182635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316182635">(Dec 16 2022 at 03:28)</a>:</h4>
<p>I think there is no problem just editting if the file is sitting around for a month and has a 'help wanted' tag</p>



<a name="316183525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316183525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316183525">(Dec 16 2022 at 03:42)</a>:</h4>
<p>Sorry, I've been busy with other things and feeling guilty I haven't looked at that.</p>



<a name="316183550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316183550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316183550">(Dec 16 2022 at 03:42)</a>:</h4>
<p>From memory Richard indicated that <code>aesop</code> wasn't doing something that <code>tidy</code> used to, so you may need to experiment with powering up aesop (giving it access to more tactics or lemmas or whatever).</p>



<a name="316183561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316183561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316183561">(Dec 16 2022 at 03:43)</a>:</h4>
<p>Please ping if you want more eyes!</p>



<a name="316195177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316195177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316195177">(Dec 16 2022 at 06:25)</a>:</h4>
<p>I got the file to typecheck! There's still a lot of cleanup left to do, but I'll compile all the weird behaviors I encountered in this thread once I figure out what's going on...</p>



<a name="316208154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316208154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316208154">(Dec 16 2022 at 08:16)</a>:</h4>
<p>Describing the weird behaviours as <code>-- Porting note: ...</code> or <code>-- Porting note: TODO ...</code> is  good too. :-)</p>



<a name="316266776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316266776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316266776">(Dec 16 2022 at 13:30)</a>:</h4>
<p>I took a quick look at this file. It seems that <code>aesop_cat</code> can't see that things like <code>Function.Injective</code>, <code>Function.RightInverse</code>, etc. are functions and that <code>intros</code> should be applied. At least <code>aesop_cat</code> succeeds if the <code>Function.Injective</code> and/or <code>Function.RightInverse</code> are unfolded first. What's the right approach here? How does one train <code>aesop_cat</code> to use <code>intros</code> (or to unfold) in such situations?</p>



<a name="316269059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316269059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316269059">(Dec 16 2022 at 13:41)</a>:</h4>
<p><code>aesop_cat (add norm unfold Function.Injective)</code> if you want to unfold <code>Injective</code> at one particular Aesop call.</p>
<p>If you want to unfold <code>Injective</code> as a global rule, add <code>@[aesop norm unfold]</code> on <code>Function.Injective</code>. However, this is maybe too aggressive. For example, a rule <code>Involutive -&gt; Injective</code> would not apply any more since <code>Injective</code> is unfolded first. I've had good experiences with this setup:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[aesop safe forward]</span>
<span class="kd">theorem</span> <span class="n">injective_elim</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">Injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
  <span class="n">h₁</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h₂</span>

<span class="kd">@[aesop 99%]</span>
<span class="kd">theorem</span> <span class="n">injective_intro</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">Injective</span> <span class="n">f</span> <span class="o">:=</span>
  <span class="n">h</span>
</code></pre></div>
<p>If you have hypotheses <code>h : Injective f</code> and <code>h' : f a = f b</code>, the first rule will conclude <code>a = b</code>. If you have a target <code>Injective f</code>, the second rule will unfold <code>Injective</code>, but unsafely, thus giving other rules a chance to fire.</p>



<a name="316294767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316294767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316294767">(Dec 16 2022 at 15:33)</a>:</h4>
<p>Thanks Jannis! What's the heuristic for that 99%? Does this mean the (unsafe) rule is applied 99% of the time or 1% of the time?</p>



<a name="316334005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316334005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316334005">(Dec 16 2022 at 18:31)</a>:</h4>
<p>I haven't marked any of the lemmas in the file for Aesop. Is there a rough guideline for what kinds of lemmas would make for good Aesop lemmas?</p>



<a name="316334717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316334717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Richard Osborn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316334717">(Dec 16 2022 at 18:34)</a>:</h4>
<p>Yea, the files should be complete other than <code>aesop_cat</code> and <code>unfold_proj</code> blocking them. The proofs can fairly easily be rewritten to work around the issues in the short term if you want to start porting subsequent files. I won’t have access to my computer until later tonight, but I can push new proofs while <code>aesop_cat</code> gets fixed and <code>unfold_proj</code> gets implemented. Also, feel free to work on the files. I only have a couple hrs each day to look into them.</p>



<a name="316336628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316336628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316336628">(Dec 16 2022 at 18:44)</a>:</h4>
<p>I did some work on it last night, and the file is pretty much done at this point. Just some minor aesthetic issues with one of the proofs... </p>
<p>I think something that would be helpful is if someone more knowledgeable about how casts work in Lean 4 could check out what's going on at this porting note: <a href="https://github.com/leanprover-community/mathlib4/blob/60d4254544886e10cfc417aff29a3c6362b1a9c6/Mathlib/CategoryTheory/Functor/FullyFaithful.lean#L324">https://github.com/leanprover-community/mathlib4/blob/60d4254544886e10cfc417aff29a3c6362b1a9c6/Mathlib/CategoryTheory/Functor/FullyFaithful.lean#L324</a> .</p>
<p>I was able to get around the issue manually, but it seemed like in the Lean 3 proof, Lean was far more willing to rewrite through casts...</p>



<a name="316378673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316378673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316378673">(Dec 16 2022 at 23:23)</a>:</h4>
<p>I golfed this proof a little bit...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- “Divide” a functor by a faithful functor. -/</span>
<span class="kn">protected</span> <span class="kd">def</span> <span class="n">Faithful.div</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">⥤</span> <span class="n">E</span><span class="o">)</span> <span class="o">[</span><span class="n">Faithful</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">obj</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">D</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h_obj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span><span class="o">,</span> <span class="n">G.obj</span> <span class="o">(</span><span class="n">obj</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="n">F.obj</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">},</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">obj</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">obj</span> <span class="n">Y</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h_map</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">},</span> <span class="n">HEq</span> <span class="o">(</span><span class="n">G.map</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span><span class="o">))</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">obj</span><span class="o">,</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">map</span><span class="o">,</span>
    <span class="n">map_id</span> <span class="o">:=</span> <span class="kd">by</span>
      <span class="n">intros</span> <span class="n">X</span>
      <span class="n">apply</span> <span class="n">G.map_injective</span>
      <span class="n">apply</span> <span class="n">eq_of_heq</span>
      <span class="n">refine</span> <span class="n">HEq.trans</span> <span class="n">h_map</span> <span class="bp">?</span><span class="n">_</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Functor.map_id</span><span class="o">]</span>
      <span class="n">convert</span> <span class="n">HEq.refl</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">X</span><span class="o">))</span>
      <span class="n">all_goals</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">h_obj</span> <span class="o">}</span>
    <span class="n">map_comp</span> <span class="o">:=</span> <span class="kd">by</span>
      <span class="n">intros</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="n">f</span> <span class="n">g</span>
      <span class="n">apply</span> <span class="n">G.map_injective</span>
      <span class="n">apply</span> <span class="n">eq_of_heq</span>
      <span class="n">refine</span> <span class="n">HEq.trans</span> <span class="n">h_map</span> <span class="bp">?</span><span class="n">_</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Functor.map_comp</span><span class="o">]</span>
      <span class="n">convert</span> <span class="n">HEq.refl</span> <span class="o">(</span><span class="n">F.map</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">F.map</span> <span class="n">g</span><span class="o">)</span>
      <span class="n">all_goals</span> <span class="o">{</span> <span class="n">try</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">h_obj</span> <span class="o">}</span> <span class="bp">&lt;;&gt;</span> <span class="n">apply</span> <span class="n">h_map</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="316378780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316378780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316378780">(Dec 16 2022 at 23:24)</a>:</h4>
<p>I'm not really sure why casts showed up in the first place?</p>



<a name="316380140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316380140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316380140">(Dec 16 2022 at 23:37)</a>:</h4>
<p>Oh that looks way better!</p>
<p>It is quite strange, the original proof could just call<br>
<code>transitive F.map (𝟙 X)</code>, but in Lean 4 it was failing to  unify <code>F.map (𝟙 X)</code> with something that could be <code>HEq</code> with <code>G.map (map (𝟙 X))</code></p>



<a name="316380277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316380277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316380277">(Dec 16 2022 at 23:38)</a>:</h4>
<p>Could you push to the branch? I'm away from my computer for a few hours...</p>



<a name="316380469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316380469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316380469">(Dec 16 2022 at 23:40)</a>:</h4>
<p>pushed!</p>



<a name="316380661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316380661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316380661">(Dec 16 2022 at 23:42)</a>:</h4>
<p>Let me add back the porting note about the trans tactic, so we don't forget!</p>



<a name="316425283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316425283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316425283">(Dec 17 2022 at 09:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful/near/316294767">said</a>:</p>
<blockquote>
<p>Thanks Jannis! What's the heuristic for that 99%? Does this mean the (unsafe) rule is applied 99% of the time or 1% of the time?</p>
</blockquote>
<p>The number is supposed to be a (very rough) estimate of the success probability of a rule. So "when you have an <code>Injective</code> target, how likely is it that this rule will lead to a proof?" Operationally, rules with higher success probability are tried first and the priority of the subgoals of a rule is the priority of the goal to which the rule was applied, multiplied with the success probability.</p>



<a name="316432890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316432890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316432890">(Dec 17 2022 at 10:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="455674">Matej Penciak</span> <a href="#narrow/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful/near/316334005">said</a>:</p>
<blockquote>
<p>I haven't marked any of the lemmas in the file for Aesop. Is there a rough guideline for what kinds of lemmas would make for good Aesop lemmas?</p>
</blockquote>
<p>I tend to think not so much in terms of individual lemmas but in terms of proofs. So take some class of proofs that seems like they ought to be automatic and add the relevant lemmas as <code>apply</code> rules, if they should be applied to the target, or <code>forward</code>/<code>destruct</code> rules, if they should be used to generate new hypotheses. Equations should be registered as <code>simp</code> lemmas.</p>
<p>To get reasonable performance, you'll have to avoid these sorts of rules:</p>
<ul>
<li>Anything that sends Aesop into a loop, e.g. an <code>apply</code> rule that is applicable to one of its own premises. These rules can be useful as low-priority local rules, but generally not as global rules.</li>
<li>Similarly, anything that introduces metavariables, e.g. exists-intro or transitivity rules, is better used as a local rule (if at all).</li>
<li><code>apply</code> rules with many premises on which Aesop can make progress but which don't ultimately lead to a proof.</li>
<li>Too many <code>forward</code> rules in general, since the implementation of <code>forward</code> rules is currently a bit naive. (<code>destruct</code> is fine.)</li>
</ul>
<p>Also, the rules should be in simp-normal form (as usual) since Aesop simps the whole goal before it does anything else.</p>
<p>A frequent source of tension is that while you build an API, you want rules that look through abstractions (e.g. unfold <code>Injective</code>) and when the API is built, you want rules that preserve abstractions. One way around this is to define a separate rule set for building the API; the other way is to add abstraction-breaking rules only locally. At some point I'll change the UI such that the rule set approach has less syntactic overhead.</p>



<a name="316495491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316495491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316495491">(Dec 17 2022 at 18:22)</a>:</h4>
<p>I had another question while reviewing this PR. Consider the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- If `F` is full, and naturally isomorphic to some `F'`, then `F'` is also full. -/</span>
<span class="kd">def</span> <span class="n">Full.ofIso</span> <span class="o">[</span><span class="n">Full</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">≅</span> <span class="n">F'</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">Full</span> <span class="n">F'</span> <span class="n">where</span>
  <span class="n">preimage</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">F.preimage</span> <span class="o">((</span><span class="n">α.app</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">hom</span> <span class="bp">≫</span> <span class="n">f</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">α.app</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">inv</span><span class="o">)</span>
  <span class="n">witness</span> <span class="n">f</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span><span class="n">NatIso.naturality_1</span> <span class="n">α</span><span class="o">]</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">category_theory.full.of_iso</span> <span class="n">CategoryTheory.Full.ofIso</span>

<span class="kd">theorem</span> <span class="n">Faithful.of_iso</span> <span class="o">[</span><span class="n">Faithful</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">≅</span> <span class="n">F'</span><span class="o">)</span> <span class="o">:</span> <span class="n">Faithful</span> <span class="n">F'</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">map_injective</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">h</span> <span class="bp">=&gt;</span>
      <span class="n">F.map_injective</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">NatIso.naturality_1</span> <span class="n">α.symm</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">NatIso.naturality_1</span> <span class="n">α.symm</span><span class="o">])</span> <span class="o">}</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">category_theory.faithful.of_iso</span> <span class="n">CategoryTheory.Faithful.of_iso</span>
</code></pre></div>
<p>This does technically fit with out naming conventions since <code>Functor.Full</code> has data while <code>Functor.Faithful</code> is a prop-valued class. But the asymmetry in the names here seems quite bad to me!</p>



<a name="316495633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316495633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316495633">(Dec 17 2022 at 18:23)</a>:</h4>
<p>My vote would be to use lower-camel-case for both names, and more generally for names of all instances, regardless of whether they are props or not! Thoughts?</p>



<a name="316499529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316499529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316499529">(Dec 17 2022 at 19:01)</a>:</h4>
<p>Hmm, I think it's quite a useful feature that we can distinguish prop-vs-data using the naming convention.</p>



<a name="316506217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316506217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316506217">(Dec 17 2022 at 20:16)</a>:</h4>
<p>This was a weird thing that came up in porting the file as well:</p>
<p>In writing the proof for <a href="https://github.com/leanprover-community/mathlib4/blob/aa5e1f92324d6a35fbbb434b4b4a4f11224f54e5/Mathlib/CategoryTheory/Functor/FullyFaithful.lean#L320">Faithful.div</a> , something about the parser for the structure syntax was bugging out and causing some issues. I've minimized it to the following MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foo</span> <span class="n">where</span>
  <span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">a_eq_b</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>

<span class="kd">def</span> <span class="n">natToFoo</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">bar</span> <span class="o">:</span> <span class="n">Foo</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">bar.b</span><span class="o">)</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">bar.b</span><span class="o">,</span>
    <span class="n">a_eq_b</span> <span class="o">:=</span> <span class="kd">by</span>
      <span class="gr">sorry</span>
  <span class="o">}</span>
</code></pre></div>
<p>When trying to fill in the <code>sorry</code>, the only way I can get the infoview to show my goals is to add a <code>done</code> at the end, otherwise it shows nothing.</p>



<a name="316506462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316506462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316506462">(Dec 17 2022 at 20:19)</a>:</h4>
<p>This does not happen if instead I write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">natToFoo</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">bar</span> <span class="o">:</span> <span class="n">Foo</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">bar.b</span><span class="o">)</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">bar.b</span><span class="o">,</span>
    <span class="n">a_eq_b</span> <span class="o">:=</span> <span class="kd">by</span>
      <span class="gr">sorry</span>
  <span class="o">}</span>
</code></pre></div>
<p>so it looks like it's something about the field init shorthand (which I actually didn't even know Lean had until I saw <code>Faithful.div</code>!)</p>



<a name="316506556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316506556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316506556">(Dec 17 2022 at 20:20)</a>:</h4>
<p>Is that syntax definitely allowed? In my VS Code the <code>a</code> in <code>a, b</code> is blue, indicating that it's not a structure field.</p>



<a name="316506630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316506630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316506630">(Dec 17 2022 at 20:21)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="mi">37</span><span class="o">,</span> <span class="c1">-- unknown identifier 'a'</span>
    <span class="n">a_eq_b</span> <span class="o">:=</span> <span class="kd">by</span>
      <span class="gr">sorry</span>
      <span class="n">done</span>
  <span class="o">}</span>
</code></pre></div>



<a name="316506721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316506721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316506721">(Dec 17 2022 at 20:22)</a>:</h4>
<p>I'm not sure <span aria-label="grimacing" class="emoji emoji-1f62c" role="img" title="grimacing">:grimacing:</span>, but if you fill in the proof Lean doesn't complain, so I assumed it had something to do with this fancy thing I literally just read in the Rust book a couple days ago: <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-the-field-init-shorthand">https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-the-field-init-shorthand</a></p>



<a name="316506764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316506764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316506764">(Dec 17 2022 at 20:22)</a>:</h4>
<p>My guess is that if <code>a</code> is in the context, and has the same name  and type as a field in the structure you can just put it in.</p>



<a name="316506820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316506820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316506820">(Dec 17 2022 at 20:23)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">natToFoo</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">a_eq_b</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a_eq_b</span><span class="o">}</span>

<span class="k">#eval</span> <span class="n">natToFoo</span> <span class="mi">2</span> <span class="mi">2</span> <span class="n">rfl</span> <span class="c1">-- { a := 2, b := 2, a_eq_b := _ }</span>
</code></pre></div>
<p>works</p>



<a name="316507146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316507146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316507146">(Dec 17 2022 at 20:26)</a>:</h4>
<p>Oh I see! You weren't attempting to assign <code>bar.b</code> to <code>a</code> too? Sorry, I misunderstood that part.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">natToFoo</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">bar</span> <span class="o">:</span> <span class="n">Foo</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">bar.b</span><span class="o">)</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">bar.b</span><span class="o">,</span>
    <span class="n">a_eq_b</span> <span class="o">:=</span> <span class="kd">by</span>
      <span class="c1">-- ⊢ a = bar.b</span>
      <span class="gr">sorry</span>
  <span class="o">}</span>
</code></pre></div>
<p>I see the goal if I put the cursor just before the <code>s</code> of <code>sorry</code> (which is something I do a lot).</p>



<a name="316507266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316507266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316507266">(Dec 17 2022 at 20:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful/near/316507146">said</a>:</p>
<blockquote>
<p>Oh I see! You weren't attempting to assign <code>bar.b</code> to <code>a</code> too? Sorry, I misunderstood that part.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">natToFoo</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">bar</span> <span class="o">:</span> <span class="n">Foo</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">bar.b</span><span class="o">)</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">bar.b</span><span class="o">,</span>
    <span class="n">a_eq_b</span> <span class="o">:=</span> <span class="kd">by</span>
      <span class="c1">-- ⊢ a = bar.b</span>
      <span class="gr">sorry</span>
  <span class="o">}</span>
</code></pre></div>
<p>I see the goal if I put the cursor just before the <code>s</code> of <code>sorry</code> (which is something I do a lot).</p>
</blockquote>
<p>But if you delete the sorry and try to fill in the goal, there is nothing in the infoview</p>



<a name="316507528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316507528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316507528">(Dec 17 2022 at 20:30)</a>:</h4>
<p>Oh actually this isn't as bad as I remembered, as long as there is even a single line in the proof something appears in the infoview...</p>



<a name="316508929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316508929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316508929">(Dec 17 2022 at 20:46)</a>:</h4>
<p>Oh this is interesting: I always put a <code>sorry</code> at the end of a proof before I start working on it, so I had never noticed this phenomenon.</p>



<a name="316508983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316508983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316508983">(Dec 17 2022 at 20:47)</a>:</h4>
<p>this is the same issue that people were talking about <code>done</code>/<code>qed</code> in the other thread for: empty blocks are a syntax error and this breaks a lot of things</p>



<a name="316509037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316509037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316509037">(Dec 17 2022 at 20:48)</a>:</h4>
<p>I see -- the issue is that the <code>}</code> just throws Lean into confusion because it was expecting a tactic.</p>



<a name="316532562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316532562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316532562">(Dec 18 2022 at 02:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful/near/316499529">said</a>:</p>
<blockquote>
<p>Hmm, I think it's quite a useful feature that we can distinguish prop-vs-data using the naming convention.</p>
</blockquote>
<p>This actually brings up another point. IMO <code>Functor.Full</code> could very well be made prop-valued. Anyone, one could certainly make an argument either way. What happens in the future, after the port is done, if we want to make <code>Functor.Full</code> Prop-valued? The current naming convention would probably make such a refactor more annoying.</p>
<p>This is not unprecedented. <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.has_limits">docs#category_theory.limits.has_limits</a> used to contain data.</p>



<a name="316532973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316532973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316532973">(Dec 18 2022 at 02:09)</a>:</h4>
<p>I would guess that such changes occur mostly for typeclasses. So if we choose a uniform naming convention for instances, that would eliminate the potential additional work (or at least most of it)</p>



<a name="316533036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316533036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316533036">(Dec 18 2022 at 02:10)</a>:</h4>
<p>I should also mention that I'm not really invested in this suggestion. I'm sure I could get used to whatever convention we settle on. But j do think these things are worth discussing.</p>



<a name="316556674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316556674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316556674">(Dec 18 2022 at 08:48)</a>:</h4>
<p>I was told by someone that in Isabelle/HOL they stick out the is_ convention for prop-valued typeclasses and if worked great</p>



<a name="316576480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316576480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316576480">(Dec 18 2022 at 11:59)</a>:</h4>
<p>I think that with proper language server support, doing a global rename of something should be pretty easy. So I think Lean 4 will actually make this easier then it was in Lean 3.</p>



<a name="316595724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316595724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316595724">(Dec 18 2022 at 14:25)</a>:</h4>
<p>Presumably the LSP could also detect which terms are proofs and which are data, and reflect that info in the editor in some way (e.g. text colour).</p>



<a name="316638989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316638989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316638989">(Dec 18 2022 at 21:22)</a>:</h4>
<p>Back to the aesop issue, I think the more important question is why aesop is not doing the variable introduction when it sees an <code>injective</code> goal.</p>



<a name="316639006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316639006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316639006">(Dec 18 2022 at 21:23)</a>:</h4>
<p>Is it not actually trying <code>intro</code>, but instead looking at the syntactical form of the goal?</p>



<a name="316639008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316639008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316639008">(Dec 18 2022 at 21:23)</a>:</h4>
<p>If so, this should be changed (at least under an option).</p>



<a name="316639032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316639032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316639032">(Dec 18 2022 at 21:23)</a>:</h4>
<p>We definitely don't want to be adding unsafe rules about unfolding Injective, I think.</p>



<a name="316771289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316771289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316771289">(Dec 19 2022 at 15:36)</a>:</h4>
<p>Aesop uses the <code>MetaM</code> equivalent of <code>intros</code>, which does not unfold <code>Injective</code> to discover the forall binders:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Init.Function</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">f.Injective</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="c1">-- ... ⊢ Function.Injective f</span>
  <span class="n">intros</span>
  <span class="c1">-- ... ⊢ Function.Injective f</span>
  <span class="n">intro</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
  <span class="c1">-- ... ⊢ a₁ = a₂</span>
  <span class="gr">sorry</span>
</code></pre></div>
<p>I can change this of course, but I think the current behaviour is correct. If we eagerly unfold <code>Injective</code> and introduce its premises, rules like <code>Involutive f -&gt; Injective f</code> will not work any more.</p>
<p>(Interestingly, the behaviour of <code>intros</code> does not change if we make <code>Injective</code> an <code>abbrev</code>.)</p>



<a name="316780500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316780500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316780500">(Dec 19 2022 at 16:20)</a>:</h4>
<p>As Scott said, maybe we could add an option for aesop to be more aggressive with intros?</p>



<a name="316780782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316780782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316780782">(Dec 19 2022 at 16:22)</a>:</h4>
<p>This port PR is holding up a bunch of category theory porting. Do we want to wait until we figure out what to do with <code>aesop_cat</code> before merging?</p>



<a name="316782012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316782012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316782012">(Dec 19 2022 at 16:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful/near/316780500">said</a>:</p>
<blockquote>
<p>As Scott said, maybe we could add an option for aesop to be more aggressive with intros?</p>
</blockquote>
<p>Can be done, but what's wrong with the scheme I outlined above?</p>



<a name="316783003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316783003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316783003">(Dec 19 2022 at 16:33)</a>:</h4>
<p>One issue I see is that it's not just <code>Function.Injective</code> but various other things like <code>Function.RightInverse</code>, etc. I suppose we would have to manually add <code>intro/elim</code> rules for all of these with this approach? Maybe <span class="user-mention" data-user-id="110087">@Scott Morrison</span> had other issues in mind as well?</p>



<a name="316783653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316783653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316783653">(Dec 19 2022 at 16:36)</a>:</h4>
<p>In any case, it seems that by adding an "aggressive intros" option to <code>aesop</code>, that could help <code>aesop_cat</code> cover more goals which are handled with <code>tidy</code> in mathlib3, and that would certainly be a great help in porting the category theory library!</p>



<a name="316785999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316785999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316785999">(Dec 19 2022 at 16:48)</a>:</h4>
<p>Yes, my scheme would require two rules per <code>def</code>. I'll implement the option and then you can see whether it works better for you.</p>



<a name="316786145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316786145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316786145">(Dec 19 2022 at 16:49)</a>:</h4>
<p>Thanks Jannis! that would be very helpful!</p>



<a name="316786326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316786326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316786326">(Dec 19 2022 at 16:50)</a>:</h4>
<p>Sure, no problem!</p>



<a name="316802930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316802930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316802930">(Dec 19 2022 at 18:18)</a>:</h4>
<p>Implemented in <a href="https://github.com/JLimperg/aesop/commit/87a654a5a10f5edf3cfaee9052c08a4342b24179">87a654a5a10f5edf3cfaee9052c08a4342b24179</a>.</p>



<a name="316840983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316840983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316840983">(Dec 19 2022 at 22:17)</a>:</h4>
<p>The new option can be set with <code>aesop (options := { introsTransparency := some .default })</code>, which will cause <code>intros</code> to unfold definitions up to <code>default</code> transparency.</p>



<a name="316877906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316877906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316877906">(Dec 20 2022 at 05:27)</a>:</h4>
<p><span class="user-mention" data-user-id="256311">@Jannis Limperg</span>, adding <code>(options := { introsTransparency := some .default }) </code> to the definition of <code>aesop_cat</code> causes previously working proofs in <code>Mathlib.CategoryTheory.Category.Basic</code> to instead use <code>sorry</code>!</p>



<a name="316877998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316877998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316877998">(Dec 20 2022 at 05:28)</a>:</h4>
<p>Strangely this occurs for any value of <code>introsTransparency</code>, including <code>none</code>. Merely having the <code>(options := { })</code> is fine.</p>



<a name="316878055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316878055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316878055">(Dec 20 2022 at 05:29)</a>:</h4>
<p>Ah, all okay. It's <code>introsTransparency?</code>. Not sure why it is generating <code>sorry</code> rather than giving a good error message.</p>



<a name="316901493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/CategoryTheory.Functor.FullyFaithful/near/316901493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful.html#316901493">(Dec 20 2022 at 08:55)</a>:</h4>
<p>Sorry about the error (edited for posterity). I've also changed the elaboration of <code>(options := )</code> so that it throws an error instead of converting to <code>sorry</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
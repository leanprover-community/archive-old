---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Randomness.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html">Randomness</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="321191058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321191058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321191058">(Jan 13 2023 at 15:39)</a>:</h4>
<p>Are there any good tutorials on how to use randomness, in particular the <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rand#doc">docs4#Rand</a> monad?</p>



<a name="321191450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321191450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321191450">(Jan 13 2023 at 15:41)</a>:</h4>
<p>The implementation looks a bit like <a href="https://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.html">Control.Monad.Random</a> from haskell. They've probably got some good tutorials.</p>



<a name="321191941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321191941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321191941">(Jan 13 2023 at 15:43)</a>:</h4>
<p>I think it's just you use <code>Rand A</code> as a monad, within which you can call <code>rand : Rand T</code> to get random elements of any type <code>T</code></p>



<a name="321192179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321192179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321192179">(Jan 13 2023 at 15:44)</a>:</h4>
<p>And how does one "run" it?</p>



<a name="321192217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321192217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321192217">(Jan 13 2023 at 15:45)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IO.runRand#doc">docs4#IO.runRand</a></p>



<a name="321192338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321192338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321192338">(Jan 13 2023 at 15:45)</a>:</h4>
<p>Or to use it with a fixed seed presumably you can just use the <code>StateM</code> machinery</p>



<a name="321192403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321192403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321192403">(Jan 13 2023 at 15:45)</a>:</h4>
<p>If it's just ported from mathlib, you can also use <code>(some_rand_obj.run (ULift.up (mkStdGen seed))).1</code> (<a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mkStdGen#doc">docs4#mkStdGen</a>, <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StateT.run#doc">docs4#StateT.run</a>)</p>



<a name="321192644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321192644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321192644">(Jan 13 2023 at 15:46)</a>:</h4>
<p>Checking the impl of <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IO.runRandWith#doc">docs4#IO.runRandWith</a>, you can use <code>(StateT.run cmd { down := mkStdGen seed }).fst</code></p>



<a name="321192706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321192706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321192706">(Jan 13 2023 at 15:47)</a>:</h4>
<p>Oh wait, so not much changed from the Lean 3 implementation?</p>



<a name="321192724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321192724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321192724">(Jan 13 2023 at 15:47)</a>:</h4>
<p>Ah, Eric beat me to it!</p>



<a name="321193247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321193247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321193247">(Jan 13 2023 at 15:49)</a>:</h4>
<p>You might be interested in <a href="#narrow/stream/113488-general/topic/Stating.20properties.20of.20the.20results.20of.20monads/near/319573258">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Stating.20properties.20of.20the.20results.20of.20monads/near/319573258</a>, <span class="user-mention" data-user-id="387244">@Yaël Dillies</span>, which has some example code</p>



<a name="321193688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321193688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321193688">(Jan 13 2023 at 15:51)</a>:</h4>
<p>Time to see whether the bug I found in <a href="#narrow/stream/113488-general/topic/Not.20so.20random">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Not.20so.20random</a> is still there <span aria-label="stuck out tongue closed eyes" class="emoji emoji-1f61d" role="img" title="stuck out tongue closed eyes">:stuck_out_tongue_closed_eyes:</span></p>



<a name="321195337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321195337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321195337">(Jan 13 2023 at 15:57)</a>:</h4>
<p>it is, it's documented as such</p>



<a name="321226842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321226842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321226842">(Jan 13 2023 at 18:18)</a>:</h4>
<p>How would one fill this in?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Control.Random</span>

<span class="kd">def</span> <span class="n">Random.pi</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">RandomGen</span> <span class="n">g</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">RandG</span> <span class="n">g</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">RandG</span> <span class="n">g</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>Do we have a typeclass to say that <code>α</code> is enumerable?</p>



<a name="321227306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321227306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321227306">(Jan 13 2023 at 18:21)</a>:</h4>
<p>Is <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Encodable#doc">docs4#Encodable</a> a reasonable choice?</p>



<a name="321227350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321227350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321227350">(Jan 13 2023 at 18:21)</a>:</h4>
<p>Ah! Not there yet.</p>



<a name="321228412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321228412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321228412">(Jan 13 2023 at 18:27)</a>:</h4>
<p><del>You could fill it in as <code>pure default</code></del></p>



<a name="321229396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321229396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321229396">(Jan 13 2023 at 18:32)</a>:</h4>
<p>What's the algorithm for an <a href="https://leanprover-community.github.io/mathlib_docs/find/encodable">docs#encodable</a> type?</p>



<a name="321229467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321229467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321229467">(Jan 13 2023 at 18:32)</a>:</h4>
<p>I don't see how you would generate an infinite series of bits with a finite number of invocations of the random number generator</p>



<a name="321229540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321229540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321229540">(Jan 13 2023 at 18:33)</a>:</h4>
<p>I'm going with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Enum</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">enum</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span>
  <span class="n">enum_nodup</span> <span class="o">:</span> <span class="n">enum.Nodup</span>
  <span class="n">mem_enum</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">enum</span>
</code></pre></div>
<p>which sounds like it should work?</p>



<a name="321229604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321229604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321229604">(Jan 13 2023 at 18:33)</a>:</h4>
<p>So <code>fintype</code>?</p>



<a name="321229656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321229656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321229656">(Jan 13 2023 at 18:33)</a>:</h4>
<p>No!</p>



<a name="321229729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321229729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321229729">(Jan 13 2023 at 18:34)</a>:</h4>
<p>I need an order on the elements, else I cannot pass around the monad.</p>



<a name="321229808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321229808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321229808">(Jan 13 2023 at 18:34)</a>:</h4>
<p>/me laughs in quot.unquot</p>



<a name="321229863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321229863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321229863">(Jan 13 2023 at 18:34)</a>:</h4>
<p>I don't think you can prove anything interesting about <code>RandG</code> anyway</p>



<a name="321229883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321229883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321229883">(Jan 13 2023 at 18:34)</a>:</h4>
<p>So peeking under the quotient feels like fair game</p>



<a name="321229928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321229928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321229928">(Jan 13 2023 at 18:35)</a>:</h4>
<p>I can make it generate tests for my CATAM projects, however.</p>



<a name="321230002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321230002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321230002">(Jan 13 2023 at 18:35)</a>:</h4>
<p>Right, my point is that the <code>unsafe</code> on <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quot.unquot#doc">docs4#Quot.unquot</a> isn't a problem for you</p>



<a name="321230030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321230030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321230030">(Jan 13 2023 at 18:35)</a>:</h4>
<p>In my case, <code>α</code> is <code>Fin n</code>, so it feels a bit dumb not providing <code>List.finRange</code> directly</p>



<a name="321230172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321230172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321230172">(Jan 13 2023 at 18:36)</a>:</h4>
<p>To the compiler, I would guess finset.univ.unquot is exactly that</p>



<a name="321230193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321230193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321230193">(Jan 13 2023 at 18:36)</a>:</h4>
<p>But I guess we don't have <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype#doc">docs4#Fintype</a> so that's irrelevant</p>



<a name="321230231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321230231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321230231">(Jan 13 2023 at 18:36)</a>:</h4>
<p>Regardless, how do I then use this enumerating list to build my random function?</p>



<a name="321230233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321230233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321230233">(Jan 13 2023 at 18:36)</a>:</h4>
<p>Oh, we have an ad-hoc port for precisely what you need! (the fin instances)</p>



<a name="321230356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321230356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321230356">(Jan 13 2023 at 18:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/287929-mathlib4/topic/Randomness/near/321230231">said</a>:</p>
<blockquote>
<p>Regardless, how do I then use this enumerating list to build my random function?</p>
</blockquote>
<p><code>mmap</code> over the list of all <code>α</code>, and turn the list back into a function</p>



<a name="321230510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321230510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321230510">(Jan 13 2023 at 18:38)</a>:</h4>
<p>Ah! <code>List.ofFn</code>!</p>



<a name="321230562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321230562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321230562">(Jan 13 2023 at 18:38)</a>:</h4>
<p>No, the reverse; <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.get#doc">docs4#List.get</a></p>



<a name="321231365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321231365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321231365">(Jan 13 2023 at 18:43)</a>:</h4>
<p>Does that sound right?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">pi</span> <span class="o">[</span><span class="n">Enum</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">RandG</span> <span class="n">g</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">RandG</span> <span class="n">g</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="n">a</span> <span class="bp">↦</span> <span class="n">_</span><span class="o">)</span> <span class="bp">&lt;$&gt;</span> <span class="o">(</span><span class="n">Enum.enum</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">mapM</span> <span class="n">r</span>
</code></pre></div>



<a name="321234585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321234585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321234585">(Jan 13 2023 at 18:58)</a>:</h4>
<p>That's only going to work for <code>Fin</code></p>



<a name="321234673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321234673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321234673">(Jan 13 2023 at 18:58)</a>:</h4>
<p>You're going to need to produce a list of <code>(a, b)</code> pairs to do a lookup for other types (either by zipping with <code>Enum.enum</code>, or by using <code>do b &lt;- r a, pure (a, b)</code> in the map.</p>



<a name="321234707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321234707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321234707">(Jan 13 2023 at 18:59)</a>:</h4>
<p>Which is also going to be slower</p>



<a name="321235043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321235043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321235043">(Jan 13 2023 at 19:00)</a>:</h4>
<p>This is what it looks like now</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Enum</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">enum</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span>
  <span class="n">enum_nodup</span> <span class="o">:</span> <span class="n">enum.Nodup</span>
  <span class="n">index</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Fin</span> <span class="n">enum.length</span>
  <span class="n">enum_index</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">enum.get</span> <span class="o">(</span><span class="n">index</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">Enum</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">enum</span> <span class="o">:=</span> <span class="n">List.finRange</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">enum_nodup</span> <span class="o">:=</span> <span class="n">List.nodup_finRange</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">index</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span> <span class="bp">↦</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">List.length_finRange</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">n.2</span><span class="o">⟩,</span>
  <span class="n">enum_index</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="bp">↦</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kn">namespace</span> <span class="n">Random</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">RandomGen</span> <span class="n">g</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">pi</span> <span class="o">[</span><span class="n">Enum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">BEq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">RandG</span> <span class="n">g</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">RandG</span> <span class="n">g</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="n">a</span> <span class="bp">↦</span> <span class="n">List.get</span> <span class="n">l</span> <span class="bp">$</span> <span class="o">⟨</span><span class="n">Enum.index</span> <span class="n">a</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩)</span> <span class="bp">&lt;$&gt;</span> <span class="o">(</span><span class="n">Enum.enum</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">mapM</span> <span class="n">r</span>
</code></pre></div>



<a name="321235210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321235210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321235210">(Jan 13 2023 at 19:01)</a>:</h4>
<p>The problem is that I cannot fill in the <code>sorry</code> because I don't know that the list I'm getting out of the <code>mapM</code> has the right length, which is exactly the same problem as you had, right?</p>



<a name="321235304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321235304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321235304">(Jan 13 2023 at 19:01)</a>:</h4>
<p>Yes, you need a <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Vector.mapM#doc">docs4#Vector.mapM</a> (<a href="https://leanprover-community.github.io/mathlib_docs/find/vector.mmap">docs#vector.mmap</a>)</p>



<a name="321235333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321235333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321235333">(Jan 13 2023 at 19:01)</a>:</h4>
<p>Or to map over the subtype</p>



<a name="321235650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321235650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321235650">(Jan 13 2023 at 19:03)</a>:</h4>
<p>Do we not have <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.length_mapM?#doc">docs4#List.length_mapM?</a></p>



<a name="321236085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321236085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321236085">(Jan 13 2023 at 19:05)</a>:</h4>
<p>How would you state it?</p>



<a name="321236519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321236519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321236519">(Jan 13 2023 at 19:06)</a>:</h4>
<p>Oh</p>



<a name="321236593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321236593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321236593">(Jan 13 2023 at 19:07)</a>:</h4>
<p>You could just grab that vector lemma from mathport</p>



<a name="321236607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321236607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321236607">(Jan 13 2023 at 19:07)</a>:</h4>
<p>I guess I need to port <code>Data.Vector.Basic</code>, then :P</p>



<a name="321236652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321236652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321236652">(Jan 13 2023 at 19:07)</a>:</h4>
<p>It has some dependencies yet</p>



<a name="321236746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321236746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321236746">(Jan 13 2023 at 19:07)</a>:</h4>
<p>I think data.fin.tuple.basic and data.list.of_fn</p>



<a name="321240548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321240548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321240548">(Jan 13 2023 at 19:27)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> You probably don't want an <code>Enum</code> that has an actual <code>List</code> of all elements if you're going to be choosing random elements for programming purposes (for example, a random 32-bit integer is impossible this way, or, equivalently, getting a random <code>Fin 32 -&gt; Fin 2</code>).</p>
<p>Another option is to have <code>Enum</code> be a wrapper around <code>Equiv</code> to a <code>Fin n</code> for some <code>n</code>. A while back I had some experiment with this: <a href="https://gist.github.com/kmill/9055e1fc32d75b818cbb036650d309ed#file-vec_experiment2-lean-L73">https://gist.github.com/kmill/9055e1fc32d75b818cbb036650d309ed#file-vec_experiment2-lean-L73</a> (not for randomness though)</p>



<a name="321241636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321241636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321241636">(Jan 13 2023 at 19:33)</a>:</h4>
<p>I'm not sure I understand your objection.</p>



<a name="321241802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321241802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321241802">(Jan 13 2023 at 19:34)</a>:</h4>
<p>I just managed to get a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mo>×</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">10 × 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span> matrix of random <code>Bool</code>s!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[[</span><span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">],</span> <span class="o">[</span><span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">],</span> <span class="o">[</span><span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">],</span> <span class="o">[</span><span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">],</span> <span class="o">[</span><span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">],</span> <span class="o">[</span><span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">],</span> <span class="o">[</span><span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">],</span> <span class="o">[</span><span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">],</span> <span class="o">[</span><span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">],</span> <span class="o">[</span><span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">]]</span>
</code></pre></div>



<a name="321241948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321241948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321241948">(Jan 13 2023 at 19:35)</a>:</h4>
<p>(and I set the probability to <code>0.33333333333</code>)</p>



<a name="321242057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321242057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321242057">(Jan 13 2023 at 19:36)</a>:</h4>
<p>The other ingredient was</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">Enum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">ToString</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span> <span class="n">ToString</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span> <span class="bp">↦</span> <span class="n">toString</span> <span class="bp">$</span> <span class="n">Enum.enum.map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">a</span> <span class="bp">↦</span> <span class="n">toString</span> <span class="bp">$</span> <span class="n">f</span> <span class="n">a</span><span class="o">⟩</span>
</code></pre></div>



<a name="321242186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321242186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321242186">(Jan 13 2023 at 19:37)</a>:</h4>
<p>That seems like bad ToString</p>



<a name="321242210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321242210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321242210">(Jan 13 2023 at 19:37)</a>:</h4>
<p>Also, you'll get nice line-wrappign if you implement <code>Repr</code> instead</p>



<a name="321242291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321242291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321242291">(Jan 13 2023 at 19:37)</a>:</h4>
<p>How should I unbad my <code>ToString</code>?</p>



<a name="321242402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321242402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321242402">(Jan 13 2023 at 19:38)</a>:</h4>
<p>Well right now it pretends functions are lists</p>



<a name="321242558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321242558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321242558">(Jan 13 2023 at 19:39)</a>:</h4>
<p>You could print it as <code>λ a ↦ [elems...].get ⟨Enum.index a, _⟩</code></p>



<a name="321242630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321242630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321242630">(Jan 13 2023 at 19:39)</a>:</h4>
<p>That's the role of <code>Repr</code>, right? <code>ToString</code> can just "look nice"</p>



<a name="321242723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321242723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321242723">(Jan 13 2023 at 19:40)</a>:</h4>
<p>I have no idea what <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ToString#doc">docs4#ToString</a> is for</p>



<a name="321242989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321242989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321242989">(Jan 13 2023 at 19:41)</a>:</h4>
<p>I thought you were using a different design, where you use <code>Enum</code> and choose elements uniformly at random, since this is something you can do for everything that implements <code>Enum</code>.</p>



<a name="321243298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321243298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321243298">(Jan 13 2023 at 19:43)</a>:</h4>
<p>Ah no, the role of <code>Enum</code> here is to pick a canonical order in which to run the dice rolls.</p>



<a name="321247535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321247535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321247535">(Jan 13 2023 at 20:06)</a>:</h4>
<p>I just defined</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">randFin'</span> <span class="o">[</span><span class="n">NeZero</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">RandG</span> <span class="n">g</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">⟨</span><span class="n">g</span><span class="o">⟩</span> <span class="bp">↦</span> <span class="n">randNat</span> <span class="n">g</span> <span class="mi">0</span> <span class="n">n</span> <span class="bp">|&gt;.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="bp">↦</span> <span class="n">Fin.ofNat'</span> <span class="n">a</span> <span class="bp">$</span> <span class="n">NeZero.pos</span> <span class="n">n</span><span class="o">)</span> <span class="n">ULift.up</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Enum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">NeZero</span> <span class="o">(</span><span class="n">Enum.enum</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">uniform</span> <span class="o">[</span><span class="n">Enum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">RandG</span> <span class="n">g</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Enum.enum.get</span> <span class="bp">&lt;$&gt;</span> <span class="n">randFin'</span>
</code></pre></div>
<p>which I assume is what you meant?</p>



<a name="321247815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321247815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321247815">(Jan 13 2023 at 20:08)</a>:</h4>
<p>I still don't understand your objection. If I had</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">List.pi</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">List</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>then I would be able to provide an <code>Enum (Fin 32 → Fin 2)</code> instance and generate 32-bits integers uniformly at random.</p>



<a name="321247941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321247941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321247941">(Jan 13 2023 at 20:09)</a>:</h4>
<p>Or is your argument that it is too slow?</p>



<a name="321249631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321249631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321249631">(Jan 13 2023 at 20:19)</a>:</h4>
<p>Mathematically it's fine, but a <code>List (Fin 32 → Fin 2)</code> that enumerates that type would take 96 gigabytes of RAM minimum.</p>



<a name="321250204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321250204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321250204">(Jan 13 2023 at 20:23)</a>:</h4>
<p>(That's two 8-byte pointers per <code>List.cons</code>, and 8 bytes per <code>Fin 32 -&gt; Fin 2</code>, which is an optimistic lower bound for how Lean would represent such a function.)</p>



<a name="321261181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321261181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321261181">(Jan 13 2023 at 21:32)</a>:</h4>
<p>How is your suggested <code>Enum</code> better?</p>



<a name="321266571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321266571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321266571">(Jan 13 2023 at 22:06)</a>:</h4>
<p>And more precisely does it make what I'm doing harder?</p>



<a name="321266984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321266984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321266984">(Jan 13 2023 at 22:09)</a>:</h4>
<p>Right now, I have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">pi</span> <span class="o">[</span><span class="n">Enum</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">RandG</span> <span class="n">g</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">RandG</span> <span class="n">g</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="n">a</span> <span class="bp">↦</span> <span class="n">List.get</span> <span class="n">l.toList</span> <span class="bp">$</span> <span class="o">⟨</span><span class="n">Enum.index</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩)</span> <span class="bp">&lt;$&gt;</span> <span class="n">Vector.mapM</span> <span class="n">r</span> <span class="o">⟨</span><span class="n">Enum.enum</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
</code></pre></div>
<p>Do you see any obvious way of generalizing it to dependent types?</p>



<a name="321267406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321267406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321267406">(Jan 13 2023 at 22:11)</a>:</h4>
<p>Put sigma types in the list?</p>



<a name="321267739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321267739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321267739">(Jan 13 2023 at 22:14)</a>:</h4>
<p>Yes but then I need a specific type of vectors whose keys are unique and complete.</p>



<a name="321267838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321267838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321267838">(Jan 13 2023 at 22:14)</a>:</h4>
<p><code>DVector</code>, if you wish</p>



<a name="321267957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321267957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321267957">(Jan 13 2023 at 22:15)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finmap">docs#finmap</a>? But I guess of fixed-length</p>



<a name="321268091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321268091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321268091">(Jan 13 2023 at 22:16)</a>:</h4>
<p>Is this an <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> problem, or are you solving this problem because you find it interesting, independent of whether you actually need it?</p>



<a name="321268118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321268118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321268118">(Jan 13 2023 at 22:16)</a>:</h4>
<p>The latter</p>



<a name="321268211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321268211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321268211">(Jan 13 2023 at 22:17)</a>:</h4>
<p>I am happy to leave it as is, but I thought there might be something interesting here.</p>



<a name="321268299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321268299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321268299">(Jan 13 2023 at 22:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/287929-mathlib4/topic/Randomness/near/321267739">said</a>:</p>
<blockquote>
<p>Yes but then I need a specific type of vectors whose keys are unique and complete.</p>
</blockquote>
<p>Why do you need the keys to be unique and complete? What goes wrong if you just have a vector of sigmas?</p>



<a name="321268701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321268701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321268701">(Jan 13 2023 at 22:20)</a>:</h4>
<p>Okay, they may not need be unique, but I need to find the entry corresponding to a key, so I need the key to exist.</p>



<a name="321268752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321268752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321268752">(Jan 13 2023 at 22:21)</a>:</h4>
<p>Can't you just look in the ith index like you do now?</p>



<a name="321268782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321268782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321268782">(Jan 13 2023 at 22:21)</a>:</h4>
<p>Hmm...</p>



<a name="321268949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321268949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321268949">(Jan 13 2023 at 22:22)</a>:</h4>
<p>Maybe you get stuck trying to cast the sigma type</p>



<a name="321272445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321272445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321272445">(Jan 13 2023 at 22:48)</a>:</h4>
<p>Indeed, I have lost the information that <code>(l.toList.get $ Enum.index a).1 = a</code></p>
<div class="codehilite" data-code-language="def"><pre><span></span><code>(λ l a ↦ _ -- `β a`
) &lt;$&gt; Vector.mapM (λ a ↦ (r a).map $ Sigma.mk a) ⟨Enum.enum, rfl⟩
</code></pre></div>



<a name="321351712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321351712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321351712">(Jan 14 2023 at 12:48)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> This should be reasonably efficient (though it's still incomplete and would need more development). Generally, <code>Array</code> is more efficient than <code>List</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Logic.Equiv.Basic</span>
<span class="kn">import</span> <span class="n">Std</span>
<span class="kn">import</span> <span class="n">Mathlib.Control.Random</span>
<span class="kn">import</span> <span class="n">Mathlib.Data.Nat.Order.Basic</span>

<span class="kd">def</span> <span class="n">Fin.arrayOf</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">Array.mkEmpty</span> <span class="n">n</span>
  <span class="n">for</span> <span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[</span><span class="mi">0</span> <span class="o">:</span> <span class="n">n</span><span class="o">]</span> <span class="k">do</span>
    <span class="n">a</span> <span class="o">:=</span> <span class="n">a.push</span> <span class="o">(</span><span class="n">f</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h.2</span><span class="o">⟩)</span>
  <span class="n">return</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">Fin.size_arrayOf</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">Fin.arrayOf</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">size</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">Fin.get_arrayof</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="o">(</span><span class="n">Fin.arrayOf</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">size</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">Fin.arrayOf</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">Fin.size_arrayOf</span> <span class="n">f</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- should cast</span>

<span class="kd">class</span> <span class="n">Enum</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">card</span> <span class="o">:</span> <span class="n">ℕ</span>
  <span class="n">enum</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">card</span> <span class="bp">≃</span> <span class="n">α</span>
  <span class="n">arrayOf</span> <span class="o">:</span> <span class="n">Unit</span> <span class="bp">→</span> <span class="n">Array</span> <span class="n">α</span> <span class="c1">-- a function, which prevents computing an `Array` unless one is actually needed.</span>
  <span class="n">arrayOf_eq</span> <span class="o">:</span> <span class="n">arrayOf</span> <span class="o">()</span> <span class="bp">=</span> <span class="n">Fin.arrayOf</span> <span class="n">enum</span>

<span class="kd">theorem</span> <span class="n">Enum.size_arrayOf</span> <span class="o">[</span><span class="n">Enum</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">Enum.arrayOf</span> <span class="o">()</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">size</span> <span class="bp">=</span> <span class="n">Enum.card</span> <span class="n">α</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">arrayOf_eq</span><span class="o">,</span> <span class="n">Fin.size_arrayOf</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">Enum</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">card</span> <span class="o">:=</span> <span class="n">n</span>
  <span class="n">enum</span> <span class="o">:=</span> <span class="n">Equiv.refl</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span><span class="o">)</span>
  <span class="n">arrayOf</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Fin.arrayOf</span> <span class="n">id</span>
  <span class="n">arrayOf_eq</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">namespace</span> <span class="n">Random</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">RandomGen</span> <span class="n">g</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">randFin'</span> <span class="o">[</span><span class="n">NeZero</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">RandG</span> <span class="n">g</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="bp">λ</span> <span class="o">⟨</span><span class="n">g</span><span class="o">⟩</span> <span class="bp">↦</span> <span class="n">randNat</span> <span class="n">g</span> <span class="mi">0</span> <span class="n">n</span> <span class="bp">|&gt;.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="bp">↦</span> <span class="n">Fin.ofNat'</span> <span class="n">a</span> <span class="bp">$</span> <span class="n">NeZero.pos</span> <span class="n">n</span><span class="o">)</span> <span class="n">ULift.up</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Enum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">NeZero</span> <span class="o">(</span><span class="n">Enum.card</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">uniform</span> <span class="o">[</span><span class="n">Enum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">RandG</span> <span class="n">g</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Enum.enum</span> <span class="bp">&lt;$&gt;</span> <span class="n">randFin'</span>

<span class="kd">def</span> <span class="n">pi</span> <span class="o">[</span><span class="n">Enum</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">RandG</span> <span class="n">g</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="n">RandG</span> <span class="n">g</span> <span class="o">((</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:</span> <span class="n">Array</span> <span class="o">((</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">×</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="bp">←</span> <span class="c1">-- graph of function we're constructing</span>
    <span class="o">(</span><span class="n">Enum.arrayOf</span> <span class="o">()</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">mapM</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="k">do</span> <span class="n">return</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="bp">←</span> <span class="n">r</span> <span class="n">x</span><span class="o">⟩)</span>
  <span class="c1">-- can't prove these two within the do block:</span>
  <span class="k">have</span> <span class="n">hsize</span> <span class="o">:</span> <span class="n">a.size</span> <span class="bp">=</span> <span class="n">Enum.card</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>
  <span class="k">have</span> <span class="n">hprop</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span>
    <span class="o">(</span><span class="n">a.get</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="n">Enum.arrayOf</span> <span class="o">())</span><span class="bp">.</span><span class="n">get</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">i</span><span class="bp">;</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">Enum.size_arrayOf</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hsize</span><span class="o">]</span> <span class="o">}⟩</span> <span class="o">:=</span> <span class="gr">sorry</span>
  <span class="n">return</span> <span class="bp">λ</span> <span class="n">x</span> <span class="bp">↦</span>
    <span class="k">match</span> <span class="n">h</span> <span class="o">:</span> <span class="n">a.get</span> <span class="o">⟨</span><span class="n">Enum.enum.symm</span> <span class="n">x</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">⟨</span><span class="n">x'</span><span class="o">,</span> <span class="n">b</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x'</span> <span class="o">:=</span> <span class="gr">sorry</span>
      <span class="n">subst</span> <span class="n">this</span>
      <span class="n">exact</span> <span class="n">b</span>
</code></pre></div>



<a name="321351970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321351970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321351970">(Jan 14 2023 at 12:50)</a>:</h4>
<p>Having both <code>Enum.enum</code> and <code>Enum.arrayOf</code> gives instances the ability to provide efficient implementations of them. Instances can also fill in one using the other if they don't want to do anything special.</p>



<a name="321403843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Randomness/near/321403843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Randomness.html#321403843">(Jan 14 2023 at 20:00)</a>:</h4>
<p>Interesting! <del>As a test case, can you generalize the following to dependent functions?</del> Nevermind, you already have. Lean 4 notation is throwing me off.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
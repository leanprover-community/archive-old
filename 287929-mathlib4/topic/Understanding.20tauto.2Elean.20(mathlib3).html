---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html">Understanding tauto.lean (mathlib3)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="303071854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303071854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303071854">(Oct 08 2022 at 23:10)</a>:</h4>
<p>I'm trying to understand <a href="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/tauto.lean"><code>tauto.lean</code></a> in mathlib3 (just as a way to learn how tactic-writing works), and I thought it might be worth asking a couple questions as to what's going on. I think understand what "should" be going on for the most part mathematically, but the meaning and usage of some lean operations is throwing me. Figured I'd gather them all here instead of creating a bunch of topics! (Unless that's frowned upon for some reason, in which case I'll make a bunch of topics. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> )</p>



<a name="303072006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303072006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303072006">(Oct 08 2022 at 23:12)</a>:</h4>
<p>First, what is <code>local_pp_name</code> is meant to do (or where is documentation for this)? The source code doesn't seem to be commented, and I can't find it in the reference manual.</p>



<a name="303072050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303072050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303072050">(Oct 08 2022 at 23:13)</a>:</h4>
<p>Equivalently, what would the analogue in Lean 4 be? Or would a totally different approach be used? Here, <code>local_pp_name</code> is used like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">...</span>
<span class="k">do</span> <span class="n">h</span> <span class="bp">←</span> <span class="n">get_local</span> <span class="n">h.local_pp_name</span><span class="o">,</span>
         <span class="n">e</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">h</span><span class="o">,</span>
         <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
         <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">¬</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">replace</span> <span class="n">h.local_pp_name</span> <span class="bp">``</span><span class="o">(</span><span class="n">mt</span> <span class="n">iff.to_eq</span> <span class="bp">%%</span><span class="n">h</span><span class="o">)</span>
         <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">_</span> <span class="bp">≠</span> <span class="n">_</span><span class="o">)</span>     <span class="o">:=</span> <span class="n">replace</span> <span class="n">h.local_pp_name</span> <span class="bp">``</span><span class="o">(</span><span class="n">mt</span> <span class="n">iff.to_eq</span> <span class="bp">%%</span><span class="n">h</span><span class="o">)</span>
         <span class="bp">|</span> <span class="bp">...</span>
</code></pre></div>



<a name="303075554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075554">(Oct 09 2022 at 00:08)</a>:</h4>
<p><code>local_pp_name</code> returns the pretty-printing name (the thing users see) for a local constant (now known as an fvar)</p>



<a name="303075560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075560">(Oct 09 2022 at 00:08)</a>:</h4>
<p>My current guess is <code>h.local_pp_name</code> is equivalent to <code>h.userName</code> where <code>h</code> might be provided by something like <code>for h in ← getLCtx</code>. But it seems a bit unsafe to me to use <code>replace</code> with what I understand to be a user-facing name to replace hypotheses after doing syntax matching. (Though I'm not sure if that is indeed what's happening here.)</p>
<p>Is there a better pattern for modifying a hypothesis in lean 4, in general?</p>



<a name="303075588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075588">(Oct 09 2022 at 00:09)</a>:</h4>
<p>what does <code>replace</code> do in this code?</p>



<a name="303075599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075599">(Oct 09 2022 at 00:09)</a>:</h4>
<p>it looks like a local function</p>



<a name="303075674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075674">(Oct 09 2022 at 00:10)</a>:</h4>
<p>here's how the function starts—it's the first in the file</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/--</span>
<span class="sd">  find all assumptions of the shape `¬ (p ∧ q)` or `¬ (p ∨ q)` and</span>
<span class="sd">  replace them using de Morgan's law.</span>
<span class="sd">-/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">distrib_not</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">hs</span> <span class="bp">←</span> <span class="n">local_context</span><span class="o">,</span>
   <span class="n">hs.for_each</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">all_goals'</span> <span class="bp">$</span>
    <span class="n">iterate_at_most'</span> <span class="mi">3</span> <span class="bp">$</span>
      <span class="k">do</span> <span class="n">h</span> <span class="bp">←</span> <span class="n">get_local</span> <span class="n">h.local_pp_name</span><span class="o">,</span>
         <span class="n">e</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">h</span><span class="o">,</span>
         <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
         <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">¬</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">replace</span> <span class="n">h.local_pp_name</span> <span class="bp">``</span><span class="o">(</span><span class="n">mt</span> <span class="n">iff.to_eq</span> <span class="bp">%%</span><span class="n">h</span><span class="o">)</span>
         <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">_</span> <span class="bp">≠</span> <span class="n">_</span><span class="o">)</span>     <span class="o">:=</span> <span class="n">replace</span> <span class="n">h.local_pp_name</span> <span class="bp">``</span><span class="o">(</span><span class="n">mt</span> <span class="n">iff.to_eq</span> <span class="bp">%%</span><span class="n">h</span><span class="o">)</span>
         <span class="bp">|</span> <span class="bp">...</span>
</code></pre></div>



<a name="303075691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075691">(Oct 09 2022 at 00:10)</a>:</h4>
<p>-</p>



<a name="303075720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075720">(Oct 09 2022 at 00:11)</a>:</h4>
<p>I mean, where is the <code>replace</code> function defined?</p>



<a name="303075733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075733">(Oct 09 2022 at 00:11)</a>:</h4>
<p>it might not mean what you think</p>



<a name="303075753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075753">(Oct 09 2022 at 00:11)</a>:</h4>
<p>VS Code says it's <code>tactic.replace</code></p>



<a name="303075760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075760">(Oct 09 2022 at 00:11)</a>:</h4>
<p>which is?</p>



<a name="303075802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075802">(Oct 09 2022 at 00:12)</a>:</h4>
<p>"replace h p elaborates the pexpr p, clears the existing hypothesis named h from the local context, and adds a new hypothesis named h. The type of this hypothesis is the type of p. Fails if there is nothing named h in the local context."</p>



<a name="303075818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075818">(Oct 09 2022 at 00:12)</a>:</h4>
<p>which seems to me like it's finding the local hypothesis by the pretty-printed name</p>



<a name="303075821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075821">(Oct 09 2022 at 00:12)</a>:</h4>
<p>which sounds unsafe</p>



<a name="303075837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075837">(Oct 09 2022 at 00:12)</a>:</h4>
<p>It's true, that is imprecise</p>



<a name="303075856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075856">(Oct 09 2022 at 00:13)</a>:</h4>
<p>most likely it's written like that to fit the signature of <code>tactic.replace</code> which is defined in core or something</p>



<a name="303075864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075864">(Oct 09 2022 at 00:13)</a>:</h4>
<p>hmmm</p>



<a name="303075869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075869">(Oct 09 2022 at 00:13)</a>:</h4>
<p>that kind of thing is reasonable for user-facing tactics since the name is coming from something the user wrote anyway</p>



<a name="303075969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075969">(Oct 09 2022 at 00:15)</a>:</h4>
<p>I should mention that I'm not really happy with the original lean 3 implementation of tauto, so I'm okay with it getting a rewrite on the way to lean 4 as long as it does basically similar things</p>



<a name="303075991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075991">(Oct 09 2022 at 00:15)</a>:</h4>
<p>although I realize that's a bit much to ask of someone who doesn't have a lot of experience writing lean tactics</p>



<a name="303075995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303075995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303075995">(Oct 09 2022 at 00:15)</a>:</h4>
<p>I see, cool! In general, is there better functionality in Lean 4 for modifying a hypothesis (seeing as we're just iterating over all of them)?</p>



<a name="303076051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303076051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303076051">(Oct 09 2022 at 00:16)</a>:</h4>
<p>You shouldn't "modify" hypotheses for the most part</p>



<a name="303076059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303076059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303076059">(Oct 09 2022 at 00:16)</a>:</h4>
<p>instead, you revert them and intro the modified versions</p>



<a name="303076090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303076090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303076090">(Oct 09 2022 at 00:17)</a>:</h4>
<p>it is important for lean's internal coherence that an fvar only ever has a single type in a single local context</p>



<a name="303076091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303076091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303076091">(Oct 09 2022 at 00:17)</a>:</h4>
<blockquote>
<p>although I realize that's a bit much to ask of someone who doesn't have a lot of experience writing lean tactics</p>
</blockquote>
<p>I mean, I'm willing to try! I just wouldn't want to prevent other people with more experience from potentially making better choices, lol</p>



<a name="303076124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303076124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303076124">(Oct 09 2022 at 00:18)</a>:</h4>
<p>Well there's always review time :P</p>



<a name="303076188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303076188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303076188">(Oct 09 2022 at 00:18)</a>:</h4>
<p>but it's great to hear you want to try it, I'll help however I can</p>



<a name="303076215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303076215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303076215">(Oct 09 2022 at 00:19)</a>:</h4>
<p>ok, that sounds great! :)</p>



<a name="303076293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303076293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303076293">(Oct 09 2022 at 00:20)</a>:</h4>
<blockquote>
<p>instead, you revert them and intro the modified versions</p>
</blockquote>
<p>hmmm... so would we start with something like <code>for h in &lt;- getLCtx</code> at all, as I initially thought, then? <code>revert</code>ing then <code>intro</code>ing seems to suggest we do a bunch of reversions then inspect the type of the goal, then do a bunch of intros based on that</p>



<a name="303076319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303076319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303076319">(Oct 09 2022 at 00:21)</a>:</h4>
<p>however, in this case it seems we might only want to revert a hypothesis based on its type in the first place. so maybe the <code>for</code> still works (thinking out loud)</p>



<a name="303076380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303076380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303076380">(Oct 09 2022 at 00:22)</a>:</h4>
<p>The usual pattern is that you say "revert h" and it reverts h and also h' which depended on h, and it gives you an array which you later pass to introN to re-intro them after rewriting</p>



<a name="303076398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303076398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303076398">(Oct 09 2022 at 00:22)</a>:</h4>
<p>ah, ok</p>



<a name="303175084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303175084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303175084">(Oct 09 2022 at 22:00)</a>:</h4>
<p>Ok, general question: I'm not totally sure what <code>tauto!</code> is meant to do in opposition to <code>tauto</code>; according to the documentation "The variants <code>tautology!</code> and <code>tauto!</code> use the law of excluded middle", but <code>tauto</code> seems to use LEM anyway, as <code>example (p : Prop) : p ∨ ¬ p := by tauto</code> works. Is there something I'm missing? (I see that <code>tauto!</code> runs <code>classical</code> first, but I can't quite tell what meaningful effect that has.)</p>



<a name="303176780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303176780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303176780">(Oct 09 2022 at 22:35)</a>:</h4>
<p>It's kind of broken, don't worry about it. I wrote <code>itauto</code> exactly because <code>tauto</code> wasn't living up to its LEM-free claim. I think you should just implement one version of <code>tauto</code> and use classical logic.</p>



<a name="303177018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303177018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303177018">(Oct 09 2022 at 22:40)</a>:</h4>
<p>Yes, mathlib is designed to be a classical library and the main issue at stake here is porting it to lean 4 so classical assumptions are fine.</p>



<a name="303177080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303177080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303177080">(Oct 09 2022 at 22:41)</a>:</h4>
<p>it is easy enough to translate both <code>tauto</code> and <code>tauto!</code> to <code>tauto</code> in mathport, so we can remove the option entirely</p>



<a name="303178306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303178306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303178306">(Oct 09 2022 at 23:04)</a>:</h4>
<p>Ok, sounds good! I'm thinking about how we might improve the functionality <code>tauto</code> in general now...</p>



<a name="303178348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303178348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303178348">(Oct 09 2022 at 23:05)</a>:</h4>
<p>For example, it seems like currently it applies <code>solve_by_elim</code> at the end to address <code>∃</code> expressions, but doesn't address tautologies within those. e.g. <code>example (p q : Prop) (hq : q) : ∃ (hq : q), p → p := by tauto</code> fails. It seems easy enough to make it recursive—would it be alright to make it succeed here?</p>



<a name="303178675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303178675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303178675">(Oct 09 2022 at 23:12)</a>:</h4>
<p>yes</p>



<a name="303178690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303178690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303178690">(Oct 09 2022 at 23:13)</a>:</h4>
<p>as long as you can do the test cases, it's okay to do more</p>



<a name="303178756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303178756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303178756">(Oct 09 2022 at 23:14)</a>:</h4>
<p>great! where are the test cases located, by the way?</p>



<a name="303178768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303178768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303178768">(Oct 09 2022 at 23:15)</a>:</h4>
<p><code>test/tauto.lean</code> in mathlib</p>



<a name="303178791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303178791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303178791">(Oct 09 2022 at 23:15)</a>:</h4>
<p>oop. of course</p>



<a name="303178795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303178795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303178795">(Oct 09 2022 at 23:15)</a>:</h4>
<p>(I was looking in <code>testing</code> by mistake)</p>



<a name="303179311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303179311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303179311">(Oct 09 2022 at 23:26)</a>:</h4>
<p>also, thinking of improving the functionality: it seems strange to me that <code>tauto</code> is exclusively a finishing tactic when it produces a bunch of goals. wouldn't it be useful for a user to be able to carry on from that point, and supply the remaining goals after <code>tauto</code> does some work? (or is that named/would that be named something else?)</p>



<a name="303179347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303179347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303179347">(Oct 09 2022 at 23:27)</a>:</h4>
<p>can you describe the goals that are generated in a clear way, such that the user can predict them?</p>



<a name="303179407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303179407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303179407">(Oct 09 2022 at 23:28)</a>:</h4>
<p>hmmm</p>



<a name="303179418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303179418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303179418">(Oct 09 2022 at 23:28)</a>:</h4>
<p>If you just do a bunch of mumbo jumbo and end up somewhere and hand control back to the user, that's not very robust to tactic changes</p>



<a name="303179457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303179457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303179457">(Oct 09 2022 at 23:29)</a>:</h4>
<p>I see, makes sense</p>



<a name="303179459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303179459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303179459">(Oct 09 2022 at 23:29)</a>:</h4>
<p>The standard is a lot higher on non-"finishing tactics" to produce subgoals deterministically</p>



<a name="303179512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303179512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303179512">(Oct 09 2022 at 23:30)</a>:</h4>
<p>so most of the really high powered and heuristic based tactics are either finishing tactics by construction or convention</p>



<a name="303180041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303180041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303180041">(Oct 09 2022 at 23:41)</a>:</h4>
<p>that's a good convention! (but hmmm...and, it's not necessary for reimplementing <code>tauto</code>, but...I wonder if there exists a sort of canonical "tautological normalization" one can perform which reduces a proposition "as much as possible" in a certain mathematically-unique way. I kind of doubt that there does, but it'd be neat! After all, some of the goals that <code>tauto</code> produces anyway are pretty intelligible...but that's a generalization for later :) )</p>



<a name="303226531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/303226531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#303226531">(Oct 10 2022 at 09:36)</a>:</h4>
<p>One thing that might be useful is rather than setting new subgoals (which may indeed be a bit random), to print some sufficient facts (when <code>tauto</code> fails but does reduce the problem a bit) that the user can <code>have :=</code> into context above, so that <code>tauto</code> will then finish.</p>



<a name="304573335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/304573335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#304573335">(Oct 17 2022 at 22:44)</a>:</h4>
<p>Okay, finally feeling well enough to start working on <code>tauto</code> again! I'm still working through the existing file to see what it does.</p>



<a name="304573552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/304573552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#304573552">(Oct 17 2022 at 22:45)</a>:</h4>
<p>First question: consider the definition of <code>add_symm_proof</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/--</span>
<span class="sd">  If there exists a symmetry lemma that can be applied to the hypothesis `e`,</span>
<span class="sd">  store it.</span>
<span class="sd">-/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">add_symm_proof</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">tauto_state</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">expr</span> <span class="bp">×</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">env</span> <span class="bp">←</span> <span class="n">get_env</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">rel</span> <span class="o">:=</span> <span class="n">e.get_app_fn.const_name</span><span class="o">,</span>
   <span class="n">some</span> <span class="n">symm</span> <span class="bp">←</span> <span class="n">pure</span> <span class="bp">$</span> <span class="n">environment.symm_for</span> <span class="n">env</span> <span class="n">rel</span>
     <span class="bp">|</span> <span class="n">add_refl</span> <span class="n">r</span> <span class="n">e</span><span class="o">,</span>
   <span class="o">(</span><span class="k">do</span> <span class="n">e'</span> <span class="bp">←</span> <span class="n">mk_meta_var</span> <span class="bp">`</span><span class="o">(</span><span class="kt">Prop</span><span class="o">),</span>
       <span class="n">iff_t</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">%%</span><span class="n">e</span> <span class="bp">=</span> <span class="bp">%%</span><span class="n">e'</span><span class="o">),</span>
       <span class="o">(</span><span class="n">_</span><span class="o">,</span><span class="n">p</span><span class="o">)</span> <span class="bp">←</span> <span class="n">solve_aux</span> <span class="n">iff_t</span>
         <span class="o">(</span><span class="n">applyc</span> <span class="bp">`</span><span class="n">iff.to_eq</span> <span class="bp">;</span> <span class="o">()</span> <span class="bp">&lt;$</span> <span class="n">split</span> <span class="bp">;</span> <span class="n">applyc</span> <span class="n">symm</span><span class="o">),</span>
       <span class="n">e'</span> <span class="bp">←</span> <span class="n">instantiate_mvars</span> <span class="n">e'</span><span class="o">,</span>
       <span class="n">m</span> <span class="bp">←</span> <span class="n">read_ref</span> <span class="n">r</span><span class="o">,</span>
       <span class="n">write_ref</span> <span class="n">r</span> <span class="bp">$</span> <span class="o">(</span><span class="n">m.insert</span> <span class="n">e</span> <span class="o">(</span><span class="n">e'</span><span class="o">,</span><span class="n">p</span><span class="o">))</span><span class="bp">.</span><span class="n">insert</span> <span class="n">e'</span> <span class="n">none</span><span class="o">,</span>
       <span class="n">return</span> <span class="o">(</span><span class="n">e'</span><span class="o">,</span><span class="n">p</span><span class="o">)</span> <span class="o">)</span>
   <span class="bp">&lt;|&gt;</span> <span class="n">add_refl</span> <span class="n">r</span> <span class="n">e</span>
</code></pre></div>



<a name="304573796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/304573796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#304573796">(Oct 17 2022 at 22:46)</a>:</h4>
<p>What exactly does <code>() &lt;$ split</code> do, for one? I understand what <code>&lt;$</code> does in isolation, and have an idea what <code>split</code> does, but I'm not sure how they're used together in context with <code>()</code> (the inhabitant of <code>unit</code>, as in <code>tactic unit</code>, somehow, maybe?).</p>



<a name="304576168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/304576168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#304576168">(Oct 17 2022 at 23:01)</a>:</h4>
<p><code>() &lt;$ tac</code> is an idiom similar to <code>discard tac</code> or <code>_ &lt;- tac</code>, it runs <code>tac</code> and then returns <code>()</code> instead of whatever the tactic was going to return</p>



<a name="304580420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Understanding%20tauto.lean%20%28mathlib3%29/near/304580420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Understanding.20tauto.2Elean.20(mathlib3).html#304580420">(Oct 17 2022 at 23:33)</a>:</h4>
<p>ah, ok, thanks!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/to_additive.20and.20coe.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html">to_additive and coe</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="313728534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313728534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313728534">(Dec 03 2022 at 19:56)</a>:</h4>
<p>I don't think I know how to check what attributes are attached to a declaration any more (I think <code>#print</code> no longer tells you) but I have evidence to suggest that neither <code>@[coe, to_additive]</code> nor <code>@[to_additive, coe]</code> will attach the <code>coe</code> tag to the to_additivised declaration. Is it worth opening an issue? My memory about this sort of thing in Lean 3 was a bit like learning the order of adjectives in German -- some attributes needed to be before/after others to make them work best. In some sense I don't know which one of coe and to_additive I would instinctively expect to want to put first in order to make this work, but right now I think neither does.</p>



<a name="313732501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313732501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313732501">(Dec 03 2022 at 20:45)</a>:</h4>
<p>Oh I've just realised that this is slightly more serious than I'd realised. For example <code>@[norm_cast, to_additive]</code> used to put the norm_cast tag on the additivised declaration and now it doesn't, so autoported <code>norm_cast</code> proofs can break. Currently I'm adding the tags manually but this doesn't sound ideal.</p>



<a name="313746380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313746380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313746380">(Dec 04 2022 at 00:01)</a>:</h4>
<p>I think opening an issue for that would be good and even better if you could give a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>. I will have a look into it later. At the moment the only attributes added are <code>instance</code> and <code>simp</code>.</p>



<a name="313748594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313748594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313748594">(Dec 04 2022 at 00:33)</a>:</h4>
<p>I'll do this, once I find out how to see the attributes attached to a declaration (I just asked <a href="#narrow/stream/270676-lean4/topic/attributes.20attached.20to.20a.20declaration/near/313748620">here</a>)</p>



<a name="313751236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313751236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313751236">(Dec 04 2022 at 01:12)</a>:</h4>
<p>I would be happy if you produce an error for a proof that should work. then we can add that to the tests after fixing the problem</p>



<a name="313751657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313751657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313751657">(Dec 04 2022 at 01:19)</a>:</h4>
<p>Yes I'll do this but it would be great for debugging purposes if I could actually see what was going on!</p>



<a name="313752076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313752076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313752076">(Dec 04 2022 at 01:26)</a>:</h4>
<p>I'll have a look whether I can hack a command together that shows all the attributes</p>



<a name="313752355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313752355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313752355">(Dec 04 2022 at 01:30)</a>:</h4>
<p>This is difficult. There is currently not a uniform method for recording attributes: each attribute is responsible for looking after itself!</p>



<a name="313752379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313752379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313752379">(Dec 04 2022 at 01:31)</a>:</h4>
<p>Mario has some ideas for doing this systematically, perhaps someone can find the thread.</p>



<a name="313752787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313752787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313752787">(Dec 04 2022 at 01:38)</a>:</h4>
<p><a href="#narrow/stream/270676-lean4/topic/How.20to.20inspect.20attributes.3F">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How.20to.20inspect.20attributes.3F</a></p>



<a name="313754013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313754013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313754013">(Dec 04 2022 at 02:00)</a>:</h4>
<p>this is probably the change that was referenced in <code>to_additive</code>. I think for <code>norm_cast</code> I can adapt what was done for <code>simp</code>, but in general this is really stupid that we have to write very different code depending on the attribute for copying it in <code>to_additive</code></p>



<a name="313757539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313757539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313757539">(Dec 04 2022 at 02:56)</a>:</h4>
<p>The attribute delaborator setup I mentioned (which I haven't had much time to work on) was only intended for <code>#print</code>, not for <code>to_additive</code>. I think for <code>to_additive</code> you need a way for attributes to say "I am reapplicable" with a method to copy the attribute from one declaration to another. You might be able to do that using the attribute delaborator to get <code>Syntax</code> and then applying that syntax as an attribute, but that sounds super hacky and would fail in many cases if the appropriate attribute parser doesn't exist.</p>



<a name="313775496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313775496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313775496">(Dec 04 2022 at 07:54)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib4/pull/847">mathlib4#847</a> not really tested - I am waiting for Kevin to give me a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="313823204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313823204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313823204">(Dec 04 2022 at 15:26)</a>:</h4>
<p>OK sorry for the delay; it was Saturday evening and I was doing IRL stuff. Here's some mathlib3 code (which is easier to write because I can #print):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">@[simp, to_additive bargroup]</span>
<span class="kd">lemma</span> <span class="n">foogroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">fin</span> <span class="mi">37</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- bargroup gets simp</span>
<span class="c1">--#print bargroup</span>

<span class="c1">--NB `@[to_additive bargroup, simp]` doesn't give bargroup `simp`.</span>

<span class="kd">@[norm_cast, to_additive barcoe]</span>
<span class="kd">lemma</span> <span class="n">foocoe</span> <span class="o">:</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_one</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- barcoe gets norm_cast</span>
<span class="c1">-- #print barcoe</span>

<span class="c1">--NB `@[to_additive barcoe, norm_cast]` doesn't give barcoe `norm_cast`</span>

<span class="c1">-- In Lean 4 there is also the new `coe` attribute, which we also</span>
<span class="c1">-- typically want passed on to additivised declarations.</span>
</code></pre></div>



<a name="313824995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313824995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313824995">(Dec 04 2022 at 15:42)</a>:</h4>
<p>Honestly this would be so much easier if I could just see whether a given declaration had the <code>norm_cast</code> attribute :-/ <code>norm_cast</code> is good at solving things. Basically I'm having to do a lot of work to find an example which proves to me beyond all doubt that it's not there, and what I want to do is just to write a random dumb thing and then simply look.</p>



<a name="313826376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313826376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313826376">(Dec 04 2022 at 15:55)</a>:</h4>
<p>OK here it is finally <span class="user-mention" data-user-id="412682">@Moritz Doll</span>  . Sorry for the delay:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Order.WithBot</span>

<span class="c">/-</span><span class="cm"></span>

<span class="cm"># `simp` plays well with `to_additive`</span>

<span class="cm">(as long as it goes before `to_additive`)</span>
<span class="cm">-/</span>
<span class="kd">@[simp, to_additive bargroup]</span>
<span class="kd">theorem</span> <span class="n">foogroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">Fin</span> <span class="mi">37</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">AddGroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">Fin</span> <span class="mi">37</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="bp">?</span> <span class="c1">-- works</span>

<span class="c1">-- NB @[to_additive bargroup, simp] doesn't attach `simp` to the additivised</span>
<span class="c1">-- attribute</span>


<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kd">@[to_additive]</span>
<span class="kd">def</span> <span class="n">WithOne</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">Option</span> <span class="n">α</span>

<span class="kn">namespace</span> <span class="n">WithOne</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Repr</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Repr</span> <span class="o">(</span><span class="n">WithZero</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="k">fun</span> <span class="n">o</span> <span class="n">_</span> <span class="bp">=&gt;</span>
    <span class="k">match</span> <span class="n">o</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="s2">"0"</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="s2">"↑"</span> <span class="bp">++</span> <span class="n">repr</span> <span class="n">a</span><span class="o">⟩</span>

<span class="kd">@[to_additive]</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">Repr</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Repr</span> <span class="o">(</span><span class="n">WithOne</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="k">fun</span> <span class="n">o</span> <span class="n">_</span> <span class="bp">=&gt;</span>
    <span class="k">match</span> <span class="n">o</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="s2">"1"</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="s2">"↑"</span> <span class="bp">++</span> <span class="n">repr</span> <span class="n">a</span><span class="o">⟩</span>

<span class="kd">@[to_additive]</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">One</span> <span class="o">(</span><span class="n">WithOne</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">none</span><span class="o">⟩</span>

<span class="kd">@[to_additive]</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">Inv</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Inv</span> <span class="o">(</span><span class="n">WithOne</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">Option.map</span> <span class="n">Inv.inv</span> <span class="n">a</span><span class="o">⟩</span>

  <span class="c">/-</span><span class="cm"></span>

<span class="cm">  ## `coe` doesn't play well with `to_additive`</span>

<span class="cm">  -/</span>


<span class="c1">-- `@[to_additive, coe]` doesn't work either</span>
<span class="kd">@[coe, to_additive]</span>
<span class="kd">def</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">WithOne</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">Option.some</span>

<span class="kd">@[to_additive]</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">CoeTC</span> <span class="n">α</span> <span class="o">(</span><span class="n">WithOne</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">coe</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">WithOne</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="gr">sorry</span> <span class="c1">-- ⊢ ↑a = ↑a</span>

<span class="c1">-- additivised coercion doesn't seem to get `coe` attribute</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">WithZero</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="gr">sorry</span> <span class="c1">-- ⊢ WithZero.coe a = WithZero.coe a</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">coe</span><span class="o">]</span> <span class="n">WithZero.coe</span> <span class="c1">-- add it manually</span>

<span class="c1">-- now it's there</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">WithZero</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="gr">sorry</span> <span class="c1">-- ⊢ ↑a = ↑a</span>

<span class="c">/-</span><span class="cm"></span>

<span class="cm">## `norm_cast` also doesn't play well with `to_additive`</span>

<span class="cm">-/</span>

<span class="kd">@[norm_cast, to_additive]</span>
<span class="kd">theorem</span> <span class="n">coe_inv</span> <span class="o">[</span><span class="n">Inv</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">a</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">WithOne</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">↑</span><span class="n">a</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="o">:=</span>
  <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">Inv</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">WithOne</span> <span class="n">α</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="c1">-- ⊢ (↑a)⁻¹ = 1</span>
  <span class="n">norm_cast</span>
  <span class="c1">-- ⊢ ↑a⁻¹ = 1 (goal changed)</span>
  <span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">Neg</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">-</span><span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">WithZero</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="c1">-- ⊢ -↑a = 0</span>
  <span class="n">norm_cast</span>
  <span class="c1">-- ⊢ -↑a = 0 (goal didn't change)</span>
  <span class="gr">sorry</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">norm_cast</span><span class="o">]</span> <span class="n">WithZero.coe_neg</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">Neg</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">-</span><span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">WithZero</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="c1">-- ⊢ -↑a = 0</span>
  <span class="n">norm_cast</span>
  <span class="c1">-- ⊢ ↑(-a) = 0</span>
  <span class="gr">sorry</span>
</code></pre></div>



<a name="313826992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313826992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313826992">(Dec 04 2022 at 16:00)</a>:</h4>
<p>As an unintended consequence I just noticed that the glyphs displayed on my computer for <code>a</code> in code and <code>a</code> in commented code are completely different (the former looks like a g reflected in the x-axis, the latter is a circle with a serif)</p>



<a name="313827786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313827786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Richard Osborn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313827786">(Dec 04 2022 at 16:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/to_additive.20and.20coe/near/313826992">said</a>:</p>
<blockquote>
<p>As an unintended consequence I just noticed that the glyphs displayed on my computer for <code>a</code> in code and <code>a</code> in commented code are completely different (the former looks like a g reflected in the x-axis, the latter is a circle with a serif)</p>
</blockquote>
<p>That has to do with the fact that <em>italicized</em> '<em>a</em>'s are often written in the single-storey manner as opposed to the double-storey 'a'.</p>



<a name="313860607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313860607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313860607">(Dec 04 2022 at 22:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/to_additive.20and.20coe/near/313824995">said</a>:</p>
<blockquote>
<p>Honestly this would be so much easier if I could just see whether a given declaration had the <code>norm_cast</code> attribute :-/ <code>norm_cast</code> is good at solving things. Basically I'm having to do a lot of work to find an example which proves to me beyond all doubt that it's not there, and what I want to do is just to write a random dumb thing and then simply look.</p>
</blockquote>
<p>Assuming you are okay with a solution tailored to <code>norm_cast</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Tactic.NormCast</span>

<span class="kd">@[norm_cast]</span> <span class="kd">theorem</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">Int.ofNat</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Std.Tactic.NormCast</span>
<span class="kd">def</span> <span class="n">isNormCastLemma</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">Environment</span><span class="o">)</span> <span class="o">(</span><span class="n">decl</span> <span class="o">:</span> <span class="n">Name</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bool</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">normCastExt.up.getState</span> <span class="n">env</span><span class="o">)</span><span class="bp">.</span><span class="n">isLemma</span> <span class="o">(</span><span class="bp">.</span><span class="n">decl</span> <span class="n">decl</span><span class="o">)</span> <span class="bp">||</span>
  <span class="o">(</span><span class="n">normCastExt.down.getState</span> <span class="n">env</span><span class="o">)</span><span class="bp">.</span><span class="n">isLemma</span> <span class="o">(</span><span class="bp">.</span><span class="n">decl</span> <span class="n">decl</span><span class="o">)</span> <span class="bp">||</span>
  <span class="o">(</span><span class="n">normCastExt.squash.getState</span> <span class="n">env</span><span class="o">)</span><span class="bp">.</span><span class="n">isLemma</span> <span class="o">(</span><span class="bp">.</span><span class="n">decl</span> <span class="n">decl</span><span class="o">)</span> <span class="bp">||</span>
  <span class="o">(</span><span class="n">pushCastExt.getState</span> <span class="n">env</span><span class="o">)</span><span class="bp">.</span><span class="n">isLemma</span> <span class="o">(</span><span class="bp">.</span><span class="n">decl</span> <span class="n">decl</span><span class="o">)</span>

<span class="k">#eval</span> <span class="k">show</span> <span class="n">MetaM</span> <span class="n">_</span> <span class="k">from</span> <span class="n">return</span> <span class="n">isNormCastLemma</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getEnv</span><span class="o">)</span> <span class="bp">``</span><span class="n">foo</span> <span class="c1">-- true</span>
<span class="k">#eval</span> <span class="k">show</span> <span class="n">MetaM</span> <span class="n">_</span> <span class="k">from</span> <span class="n">return</span> <span class="n">isNormCastLemma</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getEnv</span><span class="o">)</span> <span class="bp">``</span><span class="n">Nat</span> <span class="c1">-- false</span>
</code></pre></div>



<a name="313861040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/to_additive%20and%20coe/near/313861040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/to_additive.20and.20coe.html#313861040">(Dec 04 2022 at 22:25)</a>:</h4>
<p>It did occur to me after whining in #lean4 about not being able to see which attributes were attached to which declarations, that in fact in some sense the opposite is true in Lean 3 -- given half a chance I would whine that sometimes <code>#print</code> gives you half a page worth of attributes most of which I've never heard of and didn't want to see at all. When e.g. teaching, the kind of attributes I want to show to students are stuff like <code>@[simp]</code> and when debugging it's nice to see <code>@[norm_cast]</code> and now <code>@[coe]</code> but actually I'm now wondering whether in reality there's just a short list of attributes which I personally would like to be able to check up on. However for other people there might be a totally different list. </p>
<p>Regardless of all that, thanks! Indeed it's an easier way of checking that neither <code>@[norm_cast, to_additive]</code> nor <code>@[to_additive, norm_cast]</code> attach <code>@[norm_cast]</code> to the additivised declaration.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html">Q. about ByteSlice.getOp</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="269958440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/269958440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#269958440">(Jan 30 2022 at 21:24)</a>:</h4>
<p>Given the definition of <code>ByteSlice</code> as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">ByteSlice</span> <span class="o">:=</span> <span class="o">(</span><span class="n">arr</span> <span class="o">:</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="o">(</span><span class="n">off</span> <span class="n">len</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
</code></pre></div>
<p>I am surprised that the function below does not check for the possibility that <code>idx &gt;= self.len</code>.<br>
Shouldn't there be an error of some kind in that case?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Index into a byte slice. The `getOp` function allows the use of the `buf[i]` notation. -/</span>
<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">getOp</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="n">ByteSlice</span><span class="o">)</span> <span class="o">(</span><span class="n">idx</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">UInt8</span> <span class="o">:=</span> <span class="n">self.arr.get</span><span class="bp">!</span> <span class="o">(</span><span class="n">self.off</span> <span class="bp">+</span> <span class="n">idx</span><span class="o">)</span>
</code></pre></div>
<ul>
<li>Nicolas.</li>
</ul>



<a name="270006592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270006592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270006592">(Jan 31 2022 at 10:07)</a>:</h4>
<p>The <code>get!</code> function does that check and calls <code>panic!</code> if the index is out of bounds.</p>



<a name="270037736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270037736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270037736">(Jan 31 2022 at 14:18)</a>:</h4>
<p><code>get!</code> will succeed if the slice is in the middle of the array and the access is OOB for the slice but within bounds of the array, no? So this looks like a bug to me.</p>



<a name="270042773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270042773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270042773">(Jan 31 2022 at 14:50)</a>:</h4>
<p>(deleted)</p>



<a name="270055214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270055214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270055214">(Jan 31 2022 at 16:00)</a>:</h4>
<p>I wouldn't call it a bug in <code>getOp</code>.  The result is just unspecified if you access the array outside of its bounds, and here it happens to return a value other than <code>default</code>.</p>



<a name="270055690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270055690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270055690">(Jan 31 2022 at 16:03)</a>:</h4>
<p>Other functions don't panic either if you pass them out-of-bounds indices; e.g. <code>modify</code> will silently do nothing.</p>



<a name="270055695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270055695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270055695">(Jan 31 2022 at 16:03)</a>:</h4>
<p>A very unfortunate (and related) problem is that you can't prove panic-freeness of functions using these basic primitives in Lean 4 though.</p>



<a name="270782714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270782714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270782714">(Feb 04 2022 at 22:39)</a>:</h4>
<p>Allowing an out-of-bound access seems to me an open door for a vulnerability that could be potentially serious for an application.<br>
If this vulnerability is intrinsically tied to our inability to prove panic-freeness, then is it really reasonable to use panic in mathlib4?</p>
<p>Panic in lean corresponds to throwing an exception in Java/Scala. In Scala, functional programming guidelines suggest using an appropriate type to encapsulate the distinction between a value and an error; see: <a href="https://docs.scala-lang.org/scala3/book/fp-functional-error-handling.html">https://docs.scala-lang.org/scala3/book/fp-functional-error-handling.html</a></p>
<p>So, in the case of <code>ByteSlice</code>, instead of the panic-vulnerable interface:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="kd">def</span> <span class="n">getOp</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="n">ByteSlice</span><span class="o">)</span> <span class="o">(</span><span class="n">idx</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">UInt8</span>
</code></pre></div>
<p>We would have instead a monad like <code>Either</code> and a type of <code>Error</code> so that we could define a panic-free interface like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="kd">def</span> <span class="n">getOp</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="n">ByteSlice</span><span class="o">)</span> <span class="o">(</span><span class="n">idx</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Either</span> <span class="n">Error</span> <span class="n">UInt8</span>
</code></pre></div>
<p>Then presumably we could write a theorem that says that if the index is within bound, the result must be a <code>Right</code>, otherwise it must be a <code>Left</code>.</p>



<a name="270790527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270790527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270790527">(Feb 05 2022 at 00:12)</a>:</h4>
<p>You shouldn't use <code>getOp</code> if you need error checking</p>



<a name="270790535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270790535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270790535">(Feb 05 2022 at 00:13)</a>:</h4>
<p>there are other functions like <code>get?</code> for that</p>



<a name="270790649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270790649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270790649">(Feb 05 2022 at 00:14)</a>:</h4>
<p>I don't see the sense in which this could cause a vulnerability, except in the general sense that an out of bounds read is probably a bug and if you aren't using the dependently typed <code>get</code> then you are making assertions that could be false</p>



<a name="270853829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270853829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270853829">(Feb 05 2022 at 22:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp/near/270790527">said</a>:</p>
<blockquote>
<p>You shouldn't use <code>getOp</code> if you need error checking</p>
</blockquote>
<p>How so?</p>
<p>Looking at the definition, it is unclear to me what error checking takes place and where.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Index into a byte slice. The `getOp` function allows the use of the `buf[i]` notation. -/</span>
<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">getOp</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="n">ByteSlice</span><span class="o">)</span> <span class="o">(</span><span class="n">idx</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">UInt8</span> <span class="o">:=</span> <span class="n">self.arr.get</span><span class="bp">!</span> <span class="o">(</span><span class="n">self.off</span> <span class="bp">+</span> <span class="n">idx</span><span class="o">)</span>
</code></pre></div>
<p>If <code>self.off + idx &gt; self.arr.size</code>, does <code>self.arr.get! ...</code> raise an error?<br>
If <code>idx &gt; self.len</code>, what catches that error?</p>
<p>Looking at lean4's <code>ByteArray</code>, I would have expected a dependently typed index argument, something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">getOp</span><span class="o">:</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">ByteSlice</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">@&amp;</span> <span class="n">Fin</span> <span class="n">self.len</span><span class="o">)</span> <span class="bp">→</span> <span class="n">UInt8</span>
  <span class="bp">|</span> <span class="o">⟨</span><span class="n">self</span><span class="o">⟩,</span> <span class="n">idx</span> <span class="bp">=&gt;</span> <span class="n">self.arr.get</span><span class="bp">!</span> <span class="o">(</span><span class="n">self.off</span> <span class="bp">+</span> <span class="n">idx</span><span class="o">)</span>
</code></pre></div>
<p>Isn't it preferable to use the type system as a mechanism to prevent errors?</p>



<a name="270872243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270872243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270872243">(Feb 06 2022 at 05:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="362579">Nicolas Rouquette</span> <a href="#narrow/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp/near/270853829">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp/near/270790527">said</a>:</p>
<blockquote>
<p>You shouldn't use <code>getOp</code> if you need error checking</p>
</blockquote>
<p>How so?</p>
<p>Looking at the definition, it is unclear to me what error checking takes place and where.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Index into a byte slice. The `getOp` function allows the use of the `buf[i]` notation. -/</span>
<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">getOp</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="n">ByteSlice</span><span class="o">)</span> <span class="o">(</span><span class="n">idx</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">UInt8</span> <span class="o">:=</span> <span class="n">self.arr.get</span><span class="bp">!</span> <span class="o">(</span><span class="n">self.off</span> <span class="bp">+</span> <span class="n">idx</span><span class="o">)</span>
</code></pre></div>
<p>If <code>self.off + idx &gt; self.arr.size</code>, does <code>self.arr.get! ...</code> raise an error?<br>
If <code>idx &gt; self.len</code>, what catches that error?</p>
</blockquote>
<p>The error handling behavior is inherited from <code>get!</code> here. If you use <code>Array.get!</code> with an out of bounds index, the program will not halt, you will get <code>default : A</code> back, and an error message will be printed on stderr (which is usually reserved for low level errors, and gives users an uncomfortable experience, so it should be avoided when possible). In other words, this is an <code>assert</code> statement which you should only use if you are sure it will not occur in your code. However note that memory safety is not compromised here, and a bounds check is still performed.</p>
<p><span class="user-mention silent" data-user-id="362579">Nicolas Rouquette</span> <a href="#narrow/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp/near/270853829">said</a>:</p>
<blockquote>
<p>Looking at lean4's <code>ByteArray</code>, I would have expected a dependently typed index argument, something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">getOp</span><span class="o">:</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">ByteSlice</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">@&amp;</span> <span class="n">Fin</span> <span class="n">self.len</span><span class="o">)</span> <span class="bp">→</span> <span class="n">UInt8</span>
  <span class="bp">|</span> <span class="o">⟨</span><span class="n">self</span><span class="o">⟩,</span> <span class="n">idx</span> <span class="bp">=&gt;</span> <span class="n">self.arr.get</span><span class="bp">!</span> <span class="o">(</span><span class="n">self.off</span> <span class="bp">+</span> <span class="n">idx</span><span class="o">)</span>
</code></pre></div>
<p>Isn't it preferable to use the type system as a mechanism to prevent errors?</p>
</blockquote>
<p>It's certainly possible to define such a thing yourself. But <code>self.len</code> is not the right bound here, as you would see if you deferred to <code>Array.get</code> instead:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">getOp</span><span class="o">:</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">ByteSlice</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">@&amp;</span> <span class="n">Fin</span> <span class="n">self.len</span><span class="o">)</span> <span class="bp">→</span> <span class="n">UInt8</span>
  <span class="bp">|</span> <span class="o">⟨</span><span class="n">self</span><span class="o">⟩,</span> <span class="n">idx</span> <span class="bp">=&gt;</span> <span class="n">self.arr.get</span> <span class="o">⟨</span><span class="n">self.off</span> <span class="bp">+</span> <span class="n">idx</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span>
</code></pre></div>
<p>At the <code>_</code> you will see that it expects a proof that <code>self.off + idx &lt; self.arr.size</code>, and your assumption <code>idx &lt; self.len</code> does not help to prove this.</p>



<a name="270872536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270872536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270872536">(Feb 06 2022 at 06:04)</a>:</h4>
<p>I think it is reasonable to add more proofs to these data structures, to assert that <code>off + len &lt;= arr.size</code> in <code>ByteSlice</code> and possibly also <code>off &lt;= arr.size</code> in <code>ByteSliceT</code>. If we did so, then it would make more sense to provide an "unchecked" dependently typed <code>get</code> function. Currently a dependently typed get function would be useless because knowing that it is in bounds of the slice doesn't mean it is in bounds of the underlying array</p>



<a name="270872705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270872705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270872705">(Feb 06 2022 at 06:08)</a>:</h4>
<p>However, I don't think that <code>getOp</code> (the one that gets the <code>a[i]</code> syntax) should be dependently typed. Following the lead of lean 4 core, this should just take a nat and it should have unspecified out of bounds behavior (it shouldn't do any checks it does not need to for memory safety)</p>



<a name="270910830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270910830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270910830">(Feb 06 2022 at 20:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp/near/270872536">said</a>:</p>
<blockquote>
<p>I think it is reasonable to add more proofs to these data structures, to assert that <code>off + len &lt;= arr.size</code> in <code>ByteSlice</code> and possibly also <code>off &lt;= arr.size</code> in <code>ByteSliceT</code>. If we did so, then it would make more sense to provide an "unchecked" dependently typed <code>get</code> function. Currently a dependently typed get function would be useless because knowing that it is in bounds of the slice doesn't mean it is in bounds of the underlying array</p>
</blockquote>
<p>Thanks for the explanation! While I understand in principle the suggestion, it is still unclear to me how to do this.</p>
<p>So, starting from the definition without assertions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">ByteSliceT</span> <span class="o">:=</span> <span class="o">(</span><span class="n">arr</span> <span class="o">:</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="o">(</span><span class="n">off</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
</code></pre></div>
<p>Is it correct that to add support for these assertions, we have to effectively turn them into proof obligations?</p>
<p>I tried this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">ByteSliceT</span> <span class="n">where</span>
  <span class="n">arr</span> <span class="o">:</span> <span class="n">ByteArray</span>
  <span class="n">off</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">isLt</span> <span class="o">:</span> <span class="n">Nat.lt</span> <span class="n">off</span> <span class="n">arr.size</span>

<span class="kd">def</span> <span class="n">a</span><span class="o">:</span> <span class="n">ByteArray</span> <span class="o">:=</span> <span class="o">(((</span><span class="n">ByteArray.empty.push</span> <span class="mi">10</span><span class="o">)</span><span class="bp">.</span><span class="n">push</span> <span class="mi">20</span><span class="o">)</span><span class="bp">.</span><span class="n">push</span> <span class="mi">30</span><span class="o">)</span><span class="bp">.</span><span class="n">push</span> <span class="mi">40</span>
<span class="k">#eval</span> <span class="n">a</span> <span class="c1">-- [10, 20, 30, 40]</span>

<span class="kd">def</span> <span class="n">b1</span> <span class="o">:</span> <span class="n">ByteSliceT</span> <span class="o">:=</span> <span class="n">ByteSliceT.mk</span> <span class="n">a</span> <span class="mi">1</span> <span class="o">(</span><span class="n">Nat.lt</span> <span class="mi">1</span> <span class="n">a.size</span><span class="o">)</span>

<span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
  <span class="o">{</span> <span class="n">arr</span> <span class="o">:=</span> <span class="n">a</span><span class="o">,</span> <span class="n">off</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">isLt</span> <span class="o">:=</span> <span class="n">Nat.lt</span> <span class="mi">1</span> <span class="o">(</span><span class="n">ByteArray.size</span> <span class="n">a</span><span class="o">)</span> <span class="o">}</span>
<span class="n">argument</span>
  <span class="n">Nat.lt</span> <span class="mi">1</span> <span class="o">(</span><span class="n">ByteArray.size</span> <span class="n">a</span><span class="o">)</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Prop</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">Nat.lt</span> <span class="mi">1</span> <span class="o">(</span><span class="n">ByteArray.size</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>
<p>It seems that the structure is close what what would be needed since it would reject this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">b3</span> <span class="o">:</span> <span class="n">ByteSliceT</span> <span class="o">:=</span> <span class="n">ByteSliceT.mk</span> <span class="n">a</span> <span class="mi">20</span> <span class="o">(</span><span class="n">Nat.lt</span> <span class="mi">1</span> <span class="n">a.size</span><span class="o">)</span>

<span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
  <span class="o">{</span> <span class="n">arr</span> <span class="o">:=</span> <span class="n">a</span><span class="o">,</span> <span class="n">off</span> <span class="o">:=</span> <span class="mi">20</span><span class="o">,</span> <span class="n">isLt</span> <span class="o">:=</span> <span class="n">Nat.lt</span> <span class="mi">1</span> <span class="o">(</span><span class="n">ByteArray.size</span> <span class="n">a</span><span class="o">)</span> <span class="o">}</span>
<span class="n">argument</span>
  <span class="n">Nat.lt</span> <span class="mi">1</span> <span class="o">(</span><span class="n">ByteArray.size</span> <span class="n">a</span><span class="o">)</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Prop</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">Nat.lt</span> <span class="mi">20</span> <span class="o">(</span><span class="n">ByteArray.size</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>
<p>There is something that I am missing but I am not sure what it is.</p>



<a name="270916023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270916023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270916023">(Feb 06 2022 at 22:40)</a>:</h4>
<p>first, you want the requirement to be <code>off &lt;= arr.size</code> not <code>off &lt; arr.size</code>. An empty byte slice at the end of the array should be okay</p>



<a name="270916081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270916081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270916081">(Feb 06 2022 at 22:42)</a>:</h4>
<p>The issue with <code>b1</code> is that you gave it <code>1 &lt; a.size</code> instead of a proof of <code>1 &lt; a.size</code>. In this case, it reduces to <code>1 &lt; 4</code> so <code>(by decide)</code> should work as a proof</p>



<a name="270916156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270916156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270916156">(Feb 06 2022 at 22:44)</a>:</h4>
<p>The structure is otherwise correct. Most likely you would also want a "smart constructor" <code>mkByteSliceT</code> that does not take a proof, and instead sets the offset to <code>min off a.size</code> which can be proven to always be in bounds. That way users can use <code>mkByteSliceT</code> when they don't want to do the side proof, at the cost of doing a bounds check in the constructor</p>



<a name="270921701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/270921701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#270921701">(Feb 07 2022 at 00:59)</a>:</h4>
<p>Makes sense, though I am still struggling with how to write this properly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mkByteSliceT</span> <span class="o">(</span><span class="n">arr</span> <span class="o">:</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="o">(</span><span class="n">off</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">off</span> <span class="bp">&lt;=</span> <span class="n">arr.size</span> <span class="k">then</span>
    <span class="o">(</span>
      <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">Nat.lt</span> <span class="n">off</span> <span class="n">arr.size</span>
      <span class="bp">|</span> <span class="n">ByteSliceT.mk</span> <span class="o">{</span><span class="n">arr</span><span class="o">:=</span><span class="n">arr</span><span class="o">,</span> <span class="n">off</span><span class="o">:=</span><span class="n">off</span><span class="o">,</span> <span class="n">isLT</span><span class="o">:=</span><span class="n">h</span><span class="o">}</span>
    <span class="o">)</span>
  <span class="k">else</span>
    <span class="n">panic</span><span class="bp">!</span> <span class="n">s</span><span class="s2">"Error: offset, {off}, exceeds array size, {arr.size}"</span>
</code></pre></div>
<p>Although I've read the doc several times, it is still unclear to me how to combine these aspects of computation and proof together.</p>



<a name="271384475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/271384475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#271384475">(Feb 10 2022 at 04:17)</a>:</h4>
<p>In case it is not obvious, I am stuck at how to do invoke <code>ByteSliteT.mk</code> from <code>mkByteSliceT</code>.<br>
That is, how can I convert a confirmation that <code>off &lt;= arr.size</code> into a proof suitable for calling <code>ByteSliteT.mk</code>  where <code>ByteSliceT</code> is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">ByteSliceT</span> <span class="n">where</span>
  <span class="n">arr</span> <span class="o">:</span> <span class="n">ByteArray</span>
  <span class="n">off</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">isLt</span> <span class="o">:</span> <span class="n">Nat.lt</span> <span class="n">off</span> <span class="n">arr.size</span>
</code></pre></div>



<a name="271385116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/271385116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#271385116">(Feb 10 2022 at 04:30)</a>:</h4>
<p>again, you don't want <code>isLt</code>; it should be <code>isLe</code></p>



<a name="271385123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/271385123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#271385123">(Feb 10 2022 at 04:30)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">ByteSliceT</span> <span class="n">where</span>
  <span class="n">arr</span> <span class="o">:</span> <span class="n">ByteArray</span>
  <span class="n">off</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">isLe</span> <span class="o">:</span> <span class="n">off</span> <span class="bp">&lt;=</span> <span class="n">arr.size</span>
</code></pre></div>



<a name="271385451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/271385451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#271385451">(Feb 10 2022 at 04:37)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">ByteSliceT</span> <span class="n">where</span>
  <span class="n">arr</span> <span class="o">:</span> <span class="n">ByteArray</span>
  <span class="n">off</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">isLe</span> <span class="o">:</span> <span class="n">off</span> <span class="bp">≤</span> <span class="n">arr.size</span>

<span class="kd">def</span> <span class="n">mkByteSliceT</span> <span class="o">(</span><span class="n">arr</span> <span class="o">:</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="o">(</span><span class="n">off</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">ByteSliceT</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">arr</span><span class="o">,</span> <span class="n">min</span> <span class="n">off</span> <span class="n">arr.size</span><span class="o">,</span> <span class="n">min_le_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩</span>
</code></pre></div>



<a name="271385538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/271385538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#271385538">(Feb 10 2022 at 04:39)</a>:</h4>
<p>I don't think we want to panic on out of bounds input here. It is reasonable to want to create a suffix starting after the end of the array, and this simply doesn't span any elements</p>



<a name="271533555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/271533555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#271533555">(Feb 11 2022 at 05:29)</a>:</h4>
<p>Thanks for the clarification. </p>
<p>Reasonable behavior can be subjective unless there is a way to describe what guarantees we can provide.</p>
<p>Considering the signature of the function:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mkByteSliceT</span> <span class="o">(</span><span class="n">arr</span> <span class="o">:</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="o">(</span><span class="n">off</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">ByteSliceT</span>
</code></pre></div>
<p>In conventional programming, there is the notion of pre/post condition to specify some properties about a function.<br>
It seems to me that with Lean, we do not need pre/post conditions per se, rather, it's the implementation of the function<br>
that, if written in a logical way, enables lean to "reason" about its properties as you've done for the constructor's 3rd argument:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mkByteT</span> <span class="o">(</span><span class="n">arr</span> <span class="o">:</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="o">(</span><span class="n">off</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">ByteSliceT</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">arr</span><span class="o">,</span> <span class="n">min</span> <span class="n">off</span> <span class="n">arr.size</span><span class="o">,</span> <span class="n">min_le_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩</span>
</code></pre></div>
<p>Suppose we wanted another constructor whose contract is that it either succeeds with the offset as requested or fails if the offset is too large.<br>
I agree that it is probably undesirable to use <code>panic</code> for this.<br>
In Scala, we would instead have a return type like this: <code>Either[String, ByteStringT]</code></p>
<p>Are there recommendations for how to do this in lean4?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- what is the result type?</span>
<span class="c1">-- what is the implementation?</span>
<span class="kd">def</span> <span class="n">mkByteSliceAsRequested</span> <span class="o">(</span><span class="n">arr</span> <span class="o">:</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="o">(</span><span class="n">off</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="bp">???</span> <span class="o">:=</span>
  <span class="bp">???</span>
</code></pre></div>



<a name="271533649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/271533649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#271533649">(Feb 11 2022 at 05:31)</a>:</h4>
<p>We don't need a function with a precondition, because the constructor already serves that purpose</p>



<a name="271533661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/271533661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#271533661">(Feb 11 2022 at 05:31)</a>:</h4>
<p>a version that panics might be useful but it would still have to return a valid result, so it would probably just be a guarded version of <code>mkByteSliceT</code></p>



<a name="271533727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Q.%20about%20ByteSlice.getOp/near/271533727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Q.2E.20about.20ByteSlice.2EgetOp.html#271533727">(Feb 11 2022 at 05:33)</a>:</h4>
<p>because unless you return an option or other enriched return type, even if you "fail" you are still required to not violate the type system because consistency of the logic depends on it</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
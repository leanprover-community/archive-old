---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/A.20translate.20tactic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html">A translate tactic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="320544355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320544355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320544355">(Jan 10 2023 at 21:03)</a>:</h4>
<p>Thinking about it a bit more, if we had <code>translate</code>, <code>to_additive</code> could be described as</p>
<ul>
<li>additivise the statement of <code>mul_thm</code> to get the statement of <code>add_thm</code></li>
<li>run <code>translate mul_thm</code> on <code>add_thm</code></li>
</ul>



<a name="320544440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320544440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320544440">(Jan 10 2023 at 21:04)</a>:</h4>
<p>It's basically just <code>exact_mod_cast</code> but with a different operator to <code>coe</code></p>



<a name="320544528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320544528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320544528">(Jan 10 2023 at 21:04)</a>:</h4>
<p>And probably we'll want an additional argument to <code>translate</code> for it to know which dictionary to use.</p>



<a name="320544947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320544947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320544947">(Jan 10 2023 at 21:07)</a>:</h4>
<p>Not sure what you mean by "dictionary"</p>



<a name="320545496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320545496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320545496">(Jan 10 2023 at 21:11)</a>:</h4>
<p>I'm thinking of a dictionary as a set of lemmas to allow translating between, eg:</p>
<ul>
<li><code>set</code> → <code>finset</code></li>
<li><code>list</code> → <code>array</code></li>
<li>multiplicative world → additive world</li>
<li>order theory → order theory again (but everything dualised)</li>
<li>algebra → algebra again (but <code>a + b</code> → <code>b + a</code>)</li>
<li>algebra → algebra again (but <code>a * b</code> → <code>b * a</code>)</li>
</ul>



<a name="320546037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320546037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320546037">(Jan 10 2023 at 21:15)</a>:</h4>
<p>This sounds to me like some kind of natural isomorphism stuff.</p>



<a name="320548800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320548800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320548800">(Jan 10 2023 at 21:32)</a>:</h4>
<p>Yes, absolutely, a meta-theoretic one.</p>



<a name="320549375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320549375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320549375">(Jan 10 2023 at 21:36)</a>:</h4>
<p>I'm quite surprised that this doesn't already exist! It sounds like a very natural abstraction, but I don't know how difficult implementing such a tactic would be.</p>



<a name="320549441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320549441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320549441">(Jan 10 2023 at 21:36)</a>:</h4>
<p>My thinking is the way this would work, for two types <code>A</code> and <code>B</code></p>
<ul>
<li>Start with a lemma about a type <code>A</code></li>
<li>Instantiate all the binders of a lemma with <code>B_to_A x</code></li>
<li>Apply <code>A_to_B</code> around the outside of the outer <code>=</code> in the statement if there is one (TODO: recurse into iffs)</li>
<li>Push the former inwards, and the latter outwards until they cross and cancel. The dictionary containing these types of lemma would be keyed by <code>(B_to_A, A_to_b)</code> or similar</li>
<li>End up with a lemma about the type <code>B</code></li>
</ul>



<a name="320549721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320549721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320549721">(Jan 10 2023 at 21:38)</a>:</h4>
<p>When "pushing" in and out, that's where we'd use the lemmas mapping each operation over the isomorphism, presumably?</p>



<a name="320549772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320549772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320549772">(Jan 10 2023 at 21:38)</a>:</h4>
<p>Yes, exactly</p>



<a name="320549881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320549881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320549881">(Jan 10 2023 at 21:39)</a>:</h4>
<p>Things like <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_opposite.op_mul">docs#mul_opposite.op_mul</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/of_add_add">docs#of_add_add</a></p>



<a name="320550185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320550185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320550185">(Jan 10 2023 at 21:40)</a>:</h4>
<p>Note that in my explanation, I explicitly stated that <code>translate</code> shouldn't try to <em>generate</em> the statement. This is best done by specialised tools (the current <code>to_additive</code> dictionary) and might not have a single solution (in order theory there are exponentially many possible dualised statements).</p>



<a name="320550290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320550290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320550290">(Jan 10 2023 at 21:41)</a>:</h4>
<p>Also note that we want to support more relations than just <code>=</code>, and not only relations. Eg <code>⊆</code>, <code>⊂</code>, <code>.nonempty</code></p>



<a name="320551103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320551103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320551103">(Jan 10 2023 at 21:46)</a>:</h4>
<blockquote>
<p>and might not have a single solution (in order theory there are exponentially many possible dualised statements).</p>
</blockquote>
<p>Can you give an example?</p>



<a name="320551392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320551392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320551392">(Jan 10 2023 at 21:48)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/monotone.comp">docs#monotone.comp</a> involves three orders, and two out of the three can be meaningfully dualised. which results in 4 lemmas.</p>



<a name="320551595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320551595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320551595">(Jan 10 2023 at 21:49)</a>:</h4>
<p>Can you split this thread at what you think is an appropriate point? Arrays are far behind us...</p>



<a name="320551743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320551743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320551743">(Jan 10 2023 at 21:50)</a>:</h4>
<p>While this discussion is taking place, can I add to the list of wishes also automation to prove results about <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.trailing_degree">docs#polynomial.trailing_degree</a>, from results about <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.degree">docs#polynomial.degree</a>?  <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="320551790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320551790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320551790">(Jan 10 2023 at 21:50)</a>:</h4>
<p>Hmm actually it seems that I can't...</p>



<a name="320551838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320551838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320551838">(Jan 10 2023 at 21:51)</a>:</h4>
<p>19 messages were moved here from <a class="stream-topic" data-stream-id="287929" href="/#narrow/stream/287929-mathlib4/topic/Array">#mathlib4 &gt; Array</a> by <span class="user-mention silent" data-user-id="310045">Eric Wieser</span>.</p>



<a name="320552134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320552134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320552134">(Jan 10 2023 at 21:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/A.20translate.20tactic/near/320549441">said</a>:</p>
<blockquote>
<p>My thinking is the way this would work, for two types <code>A</code> and <code>B</code></p>
<ul>
<li>Start with a lemma about a type <code>A</code></li>
<li>Instantiate all the binders of a lemma with <code>B_to_A x</code></li>
<li>Apply <code>A_to_B</code> around the outside of the outer <code>=</code> in the statement if there is one (TODO: recurse into iffs)</li>
</ul>
</blockquote>
<p>After applying your first three steps, would <code>aesop</code> be able to solve the resulting goal?</p>



<a name="320552191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320552191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320552191">(Jan 10 2023 at 21:53)</a>:</h4>
<p>(after being taught the appropriate lemmas)</p>



<a name="320552202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320552202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320552202">(Jan 10 2023 at 21:53)</a>:</h4>
<p>Oh yeah, Damiano, nice one.</p>



<a name="320552325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320552325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320552325">(Jan 10 2023 at 21:54)</a>:</h4>
<p>I don't see Aesop being more useful than <code>simp only ...</code> here, but I could be mistaken</p>



<a name="320552341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320552341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320552341">(Jan 10 2023 at 21:54)</a>:</h4>
<p>I think <code>aesop</code> is overkill here. We have a very well delimited domain.</p>



<a name="320552657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320552657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320552657">(Jan 10 2023 at 21:56)</a>:</h4>
<p><code>simp only</code> sounds like a reasonable thing to use to perform the 4th step.</p>



<a name="320552779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320552779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320552779">(Jan 10 2023 at 21:57)</a>:</h4>
<p>This doesn't seem like a particularly difficult tactic to write given all of the infrastructure - I'd be interested in trying to write (at least a prototype version of) it.</p>



<a name="320553635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320553635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320553635">(Jan 10 2023 at 22:03)</a>:</h4>
<p>Step 4 alone would be a useful thing to prototype</p>



<a name="320553774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320553774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320553774">(Jan 10 2023 at 22:04)</a>:</h4>
<p>To me, the first step (finding the correct <code>coe_inj</code>/<code>coe_subset</code>-like lemma and applying it) is the hardest.</p>



<a name="320553822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320553822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320553822">(Jan 10 2023 at 22:04)</a>:</h4>
<p>It sounds like it to me too.</p>



<a name="320553967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320553967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320553967">(Jan 10 2023 at 22:05)</a>:</h4>
<p>I think the tricky bit is building the lookup from "push this application inwards / outwards" to a list of the intended lemmas</p>



<a name="320553983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320553983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320553983">(Jan 10 2023 at 22:05)</a>:</h4>
<p>Note that we have to be picky about the lemmas we provide <code>simp</code> with in the last step, as <code>coe_inj</code>/<code>coe_subset</code> are simp lemmas and risk reverting the goal to the original statement!</p>



<a name="320554076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320554076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320554076">(Jan 10 2023 at 22:06)</a>:</h4>
<p>I think there's a lot of overlap with the norm_cast push/pull/elim framework here</p>



<a name="320554120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320554120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320554120">(Jan 10 2023 at 22:06)</a>:</h4>
<p>I expect there to be wisdom to extract from <code>norm_cast</code>'s implementation.</p>



<a name="320554203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320554203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320554203">(Jan 10 2023 at 22:07)</a>:</h4>
<p>Why am I even talking anymore? We clearly are the hive mind <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="320554207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320554207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320554207">(Jan 10 2023 at 22:07)</a>:</h4>
<p>I may have some time tomorrow to look over this.</p>



<a name="320554212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320554212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320554212">(Jan 10 2023 at 22:07)</a>:</h4>
<p>This also overlaps with the <code>push_hom</code>/<code>pull_hom</code> proposal</p>



<a name="320554297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320554297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320554297">(Jan 10 2023 at 22:08)</a>:</h4>
<p>Yes, there might be a pair of generic <code>push</code>/<code>pull</code> tactics to extract from this as well.</p>



<a name="320554355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320554355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320554355">(Jan 10 2023 at 22:08)</a>:</h4>
<p>I think probably a good step would just be writing out a list of all the sorts of lemmas we'd want to be able to push / pull, perhaps for:</p>
<ul>
<li><code>order_dual</code></li>
<li><code>mul_opposite</code></li>
<li><code>add_monoid_hom</code></li>
</ul>



<a name="320554578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320554578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320554578">(Jan 10 2023 at 22:09)</a>:</h4>
<p>I assume you mean functions rather than lemmas?</p>



<a name="320554676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320554676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320554676">(Jan 10 2023 at 22:10)</a>:</h4>
<p>No, I mean lemmas. For the obvious push / pull actions in those areas, what lemmas would be valid things to apply</p>



<a name="320554781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320554781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320554781">(Jan 10 2023 at 22:11)</a>:</h4>
<p>Oh "(the sorts of lemmas we'd want) to be able to push", not "the sort of (lemmas we'd want to be able to push)". Linear language be cursed.</p>



<a name="320623992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320623992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320623992">(Jan 11 2023 at 07:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Array/near/320576366">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/287929-mathlib4/topic/Array/near/320541677">said</a>:</p>
<blockquote>
<p>Regarding <code>set</code> and <code>finset</code>, I found that <code>coe_inj.2 $ by { norm_cast, exact set.some_lemma }</code> (or the <code>coe_subset</code> version thereof) was a reliable way of proving <code>finset.some_lemma</code>. By now, there are many lemmas in mathlib I proved that way. So I think it is a sensible heuristic for implementing such a tactic.</p>
</blockquote>
<p>This is basically what the <code>norm_cast</code> tactic does, so I would say the tactic to do this already exists</p>
</blockquote>
<p>I'm not sure, no. <code>norm_cast</code> only goes one direction, and what happens here is that you first need to apply some lemmas in the <code>push_cast</code> direction, then some others in the <code>norm_cast</code> one.</p>



<a name="320624396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320624396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320624396">(Jan 11 2023 at 07:38)</a>:</h4>
<p>Essentially, the diagram of possible cast normalisations is a square, and we're walking along three of its edges to deduce the fourth.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">set.X</span>  <span class="bp">→</span> <span class="n">finset.X</span>
   <span class="bp">↑</span>        <span class="bp">↑</span>      <span class="n">norm_cast</span>
<span class="n">set.X'</span> <span class="bp">→</span> <span class="n">finset.X'</span>
</code></pre></div>



<a name="320626797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320626797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320626797">(Jan 11 2023 at 07:45)</a>:</h4>
<p>In the vast majority of cases this is just something like <code>ext; simp</code></p>



<a name="320626935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320626935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320626935">(Jan 11 2023 at 07:46)</a>:</h4>
<p>the <code>ext</code> "activates" the simp lemmas, indicating that you want to go around the square</p>



<a name="320627045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320627045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320627045">(Jan 11 2023 at 07:46)</a>:</h4>
<p>it would be a bad idea to go traversing that square without some explicit indication of such</p>



<a name="320627303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320627303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320627303">(Jan 11 2023 at 07:47)</a>:</h4>
<p>(unless you are in the context of a big closing tactic like <code>aesop</code>, where you can try stuff and roll back)</p>



<a name="320627324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320627324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320627324">(Jan 11 2023 at 07:47)</a>:</h4>
<p>Yes, I'm proposing we mark that information explicitly. And, no, <code>ext</code> won't cut it.</p>



<a name="320627409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320627409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320627409">(Jan 11 2023 at 07:47)</a>:</h4>
<p>I haven't seen a convincing example of that</p>



<a name="320627417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320627417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320627417">(Jan 11 2023 at 07:47)</a>:</h4>
<p>Can you read the entire thread? I feel like you're missing context.</p>



<a name="320627613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320627613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320627613">(Jan 11 2023 at 07:48)</a>:</h4>
<p>you yourself said that the proof is usually <code>apply ext_lemma; simp</code> or so</p>



<a name="320627794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320627794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320627794">(Jan 11 2023 at 07:49)</a>:</h4>
<p>(in the thread from which you got my quote)</p>



<a name="320627817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320627817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320627817">(Jan 11 2023 at 07:49)</a>:</h4>
<p>I never said this, no. I rather said <code>rw ←norm_cast_lemma; norm_cast; simp</code></p>



<a name="320627954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320627954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320627954">(Jan 11 2023 at 07:49)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finset.coe_subset">docs#finset.coe_subset</a> is not an extensionality lemma, for example.</p>



<a name="320628012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320628012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320628012">(Jan 11 2023 at 07:49)</a>:</h4>
<p>okay, either way it's a one liner already</p>



<a name="320628120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320628120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320628120">(Jan 11 2023 at 07:50)</a>:</h4>
<p>I don't see a motivation for writing a tactic here</p>



<a name="320628728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320628728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320628728">(Jan 11 2023 at 07:52)</a>:</h4>
<p>Well, it's a one-liner for the <code>set</code>/<code>finset</code> translation, but it's not for at least 4 of the other use cases I'm stating.</p>



<a name="320629627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320629627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320629627">(Jan 11 2023 at 07:54)</a>:</h4>
<p>Simp lemmas do most of the work in all of those examples</p>



<a name="320630141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320630141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320630141">(Jan 11 2023 at 07:56)</a>:</h4>
<p><code>to_additive</code> is a lot of work to maintain and this sounds like it would be at least as complicated, if not more because you want it to apply to a bunch of very differently shaped domains</p>



<a name="320630478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320630478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320630478">(Jan 11 2023 at 07:57)</a>:</h4>
<p>The only thing that could feasibly cover all of those domains is a simp set, so we're back to <code>norm_cast</code></p>



<a name="320630798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320630798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320630798">(Jan 11 2023 at 07:58)</a>:</h4>
<p>just make a macro for <code>simp [up]; simp [left]; simp [down]</code></p>



<a name="320716872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320716872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320716872">(Jan 11 2023 at 14:32)</a>:</h4>
<p>Another direction you might be interested in is to adapt locales (as seen in Isabelle). They seem to be quite good at implementing the kind of rewriting used by <code>to_additive</code> but in a more robust way. I don't know how effectively a basic implementation would mesh with existing Lean metaprogramming, but it's certainly worth mentioning as an alternative.</p>



<a name="320801718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320801718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320801718">(Jan 11 2023 at 21:34)</a>:</h4>
<p>I was thinking that an easy way to deal with the non-uniqueness of a goal is to perfom the rewriting lemmas on the hypothesis <em>and</em> the goal. Then they'll both be normalised to the same form, and the user just needs to make sure they write the goal in the way they'd like.</p>



<a name="320801768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/320801768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#320801768">(Jan 11 2023 at 21:34)</a>:</h4>
<p>It also makes translating "backwards" just as easy as translating "forwards".</p>



<a name="321699781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/321699781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#321699781">(Jan 16 2023 at 18:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/A.20translate.20tactic/near/320630478">said</a>:</p>
<blockquote>
<p>The only thing that could feasibly cover all of those domains is a simp set, so we're back to <code>norm_cast</code></p>
</blockquote>
<p>Are are you saying that <code>norm_cast</code>itself could be used to do these sorts of simplifications for other domains like <code>Array&lt;-&gt;List</code>? Or just that you could get similar behavior using simp sets?</p>



<a name="321699909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/321699909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#321699909">(Jan 16 2023 at 18:42)</a>:</h4>
<p>To use <code>norm_cast</code> directly you need to be using things that are marked as <code>@[coe]</code></p>



<a name="321699991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/321699991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#321699991">(Jan 16 2023 at 18:43)</a>:</h4>
<p>but it's a wrapper for simp with specific simp sets so you can make your own simp sets to do something with non-coes</p>



<a name="321700212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/321700212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#321700212">(Jan 16 2023 at 18:44)</a>:</h4>
<p>So we could have a macro which takes as arguments the appropriate simp sets.  Where if you pass it the <code>coe</code> simp sets, it behaves like norm_cast, but if you pass it other simp sets it could handle other isomporphisms?</p>



<a name="321700333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/321700333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#321700333">(Jan 16 2023 at 18:45)</a>:</h4>
<p>yes</p>



<a name="321700791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/321700791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#321700791">(Jan 16 2023 at 18:48)</a>:</h4>
<p>Ok that makes sense. I can give it a shot.  From a software engineering perspective, does it make sense to try to modify the <code>norm_cast</code> implementation to allow you to control the simp sets it is using, or does it make more sense to implement something from scratch?</p>



<a name="321701931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/A%20translate%20tactic/near/321701931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/A.20translate.20tactic.html#321701931">(Jan 16 2023 at 18:56)</a>:</h4>
<p>I think you should start by doing it from scratch (or rather, copy and paste) to make sure that it actually works as intended</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html">logic.equiv.basic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="310955502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310955502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310955502">(Nov 19 2022 at 02:10)</a>:</h4>
<p>77tigers (sorry, I don't know their zulip usernames --- <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>?) started the port of <code>Logic.Equiv.Basic</code> in <a href="https://github.com/leanprover-community/mathlib4/pull/631">mathlib4#631</a>.</p>
<p>I feel this one is on the critical path to porting many other things, so I hope it is okay with the OP if others join in to get it done asap.</p>



<a name="310955511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310955511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310955511">(Nov 19 2022 at 02:10)</a>:</h4>
<p>I've just gone ahead and finished renaming and aligning the file.</p>



<a name="310955538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310955538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310955538">(Nov 19 2022 at 02:11)</a>:</h4>
<p>However there are <em>many</em> broken proofs still, for mostly independent reasons, so it should be fine if anyone wants to jump in and just fix as many as they have inclination to do.</p>



<a name="310955566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310955566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310955566">(Nov 19 2022 at 02:12)</a>:</h4>
<p>Probably best not to sit on changes, however: if you fix a few proofs, push your commit. :-)</p>



<a name="310956459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310956459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310956459">(Nov 19 2022 at 02:27)</a>:</h4>
<p>In that logic.equiv.basic we have the slightly esoteric (and only used in Chevalley-Warning)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The type of all functions `X → Y` with prescribed values for all `x' ≠ x`</span>
<span class="sd">is equivalent to the codomain `Y`. -/</span>
<span class="kd">def</span> <span class="n">subtypeEquivCodomain</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x'</span> <span class="bp">//</span> <span class="n">x'</span> <span class="bp">≠</span> <span class="n">x</span> <span class="o">}</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">//</span> <span class="n">g</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">}</span> <span class="bp">≃</span> <span class="n">Y</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>but of course <code>coe</code> doesn't mean anything now. I'm guessing the closest replacement for this theorem will be:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">subtypeEquivCodomain</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x'</span> <span class="bp">//</span> <span class="n">x'</span> <span class="bp">≠</span> <span class="n">x</span> <span class="o">}</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">//</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x'</span> <span class="bp">//</span> <span class="n">x'</span> <span class="bp">≠</span> <span class="n">x</span> <span class="o">}</span>  <span class="bp">=&gt;</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">}</span> <span class="bp">≃</span> <span class="n">Y</span> <span class="o">:=</span>
</code></pre></div>
<p>Any other suggestions?</p>



<a name="310956791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310956791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310956791">(Nov 19 2022 at 02:32)</a>:</h4>
<p>For specific types where we can find a <code>Coe</code> instance, you should replace occurrences of <code>coe</code> with <code>(↑)</code> (defined in <code>Mathlib.Tactic.Coe</code>) or <code>(·)</code></p>



<a name="310956992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310956992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310956992">(Nov 19 2022 at 02:36)</a>:</h4>
<p>I can't get <code>(↑)</code> or <code>(·)</code> to work here, as without a type annotation on the left-hand-side (i.e. <code>g ∘ (·)</code>) they just seem to default to the identity, and then we get a type error on the <code>f</code>.</p>



<a name="310956999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310956999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310956999">(Nov 19 2022 at 02:36)</a>:</h4>
<p>Hence writing <code>(fun x : { x' // x' ≠ x } =&gt; g x) = f</code>.</p>



<a name="310957943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310957943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310957943">(Nov 19 2022 at 02:54)</a>:</h4>
<p>I'm getting a bad error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">Coe</span> <span class="o">(</span><span class="n">Subtype</span> <span class="n">p</span><span class="o">)</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Subtype.val</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">subtypeEquivCodomain</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x'</span> <span class="bp">//</span> <span class="n">x'</span> <span class="bp">≠</span> <span class="n">x</span> <span class="o">}</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">{</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">//</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="o">(</span><span class="bp">·</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">}</span> <span class="bp">≃</span> <span class="n">Y</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- failed to synthesize</span>
<span class="c1">--   CoeHTCT ({ x' // x' ≠ x } → Y) (X → Y)</span>
<span class="c1">-- (deterministic) timeout at 'typeclass', maximum number of heartbeats (20000) has been reached (use 'set_option synthInstance.maxHeartbeats &lt;num&gt;' to set the limit)</span>
</code></pre></div>



<a name="310957961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310957961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310957961">(Nov 19 2022 at 02:55)</a>:</h4>
<p>which indicates that there is a bad instance somewhere causing a loop</p>



<a name="310958026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310958026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310958026">(Nov 19 2022 at 02:56)</a>:</h4>
<p>oh, actually it's probably the subtype coe I had to add to make this compile</p>



<a name="310958052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310958052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310958052">(Nov 19 2022 at 02:57)</a>:</h4>
<p>Using <code>Subtype.val</code> works, of course</p>



<a name="310958118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310958118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310958118">(Nov 19 2022 at 02:58)</a>:</h4>
<p>also <code>by exact (·)</code></p>



<a name="310958120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310958120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310958120">(Nov 19 2022 at 02:58)</a>:</h4>
<p>So is it better to have <code>Subtype.val</code> in the statement, or what I wrote?</p>



<a name="310958122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310958122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310958122">(Nov 19 2022 at 02:58)</a>:</h4>
<p>I think this is a bug report</p>



<a name="310958142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310958142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310958142">(Nov 19 2022 at 02:59)</a>:</h4>
<p>That <code>(↑)</code> doesn't work here is a bug.  Give me a sec.</p>



<a name="310958143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310958143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310958143">(Nov 19 2022 at 02:59)</a>:</h4>
<p>A separate logic.equiv.basic question, I seem to be encountering a failure of beta reduction in the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Equiv</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
  <span class="n">invFun</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="n">left_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">invFun</span> <span class="o">(</span><span class="n">toFun</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span>

<span class="kd">infixl</span><span class="o">:</span><span class="mi">25</span> <span class="s2">" ≃ "</span> <span class="bp">=&gt;</span> <span class="n">Equiv</span>

<span class="sd">/-- A product of types can be split as the binary product of one of the types and the product</span>
<span class="sd">  of all the remaining types. -/</span>
<span class="kd">def</span> <span class="n">piSplitAt</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">DecidableEq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="n">j</span><span class="o">,</span> <span class="n">β</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≃</span> <span class="n">β</span> <span class="n">i</span> <span class="bp">×</span> <span class="bp">∀</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span> <span class="n">j</span> <span class="bp">//</span> <span class="n">j</span> <span class="bp">≠</span> <span class="n">i</span> <span class="o">},</span> <span class="n">β</span> <span class="n">j</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">f</span> <span class="n">i</span><span class="o">,</span> <span class="k">fun</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">j</span><span class="o">⟩</span>
  <span class="n">invFun</span> <span class="n">f</span> <span class="n">j</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">h.symm.rec</span> <span class="n">f.1</span> <span class="k">else</span> <span class="n">f.2</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>
  <span class="n">left_inv</span> <span class="n">f</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">apply</span> <span class="n">funext</span>
    <span class="n">intro</span> <span class="n">x</span>
    <span class="c">/-</span><span class="cm"> Goal is now:</span>
<span class="cm">    ```</span>
<span class="cm">    (fun f j =&gt; if h : j = i then (_ : i = j) ▸ f.fst else Prod.snd f { val := j, property := h })</span>
<span class="cm">      ((fun f =&gt; (f i, fun j =&gt; f j.val)) f) x =</span>
<span class="cm">      f x</span>
<span class="cm">    ```</span>
<span class="cm">    -/</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="c1">-- Does nothing</span>
    <span class="c1">-- Expected the goal to start with `if h : j = i ...`</span>
</code></pre></div>
<p>Am I missing something, or is this a bug?</p>



<a name="310958156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310958156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310958156">(Nov 19 2022 at 02:59)</a>:</h4>
<p>I'm inclined to use <code>Subtype.val</code> (or something that expands to it, once we work that out) to ensure it is still written in first-order style with explicit composition</p>



<a name="310958244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310958244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310958244">(Nov 19 2022 at 03:00)</a>:</h4>
<p>that also looks like a bug</p>



<a name="310958309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310958309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310958309">(Nov 19 2022 at 03:01)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib4/pull/652">https://github.com/leanprover-community/mathlib4/pull/652</a></p>



<a name="310958407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310958407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310958407">(Nov 19 2022 at 03:03)</a>:</h4>
<p>Reported the beta reduction issue as <a href="https://github.com/leanprover/lean4/pull/1856">lean4#1856</a>.</p>



<a name="310973841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310973841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310973841">(Nov 19 2022 at 07:35)</a>:</h4>
<p>In <code>logic.equiv.basic</code> we have the somewhat tricky statement <code>pi_congr_left'</code>, which translates to:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Logic.Equiv.Defs</span>

<span class="kn">namespace</span> <span class="n">Equiv</span>

<span class="kd">def</span> <span class="n">piCongrLeft'</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="bp">≃</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">e.symm</span> <span class="n">b</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">(</span><span class="n">e.symm</span> <span class="n">x</span><span class="o">)</span>
  <span class="n">invFun</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">e.symm_apply_apply</span> <span class="n">x</span><span class="o">]</span>
    <span class="n">exact</span> <span class="n">f</span> <span class="o">(</span><span class="n">e</span> <span class="n">x</span><span class="o">)</span>
  <span class="n">left_inv</span> <span class="n">f</span> <span class="o">:=</span>
    <span class="n">funext</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span>
      <span class="n">eq_of_heq</span>
        <span class="o">((</span><span class="n">eq_rec_heq</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span>
          <span class="o">(</span><span class="kd">by</span>
            <span class="n">dsimp</span>
            <span class="n">rw</span> <span class="o">[</span><span class="n">e.symm_apply_apply</span><span class="o">]))</span>    <span class="c1">-- fails, but the goal was already bad: `HEq ?m.205 ?m.206`</span>
  <span class="n">right_inv</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">funext</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">eq_of_heq</span> <span class="o">((</span><span class="n">eq_rec_heq</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">e.apply_symm_apply</span><span class="o">]))</span>    <span class="c1">-- fails similarly</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">equiv.Pi_congr_left'</span> <span class="n">Equiv.piCongrLeft'</span>
</code></pre></div>
<p>However this proof isn't working. When I try to do it step by step I can't get the <code>eq_rec_heq</code>s to unify. Can anyone work out a new proof here?</p>



<a name="310977689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.equiv.basic/near/310977689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.html#310977689">(Nov 19 2022 at 08:22)</a>:</h4>
<p>Ah, got it. I found the old thread form 2020 when we first put this in mathlib, where Mario offered some alternative proofs, and one of those translates just fine.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html">Which files to port?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="238397100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238397100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238397100">(May 11 2021 at 23:25)</a>:</h4>
<p>I don't think we are ready to start large scale porting now, that's exactly the point. We should be prepared for lean 4 to change from under us, and the more code there is the harder that gets. But since you asked, here are some files I would like to port before we have the infrastructure for the real port:</p>
<ul>
<li><code>data.list.defs</code>, <code>data.list.basic</code></li>
<li><code>data.nat.basic</code></li>
<li>Everything in <code>init</code><ul>
<li>Algebra is still an open problem, this will need specific investigation and experimentation</li>
</ul>
</li>
<li>All tactics in <code>init</code> and <code>tactic</code> (reserve them individually)</li>
</ul>
<p>There are also some new theories for the more programming oriented parts of lean 4:</p>
<ul>
<li>Lemmas about <code>UInt8</code> and other fixed width integers</li>
<li>Maybe a library for <code>Array</code> which is comparable to <code>List</code>? It's gotten a lot better in lean 4 and maybe we want to prioritize it over lists</li>
<li>Theorems about data structures! Maybe port that new isabelle book</li>
</ul>



<a name="238397199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238397199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238397199">(May 11 2021 at 23:26)</a>:</h4>
<p>A high priority for now is making the process of porting itself as smooth as possible, learning the tricks and so on</p>



<a name="238435817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238435817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238435817">(May 12 2021 at 07:58)</a>:</h4>
<p>Part of my manual porting of a chunk of the algebra heirarchy yesterday to a standalone gist was to get some kind of idea of what the algebra heirarchy looks like. I would like to do tests of random things ASAP. Whenever someone comes along with a Lean 3 problem which looks like it has something to with the algebra heirarchy, e.g. <span class="user-mention" data-user-id="310045">@Eric Wieser</span> complaining recently when working with direct sums that he was having to fight the elaborator, or me having to wait 2 seconds every time I did <code>rw T</code> instead of <code>rw T x</code> earlier this week, I am thinking "well, will this actually be any better in Lean 4?" The fact that I wrote a <a href="https://gist.github.com/kbuzzard/999fd7d54af7e37c91b1c13122daf941">standalone 350 line file yesterday</a> which enabled me to do rewrites involving Frobenius homomorphisms in perfections of commutative rings from scratch made me realise that testing these sorts of things in Lean 4 is actually very much within the realms of feasibility right now. </p>
<p>However my main problem with this right now is this whole old_structure / new_structure thing. Whilst I understand on a theoretical level that old structures and new structures are different ways of storing the same information, I find the entire subject of run time analysis extremely boring and have no understanding of the ramifications of the different choices. I made a recent thread where I really wanted to try and make changes to Lean 3 and port stuff from old structures to new, but I need guidance here because my understanding is that there are design decisions to be made. For example here is a link to <a href="#narrow/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60/near/235969759">Eric's comment</a> about how one has to choose a spanning tree for something, and I have no idea what something he is talking about, or how to generate it, or how to choose a spanning tree, or what design decisions are involved in choosing this spanning tree. Here is a concrete example. Eric and I have had a lot of discussions recently, both on public Zulip and in DMs, about internal and external direct sums. I'd like to experiment with those in Lean 4. My experience yesterday seems to suggest that we are only a few hundred lines of code away from being able to do those experiments and speaking as someone who is deeply interested in doing mathematics in Lean with objects deep into the algebra heirarchy I would be interested in doing them myself. But until someone explains to me how we're going to define rings in Lean 4 -- I am talking about something as simple as a ring, with its projections to groups and add_groups and add_semigroups and add_left_right_cancel_monoids or whatever other junk we have down there which people are interested in, I am not able to do these experiments. </p>
<p>In short, I cannot work on "Algebra is still an open problem" but it seems to me that now is a very good time to start breaking that vague statement down into a more precise project which I can work on.</p>



<a name="238436536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238436536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238436536">(May 12 2021 at 08:04)</a>:</h4>
<p>The "something" I was referring to is "the entire hierarchy of algebra classes", which for your experiment probably amounts to "everything which <code>comm_ring</code> transitively extends"</p>



<a name="238436738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238436738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238436738">(May 12 2021 at 08:06)</a>:</h4>
<p>right, but I don't understand the edges, and I don't understand why a spanning tree is important, and as a result I don't know what the definition of a ring is supposed to look like in Lean 4, which stops me formalising it and hence stops me being able to experiment with it.</p>



<a name="238436781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238436781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238436781">(May 12 2021 at 08:06)</a>:</h4>
<p>For me as a mathematician if A is a B then there's some kind of an "edge" from A to B, but I think you might be thinking about something else.</p>



<a name="238436950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238436950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238436950">(May 12 2021 at 08:08)</a>:</h4>
<p>I think that's the graph we have in mind. There's an edge from <code>A</code> to <code>B</code> precisely when every <code>A</code> "is" (in mathematician speak) a <code>B</code>.</p>



<a name="238437008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437008">(May 12 2021 at 08:08)</a>:</h4>
<p>Then we want to pick some spanning tree of this graph, and we will realise those "is"s using <code>extends</code>, and all the other "is"s just as instances that repack the fields.</p>



<a name="238437016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437016">(May 12 2021 at 08:08)</a>:</h4>
<p>(deleted)</p>



<a name="238437179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437179">(May 12 2021 at 08:10)</a>:</h4>
<p>I know you just deleted that, but the problem is that without old_structure_cmd there are two different kinds of arrows, and we can only use the stronger one sometimes</p>



<a name="238437189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437189">(May 12 2021 at 08:10)</a>:</h4>
<p>My understanding was that new structures won't let us do all the <code>extends</code> we want, so this puts some strong restrictions on the spanning tree, right? For example I can't extend <code>ring</code> and <code>comm_group</code> to get <code>comm_ring</code></p>



<a name="238437235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437235">(May 12 2021 at 08:10)</a>:</h4>
<p>I guess it's not a spanning tree thought it's a spanning DAG</p>



<a name="238437251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437251">(May 12 2021 at 08:10)</a>:</h4>
<p>(I deleted the question because Scott answered it as I posted it)</p>



<a name="238437274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437274">(May 12 2021 at 08:10)</a>:</h4>
<p>Exactly, you can only extend one and have to build manual glue for the other</p>



<a name="238437288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437288">(May 12 2021 at 08:11)</a>:</h4>
<p>but I can envisage a spanning tree where they are both edges</p>



<a name="238437292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437292">(May 12 2021 at 08:11)</a>:</h4>
<p>(or glue, aka the weaker of the two arrows, for both if you don't know which is the right choice yet)</p>



<a name="238437448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437448">(May 12 2021 at 08:12)</a>:</h4>
<p>My problem is that I can never know what the right choice is because I have no real understanding of why we are even thinking about this boring question or what its relevance is, because I have fundamental lack of understanding of the actual issues at stake. This is frustrating for me because I really want to have a definition of a commutative ring in Lean 4.</p>



<a name="238437538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437538">(May 12 2021 at 08:13)</a>:</h4>
<p>Maybe try using the weak arrows everywhere then, which is analogous to what lean3 is doing anyway</p>



<a name="238437547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437547">(May 12 2021 at 08:13)</a>:</h4>
<p>All I know is that we don't have eta for structures and this somehow matters but not in a way which I fully <em>comprehend</em> in some deep way.</p>



<a name="238437706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437706">(May 12 2021 at 08:14)</a>:</h4>
<p>I assume there's some nasty typetheoretical reason why we can't have eta for structures</p>



<a name="238437731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437731">(May 12 2021 at 08:15)</a>:</h4>
<p>Does "use weak arrows everywhere" literally mean that I can define a commutative ring by not bothering to worry about what extends what, and just literally list all the axioms?</p>



<a name="238437753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437753">(May 12 2021 at 08:15)</a>:</h4>
<p>Yes</p>



<a name="238437773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437773">(May 12 2021 at 08:15)</a>:</h4>
<p>I don't think the relevant question is why we can't have eta for structures, if we don't have them then we don't have them.</p>



<a name="238437873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437873">(May 12 2021 at 08:16)</a>:</h4>
<p>You'll end up having <code>add_assoc</code> etc repeated in lots of places, but listing all the axioms every time is what old structures do</p>



<a name="238437904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437904">(May 12 2021 at 08:16)</a>:</h4>
<p>Lean3 just does the copy-paste for you</p>



<a name="238437910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437910">(May 12 2021 at 08:16)</a>:</h4>
<p>If one lists all the axioms then as a mathematician I'd be prone to shortcuts, e.g. I would not bother having <code>one_mul</code> and <code>mul_one</code> both as axioms for a commutative ring, because one implies the other. Is that going to be an issue?</p>



<a name="238437934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238437934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238437934">(May 12 2021 at 08:16)</a>:</h4>
<p>I am not averse to copy-paste, indeed I've said many times before that I don't understand why CS people are so averse to code duplication</p>



<a name="238438021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238438021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238438021">(May 12 2021 at 08:18)</a>:</h4>
<p>Similarly I would have three axioms for a group, you can deduce <code>one_mul</code> from <code>mul_one</code> if you know what you're doing and have the correct inverse axiom.</p>



<a name="238438074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238438074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238438074">(May 12 2021 at 08:18)</a>:</h4>
<p>It will be an issue when you write <code>comm_ring.to_ring</code> as now you actually have to prove stuff rather than writing <code>..inst</code></p>



<a name="238438080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238438080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238438080">(May 12 2021 at 08:18)</a>:</h4>
<p>But that's not a big issue</p>



<a name="238438120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238438120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238438120">(May 12 2021 at 08:18)</a>:</h4>
<p>that is indeed how my internal model of maths works</p>



<a name="238438334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238438334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238438334">(May 12 2021 at 08:20)</a>:</h4>
<p>One thing we've noticed in mathlib3 is that it's difficult to add extra stuff into the algebra heirarchy, like e.g. suddenly we decided we wanted monoids with 0 and it was a huge amount of work, and there are smart people like Cyril Cohen who write papers about this stuff which I never read or understand. Will the "just write down all the axioms" approach make this even worse?</p>



<a name="238438399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238438399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238438399">(May 12 2021 at 08:21)</a>:</h4>
<p>For example, I have no interest whatsoever in add_left_cancel_monoids or whatever, my instinct would just be to define monoids, groups, rings and fields, and leave the boring stuff to other people.</p>



<a name="238438536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238438536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238438536">(May 12 2021 at 08:22)</a>:</h4>
<p><span class="user-mention" data-user-id="243312">@Jason KY.</span> and I developed the basics of finite group theory from scratch in Lean 3 (i.e. with our own definition of <code>group</code>) and one could imagine porting this to Lean 4 as an experiment.</p>



<a name="238439264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238439264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238439264">(May 12 2021 at 08:29)</a>:</h4>
<p>From what I can tell the reason adding new typeclasses is a lot of work is that if you have <code>AwithFooBarBaz -&gt; AwithFooBar -&gt; A</code> and want to add a new typeclass <code>AwithFooBaz</code>, you also end up having to also add <code>AwithFoo</code> so that you don't end up copying the lemmas about <code>AwithFooBar</code> that actually didn't need <code>Bar</code></p>



<a name="238440092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238440092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238440092">(May 12 2021 at 08:35)</a>:</h4>
<p>Eg, if you have comm_ring and ring and want to add <code>comm_semiring</code>, you then need to also add <code>semiring</code> to avoid having two different mul_add lemmas</p>



<a name="238443841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238443841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238443841">(May 12 2021 at 09:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , here is what would seem like a reasonable hierarchy. Would you fancy implementing this in Lean 4 and seeing if there are rough edges? I only put the names of the instances, not their fields, but I guess you know what they should be. There are two main points here:</p>
<ul>
<li>when one <code>extends foo, bar</code>, there should be no common field in <code>foo</code> and <code>bar</code></li>
<li>Try to follow the main mathematical paths when defining stuff, and declare instances to more gadget stuff.</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">has_add</span>
<span class="n">has_zero</span>
<span class="n">has_neg</span>
<span class="n">has_sub</span>
<span class="n">has_mul</span>
<span class="n">has_one</span>
<span class="n">has_inv</span>
<span class="n">has_div</span>

<span class="n">semigroup</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">has_mul</span>
<span class="n">monoid</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">semigroup</span><span class="o">,</span> <span class="n">has_one</span>
<span class="n">comm_monoid</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">monoid</span>
<span class="n">monoid_with_zero</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">monoid</span><span class="o">,</span> <span class="n">has_zero</span>
<span class="n">group</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">monoid</span><span class="o">,</span> <span class="n">has_inv</span><span class="o">,</span> <span class="n">has_div</span>
<span class="n">comm_group</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">group</span>
<span class="n">declare</span> <span class="kd">instance</span> <span class="k">from</span> <span class="n">comm_group</span> <span class="n">to</span> <span class="n">comm_monoid</span>
<span class="n">group_with_zero</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">group</span><span class="o">,</span> <span class="n">with_zero</span>
<span class="n">declare</span> <span class="kd">instance</span> <span class="k">from</span> <span class="n">group_with_zero</span> <span class="n">to</span> <span class="n">monoid_with_zero</span>

<span class="n">add_semigroup</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">has_add</span>
<span class="n">add_monoid</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">had_add</span><span class="o">,</span> <span class="n">has_zero</span>
<span class="n">add_group</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">add_monoid</span><span class="o">,</span> <span class="n">has_neg</span><span class="o">,</span> <span class="n">has_sub</span>
<span class="n">add_comm_group</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">add_group</span>

<span class="n">semiring</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">monoid</span><span class="o">,</span> <span class="n">add_comm_monoid</span>
<span class="n">declare</span> <span class="kd">instance</span> <span class="k">from</span> <span class="n">semiring</span> <span class="n">to</span> <span class="n">monoid_with_zero</span>
<span class="n">comm_semiring</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">semiring</span>
<span class="n">declare</span> <span class="kd">instance</span> <span class="k">from</span> <span class="n">comm_semiring</span> <span class="n">to</span> <span class="n">comm_monoid</span>
<span class="n">ring</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">monoid</span><span class="o">,</span> <span class="n">add_comm_group</span>
<span class="n">declare</span> <span class="kd">instance</span> <span class="k">from</span> <span class="n">ring</span> <span class="n">to</span> <span class="n">semiring</span>
<span class="n">comm_ring</span> <span class="o">:</span> <span class="kd">extends</span> <span class="n">ring</span>
<span class="n">declare</span> <span class="kd">instance</span> <span class="k">from</span> <span class="n">comm_ring</span> <span class="n">to</span> <span class="n">comm_semiring</span>
</code></pre></div>
<p>(Sorry, edited several times to fix stupid stuff)</p>



<a name="238444472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238444472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238444472">(May 12 2021 at 09:15)</a>:</h4>
<p>I noticed recently in Lean 3 that when declaring structures, you can use the <code>.. bar</code> trick even when <code>bar</code> is not extended by the structure you're defining. I don't know if this is the case in Lean 4, but if it's true then all the additional instances to be declared above would be trivial. I mean, the instance from <code>comm_ring</code> to <code>comm_semiring</code> would just be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">comm_semiring</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">{</span> <span class="bp">..</span> <span class="n">h</span> <span class="o">}</span>
</code></pre></div>



<a name="238445389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238445389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238445389">(May 12 2021 at 09:24)</a>:</h4>
<p>(I'm leaving aside the <code>add_left_cancel</code> stuff and so on, because they could just be mixins)</p>



<a name="238457759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238457759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238457759">(May 12 2021 at 11:25)</a>:</h4>
<p>Note that there is no <code>distrib</code> in  what I propose, because <code>distrib</code> contains both <code>has_add</code> and <code>has_mul</code>, so if you extend <code>distrib</code> then with the rule that fields can not be shared you can not extend anything else basically. This means that the <code>distrib</code> fields will have to be copied verbatim both in <code>semiring</code> and <code>ring</code>. Then if you want to declare a <code>distrib</code> class and register an instance to it from <code>semiring</code> you can do that, but I don't see what it would bring us.</p>



<a name="238461320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238461320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238461320">(May 12 2021 at 11:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I will probably make a start on this on Thursday. I would keep declarations in files whose name corresponds to the corresponding mathlib3 file. Shall I do this in my own sandbox <a href="https://github.com/kbuzzard/mathlib4_experiments">https://github.com/kbuzzard/mathlib4_experiments</a> or should I be PRing to <a href="https://github.com/leanprover-community/mathlib4">https://github.com/leanprover-community/mathlib4</a> ?</p>



<a name="238469109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238469109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> pcpthm <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238469109">(May 12 2021 at 13:01)</a>:</h4>
<p>FYI there is a previous discussion on algebraic hierarchy &lt;<a href="#narrow/stream/270676-lean4/topic/to_additive">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive</a>&gt;<br>
In particular, &lt;<a href="https://github.com/leanprover/lean4/blob/master/tests/lean/run/KyleAlg.lean">https://github.com/leanprover/lean4/blob/master/tests/lean/run/KyleAlg.lean</a>&gt; is similar to what Sebastien wrote above.<br>
(I think this discussion worth a separate topic)</p>



<a name="238482248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238482248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238482248">(May 12 2021 at 14:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238444472">said</a>:</p>
<blockquote>
<p>I noticed recently in Lean 3 that when declaring structures, you can use the <code>.. bar</code> trick even when <code>bar</code> is not extended by the structure you're defining. I don't know if this is the case in Lean 4, but if it's true then all the additional instances to be declared above would be trivial. </p>
</blockquote>
<p>It works in Lean4 but with slightly different syntax:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">CommRing</span>     <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">class</span> <span class="n">CommSemiring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">CommRing</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">CommSemiring</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">h</span> <span class="k">with</span> <span class="o">}</span>
</code></pre></div>



<a name="238496699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238496699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238496699">(May 12 2021 at 15:46)</a>:</h4>
<p>One reason I advocated for the <code>{ ..s }</code> syntax over <code>{ s with }</code> (which by the way was the original form in lean 3 and still exists although it's basically not used at all in mathlib) is that it supports multiple mixins with <code>{ ..s, ..t }</code>. We could either implement that notation, or we could extend the <code>with</code> notation, e.g. <code>{ s, t with ... }</code>. Certainly it is a useful thing to do and mathlib uses it frequently so we'll have to do something about it</p>



<a name="238497432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238497432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238497432">(May 12 2021 at 15:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238461320">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> I will probably make a start on this on Thursday. I would keep declarations in files whose name corresponds to the corresponding mathlib3 file. Shall I do this in my own sandbox <a href="https://github.com/kbuzzard/mathlib4_experiments">https://github.com/kbuzzard/mathlib4_experiments</a> or should I be PRing to <a href="https://github.com/leanprover-community/mathlib4">https://github.com/leanprover-community/mathlib4</a> ?</p>
</blockquote>
<p>I think you should feel free to use mathlib4 repo as a sandbox for now. Try to put things in the right places as though it were the real thing, but experimental additions are fine.</p>



<a name="238499558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238499558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238499558">(May 12 2021 at 16:01)</a>:</h4>
<p>Do you mean that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">FooClass</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">class</span> <span class="n">BarClass</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">class</span> <span class="n">FooBarClass</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">α</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">FooClass</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">h'</span> <span class="o">:</span> <span class="n">BarClass</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">FooBarClass</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">h</span><span class="o">,</span> <span class="n">h'</span> <span class="k">with</span> <span class="o">}</span>
</code></pre></div>
<p>doesn't work currently? Indeed, we use this all the time in mathlib.</p>



<a name="238506746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238506746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238506746">(May 12 2021 at 16:47)</a>:</h4>
<p>that's correct, I just tested and it's a parse error, and looking at the code there is no handling for it either</p>



<a name="238549501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238549501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Kiniry <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238549501">(May 12 2021 at 21:46)</a>:</h4>
<p>Can you not just use chained typeclasses to achieve the same effect?  (I have only read the manual and used typeclasses extensively in other languages, so have not yet tried them in vain in Lean4.)</p>



<a name="238551700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238551700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238551700">(May 12 2021 at 22:06)</a>:</h4>
<p><span class="user-mention" data-user-id="394849">@Joe Kiniry</span> I'm not sure what effect you are referring to.</p>



<a name="238660430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238660430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238660430">(May 13 2021 at 18:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> or anyone who understands new structures -- if <code>group</code> extends <code>monoid</code> then I have to prove <code>one_mul</code> and <code>mul_one</code> (both axioms for monoids), whereas <code>add_assoc</code>, <code>one_mul</code> and <code>mul_left_inv</code> imply <code>mul_one</code> in groups. Is there any reason why I should not just extend <code>semigroup</code> instead, and make an instance to <code>monoid</code> which contains <a href="https://xenaproject.wordpress.com/2018/04/30/group-theory-revision/">the proof of this</a>? I am still stupidly confused about the issues here, somehow I've failed to internalise the key point of all this new stucture stuff so still am not at the stage where I can answer my own questions.</p>



<a name="238660625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238660625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238660625">(May 13 2021 at 18:29)</a>:</h4>
<p>Oh -- do we want <code>npow</code> for groups as well as <code>gpow</code>? Again we have the option to avoid this.</p>



<a name="238660967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238660967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238660967">(May 13 2021 at 18:31)</a>:</h4>
<p>New structure "compositional inheritance" means that group is a structure that looks like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">group</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">to_monoid</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">A</span>
  <span class="n">inv</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">A</span>
  <span class="n">mul_left_inv</span> <span class="o">:</span> <span class="bp">...</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">s</span> <span class="o">:</span> <span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">s.to_monoid</span>
</code></pre></div>
<p>Old structure inheritance looks like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">group</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">one</span> <span class="o">:</span> <span class="n">A</span>
  <span class="n">mul</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">A</span>
  <span class="bp">...</span>
  <span class="n">inv</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">A</span>
  <span class="n">mul_left_inv</span> <span class="o">:</span> <span class="bp">...</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">s</span> <span class="o">:</span> <span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="o">}</span>
</code></pre></div>



<a name="238662600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238662600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238662600">(May 13 2021 at 18:44)</a>:</h4>
<p>Hmm. A <code>group_with_zero</code> is not a group, so <code>group_with_zero</code> can't extend <code>group</code>. I propose extending <code>monoid_with_zero</code> instead.</p>



<a name="238665108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238665108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238665108">(May 13 2021 at 19:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238660430">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> or anyone who understands new structures -- if <code>group</code> extends <code>monoid</code> then I have to prove <code>one_mul</code> and <code>mul_one</code> (both axioms for monoids), whereas <code>add_assoc</code>, <code>one_mul</code> and <code>mul_left_inv</code> imply <code>mul_one</code> in groups. Is there any reason why I should not just extend <code>semigroup</code> instead, and make an instance to <code>monoid</code> which contains <a href="https://xenaproject.wordpress.com/2018/04/30/group-theory-revision/">the proof of this</a>? I am still stupidly confused about the issues here, somehow I've failed to internalise the key point of all this new stucture stuff so still am not at the stage where I can answer my own questions.</p>
</blockquote>
<p>Yes, you can definitely do that. Inheritance paths wouldn't probably be as nice, though, so I think I'd rather let <code>group</code> extend <code>monoid</code>, and include an automatic proof of <code>mul_one</code>. I don't know if default arguments already work, otherwise just doing the proofs by hand for now should be enough.</p>



<a name="238665145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238665145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238665145">(May 13 2021 at 19:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238662600">said</a>:</p>
<blockquote>
<p>Hmm. A <code>group_with_zero</code> is not a group, so <code>group_with_zero</code> can't extend <code>group</code>. I propose extending <code>monoid_with_zero</code> instead.</p>
</blockquote>
<p>You're absolutely right!</p>



<a name="238665496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238665496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238665496">(May 13 2021 at 19:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238660625">said</a>:</p>
<blockquote>
<p>Oh -- do we want <code>npow</code> for groups as well as <code>gpow</code>? Again we have the option to avoid this.</p>
</blockquote>
<p>You definitely want <code>npow</code> there -- but if you extend <code>monoid</code> it is already there for you.</p>



<a name="238667585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238667585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238667585">(May 13 2021 at 19:22)</a>:</h4>
<p><code>semiring</code> is supposed to extend <code>add_comm_monoid</code> which Lean points out isn't in the list, so I'm extending <code>add_monoid</code> and again I have an option to drop one of <code>zero_add</code> and <code>add_zero</code> and extend something weaker, but presumably people don't want this, so I'll extend <code>add_monoid</code> and then declare an instance from <code>add_comm_group</code> to <code>add_comm_monoid</code>.</p>



<a name="238667694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238667694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238667694">(May 13 2021 at 19:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238660967">said</a>:</p>
<blockquote>
<p>New structure "compositional inheritance" means that group is a structure that looks like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">group</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">to_monoid</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">A</span>
  <span class="n">inv</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">A</span>
  <span class="n">mul_left_inv</span> <span class="o">:</span> <span class="bp">...</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">s</span> <span class="o">:</span> <span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">s.to_monoid</span>
</code></pre></div>
<p>Old structure inheritance looks like this:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">group</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">one</span> <span class="o">:</span> <span class="n">A</span>
  <span class="n">mul</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">A</span>
  <span class="bp">...</span>
  <span class="n">inv</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">A</span>
  <span class="n">mul_left_inv</span> <span class="o">:</span> <span class="bp">...</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">s</span> <span class="o">:</span> <span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="o">}</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Yes, this is precisely the part I understand. The problem is that I don't understand why people care about the difference, because it is something to do with running time, which I never pay any attention to.</p>



<a name="238668376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238668376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238668376">(May 13 2021 at 19:29)</a>:</h4>
<p>Is <code>0 * a = 0</code> definitely an axiom for semirings? We have it as an axiom in Lean 3, and I am assuming that we know what we're talking about. Interestingly, the Lean 4 suggestion above is that <code>ring</code> extend <code>monoid</code> and <code>add_comm_group</code>, and so we don't have <code>0 * a = 0</code> and <code>a * 0 = 0</code> added automatically, however if memory serves they can be deduced from the <code>distrib</code> axioms in the <code>ring</code> case.</p>



<a name="238668780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238668780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238668780">(May 13 2021 at 19:32)</a>:</h4>
<p>In Sebastien's sketched hierarchy, the implication is that any axioms not given by the extends clauses would be additional fields on the class, so in the case of <code>semiring</code> I would assume <code>mul_zero</code> is a field of <code>semiring</code>.</p>



<a name="238668871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238668871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238668871">(May 13 2021 at 19:33)</a>:</h4>
<p>Sure, I'm just asking whether it's definitely an axiom for real life semirings</p>



<a name="238668928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238668928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238668928">(May 13 2021 at 19:33)</a>:</h4>
<p>For real life rings I was taught that it was a theorem rather than an axiom, and given that we're no longer extending monoid_with_zero I can make it so.</p>



<a name="238668930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238668930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238668930">(May 13 2021 at 19:33)</a>:</h4>
<p>it's certainly supposed to be true, so if it isn't derivable from the other things then it needs to be an axiom</p>



<a name="238668967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238668967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238668967">(May 13 2021 at 19:33)</a>:</h4>
<p>Oh OK. I don't know anything about semirings :-)</p>



<a name="238669062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669062">(May 13 2021 at 19:34)</a>:</h4>
<p>It might be derivable though, in which case it need not be an axiom, I haven't thought deeply about the particular setting</p>



<a name="238669108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669108">(May 13 2021 at 19:34)</a>:</h4>
<p>I think there is some proof using distribution, like <code>x * (0 + 0) = x * 0 + x * 0</code> and cancel</p>



<a name="238669116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669116">(May 13 2021 at 19:34)</a>:</h4>
<p>I can't see how to derive it for semirings but my memory is that it's derivable for rings from Monoid, AddCommMonoid and Distrib</p>



<a name="238669125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669125">(May 13 2021 at 19:35)</a>:</h4>
<p>but that doesn't work if you can't cancel</p>



<a name="238669135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669135">(May 13 2021 at 19:35)</a>:</h4>
<p>right</p>



<a name="238669157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669157">(May 13 2021 at 19:35)</a>:</h4>
<p>great, so that's the proof for rings</p>



<a name="238669224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669224">(May 13 2021 at 19:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238667585">said</a>:</p>
<blockquote>
<p><code>semiring</code> is supposed to extend <code>add_comm_monoid</code> which Lean points out isn't in the list, so I'm extending <code>add_monoid</code> and again I have an option to drop one of <code>zero_add</code> and <code>add_zero</code> and extend something weaker, but presumably people don't want this, so I'll extend <code>add_monoid</code> and then declare an instance from <code>add_comm_group</code> to <code>add_comm_monoid</code>.</p>
</blockquote>
<p>That's an oversight on my side, <code>add_comm_monoid</code> should definitely be added on the list. Sorry!</p>



<a name="238669229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669229">(May 13 2021 at 19:35)</a>:</h4>
<p>Note that one constraint of compositional inheritance is that you can't drop unnecessary axioms</p>



<a name="238669410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669410">(May 13 2021 at 19:36)</a>:</h4>
<p>so if <code>ring extends semiring</code> then you wouldn't be able to supply that proof (or can you? There is some trick for adding defaults to old fields in lean 3, I'm not sure if it still works in lean 4)</p>



<a name="238669471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669471">(May 13 2021 at 19:37)</a>:</h4>
<p>You can't drop them, but you can add a default proof for them, right? (Or rather, it will be possible once this is available for structures -- this is not the case for now if I understand correctly a message by Sebastian above in <a href="#narrow/stream/270676-lean4/topic/.28x.20.3A.20A.20.2E.20t.29.20implicit.20argument.20synthesized.20by.20tactic/near/238662208">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.28x.20.3A.20A.20.2E.20t.29.20implicit.20argument.20synthesized.20by.20tactic/near/238662208</a>)</p>



<a name="238669519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669519">(May 13 2021 at 19:37)</a>:</h4>
<p>right, that's what I was alluding to</p>



<a name="238669594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669594">(May 13 2021 at 19:38)</a>:</h4>
<p>We have some examples of it but I can't remember where</p>



<a name="238669689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669689">(May 13 2021 at 19:38)</a>:</h4>
<p>In the plan above, Ring extends Monoid and AddCommGroup, so I <em>can</em> drop them</p>



<a name="238669692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669692">(May 13 2021 at 19:38)</a>:</h4>
<p>Well, the feature in lean 3 was a little weird since you would add a default to a field that was already declared</p>



<a name="238669777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669777">(May 13 2021 at 19:39)</a>:</h4>
<p>How about we also kill <code>left_distrib</code> as a structure field and call it whichever one of <code>add_mul</code> and <code>mul_add</code> it was?</p>



<a name="238669791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669791">(May 13 2021 at 19:39)</a>:</h4>
<p>oh interesting, semirings aren't on the main path?</p>



<a name="238669810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669810">(May 13 2021 at 19:39)</a>:</h4>
<p>Who cares about semirings??</p>



<a name="238669827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669827">(May 13 2021 at 19:40)</a>:</h4>
<p><code>nat</code>...</p>



<a name="238669884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669884">(May 13 2021 at 19:40)</a>:</h4>
<p>seriously it's one of the most useful structures in lean</p>



<a name="238669943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669943">(May 13 2021 at 19:40)</a>:</h4>
<p>But nobody is doing arithmetic with it</p>



<a name="238669956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238669956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238669956">(May 13 2021 at 19:40)</a>:</h4>
<p>I did not put rings to semirings on the main path precisely for this reason, that there are fields that could be dropped. But I wonder if this is a good design decision: there will be reduction from rings to semirings everywhere in the linear algebra part of the library, so maybe it should better be direct.</p>



<a name="238670011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238670011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238670011">(May 13 2021 at 19:41)</a>:</h4>
<p>The question is which reductions will be seen most often in the library. These ones we should design to be direct.</p>



<a name="238670051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238670051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238670051">(May 13 2021 at 19:41)</a>:</h4>
<p>Oh! we could actually gather statistics on that</p>



<a name="238670264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238670264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238670264">(May 13 2021 at 19:43)</a>:</h4>
<p>If ring to add_comm_group is more frequent than ring to semiring, we should design the former to be direct, otherwise the latter. Well, maybe the criterion is not "more frequent" but "nontrivial to check definitionally", but that's harder to get statistics on.</p>



<a name="238671209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238671209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238671209">(May 13 2021 at 19:51)</a>:</h4>
<p>A related question: can we make it so that default priority when using <code>extends</code> is say, 200, while we would use a standard priority of 100 when defining instances that always apply (and 1000 for specific instances, as we currently do)? This would make sure that standard paths are followed most often, and should help check definitional equality.</p>



<a name="238676158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238676158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238676158">(May 13 2021 at 20:29)</a>:</h4>
<p>Ok so things are getting interesting. To prove <code>zero_mul</code> for <code>Ring</code>s I need to actually develop some group theory. Or perhaps I should call it <code>AddRightCancelSemigroup</code> theory. I need that a+b=b implies a=0 for an <code>AddCommGroup</code>, but in Lean 3 this is proved for <code>add_right_cancel_semigroup</code>s by reducing to <code>a+b=0+b</code> and then cancelling the <code>b</code>, which I can do in an add_group but which I can also do in this slightly more general cancellative object, which one can argue is important because nat, pnat, polynomials over a semiring, lists etc all satisfy this condition and none of them are add_groups. So does this mean that I should really add <code>AddRightCancelSemigroup</code> to my heirarchy? It's just an AddSemigroup with the property that <code>a + b = c + b -&gt; a = c</code>. If so then we have more decisions to make about what to extend or not extend etc.</p>
<p>The second interesting thing is that <code>with h</code> has now started to fail me. Here's a not particularly minimal working example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm">!</span>
<span class="cm"># Typeclasses for monoids and groups etc</span>
<span class="cm">-/</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">## Stuff which was in core Lean 3</span>
<span class="cm">-/</span>

<span class="kd">class</span> <span class="n">Zero</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">zero</span> <span class="o">:</span> <span class="n">α</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="mi">0</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">ofNat</span> <span class="o">:=</span> <span class="n">Zero.zero</span>

<span class="kd">class</span> <span class="n">One</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">one</span> <span class="o">:</span> <span class="n">α</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">One</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="mi">1</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">ofNat</span> <span class="o">:=</span> <span class="n">One.one</span>

<span class="kd">class</span> <span class="n">Inv</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">inv</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>

<span class="kd">postfix</span><span class="o">:</span><span class="n">max</span> <span class="s2">"⁻¹"</span> <span class="bp">=&gt;</span> <span class="n">Inv.inv</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">## The trick for adding a natural action onto monoids</span>
<span class="cm">-/</span>

<span class="kn">section</span> <span class="n">nat_action</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kd">notation</span> <span class="s2">"ℕ"</span> <span class="bp">=&gt;</span> <span class="n">Nat</span>

<span class="c1">-- see npow_rec comment for explanation about why not nsmul_rec n a + a</span>
<span class="sd">/-- The fundamental scalar multiplication in an additive monoid. `nsmul_rec n a = a+a+...+a` n</span>
<span class="sd">times. Use instead `n • a`, which has better definitional behavior. -/</span>
<span class="kd">def</span> <span class="n">nsmul_rec</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span>
<span class="bp">|</span> <span class="mi">0</span>  <span class="o">,</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">nsmul_rec</span> <span class="n">n</span> <span class="n">a</span>

<span class="c1">-- use `x * npow_rec n x` and not `npow_rec n x * x` in the definition to make sure that</span>
<span class="c1">-- definitional unfolding of `npow_rec` is blocked, to avoid deep recursion issues.</span>
<span class="sd">/-- The fundamental power operation in a monoid. `npow_rec n a = a*a*...*a` n times.</span>
<span class="sd">Use instead `a ^ n`,  which has better definitional behavior. -/</span>
<span class="kd">def</span> <span class="n">npow_rec</span> <span class="o">[</span><span class="n">One</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span>
<span class="bp">|</span> <span class="mi">0</span>  <span class="o">,</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">a</span>

<span class="kd">end</span> <span class="n">nat_action</span>

<span class="kn">section</span> <span class="n">int_action</span>

<span class="kd">notation</span> <span class="s2">"ℤ"</span> <span class="bp">=&gt;</span> <span class="n">Int</span>

<span class="sd">/-- The fundamental scalar multiplication in an additive group. `gsmul_rec n a = a+a+...+a` n</span>
<span class="sd">times, for integer `n`. Use instead `n • a`, which has better definitional behavior. -/</span>
<span class="kd">def</span> <span class="n">gsmul_rec</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">Neg</span> <span class="n">G</span><span class="o">]:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Int.ofNat</span> <span class="n">n</span><span class="o">)</span>  <span class="o">,</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">nsmul_rec</span> <span class="n">n</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Int.negSucc</span> <span class="n">n</span><span class="o">),</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="bp">-</span> <span class="o">(</span><span class="n">nsmul_rec</span> <span class="n">n.succ</span> <span class="n">a</span><span class="o">)</span>

<span class="sd">/-- The fundamental power operation in a group. `gpow_rec n a = a*a*...*a` n times, for integer `n`.</span>
<span class="sd">Use instead `a ^ n`,  which has better definitional behavior. -/</span>
<span class="kd">def</span> <span class="n">gpow_rec</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">One</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">Inv</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Int.ofNat</span> <span class="n">n</span><span class="o">)</span>  <span class="o">,</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Int.negSucc</span> <span class="n">n</span><span class="o">),</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">npow_rec</span> <span class="n">n.succ</span> <span class="n">a</span><span class="o">)</span> <span class="bp">⁻¹</span>

<span class="kd">end</span> <span class="n">int_action</span>

<span class="c">/-</span><span class="cm"></span>

<span class="cm"># Additive groups</span>

<span class="cm">-/</span>

<span class="kd">class</span> <span class="n">AddSemigroup</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">add_assoc</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">AddMonoid</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">AddSemigroup</span> <span class="n">A</span><span class="o">,</span> <span class="n">Zero</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">add_zero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span>
  <span class="n">zero_add</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
  <span class="n">nsmul</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">nsmul_rec</span>
  <span class="n">nsmul_zero'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">nsmul</span> <span class="mi">0</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="c1">-- fill in with tactic once we can do this</span>
  <span class="n">nsmul_succ'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span> <span class="n">nsmul</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">nsmul</span> <span class="n">n</span> <span class="n">x</span> <span class="c1">-- fill in with tactic</span>

<span class="kd">class</span> <span class="n">AddCommMonoid</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">AddMonoid</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">add_comm</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span>

<span class="kd">class</span> <span class="n">AddGroup</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">AddMonoid</span> <span class="n">A</span><span class="o">,</span> <span class="n">Neg</span> <span class="n">A</span><span class="o">,</span> <span class="n">Sub</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">add_left_neg</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="bp">-</span><span class="n">a</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span>
  <span class="n">sub_eq_add_neg</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">b</span>
  <span class="n">gsmul</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">gsmul_rec</span>
  <span class="n">gpow_zero'</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">gsmul</span> <span class="mi">0</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="c1">-- try rfl</span>
  <span class="n">gpow_succ'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">gsmul</span> <span class="o">(</span><span class="n">Int.ofNat</span> <span class="n">n.succ</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">gsmul</span> <span class="o">(</span><span class="n">Int.ofNat</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span>
  <span class="n">gpow_neg'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">gsmul</span> <span class="o">(</span><span class="n">Int.negSucc</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">-</span><span class="o">(</span><span class="n">gsmul</span> <span class="bp">↑</span><span class="o">(</span><span class="n">n.succ</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">AddCommGroup</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">AddGroup</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">add_comm</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">AddCommGroup</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">AddCommMonoid</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">h</span> <span class="k">with</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm"></span>

<span class="cm"># Multiplicative groups</span>

<span class="cm">-/</span>
<span class="kd">class</span> <span class="n">Semigroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Mul</span> <span class="n">G</span> <span class="n">where</span>
  <span class="n">mul_assoc</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Semigroup</span> <span class="n">M</span><span class="o">,</span> <span class="n">One</span> <span class="n">M</span> <span class="n">where</span>
  <span class="n">mul_one</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">m</span>
  <span class="n">one_mul</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span>
  <span class="n">npow</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">npow_rec</span>
  <span class="n">npow_zero'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">npow</span> <span class="mi">0</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="c1">-- fill in with tactic once we can do this</span>
  <span class="n">npow_succ'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span> <span class="n">npow</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">npow</span> <span class="n">n</span> <span class="n">x</span> <span class="c1">-- fill in with tactic</span>

<span class="c1">-- if anyone bothers to make CommSemigroup we need an instance</span>
<span class="c1">-- from CommMonoid to it, as we're no longer extending it</span>
<span class="kd">class</span> <span class="n">CommMonoid</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Monoid</span> <span class="n">M</span> <span class="n">where</span>
  <span class="n">mul_comm</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span>

<span class="kd">class</span> <span class="n">Group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Monoid</span> <span class="n">G</span><span class="o">,</span> <span class="n">Inv</span> <span class="n">G</span><span class="o">,</span> <span class="n">Div</span> <span class="n">G</span> <span class="n">where</span>
  <span class="n">mul_left_inv</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span>
  <span class="n">div_eq_mul_inv</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">⁻¹</span>
  <span class="n">gpow</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">gpow_rec</span>
  <span class="n">gpow_zero'</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">gpow</span> <span class="mi">0</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span> <span class="c1">-- try rfl</span>
  <span class="n">gpow_succ'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">gpow</span> <span class="o">(</span><span class="n">Int.ofNat</span> <span class="n">n.succ</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">gpow</span> <span class="o">(</span><span class="n">Int.ofNat</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span>
  <span class="n">gpow_neg'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">gpow</span> <span class="o">(</span><span class="n">Int.negSucc</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">gpow</span> <span class="bp">↑</span><span class="o">(</span><span class="n">n.succ</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span><span class="bp">⁻¹</span>

<span class="kd">class</span> <span class="n">CommGroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Group</span> <span class="n">G</span> <span class="n">where</span>
  <span class="n">mul_comm</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">CommGroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">CommMonoid</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">h</span> <span class="k">with</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm"></span>

<span class="cm">## Rings</span>

<span class="cm">-/</span>

<span class="kd">class</span> <span class="n">Semiring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Monoid</span> <span class="n">R</span><span class="o">,</span> <span class="n">AddCommMonoid</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">zero_mul</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span>
  <span class="n">mul_zero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span>
  <span class="n">mul_add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span>
  <span class="n">add_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span>

<span class="kd">class</span> <span class="n">CommSemiring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Semiring</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">mul_comm</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">CommSemiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">CommMonoid</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">h</span> <span class="k">with</span> <span class="o">}</span>

<span class="kd">class</span> <span class="n">Ring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Monoid</span> <span class="n">R</span><span class="o">,</span> <span class="n">AddCommGroup</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">mul_add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span>
  <span class="n">add_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">Ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">Semiring</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">h</span> <span class="k">with</span>
  <span class="n">zero_mul</span> <span class="o">:=</span> <span class="gr">sorry</span>
  <span class="n">mul_zero</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="o">}</span>
</code></pre></div>
<p>The error is</p>
<div class="codehilite" data-code-language="Bash"><pre><span></span><code>invalid field <span class="s1">'toAddCommMonoid'</span>, the environment does not contain <span class="s1">'Ring.toAddCommMonoid'</span>
  h
has <span class="nb">type</span>
  Ring R
</code></pre></div>
<p>repeated 9 times for some reason. This seems to be an issue with new structures which we'll have to think about. Note that <code>h with</code> has been working like a dream up until now, but now I've hit this error I've realised that in some sense this might have been a coincidence.</p>



<a name="238677588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238677588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238677588">(May 13 2021 at 20:39)</a>:</h4>
<p>I know what the error is saying. This is something that lean 3 would handle transparently, but if you think about it for a bit you will realize it's doing some magic. As I mentioned, a new structure contains fields like <code>B.toA</code> instead of <code>B.fieldA</code> for every field in <code>A</code>. But what if, in a structure instance using <code>..s</code>, you have in <code>s</code> every field in <code>A</code> but not a field called <code>toA</code>? In lean 3 it would try either one, with preference for a <code>toA</code> field and falling back on <code>toA := { ..s }</code> where now the splat is looking for A's fields instead of B's.</p>



<a name="238677835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238677835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238677835">(May 13 2021 at 20:41)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">B</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">C</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">B</span> <span class="o">:=</span> <span class="o">{</span><span class="bp">..</span><span class="n">s</span><span class="o">}</span>
<span class="k">#print</span> <span class="n">foo</span>

<span class="c1">-- def foo : C → B :=</span>
<span class="c1">-- λ (s : C), {to_A := {a := s.a, b := s.b}, c := s.c}</span>
</code></pre></div>



<a name="238677862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238677862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238677862">(May 13 2021 at 20:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238676158">said</a>:</p>
<blockquote>
<p>Ok so things are getting interesting. To prove <code>zero_mul</code> for <code>Ring</code>s I need to actually develop some group theory. Or perhaps I should call it <code>AddRightCancelSemigroup</code> theory. I need that a+b=b implies a=0 for an <code>AddCommGroup</code>, but in Lean 3 this is proved for <code>add_right_cancel_semigroup</code>s by reducing to <code>a+b=0+b</code> and then cancelling the <code>b</code>, which I can do in an add_group but which I can also do in this slightly more general cancellative object, which one can argue is important because nat, pnat, polynomials over a semiring, lists etc all satisfy this condition and none of them are add_groups. So does this mean that I should really add <code>AddRightCancelSemigroup</code> to my heirarchy? It's just an AddSemigroup with the property that <code>a + b = c + b -&gt; a = c</code>. If so then we have more decisions to make about what to extend or not extend etc.</p>
</blockquote>
<p>You can do it as follows: define a mixin <code>AddRightCancel</code> on an <code>AddSemigroup</code>, prove the lemmas you like using this, and then declare an instance from <code>AddGroup</code> to <code>AddRightCancel</code>. Then you don't need to extend your main hierarchy, but still you can state and prove your lemmas in the maximal generality.</p>



<a name="238678102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238678102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238678102">(May 13 2021 at 20:43)</a>:</h4>
<p>actually I lied about preference for <code>to_A</code>, since this doesn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">B</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">D</span> <span class="o">:=</span> <span class="o">(</span><span class="n">to_A</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span> <span class="n">B</span> <span class="o">:=</span> <span class="o">{</span><span class="bp">..</span><span class="n">s</span><span class="o">}</span> <span class="c1">-- fail, a b not provided</span>
</code></pre></div>



<a name="238678193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238678193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238678193">(May 13 2021 at 20:44)</a>:</h4>
<p>As for your <code>with h</code> error, I think this is precisely the kind of datapoint the Lean 4 devs are interested in. If you can minimize and then register an issue (or mention it in the main Lean 4 thread), this would be extremely helpful.</p>



<a name="238678271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238678271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238678271">(May 13 2021 at 20:44)</a>:</h4>
<p>A mixin is like <code>distrib</code>? <code>AddRightCancel A</code> would just extend <code>Add A</code> with the one axiom, right?</p>



<a name="238678391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238678391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238678391">(May 13 2021 at 20:45)</a>:</h4>
<p>Here's a version of the MWE for lean 4:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">B</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">C</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">D</span> <span class="o">:=</span> <span class="o">(</span><span class="n">toA</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">B</span> <span class="o">:=</span> <span class="o">{</span><span class="n">s</span> <span class="k">with</span><span class="o">}</span> <span class="c1">-- fails in lean 4, works in lean 3</span>
<span class="kd">def</span> <span class="n">bar</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span> <span class="n">B</span> <span class="o">:=</span> <span class="o">{</span><span class="n">s</span> <span class="k">with</span><span class="o">}</span> <span class="c1">-- works in lean 4, fails in lean 3</span>
</code></pre></div>



<a name="238678509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238678509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238678509">(May 13 2021 at 20:46)</a>:</h4>
<p>Thanks Mario, indeed thanks to both of you. I need to stop working on this now. I'll make a PR to mathlib4 (let me know if I should be doing something else) and will come back to this next Thursday.</p>



<a name="238678579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238678579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238678579">(May 13 2021 at 20:47)</a>:</h4>
<p>You mentioned <code>Data.Set.Basic</code>, please PR that if you have a file ready</p>



<a name="238678621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238678621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238678621">(May 13 2021 at 20:47)</a>:</h4>
<p>plus this stuff of course</p>



<a name="238678678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238678678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238678678">(May 13 2021 at 20:47)</a>:</h4>
<p>can we do <a href="https://github.com/leanprover-community/mathlib4/issues/4">mathlib4#4</a> ? Edit: yes!</p>



<a name="238679082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238679082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238679082">(May 13 2021 at 20:50)</a>:</h4>
<p>Re Data.Set.Basic: I have <a href="https://github.com/kbuzzard/lean4-filters/blob/master/Lean4_filters/Set/Basic.lean">https://github.com/kbuzzard/lean4-filters/blob/master/Lean4_filters/Set/Basic.lean</a> and <a href="https://github.com/kbuzzard/lean4-filters/blob/master/Lean4_filters/Set/CompleteLattice.lean">https://github.com/kbuzzard/lean4-filters/blob/master/Lean4_filters/Set/CompleteLattice.lean</a> (Set X is a complete lattice) but I didn't attempt to golf proofs, I was thinking about how to teach them rather than how to golf them.</p>



<a name="238680706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238680706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238680706">(May 13 2021 at 21:02)</a>:</h4>
<p>I also did not think about what went where, in contrast to the PR I just made, where every definition made in the PR is in the right file.</p>



<a name="238681701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238681701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238681701">(May 13 2021 at 21:09)</a>:</h4>
<p>Floris has just popped up on the discord and suggested a workaround for the ring to semiring instance -- we now have it running in the PR.</p>



<a name="238685440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238685440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238685440">(May 13 2021 at 21:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238678391">said</a>:</p>
<blockquote>
<p>Here's a version of the MWE for lean 4:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">B</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">C</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">D</span> <span class="o">:=</span> <span class="o">(</span><span class="n">toA</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">B</span> <span class="o">:=</span> <span class="o">{</span><span class="n">s</span> <span class="k">with</span><span class="o">}</span> <span class="c1">-- fails in lean 4, works in lean 3</span>
<span class="kd">def</span> <span class="n">bar</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span> <span class="n">B</span> <span class="o">:=</span> <span class="o">{</span><span class="n">s</span> <span class="k">with</span><span class="o">}</span> <span class="c1">-- works in lean 4, fails in lean 3</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Mario are you going to open this as an issue? You know more about what you're talking about than I do.</p>



<a name="238686042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238686042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238686042">(May 13 2021 at 21:47)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/issues/463">leanprover/lean4#463</a></p>



<a name="238692428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238692428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238692428">(May 13 2021 at 22:46)</a>:</h4>
<p>Thanks. I will now work on those two sorries which I just accidentally PR'ed to mathlib4 in return :-)</p>



<a name="238694075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238694075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238694075">(May 13 2021 at 23:03)</a>:</h4>
<p>I don't understand which one is being suggested:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">IsAddRightCancel</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">add_right_cancel</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span>

<span class="kd">class</span> <span class="n">IsAddRightCancel'</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="n">add_right_cancel</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span>
</code></pre></div>



<a name="238694823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238694823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238694823">(May 13 2021 at 23:11)</a>:</h4>
<p>I think when sebastien says mixin he means <code>IsAddRightCancel'</code></p>



<a name="238694925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238694925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238694925">(May 13 2021 at 23:12)</a>:</h4>
<p>mixins in the first sense work better with old structures</p>



<a name="238694938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238694938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238694938">(May 13 2021 at 23:12)</a>:</h4>
<p>but the lack of diamonds means you can't actually mix them in with new structures</p>



<a name="238696141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238696141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238696141">(May 13 2021 at 23:27)</a>:</h4>
<p>Aah I see my mistake now. I had assumed it was the second one but then I looked at distrib and it was the first one, but that's because old_structures. I'll remove those sorrys in my PR tomorrow</p>



<a name="238700880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238700880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238700880">(May 14 2021 at 00:28)</a>:</h4>
<p>I'm wondering: if the old mathlib hierarchy is going to be altered in the port, why not change it to something like what <span class="user-mention" data-user-id="306601">@Kyle Miller</span>  suggested in the <code>to_addtive</code> thread here: <a href="#narrow/stream/270676-lean4/topic/to_additive/near/223422846">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/223422846</a>. People seemed quite happy with it at the time.</p>



<a name="238701063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238701063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238701063">(May 14 2021 at 00:31)</a>:</h4>
<p>It's more dynamic and flexible and removes many of the inheritance headaches being discussed.</p>



<a name="238702212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238702212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238702212">(May 14 2021 at 00:47)</a>:</h4>
<p>I think making <code>Ring.mk</code> et al. instances is a big mistake. This makes all the problems of exploding instances inside defeq problems in old structures return while doing typeclass search: while proving <code>Nonempty Nat</code> we're going to try <code>Ring Nat</code> and from there apply <code>Ring.mk ...</code> and explore <code>Distrib Nat</code> and a bunch of other useless things</p>



<a name="238702425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238702425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238702425">(May 14 2021 at 00:50)</a>:</h4>
<p>I don't think the goal right now should be to fundamentally refactor the algebraic hierarchy; we're trying to avoid doing too many refactors at once. Instead we want something which will make porting simple but also works with the lean 4 way</p>



<a name="238717331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238717331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Kiniry <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238717331">(May 14 2021 at 04:28)</a>:</h4>
<p>Meaning, to model subtyping of structures using mixins like the hierarchy of algebraic concepts discussed earlier.</p>



<a name="238789547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238789547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238789547">(May 14 2021 at 16:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238702212">said</a>:</p>
<blockquote>
<p>I think making <code>Ring.mk</code> et al. instances is a big mistake. This makes all the problems of exploding instances inside defeq problems in old structures return while doing typeclass search</p>
</blockquote>
<p>From what I understood in that thread, it seemed to imply that that was no longer a problem with the new typeclass search based on what <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> stated in there. Also, the runtime analysis <span class="user-mention" data-user-id="306601">@Kyle Miller</span> did showed no exponential blow-up. However, someone more experience than me with the inner working of Lean will probably need to chime in to verify this.</p>



<a name="238790473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238790473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238790473">(May 14 2021 at 16:10)</a>:</h4>
<p>It's not an exponential blowup, but it is still a x30 blowup or however many fields there are in the big structures</p>



<a name="238791803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238791803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238791803">(May 14 2021 at 16:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238790473">said</a>:</p>
<blockquote>
<p>It's not an exponential blowup, but it is still a x30 blowup or however many fields there are in the big structures</p>
</blockquote>
<p>Are you sure that is true for simple things like <code>Nonempty</code>? My understanding is that new typeclass search is breadth focused and avoids deep paths . So if there is a faster (i.e., less deep) path to <code>Nonempty</code> than synthesizing a <code>Ring</code>, it will take that.</p>



<a name="238793491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238793491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238793491">(May 14 2021 at 16:31)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> FYI TC is depth-first.</p>



<a name="238799575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238799575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238799575">(May 14 2021 at 17:16)</a>:</h4>
<p><code>nonempty nat</code> seems irrelevant here, it's found very quickly thanks to the priority on <a href="https://leanprover-community.github.io/mathlib_docs/find/nonempty_of_inhabited">docs#nonempty_of_inhabited</a></p>



<a name="238806477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238806477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238806477">(May 14 2021 at 18:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238793491">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> FYI TC is depth-first.</p>
</blockquote>
<p>Oh! My bad! I assumed it was breath focused because of how it avoids cycles. Is there a write-up of the approach anywhere (e.g., a paper)?</p>



<a name="238806701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238806701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238806701">(May 14 2021 at 18:06)</a>:</h4>
<p>yes, <a href="https://arxiv.org/abs/2001.04301">Tabled Typeclass Resolution</a> (by Daniel et al)</p>



<a name="238809158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238809158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238809158">(May 14 2021 at 18:23)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> I should clarify: the decision points are processed depth-first, i.e. using stacks, but as you point out, this does not correspond to DFS in the naive sense because of the tabling.</p>



<a name="238810127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238810127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238810127">(May 14 2021 at 18:31)</a>:</h4>
<p>Do we want <code>CommSemigroup</code>? Is the answer to this something dumb like "<code>pnat</code> is an AddCommSemigroup and not an AddCommMonoid therefore we need AddCommSemigroup therefore we need CommSemigroup"? If so, it needs to be inserted into the table of Sebastien's which I was following (see <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238443841">his earlier post</a>). If so, we have to decide whether AddCommMonoid extends AddMonoid or AddCommSemigroup. Note that right now AddCommGroup extends AddGroup and there's an instance to AddCommMonoid.</p>



<a name="238810449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238810449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238810449">(May 14 2021 at 18:33)</a>:</h4>
<p>I think AddMonoid would be better and CommSemigroup can be off the main path if we need it at all</p>



<a name="238810955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238810955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238810955">(May 14 2021 at 18:37)</a>:</h4>
<p>I only ran into it because <code>mul_left_comm</code> and <code>mul_right_comm</code> are theorems about commutative semigroups.</p>



<a name="238814136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238814136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238814136">(May 14 2021 at 19:03)</a>:</h4>
<p>I agree with Mario that it is better to extend <code>AddMonoid</code>. My reasoning is the following: there are some classes in which one is adding new data, but let's make as few of them as possible. Here, if you extended <code>CommSemiGroup</code>, you would need to add <code>one</code>, while you can avoid this by going the other direction, so let's go in the other direction.</p>



<a name="238814606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238814606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238814606">(May 14 2021 at 19:06)</a>:</h4>
<p>Aah, this is a nice rule of thumb!</p>



<a name="238818112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238818112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238818112">(May 14 2021 at 19:34)</a>:</h4>
<p>I have a feeling that this will help Lean check defeqness down the road, because checking defeqness of data is more difficult than checking defeqness of Props: if the data always comes from the same place, there shouldn't be any difficulty to check it is the same, without needing further unfolding. It's just a feeling, though, not based on any objective numbers.</p>



<a name="238820737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238820737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238820737">(May 14 2021 at 19:54)</a>:</h4>
<p>Thanks to all your help, I've just updated <a href="https://github.com/leanprover-community/mathlib4/issues/4">mathlib4#4</a> to include everything in your suggested algebra hierarchy.</p>



<a name="238856185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238856185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238856185">(May 15 2021 at 01:26)</a>:</h4>
<p>What is the bigger plan here? Are we thinking to backport this proposed new algebra hierarchy to mathlib3, if we see that it works out well in lean4? Are we planning on just discarding it when it comes time to execute the <code>mathport</code> plan?</p>



<a name="238856237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238856237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238856237">(May 15 2021 at 01:27)</a>:</h4>
<p>I think the port should be manually or automatically merged with the stuff in mathlib4 so far</p>



<a name="238856303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238856303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238856303">(May 15 2021 at 01:28)</a>:</h4>
<p>As long as the hierarchies are similar enough that we can 1-1 map things this shouldn't be a problem given the likely level of human intervention in the port</p>



<a name="238856423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238856423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238856423">(May 15 2021 at 01:30)</a>:</h4>
<p>While backporting is possible I don't see it as necessary or all that helpful. We still have the same classes and the same instances</p>



<a name="238856448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238856448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238856448">(May 15 2021 at 01:31)</a>:</h4>
<p>new vs old structures is an implementation detail that will need to be navigated in the hand tuning part of the port</p>



<a name="238858288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238858288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238858288">(May 15 2021 at 01:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238856185">said</a>:</p>
<blockquote>
<p>the <code>mathport</code> plan?</p>
</blockquote>
<p>The original <code>mathport</code> plan (i.e. lean3 <code>.tlean</code> -&gt; lean4 <code>.olean</code>) is still on the table but the tentative frontrunner seems to be porting syntax directly (see <a href="#narrow/stream/270676-lean4/topic/Mathlib.204.20source.20files">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mathlib.204.20source.20files</a>). There are many potential advantages to this approach, including the fact that it is much more robust to imperfect (i.e. non-defeq) alignments. So, small refactors that more-or-less preserve syntax-level alignments might be feasible to perform during the port without needing to backport them.</p>



<a name="238861158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238861158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238861158">(May 15 2021 at 02:43)</a>:</h4>
<p>The algebra hierarchy change being discussed above sounds far from small...!</p>



<a name="238861386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238861386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238861386">(May 15 2021 at 02:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238861158">said</a>:</p>
<blockquote>
<p>The algebra hierarchy change being discussed above sounds far from small...!</p>
</blockquote>
<p>I merely meant to clarify that "small" would be acceptable in the new plan, in contrast to the old one that would require "zero". I would need to think more about whether this particular proposal was "small" enough.</p>



<a name="238861468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238861468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238861468">(May 15 2021 at 02:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/238861158">said</a>:</p>
<blockquote>
<p>The algebra hierarchy change being discussed above sounds far from small...!</p>
</blockquote>
<p>What specifically looks less than small? The only thing of note seems to be that <code>Distrib</code> is gone</p>



<a name="238861880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238861880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238861880">(May 15 2021 at 02:56)</a>:</h4>
<p>I guess just that everytime we have inserted some additional typeclass in the middle of the hierarchy in mathib, there's been a bunch of unexpected places where lemmas don't quite work any more, or inference has changed, or some defeq thing changes... So doing bulk changes to who extends who seems sure to create problems all over the place. I'm just a little terrified that we're making these changes without any way of verifying that we're not creating some incompatibility with mathlib, and we won't know until much later.</p>



<a name="238862063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238862063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238862063">(May 15 2021 at 03:00)</a>:</h4>
<p>What is the argument against making these changes in mathlib first? It seems much safer to have the assurance of "and the rest of mathlib still works".</p>



<a name="238867368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238867368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238867368">(May 15 2021 at 04:28)</a>:</h4>
<p>yes, it is probably going to cause small problems all over the place. These problems will not be distinguishable from all the other small problems all over the place because of lean 4</p>



<a name="238867388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238867388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238867388">(May 15 2021 at 04:29)</a>:</h4>
<p>However, we will get a feel for it once we start the real port. If it becomes too onerous we can change the representation as needed</p>



<a name="238867473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238867473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238867473">(May 15 2021 at 04:30)</a>:</h4>
<p>making the changes in mathlib doesn't guarantee that the port will go any smoother</p>



<a name="238867507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238867507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238867507">(May 15 2021 at 04:31)</a>:</h4>
<p>also typeclass inference is different in lean 4 so we will get different solutions in places which will also produce lots of small incompatibilities anyway</p>



<a name="238880267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238880267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238880267">(May 15 2021 at 08:25)</a>:</h4>
<p>Will <code>non_unital_non_assoc_semiring</code> make <code>distrib</code> useless in mathlib 3? Are there any objects that are distributive but have no zero?</p>



<a name="238883530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238883530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238883530">(May 15 2021 at 09:24)</a>:</h4>
<p>Finsets of an infinite set with intersection as addition and union and multiplication?  I may be wrong, since I find the semirings with interchangeable add and mul very confusing!</p>



<a name="238904906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238904906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238904906">(May 15 2021 at 15:16)</a>:</h4>
<p>I just realized that I messed up something in my sketched hierarchy. In Kevin's implementation, there are two classes that implement <code>gpow</code> (<code>group</code> and <code>group_with_zero</code>), and this is bad because it means we can not define an integer power operation in a uniform way. Instead, we need a basic class that implements <code>gpow</code>, that would be extended both by <code>group</code> and <code>group_with_zero</code>. This class, which I forgot in my plan, is <code>div_inv_monoid</code>, and should be implemented as an extension of <code>monoid</code> and should be extended both by <code>group</code> and <code>group_with_zero</code>. In the same way, I forgot <code>sub_neg_monoid</code>, which plays the same role in the additive hierarchy.</p>
<p>I can try to fix that myself (but I'll need to find how to install and use Lean 4 first), or let <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  do it, as you prefer. Sorry for the mess!</p>



<a name="238905498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238905498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238905498">(May 15 2021 at 15:27)</a>:</h4>
<p>Also, a reminder that for lean 4 normNum to work, we need a class containing <code>ofNat</code> to be introduced somewhere around semirings (we need at least 0, 1, +). Currently there is a displaced definition of <code>Semiring</code> in the <code>NormNum</code> file</p>



<a name="238906424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/238906424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#238906424">(May 15 2021 at 15:43)</a>:</h4>
<p>Oh nice! I will not work on this until next Lean 4 Thursday, ie next Thursday. It might be worth putting together a list of the other classes which I didn't implement too</p>



<a name="239653394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239653394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239653394">(May 20 2021 at 20:21)</a>:</h4>
<p>So I've added a definition of <code>Set</code> and added notation <code>{a | p a}</code> and <code>{a : A | p a}</code> and <code>{a \in s | p a}</code>; I'll push later. I'm now onto this <code>div_inv_monoid</code> business and there's something I don't understand: in Lean 4 I guess <code>div_inv_monoid</code> should extend <code>monoid</code> but what I am confused about is whether it should extend <code>has_sub</code> and/or <code>has_neg</code>. I initially thought this would be a no-brainer, but in Lean 3 we have a default <code>sub</code>, namely <code>add_neg</code>, and I don't know if I can do this in Lean 4; would it hence be better not to extend <code>sub</code>??</p>



<a name="239653517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239653517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239653517">(May 20 2021 at 20:22)</a>:</h4>
<p>Lean 3:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">sub_neg_monoid</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">add_monoid</span> <span class="n">G</span><span class="o">,</span> <span class="n">has_neg</span> <span class="n">G</span><span class="o">,</span> <span class="n">has_sub</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">sub</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">b</span><span class="o">)</span>
<span class="bp">...</span>
</code></pre></div>
<p>What does that code even mean? We're extending <code>has_sub</code> but also supplying a default value?</p>



<a name="239653562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239653562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239653562">(May 20 2021 at 20:22)</a>:</h4>
<p>I think it should definitely extend <code>sub</code> or <code>div</code>.</p>



<a name="239653613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239653613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239653613">(May 20 2021 at 20:23)</a>:</h4>
<p>This code means : the <code>sub</code> field is provided by <code>has_sub G</code>, but we are providing here a default value for it.</p>



<a name="239653639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239653639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239653639">(May 20 2021 at 20:23)</a>:</h4>
<p>And yes, it's weird, but it works :-)</p>



<a name="239653776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239653776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239653776">(May 20 2021 at 20:24)</a>:</h4>
<p>For now, I think it doesn't work in Lean 4. So we should just do it by hand, and maybe we'll add the default parameter later, when it works.</p>



<a name="239653787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239653787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239653787">(May 20 2021 at 20:24)</a>:</h4>
<p>I've just checked and you're right, it does work in Lean 3!</p>



<a name="239653807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239653807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239653807">(May 20 2021 at 20:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">has_neg</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">sub_neg_monoid</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">nsmul</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">nsmul_zero'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">nsmul_succ'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
<span class="c1">--  sub := _,</span>
<span class="c1">--  sub_eq_add_neg := _,</span>
  <span class="n">gsmul</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">gsmul_zero'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">gsmul_succ'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">gsmul_neg'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="bp">..</span><span class="o">‹</span><span class="n">add_monoid</span> <span class="n">G</span><span class="o">›,</span>
  <span class="bp">..</span><span class="o">‹</span><span class="n">has_neg</span> <span class="n">G</span><span class="o">›</span>
   <span class="o">}</span>
</code></pre></div>



<a name="239653889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239653889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239653889">(May 20 2021 at 20:25)</a>:</h4>
<p><code>sub_neg_monoid</code> extends <code>[has_sub G]</code> but <code>G</code> doesn't have a <code>sub</code> and it compiles anyway.</p>



<a name="239653894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239653894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239653894">(May 20 2021 at 20:25)</a>:</h4>
<p>Normally, you shouldn't need to provide <code>nsmul</code> and <code>gsmul</code> either, because they also have default values.</p>



<a name="239653911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239653911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239653911">(May 20 2021 at 20:25)</a>:</h4>
<p>Yeah I find the syntax a bit confusing, although I don't have a significantly better suggestion</p>



<a name="239653930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239653930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239653930">(May 20 2021 at 20:25)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">has_neg</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">sub_neg_monoid</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span>
<span class="c1">--  sub := _,</span>
<span class="c1">--  sub_eq_add_neg := _,</span>
  <span class="bp">..</span><span class="o">‹</span><span class="n">add_monoid</span> <span class="n">G</span><span class="o">›,</span>
  <span class="bp">..</span><span class="o">‹</span><span class="n">has_neg</span> <span class="n">G</span><span class="o">›</span>
<span class="o">}</span>
</code></pre></div>



<a name="239654098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654098">(May 20 2021 at 20:27)</a>:</h4>
<p>By the way did you see what happened to the issues you two opened last week? :-(</p>



<a name="239654137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654137">(May 20 2021 at 20:27)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/issues/461">leanprover/lean4#461</a> says it doesn't work currently. Since it has been opened by Daniel maybe it will be fixed by the Lean core dev.</p>



<a name="239654156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654156">(May 20 2021 at 20:27)</a>:</h4>
<p>Perhaps this should be filed as a feature request?</p>



<a name="239654239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654239">(May 20 2021 at 20:28)</a>:</h4>
<p>For the other issues, I read it as: "we have much higher priorities. Do it in mathlib4 if you like."</p>



<a name="239654255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654255">(May 20 2021 at 20:28)</a>:</h4>
<p>oh I see autoparams don't exist at all</p>



<a name="239654341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654341">(May 20 2021 at 20:29)</a>:</h4>
<p>I was talking more specifically about opt/autoparam overloading of superclass fields</p>



<a name="239654370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654370">(May 20 2021 at 20:29)</a>:</h4>
<p>If the API is open enough that we can implement that on our side, I am perfectly fine with this.</p>



<a name="239654536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654536">(May 20 2021 at 20:30)</a>:</h4>
<p>which issues are you referring to <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> ?</p>



<a name="239654620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654620">(May 20 2021 at 20:31)</a>:</h4>
<p>Issues 462 and 463. (I don't know how to link to them).</p>



<a name="239654673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654673">(May 20 2021 at 20:31)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/issues/462">leanprover/lean4#462</a>, <a href="https://github.com/leanprover/lean4/issues/463">leanprover/lean4#463</a></p>



<a name="239654680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654680">(May 20 2021 at 20:31)</a>:</h4>
<p>They were flagged by Leo as "no plans to address. PR not welcome"</p>



<a name="239654681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654681">(May 20 2021 at 20:31)</a>:</h4>
<p>Great, this works in Lean 4:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">SubNegMonoid</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">AddMonoid</span> <span class="n">G</span><span class="o">,</span> <span class="n">Neg</span> <span class="n">G</span><span class="o">,</span> <span class="n">Sub</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">sub</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">a</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">sub_eq_add_neg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">gsmul</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">gsmul_rec</span><span class="o">)</span>
<span class="o">(</span><span class="n">gsmul_zero'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">gsmul</span> <span class="mi">0</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">gpow_succ'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">gsmul</span> <span class="o">(</span><span class="n">Int.ofNat</span> <span class="n">n.succ</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">gsmul</span> <span class="o">(</span><span class="n">Int.ofNat</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">gpow_neg'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">gsmul</span> <span class="o">(</span><span class="n">Int.negSucc</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">-</span><span class="o">(</span><span class="n">gsmul</span> <span class="bp">↑</span><span class="o">(</span><span class="n">n.succ</span><span class="o">)</span> <span class="n">a</span><span class="o">))</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">h1</span> <span class="o">:</span> <span class="n">AddMonoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">h2</span> <span class="o">:</span> <span class="n">Neg</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">SubNegMonoid</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">sub_eq_add_neg</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">gsmul_zero'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">gpow_succ'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">gpow_neg'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>



<a name="239654846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654846">(May 20 2021 at 20:32)</a>:</h4>
<p>I have to sorry the four fields which would be proved by one of these <code>statement . tactic_which_might_prove_it</code> tricks in Lean 3</p>



<a name="239654886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239654886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239654886">(May 20 2021 at 20:32)</a>:</h4>
<p>Then I am confused by <a href="https://github.com/leanprover/lean4/issues/461">leanprover/lean4#461</a>, which says that this doesn't work.</p>



<a name="239655247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239655247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239655247">(May 20 2021 at 20:34)</a>:</h4>
<p>On the other hand, I am not confused, because it seems to me that I can extend both <code>sub</code> and <code>neg</code> in a <code>sub_neg_monoid</code> even with new structures.</p>



<a name="239655331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239655331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239655331">(May 20 2021 at 20:35)</a>:</h4>
<p>(I mean, of course I'm confused by all the issues, but this is not something I'm trying to understand, I'm having too much fun making mathlib from scratch)</p>



<a name="239690326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239690326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239690326">(May 21 2021 at 03:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F/near/239654886">said</a>:</p>
<blockquote>
<p>Then I am confused by <a href="https://github.com/leanprover/lean4/issues/461">leanprover/lean4#461</a>, which says that this doesn't work.</p>
</blockquote>
<p>Providing defaults works fine in Lean 4 (the Lean source makes heavy use of it itself). The problem is when using providing proofs the proofs have to be true when the default is defined, they can't be conditional true. In the example <code>FooD</code> will fill in <code>h</code> at <em>use time</em>dynamically <em>when and if</em><code>x</code> and <code>y</code> are provided and equality can be provided by <code>rfl</code>. In a structure, however, <code>by rfl</code> would only work as a default if <code>x = y</code> was provable at <em>definition time</em> by <code>rfl</code> (instead of at <em>construction/use time</em>).</p>



<a name="239690416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239690416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239690416">(May 21 2021 at 03:10)</a>:</h4>
<p>At least, that is my understanding.</p>



<a name="239724554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239724554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239724554">(May 21 2021 at 09:54)</a>:</h4>
<p>It looks to me like that issue is confusing <code>auto_param</code> (run a tactic at instantiation time) and <code>opt_param</code> (produce a term at definition time). Isn't <code>:= by ...</code> in lean 4 an <code>opt_param</code> like it is in lean 3?</p>



<a name="239724875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239724875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239724875">(May 21 2021 at 09:57)</a>:</h4>
<p>It is not. We hoped this new syntax would be much more natural than the Lean 3 one.</p>



<a name="239725835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239725835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239725835">(May 21 2021 at 10:04)</a>:</h4>
<p>I think the only issue is that <code>:= by tactic</code> doesn't work in structures yet.  <span class="user-mention" data-user-id="310045">@Eric Wieser</span> did I miss anything?</p>



<a name="239726963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239726963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239726963">(May 21 2021 at 10:14)</a>:</h4>
<p>What's the syntax for populating an <code>opt_param</code> with a tactic then, if <code> := by {}</code> is now syntac for <code>auto_param</code>?</p>



<a name="239727673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239727673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239727673">(May 21 2021 at 10:21)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>
<span class="kn">open</span> <span class="n">Lean</span>

<span class="kn">open</span> <span class="n">Elab.Term</span> <span class="k">in</span>
<span class="n">elab</span> <span class="s2">"notATactic"</span> <span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">&lt;=</span> <span class="n">expectedType</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="n">elabTerm</span> <span class="n">t</span> <span class="n">expectedType</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">notATactic</span> <span class="kd">by</span> <span class="n">exact</span> <span class="mi">42</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">n</span>

<span class="k">#print</span> <span class="n">foo</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">def foo : optParam Nat 42 → Nat :=</span>
<span class="cm">fun (n : optParam Nat 42) =&gt; n</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="239727713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239727713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239727713">(May 21 2021 at 10:21)</a>:</h4>
<p>Feel free to color the bikeshed according to your preferences.</p>



<a name="239727847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239727847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239727847">(May 21 2021 at 10:23)</a>:</h4>
<p>Apparently this works as well:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="o">(</span><span class="kd">by</span> <span class="n">exact</span> <span class="mi">42</span><span class="o">))</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">n</span>

<span class="k">#print</span> <span class="n">foo</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">def foo : optParam Nat 42 → Nat :=</span>
<span class="cm">fun (n : optParam Nat 42) =&gt; n</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="239727911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239727911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239727911">(May 21 2021 at 10:23)</a>:</h4>
<p>I'm afraid to ask, but is there an actual use case for that? Hopefully not if the field is a proposition, at least?</p>



<a name="239728020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239728020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239728020">(May 21 2021 at 10:24)</a>:</h4>
<p>This is pretty important if you want to default parent fields in a structure, and definitely if the field is a prop.</p>



<a name="239728257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239728257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239728257">(May 21 2021 at 10:26)</a>:</h4>
<p>Ahh, those darn parent field overrides...</p>



<a name="239729440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239729440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239729440">(May 21 2021 at 10:38)</a>:</h4>
<p>IMO the fact that <code>:= (by exact x)</code> and <code>:= (x)</code> mean the same thing but <code>:= by exact x</code> and <code>:= x</code> do not is quite surprising. Is it worth coming up with a most distinct syntax? <code>.= x</code>? <code>:= auto x</code>?</p>



<a name="239729722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239729722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239729722">(May 21 2021 at 10:41)</a>:</h4>
<p>(or is this too lean3 a way of thinking about <code>by</code>?)</p>



<a name="239732854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239732854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239732854">(May 21 2021 at 11:10)</a>:</h4>
<p>There's a lot of places in Lean 4 where parentheses now make a semantic difference (e.g. in do-notation).  I'm perfectly happy with seeing <code>... := by ...</code> as a new compound syntax.</p>



<a name="239735537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239735537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239735537">(May 21 2021 at 11:36)</a>:</h4>
<p>Another fun trick with macros and auto params: by default, auto params are elaborated as tactics, and tactics get elaborated last.  That means projection notation will not work on terms created by tactics.  While I think that this should maybe be fixed in the elaborator, you can work around this yourself:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>
<span class="kn">open</span> <span class="n">Lean</span>

<span class="n">syntax</span> <span class="s2">"now"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">tactic</span>
<span class="n">macro_rules</span> <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="kd">by</span> <span class="n">now</span> <span class="bp">$</span><span class="n">term</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">term</span>

<span class="c1">-- the tactic terms created for auto params are strange</span>
<span class="n">macro_rules</span> <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="kd">by</span> <span class="bp">$</span><span class="n">term</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">if</span> <span class="n">term.getKind</span> <span class="bp">==</span> <span class="bp">``</span><span class="n">Parser.Tactic.tacticSeq</span> <span class="k">then</span>
    <span class="bp">`</span><span class="o">(</span><span class="kd">by</span> <span class="bp">$</span><span class="n">term</span><span class="o">:</span><span class="n">tacticSeq</span><span class="o">)</span>
  <span class="k">else</span>
    <span class="n">Macro.throwUnsupported</span>

<span class="c1">--- workaround for 'invalid auto tactic, identifier is not allowed'</span>
<span class="n">macro</span> <span class="s2">"hmmm"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">Nat</span> <span class="bp">×</span> <span class="n">Nat</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">hmmm</span><span class="o">)</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">arbitrary</span>
<span class="kd">def</span> <span class="n">g</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">now</span> <span class="n">hmmm</span><span class="o">)</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">arbitrary</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="c1">-- elaborated as tactic, invalid field notation</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="c1">-- elaborated as term, works!</span>
</code></pre></div>



<a name="239738060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239738060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239738060">(May 21 2021 at 11:59)</a>:</h4>
<p>What's the <code>()</code> example for <code>do</code>?</p>



<a name="239738217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239738217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239738217">(May 21 2021 at 12:00)</a>:</h4>
<p>I was thinking of (assert! ....) But that doesn't even parse with the parents (only without)</p>



<a name="239738294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239738294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239738294">(May 21 2021 at 12:00)</a>:</h4>
<p>But there's an example in my post above f.1 vs (f).1</p>



<a name="239738670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/239738670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#239738670">(May 21 2021 at 12:03)</a>:</h4>
<p>Another good one is the dot notation (. * x + 1) vs ((. * x) + 1)</p>



<a name="302783611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/302783611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#302783611">(Oct 07 2022 at 05:40)</a>:</h4>
<p>Sorry to necromance a 1.5 year old thread, but I just ran into the fact that Kevin long ago added some algebraic hierarchy to mathlib4, and per the above discussion tried out replacing <code>LeftCancelSemigroup</code> with an <code>IsMulLeftCancel</code> mixin.</p>
<p>I am really not happy with the prospect of patching the parts of the <code>ordered_ring</code> development that I need for <code>linarith</code> with the relevant changes. As <code>IsMulLeftCancel</code> is only a few lines in mathlib4 at the moment, I propose:</p>
<ol>
<li>Shortly, I clobber <code>IsMulLeftCancel</code> and instead just follow what is in mathlib3, and sometime much later someone can try this refactor.</li>
<li>Someone volunteers to finish <a href="https://github.com/leanprover-community/mathlib4/pull/455">mathlib4#455</a> while coping with this change. :-)</li>
</ol>



<a name="302784812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/302784812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#302784812">(Oct 07 2022 at 05:56)</a>:</h4>
<p>I think the porting process is difficult enough as it is. So I suggest nuking the mixin experiment. I vote for Scott's option (1).</p>



<a name="302966534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Which%20files%20to%20port%3F/near/302966534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Which.20files.20to.20port.3F.html#302966534">(Oct 08 2022 at 04:52)</a>:</h4>
<p>Okay, I have clobbered <code>Algebra/Group/Defs.lean</code> and <code>Algebra/Group/Basic.lean</code>, replacing them with a direct port from mathlib3 in <a href="https://github.com/leanprover-community/mathlib4/pull/457">https://github.com/leanprover-community/mathlib4/pull/457</a>. Unfortunately it is still a <code>help-wanted</code> PR, as the simplifier isn't working for me as expected in some lemmas in <code>Tactic/Ring.lean</code>, and for now I'm stumped. If someone is able to have a look at the branch that would be very helpful.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
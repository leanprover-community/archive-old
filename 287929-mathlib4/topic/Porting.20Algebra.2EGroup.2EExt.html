---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html">Porting Algebra.Group.Ext</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="313671927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313671927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313671927">(Dec 03 2022 at 11:44)</a>:</h4>
<p>I am porting <code>Algebra.Group.Ext</code> in <a href="https://github.com/leanprover-community/mathlib4/pull/837">#837</a> and I am stuck at the very beginning. The mathlib3 code is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.hom.group</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">@[ext, to_additive]</span>
<span class="kd">lemma</span> <span class="n">monoid.ext</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">⦃</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">M</span><span class="o">⦄</span> <span class="o">(</span><span class="n">h_mul</span> <span class="o">:</span> <span class="n">m₁.mul</span> <span class="bp">=</span> <span class="n">m₂.mul</span><span class="o">)</span> <span class="o">:</span> <span class="n">m₁</span> <span class="bp">=</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">monoid.to_mul_one_class</span> <span class="n">_</span> <span class="n">m₁</span><span class="o">)</span><span class="bp">.</span><span class="n">one</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">@</span><span class="n">monoid.to_mul_one_class</span> <span class="n">_</span> <span class="n">m₂</span><span class="o">)</span><span class="bp">.</span><span class="n">one</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="bp">@</span><span class="n">mul_one_class.one</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">mul_one_class.ext</span> <span class="n">h_mul</span><span class="o">),</span>
  <span class="n">set</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">monoid_hom</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">@</span><span class="n">monoid.to_mul_one_class</span> <span class="n">_</span> <span class="n">m₁</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">monoid.to_mul_one_class</span> <span class="n">_</span> <span class="n">m₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span> <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h_mul</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">hpow</span> <span class="o">:</span> <span class="n">m₁.npow</span> <span class="bp">=</span> <span class="n">m₂.npow</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">monoid_hom.map_pow</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="n">f</span> <span class="n">x</span> <span class="n">n</span> <span class="o">},</span>
  <span class="n">unfreezingI</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">m₁</span><span class="o">,</span> <span class="n">cases</span> <span class="n">m₂</span> <span class="o">},</span>
  <span class="n">congr</span><span class="bp">;</span> <span class="n">assumption</span>
<span class="kd">end</span>
</code></pre></div>
<p>The mathlib4 is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Algebra.Hom.Group</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">@[ext, to_additive]</span>
<span class="kd">theorem</span> <span class="n">Monoid.ext</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">⦃</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">Monoid</span> <span class="n">M</span><span class="o">⦄</span> <span class="o">(</span><span class="n">h_mul</span> <span class="o">:</span> <span class="n">m₁.mul</span> <span class="bp">=</span> <span class="n">m₂.mul</span><span class="o">)</span> <span class="o">:</span> <span class="n">m₁</span> <span class="bp">=</span> <span class="n">m₂</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">Monoid.toMulOneClass</span> <span class="n">_</span> <span class="n">m₁</span><span class="o">)</span><span class="bp">.</span><span class="n">one</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">@</span><span class="n">Monoid.toMulOneClass</span> <span class="n">_</span> <span class="n">m₂</span><span class="o">)</span><span class="bp">.</span><span class="n">one</span> <span class="o">:=</span>
    <span class="n">congr_arg</span> <span class="o">(</span><span class="n">MulOneClass.one</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">MulOneClass.ext</span> <span class="n">h_mul</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MonoidHom</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">@</span><span class="n">Monoid.toMulOneClass</span> <span class="n">_</span> <span class="n">m₁</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">Monoid.toMulOneClass</span> <span class="n">_</span> <span class="n">m₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="n">toFun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span> <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">map_mul'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h_mul</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">}</span>
  <span class="k">have</span> <span class="n">hpow</span> <span class="o">:</span> <span class="n">m₁.npow</span> <span class="bp">=</span> <span class="n">m₂.npow</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">ext</span> <span class="o">(</span><span class="n">n</span> <span class="n">x</span><span class="o">)</span>
    <span class="n">exact</span> <span class="bp">@</span><span class="n">MonoidHom.map_pow</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="n">f</span> <span class="n">x</span> <span class="n">n</span>
  <span class="n">cases</span> <span class="n">m₁</span>
  <span class="n">cases</span> <span class="n">m₂</span>
  <span class="n">congr</span> <span class="bp">&lt;;&gt;</span> <span class="n">assumption</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">monoid.ext</span> <span class="n">Monoid.ext</span>
</code></pre></div>
<p>The first error is about <code>@MulOneClass.one M</code>. Why there is no <code>MulOneClass.one</code>? I can fix it with <code>@One.one M</code>, but the mathlib3 way is better in my opinion.</p>
<p>Using <code>@One.one M</code> is get an error at <code>MulOneClass.ext h_mul</code></p>
<div class="codehilite" data-code-language="Bash"><pre><span></span><code>application <span class="nb">type</span> mismatch
  congr_arg <span class="o">(</span>@One.one M<span class="o">)</span> <span class="o">(</span>MulOneClass.ext ?m.404<span class="o">)</span>
argument
  MulOneClass.ext ?m.404
has <span class="nb">type</span>
  ?m.81 <span class="o">=</span> ?m.82 : Prop
but is expected to have <span class="nb">type</span>
  MulOneClass.toOne <span class="o">=</span> MulOneClass.toOne : Prop
</code></pre></div>
<p>I don't understand exactly what's wrong here...</p>



<a name="313672770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313672770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313672770">(Dec 03 2022 at 11:50)</a>:</h4>
<p>I think this is because of <code>old_structure_cmd</code></p>



<a name="313672856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313672856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313672856">(Dec 03 2022 at 11:50)</a>:</h4>
<p>Does <code>fun (inst : MulOneClass M) =&gt; inst.one</code> work?</p>



<a name="313673135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313673135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313673135">(Dec 03 2022 at 11:53)</a>:</h4>
<p>It moves the error later, so I guess it works... but it's really hard to read</p>



<a name="313673480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313673480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313673480">(Dec 03 2022 at 11:55)</a>:</h4>
<p>The problem is that in Lean3/old structures <code>mul_one_class.one</code> is a real field, but in Lean 4/new structures <code>M.one</code> is actualy syntax for <code>M.to_has_one.one</code> but only works when used as field notation</p>



<a name="313673625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313673625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313673625">(Dec 03 2022 at 11:56)</a>:</h4>
<p>I think it would be a reasonable feature request to ask that <code> MulOneClass.one</code> be syntax for the lambda function above.</p>



<a name="313673868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313673868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313673868">(Dec 03 2022 at 11:58)</a>:</h4>
<p>This seems like the easiest thing to work around. Note that if the expected type of the function is known <code>(\..one)</code> will work.</p>



<a name="313674047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313674047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313674047">(Dec 03 2022 at 11:59)</a>:</h4>
<p>OK, not it complains about</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MonoidHom</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">@</span><span class="n">Monoid.toMulOneClass</span> <span class="n">_</span> <span class="n">m₁</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">Monoid.toMulOneClass</span> <span class="n">_</span> <span class="n">m₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="n">toFun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span> <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">map_mul'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h_mul</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">}</span>
</code></pre></div>
<p>with</p>
<div class="codehilite" data-code-language="Bash"><pre><span></span><code>synthesized <span class="nb">type</span> class instance is not definitionally equal to expression inferred by typing rules, synthesized
  toMulOneClass
inferred
  toMulOneClass
</code></pre></div>
<p><span aria-label="rolling eyes" class="emoji emoji-1f644" role="img" title="rolling eyes">:rolling_eyes:</span></p>



<a name="313674077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313674077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313674077">(Dec 03 2022 at 12:00)</a>:</h4>
<p>The proof has to be different anyhow, since the shape of the structure is different because of the new bundling.</p>



<a name="313675634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313675634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313675634">(Dec 03 2022 at 12:10)</a>:</h4>
<p>OK, I seems more complicated than I thought. I am closing my WIP PR (where I basically didn't do anything) to "free" the file to anyone else interested, since I don't have much time this weekend.</p>



<a name="313742340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313742340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Richard Osborn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313742340">(Dec 03 2022 at 23:00)</a>:</h4>
<p>So is something like the following even possible to write in lean4?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Algebra.Hom.Group</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">Monoid</span> <span class="n">M</span><span class="o">)</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">MonoidHom</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">@</span><span class="n">Monoid.toMulOneClass</span> <span class="n">M</span> <span class="n">m₁</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">Monoid.toMulOneClass</span> <span class="n">M</span> <span class="n">m₂</span><span class="o">)</span> <span class="c1">-- M →* M : Type u_1</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MonoidHom</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">@</span><span class="n">Monoid.toMulOneClass</span> <span class="n">M</span> <span class="n">m₁</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">Monoid.toMulOneClass</span> <span class="n">M</span> <span class="n">m₂</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="o">:=</span> <span class="n">id</span>
  <span class="n">map_one'</span> <span class="o">:=</span> <span class="gr">sorry</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="313752063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313752063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313752063">(Dec 04 2022 at 01:26)</a>:</h4>
<p>I mean, it is impossible to fill in the sorries in any version of Lean, so I guess not?</p>



<a name="313816095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313816095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Richard Osborn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313816095">(Dec 04 2022 at 14:28)</a>:</h4>
<p>So I had a crack at porting the file. I managed to fix the proof of <code>Monoid.ext</code> and fix the proofs of injectivity, but was unable to fix the proofs for <code>DivInvMonoid.ext</code> and <code>Group.ext</code>. I've created a PR <a href="https://github.com/leanprover-community/mathlib4/pull/850">mathlib4#850</a>, so if anyone has any insights, please feel free to work on it.</p>



<a name="313816297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313816297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Richard Osborn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313816297">(Dec 04 2022 at 14:29)</a>:</h4>
<p>My main issue was that lean4 forgets that <code>m₁</code> is a <code>DivInvMonoid</code> when deconstructing the instance, so I don't have access to theorems that require a <code>DivInvMonoid</code> instance.</p>



<a name="313817029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313817029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Richard Osborn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313817029">(Dec 04 2022 at 14:34)</a>:</h4>
<p>I also couldn't figure out how to tell lean that the <code>div</code> in <code>DivInvMonoid</code> was the same as the <code>hDiv</code> in <code>div_eq_mul_inv</code>.</p>



<a name="313859178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313859178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Richard Osborn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313859178">(Dec 04 2022 at 22:00)</a>:</h4>
<p>So I managed to fix the first issue with deconstructing a class by delaying it in the proof giving me access to theorems for <code>DivInvMonoid</code> and <code>Group</code>. I feel like the main issue preventing me from completing the proofs is that lean is converting <code>(·*·)</code> and <code>(·/·)</code> into an <code>hMul</code> and <code>hDiv</code> and I can't quite wrap my head around how to give lean the information to apply lemmas using <code>(·*·)</code> and <code>(·/·)</code>. I've pushed updated versions of the proofs. Hopefully, the finishing touches to them is fairly trivial.</p>



<a name="313868130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313868130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313868130">(Dec 05 2022 at 00:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt/near/313752063">said</a>:</p>
<blockquote>
<p>I mean, it is impossible to fill in the sorries in any version of Lean, so I guess not?</p>
</blockquote>
<p>I think this question was asked poorly; in the real context, there are hypotheses available that say the <code>one</code> and <code>mul</code> agree</p>



<a name="313868492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313868492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313868492">(Dec 05 2022 at 00:10)</a>:</h4>
<p>I think the problem is the new-style classes interfering with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MonoidHom</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">@</span><span class="n">Monoid.toMulOneClass</span> <span class="n">_</span> <span class="n">m₁</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">Monoid.toMulOneClass</span> <span class="n">_</span> <span class="n">m₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="n">toFun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span> <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">map_mul'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h_mul</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">}</span>
</code></pre></div>
<p>In particular, this calls <code>MonoidHom.mk</code> and <code>OneHom.mk</code>, and seems to pass the wrong typeclass arguments into these</p>



<a name="313868744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313868744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313868744">(Dec 05 2022 at 00:14)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MonoidHom</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁.toMulOneClass</span> <span class="n">m₂.toMulOneClass</span> <span class="o">:=</span>
    <span class="bp">@</span><span class="n">MonoidHom.mk</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">OneHom.mk</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="n">_</span> <span class="n">id</span> <span class="n">h₁</span><span class="o">)</span>
      <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h_mul</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>



<a name="313868751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313868751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313868751">(Dec 05 2022 at 00:14)</a>:</h4>
<p>I'm very new to Lean4; what does <code>(_)</code> mean compared to <code>_</code>?</p>



<a name="313868851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313868851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313868851">(Dec 05 2022 at 00:16)</a>:</h4>
<p>Also, this feels like a place where the opaqueness of <code>inferInstance</code> is causing a problem (swapping <code>m₁.toMulOneClass</code> for the suggested <code>by letI := m₁ &lt;;&gt; infer_instance</code> fails)</p>



<a name="313869289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313869289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313869289">(Dec 05 2022 at 00:24)</a>:</h4>
<p>I was able to copy across the mathlib3 proof</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">div_inv_monoid.ext</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">⦃</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">div_inv_monoid</span> <span class="n">M</span><span class="o">⦄</span> <span class="o">(</span><span class="n">h_mul</span> <span class="o">:</span> <span class="n">m₁.mul</span> <span class="bp">=</span> <span class="n">m₂.mul</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_inv</span> <span class="o">:</span> <span class="n">m₁.inv</span> <span class="bp">=</span> <span class="n">m₂.inv</span><span class="o">)</span> <span class="o">:</span> <span class="n">m₁</span> <span class="bp">=</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">div_inv_monoid.to_monoid</span> <span class="n">_</span> <span class="n">m₁</span><span class="o">)</span><span class="bp">.</span><span class="n">one</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">@</span><span class="n">div_inv_monoid.to_monoid</span> <span class="n">_</span> <span class="n">m₂</span><span class="o">)</span><span class="bp">.</span><span class="n">one</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="bp">@</span><span class="n">monoid.one</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">monoid.ext</span> <span class="n">h_mul</span><span class="o">),</span>
  <span class="n">set</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">monoid_hom</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="kd">by</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">m₁</span><span class="bp">;</span> <span class="n">apply_instance</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">m₂</span><span class="bp">;</span> <span class="n">apply_instance</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span> <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h_mul</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">hpow</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">div_inv_monoid.to_monoid</span> <span class="n">_</span> <span class="n">m₁</span><span class="o">)</span><span class="bp">.</span><span class="n">npow</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">@</span><span class="n">div_inv_monoid.to_monoid</span> <span class="n">_</span> <span class="n">m₂</span><span class="o">)</span><span class="bp">.</span><span class="n">npow</span> <span class="o">:=</span>
    <span class="n">congr_arg</span> <span class="o">(</span><span class="bp">@</span><span class="n">monoid.npow</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">monoid.ext</span> <span class="n">h_mul</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hzpow</span> <span class="o">:</span> <span class="n">m₁.zpow</span> <span class="bp">=</span> <span class="n">m₂.zpow</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">m</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">@</span><span class="n">monoid_hom.map_zpow'</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="n">f</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h_inv</span><span class="o">)</span> <span class="n">x</span> <span class="n">m</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">hdiv</span> <span class="o">:</span> <span class="n">m₁.div</span> <span class="bp">=</span> <span class="n">m₂.div</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">@</span><span class="n">map_div'</span> <span class="n">M</span> <span class="n">M</span> <span class="n">_</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="n">_</span> <span class="n">f</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h_inv</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span> <span class="o">},</span>
  <span class="n">unfreezingI</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">m₁</span><span class="o">,</span> <span class="n">cases</span> <span class="n">m₂</span> <span class="o">},</span>
  <span class="n">congr</span><span class="o">,</span> <span class="n">exacts</span> <span class="o">[</span><span class="n">h_mul</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">hpow</span><span class="o">,</span> <span class="n">h_inv</span><span class="o">,</span> <span class="n">hdiv</span><span class="o">,</span> <span class="n">hzpow</span><span class="o">]</span>
<span class="kd">end</span>
</code></pre></div>
<p>as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">DivInvMonoid.ext</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">⦃</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">DivInvMonoid</span> <span class="n">M</span><span class="o">⦄</span> <span class="o">(</span><span class="n">h_mul</span> <span class="o">:</span> <span class="n">m₁.mul</span> <span class="bp">=</span> <span class="n">m₂.mul</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_inv</span> <span class="o">:</span> <span class="n">m₁.inv</span> <span class="bp">=</span> <span class="n">m₂.inv</span><span class="o">)</span> <span class="o">:</span> <span class="n">m₁</span> <span class="bp">=</span> <span class="n">m₂</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">Monoid.ext</span> <span class="n">h_mul</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">m₁.one</span> <span class="bp">=</span> <span class="n">m₂.one</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="bp">·.</span><span class="n">one</span><span class="o">)</span> <span class="n">this</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MonoidHom</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁.toMulOneClass</span> <span class="n">m₂.toMulOneClass</span> <span class="o">:=</span>
    <span class="bp">@</span><span class="n">MonoidHom.mk</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">OneHom.mk</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="n">_</span> <span class="n">id</span> <span class="n">h₁</span><span class="o">)</span>
      <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h_mul</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span>
  <span class="k">have</span> <span class="n">hpow</span> <span class="o">:</span> <span class="n">m₁.npow</span> <span class="bp">=</span> <span class="n">m₂.npow</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="bp">·.</span><span class="n">npow</span><span class="o">)</span> <span class="o">(</span><span class="n">Monoid.ext</span> <span class="n">h_mul</span><span class="o">)</span>
  <span class="k">have</span> <span class="n">hzpow</span> <span class="o">:</span> <span class="n">m₁.zpow</span> <span class="bp">=</span> <span class="n">m₂.zpow</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">ext</span> <span class="o">(</span><span class="n">m</span> <span class="n">x</span><span class="o">)</span>
    <span class="n">exact</span> <span class="bp">@</span><span class="n">MonoidHom.map_zpow'</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="n">_</span> <span class="n">f</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h_inv</span><span class="o">)</span> <span class="n">x</span> <span class="n">m</span>
  <span class="k">have</span> <span class="n">hdiv</span> <span class="o">:</span> <span class="n">m₁.div</span> <span class="bp">=</span> <span class="n">m₂.div</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">ext</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">)</span>
    <span class="n">exact</span> <span class="bp">@</span><span class="n">map_div'</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="n">_</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">MonoidHom.monoidHomClass</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span> <span class="n">f</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h_inv</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span>
  <span class="n">rcases</span> <span class="n">m₁</span> <span class="k">with</span> <span class="bp">@</span><span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">inv₁</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">div₁</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">,</span> <span class="n">zpow₁</span><span class="o">⟩</span>
  <span class="n">rcases</span> <span class="n">m₂</span> <span class="k">with</span> <span class="bp">@</span><span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">inv₂</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">div₂</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">,</span> <span class="n">zpow₂</span><span class="o">⟩</span>
  <span class="n">congr</span>
</code></pre></div>



<a name="313869663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313869663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313869663">(Dec 05 2022 at 00:30)</a>:</h4>
<p>It seems that <code>@</code> and <code>(_)</code> is ultimately the trick here</p>



<a name="313869744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313869744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313869744">(Dec 05 2022 at 00:30)</a>:</h4>
<p>Maybe it would be best to restart from the mathport output for the other instances now that we know that?</p>



<a name="313870749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313870749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Richard Osborn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313870749">(Dec 05 2022 at 00:46)</a>:</h4>
<p>Whatever ends up being the most readable/maintainable. The original mathport output is also in a block comment for <code>Group.ext</code>. Now that you have the <code>MonoidHom</code> working, it should be a similar proof. Are you planning on working on that one? I can probably figure it out, following this method.<br>
I am still slightly concerned that <code>(·*·)</code> and <code>(·/·)</code> are <code>hMuls</code> and <code>hDivs</code>. And it seems as though <code>Mul</code> and <code>Div</code> don't extend the classes, which seems weird to me. I'm assuming there's a good reason.</p>



<a name="313877755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313877755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Richard Osborn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313877755">(Dec 05 2022 at 02:28)</a>:</h4>
<p>Ok, I've fixed up all the proofs and have emulated the mathlib3 versions. Thank you for the help!<br>
Btw, is the extra destructuring that is happening at the end of these proofs something that <code>congr</code> should be able to figure out on its own?</p>



<a name="313922736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313922736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313922736">(Dec 05 2022 at 09:40)</a>:</h4>
<p>Do you mind adding to the  <a href="https://github.com/leanprover-community/mathlib4/wiki/Porting-wiki">porting wiki</a> what you had to do?</p>



<a name="313965701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313965701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Richard Osborn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313965701">(Dec 05 2022 at 13:42)</a>:</h4>
<p>As far as I understand it, to create a <code>MonoidHom</code> (or <code>OneHom</code>) with ambiguous instances, you need to use the <code>mk</code> constructor and then use <code>(_)</code> to delay the TC inference on the input type (or more generally any type in the  'contravariant' position?).</p>



<a name="313974065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313974065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313974065">(Dec 05 2022 at 13:52)</a>:</h4>
<p>It's not delaying it, it's disabling it entirely</p>



<a name="313975910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313975910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313975910">(Dec 05 2022 at 13:52)</a>:</h4>
<p>It's forcing it to use unification instead of typeclass search</p>



<a name="313976749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Porting%20Algebra.Group.Ext/near/313976749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt.html#313976749">(Dec 05 2022 at 13:53)</a>:</h4>
<p>Lean3 did that automatically for <code>{...}</code> notation</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
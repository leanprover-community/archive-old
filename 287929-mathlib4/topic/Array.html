---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Array.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html">Array</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="313101165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/313101165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#313101165">(Nov 30 2022 at 16:37)</a>:</h4>
<p><code>Array</code> in Lean 4 is not <code>array</code> in Lean 3; the easiest way to see this is the observation that <code>array</code> eats a nat and <code>Array</code> doesn't (the nat can be extracted from the array but it's not part of the input). </p>
<p>OK so right now I feel morally obliged to port <code>data.list.defs</code> because I want to have lines 751 to 754 of it in mathlib4, but on line 66 there is <code>list.to_array</code> which is flagged as a dubious translation because Array and array don't match. The declaration is used in exotic files such as <code>data.buffer.basic</code> and also in <code>data.array.lemmas</code>. What are we doing with this array mismatch? Are we making <code>Array'</code> which is aligned with Lean 3 <code>array</code>?</p>



<a name="313108239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/313108239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#313108239">(Nov 30 2022 at 17:08)</a>:</h4>
<p>I'm inclined to say to not port <code>array</code> and just leave a porting note that you've deleted it. I don't think <code>array</code> was used in anything with mathematical content. It's used in <code>hash_map</code>, but that file is nowhere imported.</p>



<a name="313108439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/313108439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#313108439">(Nov 30 2022 at 17:09)</a>:</h4>
<p>Don't duplicate work with <span class="user-mention" data-user-id="542196">@Arien Malec</span>, though (see <a href="#narrow/stream/287929-mathlib4/topic/list.2Etraverse">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/list.2Etraverse</a> )</p>



<a name="320120966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320120966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320120966">(Jan 08 2023 at 21:31)</a>:</h4>
<p>It seems to me that <code>Array</code> is missing a lot of basic lemmas.  Am I looking in the wrong place, or should I try implementing them myself?</p>
<p>Examples:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span> <span class="bp">++</span> <span class="bp">#</span><span class="o">[]</span> <span class="bp">=</span> <span class="n">a</span>
<span class="bp">#</span><span class="o">[]</span> <span class="bp">++</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
<span class="n">a</span> <span class="bp">++</span> <span class="n">toArray</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">++</span> <span class="n">l</span>
<span class="o">(</span><span class="n">a.push</span> <span class="n">x</span><span class="o">)</span> <span class="bp">++</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">++</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">l</span><span class="o">)</span>
</code></pre></div>



<a name="320121095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320121095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320121095">(Jan 08 2023 at 21:33)</a>:</h4>
<p>I think <code>Array</code> is new in lean4 - any lemmas in mathlib would be about <code>List</code></p>



<a name="320121224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320121224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320121224">(Jan 08 2023 at 21:35)</a>:</h4>
<p>There are a bunch of lemmas in Mathlib4 about Array (eg: <a href="https://leanprover-community.github.io/mathlib4_docs/Std/Data/Array/Lemmas.html">https://leanprover-community.github.io/mathlib4_docs/Std/Data/Array/Lemmas.html</a>) but it seems like still many are missing to me.</p>



<a name="320121314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320121314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320121314">(Jan 08 2023 at 21:36)</a>:</h4>
<p>Those lemmas are in the <code>Std</code> namespace, not <code>Mathlib</code>. I think these are maintained by Lean's core team.</p>



<a name="320121480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320121480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320121480">(Jan 08 2023 at 21:38)</a>:</h4>
<p>Ok, I see the distinction, <code>Mathlib</code> only has a single lemma <a href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Array/Basic.html">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Array/Basic.html</a></p>



<a name="320121525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320121525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320121525">(Jan 08 2023 at 21:39)</a>:</h4>
<p>Ok, so I should just move this discussion to the lean4 stream?</p>



<a name="320121610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320121610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320121610">(Jan 08 2023 at 21:40)</a>:</h4>
<p>I think you can use things like <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.data_toArray#doc">docs4#Array.data_toArray</a> to transport lemmas about <code>List</code> into lemmas about <code>Array</code>.</p>



<a name="320121856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320121856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320121856">(Jan 08 2023 at 21:44)</a>:</h4>
<p>I think most <code>Array</code> operations are missing an equivalence proof to the corresponding <code>List</code> operation.</p>



<a name="320121900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320121900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320121900">(Jan 08 2023 at 21:45)</a>:</h4>
<p>Ah, that sounds like something you'd have to do manually.</p>



<a name="320121915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320121915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320121915">(Jan 08 2023 at 21:45)</a>:</h4>
<p>Yeah, is this something that would be good as a contribution to <code>Std</code>?</p>



<a name="320121973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320121973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320121973">(Jan 08 2023 at 21:46)</a>:</h4>
<p>I'm not the person to ask unfortunately, but it sounds useful.</p>



<a name="320122139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320122139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320122139">(Jan 08 2023 at 21:49)</a>:</h4>
<p>Well maybe <code>Array</code> shouldn't have lemmas written about it, but I don't know.</p>



<a name="320122165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320122165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320122165">(Jan 08 2023 at 21:49)</a>:</h4>
<p>I think the existence of <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.data_toArray#doc">docs4#Array.data_toArray</a> is an indication that they want these lemmas though.</p>



<a name="320122295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320122295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320122295">(Jan 08 2023 at 21:51)</a>:</h4>
<p>I think you need lemmas about <code>Array</code> to prove things about practical programs.  But maybe there is an alternative I am missing?</p>



<a name="320122468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320122468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320122468">(Jan 08 2023 at 21:53)</a>:</h4>
<p>That sounds reasonable to me. This chat is mostly focused on the maths that we can do from within Lean, so most people here probably aren't as interested in that part of the language.</p>



<a name="320122554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320122554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320122554">(Jan 08 2023 at 21:54)</a>:</h4>
<p>Mathlib doesn't really seem like the place for Array lemmas, is my point.</p>



<a name="320125685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320125685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320125685">(Jan 08 2023 at 22:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="492774">Sky Wilshaw</span> <a href="#narrow/stream/287929-mathlib4/topic/Array/near/320121314">said</a>:</p>
<blockquote>
<p>Those lemmas are in the <code>Std</code> namespace, not <code>Mathlib</code>. I think these are maintained by Lean's core team.</p>
</blockquote>
<p>std4 team != core team but they do have intersection</p>
<p><span class="user-mention silent" data-user-id="571451">Jeremy Salwen</span> <a href="#narrow/stream/287929-mathlib4/topic/Array/near/320121856">said</a>:</p>
<blockquote>
<p>I think most <code>Array</code> operations are missing an equivalence proof to the corresponding <code>List</code> operation.</p>
</blockquote>
<p>Yes this is because <code>Array</code> is a different data structure in memory than <code>List</code>. It is merely represented as a <code>List</code> in the Lean 4 type system but the runtime has special support for it so the proofs aren't all trivial.</p>
<p><span class="user-mention silent" data-user-id="571451">Jeremy Salwen</span> <a href="#narrow/stream/287929-mathlib4/topic/Array/near/320121915">said</a>:</p>
<blockquote>
<p>Yeah, is this something that would be good as a contribution to <code>Std</code>?</p>
</blockquote>
<p>There is an issue on std4 for this: <a href="https://github.com/leanprover/std4/issues/24">https://github.com/leanprover/std4/issues/24</a></p>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/287929-mathlib4/topic/Array/near/320122139">said</a>:</p>
<blockquote>
<p>Well maybe <code>Array</code> shouldn't have lemmas written about it, but I don't know.</p>
</blockquote>
<p>Array should definitely have proofs written about it, it is in the majority of cases the more performant datastructure to use compared to lists so computer scientists doing verification of Lean programs will want to use it.</p>
<p><span class="user-mention silent" data-user-id="492774">Sky Wilshaw</span> <a href="#narrow/stream/287929-mathlib4/topic/Array/near/320122165">said</a>:</p>
<blockquote>
<p>I think the existence of <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.data_toArray#doc">docs4#Array.data_toArray</a> is an indication that they want these lemmas though.</p>
</blockquote>
<p>Due to the inherent difference in the operations of Array operations and List operations this lemma is not actually as useful as it might seem (but it and other lemmas that show similarities between List and Array operations are still helpful none the less). A few examples for why we might want to write algorithms on Arrays inherently different from List ones:</p>
<ul>
<li>You can easily add to the front of a <code>List</code> with a cons but you never want to do that with a slice of memory since it requires a full copy</li>
<li>You can easily share a <code>List</code> but you never want to do that with an Array since it requires a full copy upon access, as long as the array is uniquely referenced it is in fact updated in place</li>
<li>You don't actually want to use the <code>Array.data</code> function in practical code (unless that code is merely a facade for <code>@[extern]</code>) because turning a runtime <code>Array</code> into a <code>List</code> is O(n). What you usually want to do is write your algorithm in terms of indices like you would with regular arrays so you end up with completely different patterns. </li>
</ul>
<p>That being said if you can express your algorithm in terms of primitive operations that are implemented on both <code>Array</code> and <code>List</code> (fold, map, filter ...) it does still help to have equalities between them to apply list lemmas in verification.</p>



<a name="320126668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320126668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320126668">(Jan 08 2023 at 22:56)</a>:</h4>
<p>To my mind, mathlib should have theorems about…math. Theorems about the soundness or correctness of general purpose data types or APIs probably belong upstream (core or std), again IMHO.</p>



<a name="320141484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320141484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320141484">(Jan 09 2023 at 02:40)</a>:</h4>
<p>mathlib4 is always going to have a lower barrier to entry than std4. So even if the "right place" for a lemma (e.g. about <code>Array</code>) is in std4, we shouldn't hesitate at all about putting it in mathlib4 in the meantime. Once it has seen some use / been refactored a few times / Mario says it's time for it to be in std, it is easy to migrate it down in std4.</p>



<a name="320309253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320309253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320309253">(Jan 09 2023 at 19:15)</a>:</h4>
<p>This sounds like there is probably a niche for some container typeclasses so that we don't have to write the same lemmas about array and list</p>



<a name="320318768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320318768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320318768">(Jan 09 2023 at 19:57)</a>:</h4>
<p>That too is in the works on the std4 side.</p>



<a name="320337699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320337699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320337699">(Jan 09 2023 at 21:51)</a>:</h4>
<p>I found myself looking for these array lemmas occasionally too, and I think in those cases they would have been pretty useful.</p>
<p>There are two reasons I think they're not terribly out of place in mathlib4 per se:</p>
<ul>
<li>sometimes you need to reason about a mathematical definition which is implemented behind the scenes in a performant way, and this exposes some <code>Array</code> stuff—this doesn't <em>usually</em> happen but it does sometimes happen</li>
<li>sometimes you as a mathematician do want to write performant code! Especially if you're doing, say, some kind of explicit combinatorics or computational homology or something, where collections of things can get large and need speedy operations.</li>
</ul>
<p>So, in addition to the reasons mentioned above, I don't think the perceived "unmathiness" of these lemmas, so to speak, should prevent them from being in mathlib4 immediately. :)</p>



<a name="320340651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320340651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320340651">(Jan 09 2023 at 22:10)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> point is that if you want to prove things about arrays, you can just unfold the array definitions and then use the list proofs</p>



<a name="320340802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320340802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320340802">(Jan 09 2023 at 22:11)</a>:</h4>
<p>Which needs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">n^2 + 2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span> lemmas instead of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n^2 + 2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span>, where n is the size of the list api</p>



<a name="320526184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320526184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320526184">(Jan 10 2023 at 19:16)</a>:</h4>
<p>So I have done a few proofs about <code>Array</code>, and I have tried to do them the suggested way of converting to <code>List</code> operations.</p>
<p>If I am proving an equality of two <code>Array</code> expressions, for the most part, <code>apply Array.exp'; simp</code> will solve it.  However, sometimes when the expressions are more complex, this will not completely simplify away the expression.  Here is an example where it  took two passes:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Data.List.Basic</span>
<span class="kn">import</span> <span class="n">Mathlib.data.list.basic</span>

<span class="kn">open</span> <span class="n">Lean</span>

<span class="kd">def</span> <span class="n">Array.modifyHead</span> <span class="o">(</span><span class="n">F</span><span class="o">:</span> <span class="n">α</span><span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">Array</span> <span class="n">α</span><span class="o">):</span> <span class="n">Array</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Array.modify</span> <span class="n">a</span> <span class="mi">0</span> <span class="n">F</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">Array.modifyHead_data</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">Array</span> <span class="n">α</span><span class="o">):</span> <span class="o">(</span><span class="n">Array.modifyHead</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">data</span> <span class="bp">=</span> <span class="n">List.modifyHead</span> <span class="n">f</span> <span class="n">a.data</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">examp</span> <span class="o">(</span><span class="n">acc</span><span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">):</span> <span class="n">Array.push</span> <span class="bp">#</span><span class="o">[]</span> <span class="n">acc</span> <span class="bp">=</span> <span class="n">Array.modifyHead</span> <span class="o">(</span><span class="n">Array.append</span> <span class="n">acc</span><span class="o">)</span> <span class="o">(</span><span class="n">Array.push</span> <span class="bp">#</span><span class="o">[]</span> <span class="bp">#</span><span class="o">[]):=</span> <span class="kd">by</span>
  <span class="n">apply</span> <span class="n">Array.ext'</span>
  <span class="n">simp</span>
  <span class="c1">-- We still have the goal acc = acc ++ #[], so we need to do it again</span>
  <span class="n">apply</span> <span class="n">Array.ext'</span>
  <span class="n">simp</span>
</code></pre></div>
<p>Additionally, this only works if my goal is directly an equality of <code>Array</code> expressions.  A lot of the time, you will have <code>Array</code> subexpressions nested in some larger expression, and you'd like to just <code>simp</code> everything away, but you need to rewrite each <code>Array</code> subexpression one by one using this technique.</p>
<p>Both of these limitations make my approach feel like a bit of a hack. If <code>Array</code> lemmas were added to mathlib, then <code>simp</code> would just handle all these issue gracefully.  But if we don't add all the <code>Array</code> lemmas, it still seems like  it should be possible to write a smarter tactic that can act <em>as if</em> all these lemmas were present, by intelligently using the isomorphism to <code>List</code>.</p>



<a name="320526560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320526560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320526560">(Jan 10 2023 at 19:18)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.modify#doc">docs4#Array.modify</a> is unusual because it's not implemented in terms of <code>list.modify</code></p>



<a name="320527069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320527069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320527069">(Jan 10 2023 at 19:21)</a>:</h4>
<p>But actually, the difficulty here is that you're working with an <code>Array</code> of <code>Array</code>s; so it's not surprising that you have to use <code>ext</code> at each level</p>



<a name="320527362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320527362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320527362">(Jan 10 2023 at 19:22)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">Array.ext_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">as</span> <span class="n">bs</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>  <span class="n">as</span> <span class="bp">=</span> <span class="n">bs</span> <span class="bp">↔</span> <span class="n">as.data</span> <span class="bp">=</span> <span class="n">bs.data</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">examp</span> <span class="o">(</span><span class="n">acc</span><span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">):</span> <span class="n">Array.push</span> <span class="bp">#</span><span class="o">[]</span> <span class="n">acc</span> <span class="bp">=</span> <span class="n">Array.modifyHead</span> <span class="o">(</span><span class="n">Array.append</span> <span class="n">acc</span><span class="o">)</span> <span class="o">(</span><span class="n">Array.push</span> <span class="bp">#</span><span class="o">[]</span> <span class="bp">#</span><span class="o">[]):=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">Array.ext_iff</span><span class="o">]</span>
</code></pre></div>



<a name="320537984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320537984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320537984">(Jan 10 2023 at 20:24)</a>:</h4>
<p>Very cool! That fixes all my issues with having to apply <code>Array.ext'</code> twice.  However, it still doesn't fix the issue where simp will handle <code>List</code> subepxressions, but <code>simp Array.ext_iff</code> won't handle <code>Array</code> Subexpressions.  Here is a MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Data.List.Basic</span>
<span class="kn">import</span> <span class="n">Mathlib.data.list.basic</span>

<span class="kn">open</span> <span class="n">Lean</span>

<span class="kd">lemma</span> <span class="n">Array.ext_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">as</span> <span class="n">bs</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>  <span class="n">as</span> <span class="bp">=</span> <span class="n">bs</span> <span class="bp">↔</span> <span class="n">as.data</span> <span class="bp">=</span> <span class="n">bs.data</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">foo_array</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">Array</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)):</span> <span class="n">Array</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">examp_array</span> <span class="o">(</span><span class="n">r</span> <span class="n">rest</span><span class="o">:</span> <span class="n">Array</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)):</span>
 <span class="n">foo_array</span> <span class="o">(</span><span class="n">Array.push</span> <span class="o">(</span><span class="n">r</span> <span class="bp">++</span> <span class="n">rest</span><span class="o">)</span> <span class="n">acc</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">++</span> <span class="n">foo_array</span> <span class="o">(</span><span class="n">Array.push</span> <span class="n">rest</span> <span class="n">acc</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
 <span class="n">simp</span> <span class="o">[</span><span class="n">Array.ext_iff</span><span class="o">]</span>
 <span class="c1">-- Array subexpressions are not normalized!</span>

<span class="kd">def</span> <span class="n">foo_list</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)):</span> <span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">examp_list</span> <span class="o">(</span><span class="n">r</span> <span class="n">rest</span><span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)):</span>
 <span class="n">foo_list</span> <span class="o">(</span><span class="n">List.concat</span> <span class="o">(</span><span class="n">r</span> <span class="bp">++</span> <span class="n">rest</span><span class="o">)</span> <span class="n">acc</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">++</span> <span class="n">foo_list</span> <span class="o">(</span><span class="n">List.concat</span> <span class="n">rest</span> <span class="n">acc</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
 <span class="n">simp</span>
 <span class="c1">-- List subexpressions are normalized!</span>
</code></pre></div>



<a name="320538955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320538955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320538955">(Jan 10 2023 at 20:28)</a>:</h4>
<p>The argument here would be that this is hard because you didn't prove anything about <code>(foo_array a).to_list</code></p>



<a name="320539023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320539023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320539023">(Jan 10 2023 at 20:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/Array/near/320340802">said</a>:</p>
<blockquote>
<p>Which needs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">n^2 + 2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span> lemmas instead of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n^2 + 2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span>, where n is the size of the list api</p>
</blockquote>
<p>The <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span> lemmas here are the ones about <code>Array.toList</code> and <code>List.toArray</code>, combined with the list operations</p>



<a name="320540841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320540841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320540841">(Jan 10 2023 at 20:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/Array/near/320538955">said</a>:</p>
<blockquote>
<p>The argument here would be that this is hard because you didn't prove anything about <code>(foo_array a).to_list</code></p>
</blockquote>
<p>I agree that's <em>why</em> it's hard, but the question is why does it <em>have</em> to be hard.  Simplifying expressions involving <code>Array</code>s seems like a common and reasonable thing to do while proving things about <code>Arrays</code>.  Why wouldn't we want to have some sort of tactic to do that?</p>



<a name="320540941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320540941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320540941">(Jan 10 2023 at 20:43)</a>:</h4>
<p>It would be possible, but probably not worth the effort.</p>



<a name="320541057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320541057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320541057">(Jan 10 2023 at 20:43)</a>:</h4>
<p>Look, <a href="https://leanprover-community.github.io/mathlib_docs/find/finset">docs#finset</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/set">docs#set</a> are basically two of the biggest APIs in mathlib, and we still don't have a tactic to transfer results from one to the other.</p>



<a name="320541234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320541234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320541234">(Jan 10 2023 at 20:44)</a>:</h4>
<p>By no means am I trying to discourage someone to work on such a tactic, I'm just saying that if you don't take the matter in hands, then likely nobody will.</p>



<a name="320541677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320541677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320541677">(Jan 10 2023 at 20:48)</a>:</h4>
<p>Regarding <code>set</code> and <code>finset</code>, I found that <code>coe_inj.2 $ by { norm_cast, exact set.some_lemma }</code> (or the <code>coe_subset</code> version thereof) was a reliable way of proving <code>finset.some_lemma</code>. By now, there are many lemmas in mathlib I proved that way. So I think it is a sensible heuristic for implementing such a tactic.</p>



<a name="320541907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320541907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320541907">(Jan 10 2023 at 20:49)</a>:</h4>
<p>I would give it a shot, I am just not sure which approach would be right.  I can imagine a few ways it could be implemented: generating new lemmas, configuring simp to handle things better, preprocessing and passing to simp, or walking the expression tree directly.</p>



<a name="320542242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320542242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320542242">(Jan 10 2023 at 20:51)</a>:</h4>
<p>Note that the way such a tactic would likely work is:</p>
<ol>
<li>Prove everything we want about lists (the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> lemmas I talked about before)</li>
<li>Prove the links between the lists and array definitions (the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span> lemmas)</li>
<li>Write a tactic to generate the other <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> lemmas</li>
</ol>
<p>The thing is, once you do the first two steps, you can already get what you want with <code>simp</code></p>



<a name="320542432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320542432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320542432">(Jan 10 2023 at 20:52)</a>:</h4>
<p>But I also think there's something more general to get out of this, because such a tactic could likely replace <code>to_additive</code>'s current fragile implementation: Instead of regenerating the proof term every time, apply transfer lemmas then the original theorem.</p>



<a name="320542574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320542574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320542574">(Jan 10 2023 at 20:53)</a>:</h4>
<p>I suspect <span class="user-mention" data-user-id="571451">@Jeremy Salwen</span> is asking this question because they want to write proofs about arrays in terms of other lemmas about arrays; but if you enable this workflow then the list API falls behind the array API instead.</p>



<a name="320542667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320542667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320542667">(Jan 10 2023 at 20:53)</a>:</h4>
<p>If you're not careful you end up in a mess where some lemmas are transferred forwards and others backwards and now you have horrible import cycles.</p>



<a name="320542755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320542755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320542755">(Jan 10 2023 at 20:54)</a>:</h4>
<p>Not sure I'm following. How does this workflow favor one over the other?</p>



<a name="320542870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320542870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320542870">(Jan 10 2023 at 20:55)</a>:</h4>
<p>If you have lemmas about Array available then you're tempted into writing more complex lemmas about arrays</p>



<a name="320542894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320542894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320542894">(Jan 10 2023 at 20:55)</a>:</h4>
<p>Ah yeah I see what you mean.</p>



<a name="320542916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320542916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320542916">(Jan 10 2023 at 20:55)</a>:</h4>
<p>If you have only list lemmas available, then you always write the list lemma first</p>



<a name="320542999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320542999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320542999">(Jan 10 2023 at 20:56)</a>:</h4>
<p>My tactic suggestion would kind of prevent that, as we would only allow translation one way.</p>



<a name="320543087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320543087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320543087">(Jan 10 2023 at 20:56)</a>:</h4>
<p>You'd stil need to tell everyone PRing an array proof "please write the list proof instead". But I guess this already happens with <code>to_additive</code>.</p>



<a name="320543149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320543149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320543149">(Jan 10 2023 at 20:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/Array/near/320542574">said</a>:</p>
<blockquote>
<p>I suspect <span class="user-mention silent" data-user-id="571451">Jeremy Salwen</span> is asking this question because they want to write proofs about arrays in terms of other lemmas about arrays; but if you enable this workflow then the list API falls behind the array API instead.</p>
</blockquote>
<p>Mostly this is coming from writing proofs about programs.  To write a proof by induction about a function operating on Arrays, you end up with the induction hypothesis as a "lemma about arrays".</p>



<a name="320543241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320543241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320543241">(Jan 10 2023 at 20:57)</a>:</h4>
<p>Yeah but if all lemmas in the <code>Array</code> files are proved with <code>by translate</code>, I won't need to shout that loud to make myself understood.</p>



<a name="320544197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320544197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Salwen <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320544197">(Jan 10 2023 at 21:02)</a>:</h4>
<p>If there was a version of <code>simp</code> that understood these isomorphisms that would be cool.  It would know for certain types that it should simplify by first translating them to the canonical type and simplifying them there, and translating back.</p>



<a name="320551839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320551839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320551839">(Jan 10 2023 at 21:51)</a>:</h4>
<p>19 messages were moved from this topic to <a class="stream-topic" data-stream-id="287929" href="/#narrow/stream/287929-mathlib4/topic/A.20translate.20tactic">#mathlib4 &gt; A translate tactic</a> by <span class="user-mention silent" data-user-id="310045">Eric Wieser</span>.</p>



<a name="320576366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Array/near/320576366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Array.html#320576366">(Jan 11 2023 at 01:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/287929-mathlib4/topic/Array/near/320541677">said</a>:</p>
<blockquote>
<p>Regarding <code>set</code> and <code>finset</code>, I found that <code>coe_inj.2 $ by { norm_cast, exact set.some_lemma }</code> (or the <code>coe_subset</code> version thereof) was a reliable way of proving <code>finset.some_lemma</code>. By now, there are many lemmas in mathlib I proved that way. So I think it is a sensible heuristic for implementing such a tactic.</p>
</blockquote>
<p>This is basically what the <code>norm_cast</code> tactic does, so I would say the tactic to do this already exists</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
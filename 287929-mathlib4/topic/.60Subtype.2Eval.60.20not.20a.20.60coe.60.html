---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html">`Subtype.val` not a `coe`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="311975250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/311975250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#311975250">(Nov 24 2022 at 09:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> I was surprised to learn just now that <code>Subtype.val</code> is not marked with the <code>coe</code> attribute in either Lean 4 core or <code>Std</code>. Is there a reason for this?</p>



<a name="312019474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312019474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312019474">(Nov 24 2022 at 13:48)</a>:</h4>
<p>And yet this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">e</span><span class="o">})</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">s</span>
</code></pre></div>



<a name="312019630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312019630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312019630">(Nov 24 2022 at 13:49)</a>:</h4>
<p>and this fails</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="k">in</span>
<span class="bp">#</span><span class="n">synth</span> <span class="n">Coe</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span><span class="o">}</span> <span class="n">α</span>
</code></pre></div>
<p>and this works</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span><span class="o">})</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">↑</span><span class="n">s</span><span class="bp">;</span>
  <span class="c1">-- a: α := s.val</span>
  <span class="n">exact</span> <span class="n">a</span>
</code></pre></div>
<p>and so my confusion about how coercions work in Lean 4 grows ever larger :-)</p>



<a name="312021463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312021463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312021463">(Nov 24 2022 at 13:58)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> It's a <code>CoeHead</code> instance:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="k">in</span>
<span class="bp">#</span><span class="n">synth</span> <span class="n">CoeHead</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span><span class="o">}</span> <span class="n">α</span>
</code></pre></div>
<p><code>Coe</code> is only for chainable coercions. Lean uses <code>CoeT</code> I believe to actually compute a coercion instance.</p>



<a name="312022312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312022312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312022312">(Nov 24 2022 at 14:01)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="k">in</span>
<span class="bp">#</span><span class="n">synth</span> <span class="n">CoeT</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span><span class="o">}</span> <span class="n">α</span> <span class="c1">-- type mismatch?!</span>
</code></pre></div>
<p>In the example I posted with the <code>↑</code> it's not possible to click on the <code>↑</code> to find out what's going on because it is eagerly unfolded to <code>Subtype.val</code>. That's kind of annoying if you don't know what's going on in the middle of a complex term and want to work it out.</p>
<p>I also still have 0 feeling as to why computer scientists are telling me that a certain random coercion is only allowed at the start or end of a series of coercions; hopefully I will get this feeling one day.</p>



<a name="312022446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312022446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312022446">(Nov 24 2022 at 14:02)</a>:</h4>
<p>That's not the issue here. The <code>coe</code> classes are different from the <code>coe</code> attribute.</p>



<a name="312023101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312023101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312023101">(Nov 24 2022 at 14:05)</a>:</h4>
<p>(Let me add to the noise about non-<code>@[coe]</code>) <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> the <code>CoeT</code> class requires the term being coerced as the second argument.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span><span class="o">})</span> <span class="k">in</span>
<span class="bp">#</span><span class="n">synth</span> <span class="n">CoeT</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span><span class="o">}</span> <span class="n">x</span> <span class="n">α</span>
</code></pre></div>



<a name="312023110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312023110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312023110">(Nov 24 2022 at 14:05)</a>:</h4>
<p>Oh I am not even sure I had internalised the fact that a coe attribute existed! What does it do? OK got it (the joys of <code>import Mathlib</code>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/--</span>
<span class="sd">The `@[coe]` attribute on a function (which should also appear in a</span>
<span class="sd">`instance : Coe A B := ⟨myFn⟩` declaration) allows the delaborator to show</span>
<span class="sd">applications of this function as `↑` when printing expressions.</span>
<span class="sd">-/</span>
</code></pre></div>
<p>Can you put this attribute on <code>CoeHead</code> and <code>CoeFoot</code> or whatever the other one's called?</p>



<a name="312023121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312023121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312023121">(Nov 24 2022 at 14:05)</a>:</h4>
<p>We're missing the latter, but we have an instance of the former (for some choice of <code>Coe</code> class)</p>



<a name="312023833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312023833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312023833">(Nov 24 2022 at 14:09)</a>:</h4>
<p>The attribute registers the <code>def</code> in which it is applied as a coercion. This is necessary if you want to know that there is a coercion appearing in some expression because they are unfolded (i.e., there is no function called <code>coe</code>). So things like <code>norm_cast</code> absolutely must have functions registered with the <code>coe</code> attribute, otherwise it can't tell where the coercions are.</p>



<a name="312023927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312023927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312023927">(Nov 24 2022 at 14:09)</a>:</h4>
<p>I can't get the attribute to work so I'm still way behind everyone else (but at least we're all now talking about the same thing):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">coe</span><span class="o">]</span> <span class="n">subtypeCoe</span>
<span class="kd">@[coe]</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span><span class="o">})</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">↑</span><span class="n">s</span><span class="bp">;</span>
  <span class="c1">-- still `a : α := s.val`</span>
  <span class="n">exact</span> <span class="n">a</span>
</code></pre></div>
<p>Isn't the idea that it's supposed to print <code>a : α := ↑s</code> in the tactic state, or am I still not understanding?</p>



<a name="312024071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312024071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312024071">(Nov 24 2022 at 14:10)</a>:</h4>
<p>No, the attribute should go on <code>Subtype.val</code></p>



<a name="312024189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312024189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312024189">(Nov 24 2022 at 14:11)</a>:</h4>
<p>That's the function given in the <code>Coe</code> instance.</p>



<a name="312024630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312024630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312024630">(Nov 24 2022 at 14:13)</a>:</h4>
<p>Well thanks for asking this question because I've learnt a ton from it! Now hopefully someone will answer it :-)</p>



<a name="312024850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312024850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312024850">(Nov 24 2022 at 14:14)</a>:</h4>
<p>I suspect the answer to the question is that it's just an oversight. If there's a different answer, then <em>I</em> may learn a lot.</p>



<a name="312025062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312025062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312025062">(Nov 24 2022 at 14:15)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Tactic.CoeExt</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">coe</span><span class="o">]</span> <span class="n">Subtype.val</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span><span class="o">})</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">↑</span><span class="n">s</span><span class="bp">;</span>
  <span class="c1">-- `a : α := ↑s` τda</span>
  <span class="n">exact</span> <span class="n">a</span>
</code></pre></div>



<a name="312025978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312025978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312025978">(Nov 24 2022 at 14:20)</a>:</h4>
<p>If you get errors when applying the <code>norm_cast</code> attribute like <code>norm_cast: badly shaped lemma, lhs must contain at least one coe</code>, then there is very decent chance that a <code>coe</code> attribute is missing, which is what caused me to ask this question in the first place (see my comment on <a href="https://github.com/leanprover-community/mathlib4/pull/642">mathlib4#642</a>).</p>



<a name="312026608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312026608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312026608">(Nov 24 2022 at 14:23)</a>:</h4>
<p>Kevin, note also that someone (maybe Moritz?) wrote up some details about coercions on the mathlib4 <a href="https://github.com/leanprover-community/mathlib4/wiki">wiki</a></p>



<a name="312027925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312027925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312027925">(Nov 24 2022 at 14:30)</a>:</h4>
<p>Yes, I started it, but I guess there have been additions and corrections to it already. and if something came from this discussion that is not covered there I would be really happy if it shows up in the wiki eventually.</p>



<a name="312029695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312029695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312029695">(Nov 24 2022 at 14:39)</a>:</h4>
<p>I'll add some information to the wiki about why the <code>coe</code> attribute is necessary tomorrow.</p>



<a name="312029798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312029798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312029798">(Nov 24 2022 at 14:39)</a>:</h4>
<p>Oh there is a ton of stuff on the porting page which I hadn't seen before! Thanks! I read it all a while ago and since then have only ever looked at the top :-)</p>



<a name="312124584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312124584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312124584">(Nov 25 2022 at 06:43)</a>:</h4>
<p>It seems that <code>FunLike</code> makes Lean stop unfolding at <code>FunLike.coe</code>, so for <code>Equiv</code> etc. we have Lean3-like behavior.</p>



<a name="312124679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312124679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312124679">(Nov 25 2022 at 06:44)</a>:</h4>
<p>I added a paragraph about this to the wiki page. Note that I don't understand why it works this way.</p>



<a name="312129815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312129815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312129815">(Nov 25 2022 at 07:37)</a>:</h4>
<p>So what would be the simp normal form for an equiv? <code>e.to_fun x</code> or <code>FunLike.coe e x</code>? If we use the latter it means that we are thinking the complete unfolding of coercions introduced in Lean 4 is a bad idea and that we have crafted a devious way to avoid it. If we use the former it means we can't have universal simp lemmas applying to all FunLike stuff.</p>



<a name="312129997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312129997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312129997">(Nov 25 2022 at 07:39)</a>:</h4>
<p>Currently we use <code>FunLike.coe</code></p>



<a name="312130078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312130078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312130078">(Nov 25 2022 at 07:39)</a>:</h4>
<p>(and I don't understand why unfolding coercions is a good idea; may be, I'm wrong)</p>



<a name="312130255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312130255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312130255">(Nov 25 2022 at 07:41)</a>:</h4>
<p>E.g., it leaks the path <code>CoeTrans</code> found from <code>α</code> to <code>β</code>.</p>



<a name="312130288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312130288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312130288">(Nov 25 2022 at 07:41)</a>:</h4>
<p>There can be different defeq paths. Lean 3 would not care about this difference.</p>



<a name="312130425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312130425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312130425">(Nov 25 2022 at 07:42)</a>:</h4>
<p>I mean something like <code>(e : Equiv α β).toEmbedding.toFun</code> vs <code>e.toFun</code>.</p>



<a name="312130502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312130502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312130502">(Nov 25 2022 at 07:43)</a>:</h4>
<p>Or <code>(e : LinearIsometryEquiv _ _ _).toLinearEquiv.toEquiv</code> vs <code>e.toIsometric.toEquiv</code>.</p>



<a name="312130930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312130930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312130930">(Nov 25 2022 at 07:47)</a>:</h4>
<p>Does it even leak the path if all the coercions are tagged with <code>@[coe]</code>? Presumably.</p>



<a name="312135048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312135048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312135048">(Nov 25 2022 at 08:19)</a>:</h4>
<p><code>@[coe]</code> only affects pretty printing.</p>



<a name="312135073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312135073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312135073">(Nov 25 2022 at 08:19)</a>:</h4>
<p>(as far as I understand)</p>



<a name="312135169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312135169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312135169">(Nov 25 2022 at 08:20)</a>:</h4>
<p>It doesn't affect the actual term. So, if you want to apply a lemma, then you need to know which functions are behind those arrows.</p>



<a name="312135267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312135267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312135267">(Nov 25 2022 at 08:20)</a>:</h4>
<p>(or emulate Lean 3 as we do with <code>FunLike</code>)</p>



<a name="312136013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312136013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312136013">(Nov 25 2022 at 08:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60/near/312135048">said</a>:</p>
<blockquote>
<p><code>@[coe]</code> only affects pretty printing.</p>
</blockquote>
<p>I see. So in some sense the actual function <code>coe</code> no longer exists at all. It is only used by Lean 4 to try and fix type errors, so appears transiently at this point and, if successful, is immediately unfolded. So now we have the problem that things like <code>ring_equiv.to_ring_hom.to_monoid_hom.to_mul_hom.to_fun</code> are now monsters.</p>



<a name="312136519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312136519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312136519">(Nov 25 2022 at 08:30)</a>:</h4>
<p>Disclaimer: I'm <strong>not</strong> a Lean 4 expert.</p>



<a name="312136733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312136733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312136733">(Nov 25 2022 at 08:31)</a>:</h4>
<p>Another issue that comes to my mind. We should have a generic <code>Nat.cast</code>. But what if <code>((n : Nat) : Int)</code> unfolds to <code>Int.ofNat n</code> instead of <code>Nat.cast n</code> (I didn't check function names)?</p>



<a name="312136820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312136820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312136820">(Nov 25 2022 at 08:32)</a>:</h4>
<p>A user sees the arrow, tries to apply a lemma about the generic <code>Nat.cast</code>, and fails.</p>



<a name="312136939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312136939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312136939">(Nov 25 2022 at 08:33)</a>:</h4>
<p>Let's wait for an expert to come and explain how it should work.</p>



<a name="312226740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312226740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312226740">(Nov 25 2022 at 16:56)</a>:</h4>
<p>I am not that expert on coercions in Lean 4, but as a data point adding <code>[coe]</code> to <code>Subtype.val</code> does not cause errors in current mathlib4, and allows putting back in the missing @[norm_cast]s in <a href="https://github.com/leanprover-community/mathlib4/pull/642">mathlib4#642</a>.</p>



<a name="312226820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312226820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312226820">(Nov 25 2022 at 16:57)</a>:</h4>
<p>As that PR has been holding things up for a while, but looks pretty ready to go, I would like to merge that now (but continue this discussion and then make changes as needed!)</p>



<a name="312256225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312256225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312256225">(Nov 25 2022 at 20:52)</a>:</h4>
<p>But <code>[coe]</code> is still a syntatic sugar, yes?</p>



<a name="312256476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312256476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312256476">(Nov 25 2022 at 20:54)</a>:</h4>
<p>So, we can't apply lemmas about a generic <code>Nat.cast</code> to <code>Int.ofNat</code> or whatever specific function <code>((n : Nat) : Int)</code> unfolds to?</p>



<a name="312259638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312259638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312259638">(Nov 25 2022 at 21:29)</a>:</h4>
<p>Scott, I'm not at my machine now, but can you put that <code>coe</code> attribute in that file just with a note that it needs to move to an appropriate place?</p>



<a name="312261115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312261115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312261115">(Nov 25 2022 at 21:45)</a>:</h4>
<p>It's in <code>Data/Subtype.lean</code> now.</p>



<a name="312267513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312267513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312267513">(Nov 25 2022 at 23:04)</a>:</h4>
<p>I think the <code>Nat.cast</code> vs <code>Int.ofNat</code> conundrum has the same answer as in mathlib: make a simp lemma to go from one to the other.</p>



<a name="312428361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312428361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312428361">(Nov 27 2022 at 05:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60/near/312135048">said</a>:</p>
<blockquote>
<p><code>@[coe]</code> only affects pretty printing.</p>
</blockquote>
<p>The <code>@[coe]</code> attribute affects two things:</p>
<ol>
<li>pretty printing, and</li>
<li>the <code>norm_cast</code> tactic.</li>
</ol>
<p>So yeah, <code>Subtype.val</code> should most probably be tagged <code>@[coe]</code>.</p>



<a name="312433301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312433301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312433301">(Nov 27 2022 at 07:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> Why Lean 4 doesn't unfold beyond <code>FunLike.coe</code>?</p>



<a name="312438540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312438540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312438540">(Nov 27 2022 at 08:34)</a>:</h4>
<p>I am not Gabriel, but if you look at <a href="https://github.com/leanprover-community/mathlib4/blob/6b6f0338eb271a83eb23f9aa7a4c013a3ca36b5c/Mathlib/Data/FunLike/Basic.lean#L126-L130">https://github.com/leanprover-community/mathlib4/blob/6b6f0338eb271a83eb23f9aa7a4c013a3ca36b5c/Mathlib/Data/FunLike/Basic.lean#L126-L130</a> then it is somewhat obvious: the <code>coe</code> of <code>FunLike</code> is not the 'real' <code>coe</code> and therefore if you declare an instance of <code>FunLike</code> then the coercion seems to find the <code>FunLike</code> coercion to <code>FunLike.coe</code> first and the elaborator puts in <code>FunLike.coe</code> and does not care that this is defeq to something meaningful</p>



<a name="312486879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312486879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312486879">(Nov 27 2022 at 15:48)</a>:</h4>
<p>We have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="mi">100</span><span class="o">)</span> <span class="o">:</span> <span class="n">CoeFun</span> <span class="n">F</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">↦</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span> <span class="n">where</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">FunLike.coe</span>
</code></pre></div>
<p>in the same file.</p>



<a name="312523539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312523539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312523539">(Nov 27 2022 at 22:11)</a>:</h4>
<p>yes, this is the coercion I meant</p>



<a name="312548919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312548919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312548919">(Nov 28 2022 at 03:23)</a>:</h4>
<p>How is it different from <code>coeTrans</code>?</p>



<a name="312548932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%60Subtype.val%60%20not%20a%20%60coe%60/near/312548932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.60Subtype.2Eval.60.20not.20a.20.60coe.60.html#312548932">(Nov 28 2022 at 03:24)</a>:</h4>
<p>(does it unfold <code>coeTrans</code>?)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
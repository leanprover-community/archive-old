---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/instance.20loop.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html">instance loop?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="311533638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/311533638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#311533638">(Nov 22 2022 at 07:34)</a>:</h4>
<p>Can somebody shed some light on why <code>coe_mul</code> in <a href="https://github.com/leanprover-community/mathlib4/blob/8b509dad688ee929eef8de18abcc31d05ae10d6b/Mathlib/Algebra/Hom/Group.lean#L1260">this file</a> is giving the error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">deterministic</span><span class="o">)</span> <span class="n">timeout</span> <span class="n">at</span> <span class="bp">'</span><span class="n">whnf'</span><span class="o">,</span> <span class="n">maximum</span> <span class="n">number</span> <span class="n">of</span> <span class="n">heartbeats</span> <span class="o">(</span><span class="mi">200000</span><span class="o">)</span> <span class="n">has</span> <span class="n">been</span> <span class="n">reached</span> <span class="o">(</span><span class="n">use</span> <span class="bp">'</span><span class="kd">set_option</span> <span class="n">maxHeartbeats</span> <span class="bp">&lt;</span><span class="n">num</span><span class="bp">&gt;'</span> <span class="n">to</span> <span class="n">set</span> <span class="n">the</span> <span class="n">limit</span><span class="o">)</span>
</code></pre></div>
<p>Also, <code>coe_one</code> just before this compiles but quite slowly. The problem goes away when the <code>Monoid (Monoid.EndCat M)</code> instance a little above is removed, so it's probably some instance loop I'm not seeing. The corresponding part in mathlib3 obviously has no such problem.</p>



<a name="311552342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/311552342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#311552342">(Nov 22 2022 at 09:34)</a>:</h4>
<p>An aside; do we really want <code>Monoid.EndCat</code> and not just <code>Monoid.End</code>?</p>



<a name="311552591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/311552591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#311552591">(Nov 22 2022 at 09:35)</a>:</h4>
<p>I assume <code>EndCat</code> is just an automated choice by mathport due to casing, and not a conscious decision (cc <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>)</p>



<a name="311676830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/311676830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#311676830">(Nov 22 2022 at 18:05)</a>:</h4>
<p>Yes, <code>EndCat</code> here is certainly incorrect.</p>



<a name="311730917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/311730917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#311730917">(Nov 22 2022 at 23:48)</a>:</h4>
<p>Is there some command to see the instance search steps to catch this loop?</p>



<a name="313125082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313125082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313125082">(Nov 30 2022 at 18:26)</a>:</h4>
<p>Could I summon some help on this question? <a href="https://github.com/leanprover-community/mathlib4/pull/659">mathlib4#659</a> is holding up pretty much everything at the moment.</p>
<p>The problem we're having is an instance loop once we define <code>instance : Monoid (AddMonoid.End A)</code>.</p>
<p>Adding <code>set_option trace.Meta.synthInstance true </code> before the timeout, the typeclass search that is spiralling out of control is <a href="https://gist.github.com/semorrison/3b03009d80f9afee1fb279ac4629562b">here</a>.</p>
<p>It begins <code>[] new goal CoeFun (AddMonoid.End A) _tc.0 ▶</code>, and ends with the obviously broken:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">resume</span><span class="o">]</span> <span class="n">propagating</span> <span class="n">Monoid</span>
        <span class="o">(</span><span class="n">Monoid.End</span>
          <span class="o">(</span><span class="n">Monoid.End</span>
            <span class="o">(</span><span class="n">Monoid.End</span>
              <span class="o">(</span><span class="n">Monoid.End</span>
                <span class="o">(</span><span class="n">Monoid.End</span>
                  <span class="o">(</span><span class="n">Monoid.End</span>
                    <span class="o">(</span><span class="n">Monoid.End</span>
                      <span class="o">(</span><span class="n">Monoid.End</span>
                        <span class="o">(</span><span class="n">Monoid.End</span>
                          <span class="o">(</span><span class="n">Monoid.End</span>
                            <span class="o">(</span><span class="n">Monoid.End</span>
                              <span class="o">(</span><span class="n">Monoid.End</span>
                                <span class="o">(</span><span class="n">AddMonoid.End</span> <span class="n">A</span><span class="o">)))))))))))))</span> <span class="n">to</span> <span class="n">subgoal</span> <span class="n">Monoid</span> <span class="bp">?</span><span class="n">m.218081</span> <span class="n">of</span> <span class="n">MulOneClass</span> <span class="bp">?</span><span class="n">m.218081</span> <span class="bp">▶</span>
</code></pre></div>



<a name="313135231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313135231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313135231">(Nov 30 2022 at 19:14)</a>:</h4>
<p>Things start going wrong here with the <code>MonoidHomClass.toOneHomClass</code> instance:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">MonoidHomClass.toOneHomClass.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_2</span><span class="o">,</span> <span class="n">u_3</span><span class="o">}</span> <span class="o">:</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="bp">→</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u_2</span><span class="o">)}</span> <span class="bp">→</span>
    <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u_3</span><span class="o">)}</span> <span class="bp">→</span>
      <span class="o">[</span><span class="n">inst</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="n">MulOneClass</span> <span class="n">M</span><span class="o">)]</span> <span class="bp">→</span>
        <span class="o">[</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="n">MulOneClass</span> <span class="n">N</span><span class="o">)]</span> <span class="bp">→</span> <span class="o">[</span><span class="n">self</span> <span class="o">:</span> <span class="n">MonoidHomClass</span> <span class="n">F</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span> <span class="bp">→</span> <span class="n">OneHomClass</span> <span class="n">F</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:=</span>
</code></pre></div>
<p>What happens is that during function coercion, we need to synthesize an instance of <code>FunLike E ?a ?b</code>, then we're looking for <code>OneHomClass E ?a ?b</code>, and then we apply the instance above, which causes Lean to search for an instance of <code>MulOneClass ?M</code>.  Or in other words, enumerate <em>all</em> reasonable multiplicative structures.</p>



<a name="313135312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313135312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313135312">(Nov 30 2022 at 19:15)</a>:</h4>
<p>In Lean 3 we skipped arguments that were already assigned via unification, so we didn't run into this issue.</p>



<a name="313145270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313145270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313145270">(Nov 30 2022 at 20:07)</a>:</h4>
<p>Is this something we can/should change in Lean 4? Should I start making a MWE?</p>



<a name="313145603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313145603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313145603">(Nov 30 2022 at 20:08)</a>:</h4>
<p>MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Zero</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">A</span>
<span class="kd">class</span> <span class="n">One</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span> <span class="n">one</span> <span class="o">:</span> <span class="n">M</span>
<span class="kd">class</span> <span class="n">AddZeroClass</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Zero</span> <span class="n">M</span><span class="o">,</span> <span class="n">Add</span> <span class="n">M</span>
<span class="kd">class</span> <span class="n">MulOneClass</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">One</span> <span class="n">M</span><span class="o">,</span> <span class="n">Mul</span> <span class="n">M</span>
<span class="kd">structure</span> <span class="n">ZeroHom</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">N</span><span class="o">]</span> <span class="n">where</span> <span class="n">toFun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span>
<span class="kd">structure</span> <span class="n">OneHom</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">One</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">One</span> <span class="n">N</span><span class="o">]</span> <span class="n">where</span> <span class="n">toFun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span>
<span class="kd">structure</span> <span class="n">AddMonoidHom</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span><span class="o">)</span> <span class="o">[</span><span class="n">AddZeroClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">AddZeroClass</span> <span class="n">N</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">ZeroHom</span> <span class="n">M</span> <span class="n">N</span>
<span class="kd">structure</span> <span class="n">MonoidHom</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span><span class="o">)</span> <span class="o">[</span><span class="n">MulOneClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">MulOneClass</span> <span class="n">N</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">OneHom</span> <span class="n">M</span> <span class="n">N</span>
<span class="kd">class</span> <span class="n">AddMonoid</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">AddZeroClass</span> <span class="n">M</span>
<span class="kd">class</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">MulOneClass</span> <span class="n">M</span>
<span class="kd">def</span> <span class="n">AddMonoid.End</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">AddZeroClass</span> <span class="n">A</span><span class="o">]</span> <span class="o">:=</span> <span class="n">AddMonoidHom</span> <span class="n">A</span> <span class="n">A</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">AddZeroClass</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">AddMonoid.End</span> <span class="n">A</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="o">{</span><span class="n">toFun</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Zero.zero</span><span class="o">}</span>
  <span class="n">mul</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="o">{</span><span class="n">toFun</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Zero.zero</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">Monoid.End</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span> <span class="o">[</span><span class="n">MulOneClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span> <span class="n">MonoidHom</span> <span class="n">M</span> <span class="n">M</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">MulOneClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">Monoid.End</span> <span class="n">M</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="o">{</span><span class="n">toFun</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">One.one</span><span class="o">}</span>
  <span class="n">mul</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="o">{</span><span class="n">toFun</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">One.one</span><span class="o">}</span>

<span class="kd">class</span> <span class="n">FunLike</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Sort</span> <span class="n">v</span><span class="o">))</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">&lt;|</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">w</span><span class="o">)</span> <span class="n">where</span> <span class="n">toFun</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span>
<span class="kd">class</span> <span class="n">MulHomClass</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">_</span><span class="o">))</span> <span class="o">[</span><span class="n">outParam</span> <span class="o">(</span><span class="n">Mul</span> <span class="n">M</span><span class="o">)]</span> <span class="o">[</span><span class="n">outParam</span> <span class="o">(</span><span class="n">Mul</span> <span class="n">N</span><span class="o">)]</span> <span class="kd">extends</span> <span class="n">FunLike</span> <span class="n">F</span> <span class="n">M</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">N</span>
<span class="kd">class</span> <span class="n">OneHomClass</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">_</span><span class="o">))</span> <span class="o">[</span><span class="n">outParam</span> <span class="o">(</span><span class="n">One</span> <span class="n">M</span><span class="o">)]</span> <span class="o">[</span><span class="n">outParam</span> <span class="o">(</span><span class="n">One</span> <span class="n">N</span><span class="o">)]</span> <span class="kd">extends</span> <span class="n">FunLike</span> <span class="n">F</span> <span class="n">M</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">N</span>
<span class="kd">class</span> <span class="n">MonoidHomClass</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">_</span><span class="o">))</span> <span class="o">[</span><span class="n">outParam</span> <span class="o">(</span><span class="n">MulOneClass</span> <span class="n">M</span><span class="o">)]</span> <span class="o">[</span><span class="n">outParam</span> <span class="o">(</span><span class="n">MulOneClass</span> <span class="n">N</span><span class="o">)]</span>
  <span class="kd">extends</span> <span class="n">MulHomClass</span> <span class="n">F</span> <span class="n">M</span> <span class="n">N</span><span class="o">,</span> <span class="n">OneHomClass</span> <span class="n">F</span> <span class="n">M</span> <span class="n">N</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">FunLike</span> <span class="n">F</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">CoeFun</span> <span class="n">F</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span> <span class="n">where</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">FunLike.toFun</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">AddZeroClass</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">AddMonoid.End</span> <span class="n">A</span><span class="o">)</span> <span class="n">where</span> <span class="n">one.toFun</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">set_option</span> <span class="n">trace.Meta.synthInstance</span> <span class="n">true</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">[</span><span class="n">AddZeroClass</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">AddMonoidHom</span> <span class="n">A</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="313149091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313149091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313149091">(Nov 30 2022 at 20:29)</a>:</h4>
<p>We can shrink that a bit to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">One</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span> <span class="n">one</span> <span class="o">:</span> <span class="n">M</span>
<span class="kd">class</span> <span class="n">MulOneClass</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">One</span> <span class="n">M</span><span class="o">,</span> <span class="n">Mul</span> <span class="n">M</span>
<span class="kd">structure</span> <span class="n">OneHom</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">One</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">One</span> <span class="n">N</span><span class="o">]</span> <span class="n">where</span> <span class="n">toFun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span>
<span class="kd">structure</span> <span class="n">MonoidHom</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span><span class="o">)</span> <span class="o">[</span><span class="n">MulOneClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">MulOneClass</span> <span class="n">N</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">OneHom</span> <span class="n">M</span> <span class="n">N</span>
<span class="kd">class</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">MulOneClass</span> <span class="n">M</span>
<span class="kd">def</span> <span class="n">Monoid.End</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span> <span class="o">[</span><span class="n">MulOneClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span> <span class="n">MonoidHom</span> <span class="n">M</span> <span class="n">M</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">MulOneClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">Monoid.End</span> <span class="n">M</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="o">{</span><span class="n">toFun</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">One.one</span><span class="o">}</span>
  <span class="n">mul</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="o">{</span><span class="n">toFun</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">One.one</span><span class="o">}</span>

<span class="kd">class</span> <span class="n">FunLike</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Sort</span> <span class="n">v</span><span class="o">))</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">&lt;|</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">w</span><span class="o">)</span> <span class="n">where</span> <span class="n">toFun</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span>
<span class="kd">class</span> <span class="n">MulHomClass</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">_</span><span class="o">))</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">N</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">FunLike</span> <span class="n">F</span> <span class="n">M</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">N</span>
<span class="kd">class</span> <span class="n">OneHomClass</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">_</span><span class="o">))</span> <span class="o">[</span><span class="n">One</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">One</span> <span class="n">N</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">FunLike</span> <span class="n">F</span> <span class="n">M</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">N</span>
<span class="kd">class</span> <span class="n">MonoidHomClass</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">_</span><span class="o">))</span> <span class="o">[</span><span class="n">MulOneClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">MulOneClass</span> <span class="n">N</span><span class="o">]</span>
  <span class="kd">extends</span> <span class="n">MulHomClass</span> <span class="n">F</span> <span class="n">M</span> <span class="n">N</span><span class="o">,</span> <span class="n">OneHomClass</span> <span class="n">F</span> <span class="n">M</span> <span class="n">N</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">FunLike</span> <span class="n">F</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">CoeFun</span> <span class="n">F</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span> <span class="n">where</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">FunLike.toFun</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">MulOneClass</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">Monoid.End</span> <span class="n">A</span><span class="o">)</span> <span class="n">where</span> <span class="n">one.toFun</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">set_option</span> <span class="n">trace.Meta.synthInstance</span> <span class="n">true</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">[</span><span class="n">MulOneClass</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">MonoidHom</span> <span class="n">A</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="313149330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313149330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313149330">(Nov 30 2022 at 20:30)</a>:</h4>
<p>(removing the <code>outParam</code>s on the typeclasses, after <a href="https://github.com/leanprover/lean4/issues/1852">https://github.com/leanprover/lean4/issues/1852</a> was solved, and removed the additive structures, which aren't necessary to the example)</p>



<a name="313151114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313151114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313151114">(Nov 30 2022 at 20:41)</a>:</h4>
<p>And further minimized:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">A</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span> <span class="n">m</span> <span class="o">:</span> <span class="n">M</span>
<span class="kd">structure</span> <span class="n">Hom</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">A</span> <span class="n">N</span><span class="o">]</span> <span class="n">where</span> <span class="n">toFun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span>
<span class="kd">def</span> <span class="n">End</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span> <span class="o">[</span><span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span> <span class="n">Hom</span> <span class="n">M</span> <span class="n">M</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">A</span> <span class="o">(</span><span class="n">End</span> <span class="n">M</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">m</span> <span class="o">:=</span> <span class="o">{</span><span class="n">toFun</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">A.m</span><span class="o">}</span>

<span class="kd">class</span> <span class="n">FunLike</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Sort</span> <span class="n">v</span><span class="o">))</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">&lt;|</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">w</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span>
<span class="kd">class</span> <span class="n">HomClass</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">_</span><span class="o">))</span> <span class="o">[</span><span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">A</span> <span class="n">N</span><span class="o">]</span>
  <span class="kd">extends</span> <span class="n">FunLike</span> <span class="n">F</span> <span class="n">M</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">N</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">FunLike</span> <span class="n">F</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">CoeFun</span> <span class="n">F</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span> <span class="n">where</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">FunLike.toFun</span>

<span class="kd">set_option</span> <span class="n">trace.Meta.synthInstance</span> <span class="n">true</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">[</span><span class="n">A</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Hom</span> <span class="n">X</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="313151621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313151621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313151621">(Nov 30 2022 at 20:44)</a>:</h4>
<p>We're thinking alike. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>   The <code>End</code> is a red herring, any instance that allows you to construct larger structures will do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Funny</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">_</span><span class="o">))</span> <span class="n">where</span> <span class="n">toFun</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">Funny</span> <span class="n">F</span> <span class="n">A</span> <span class="n">B</span><span class="o">]</span> <span class="o">:</span> <span class="n">CoeFun</span> <span class="n">F</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span> <span class="n">where</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">Funny.toFun</span>
<span class="kd">class</span> <span class="n">MulHomClass</span> <span class="o">(</span><span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">outParam</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">B</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">Funny</span> <span class="n">F</span> <span class="n">A</span> <span class="n">B</span>
<span class="kd">class</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Mul</span> <span class="n">M</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">Mul</span> <span class="o">(</span><span class="n">Id</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span>
<span class="kd">set_option</span> <span class="n">trace.Meta.synthInstance</span> <span class="n">true</span>
<span class="kd">example</span> <span class="o">[</span><span class="n">Monoid</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">Monoid</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">MulHomClass</span> <span class="n">F</span> <span class="n">A</span> <span class="n">B</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="313151784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313151784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313151784">(Nov 30 2022 at 20:45)</a>:</h4>
<p>Great!</p>



<a name="313161044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313161044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313161044">(Nov 30 2022 at 21:37)</a>:</h4>
<p>I'm going to assume that either you'll work on diagnosing this, or make a lean 4 issue for it, or tell me that I should make a lean 4 issue.</p>



<a name="313161290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313161290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313161290">(Nov 30 2022 at 21:38)</a>:</h4>
<p>In the meantime since this file is holding up other things, I'm going to comment out some instances and leave porting notes pointing to this thread, then hopefully merge the file.</p>



<a name="313163834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313163834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313163834">(Nov 30 2022 at 21:53)</a>:</h4>
<p>You'd need to comment out a lot of stuff, or is this going to blow up really big.  Note that the <code>MulHomClass extends FunLike</code> is enough to trigger the issue.</p>



<a name="313163944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313163944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313163944">(Nov 30 2022 at 21:54)</a>:</h4>
<p>I've opened <a href="https://github.com/leanprover/lean4/pull/1901">lean4#1901</a>, but I don't think this is going to be fixed today.</p>



<a name="313163984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313163984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313163984">(Nov 30 2022 at 21:54)</a>:</h4>
<p>Hmm... okay.</p>



<a name="313167565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313167565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313167565">(Nov 30 2022 at 22:16)</a>:</h4>
<p>Should lean4 go back to <code>is_monoid_hom</code> style because of this?</p>



<a name="313167662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313167662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313167662">(Nov 30 2022 at 22:17)</a>:</h4>
<p>I always thought that the reason we moved away from it was precisely because lean 3 had problems with it and we didn't want to wait for lean 4 which apparently wouldn't.</p>



<a name="313177745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313177745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313177745">(Nov 30 2022 at 23:33)</a>:</h4>
<p>Is the suggestion to switch from bundled hom structures back to mixins? Isn't it unavoidable to use bundled structures?</p>



<a name="313181213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313181213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313181213">(Dec 01 2022 at 00:04)</a>:</h4>
<p>My understanding is that we would keep the bundled structures but discard <code>instance : bundled_hom_class (bundled_hom A B) A B</code> in favor of <code>instance (h : bundled_hom A B) : is_hom f</code>, where the latter has the advantage that you can do things like <code>is_hom prod.fst</code> too</p>



<a name="313299178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313299178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313299178">(Dec 01 2022 at 14:59)</a>:</h4>
<p>I'm trying to understand the difference between Lean 3 and Lean 4. In the issue, Gabriel explains that this comes from the instance</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">MulHomClass.toFunny</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">MulHomClass</span> <span class="n">F</span> <span class="n">A</span> <span class="n">B</span><span class="o">]</span> <span class="o">:</span> <span class="n">Funny</span> <span class="n">F</span> <span class="n">A</span> <span class="n">B</span>
</code></pre></div>
<p>Is that related to the difference in instance resolution order (i.e., in Lean 3 we start with the last instance parameter, <code>[MulHomClass F A B]</code>, and then this fixes <code>A</code> and <code>B</code>, while in Lean 4 we start with the first instance parameter <code>[Mul A]</code>and then since <code>A</code> is not fixed this goes crazy)?</p>
<p>If so, could we add an attribute to say that, in some lemma, one should start by the right-most instance instead of the leftmost? Or a crazy syntax like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">MulHomClass.toFunny</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">MulHomClass</span> <span class="n">F</span> <span class="n">A</span> <span class="n">B</span><span class="o">]</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">:</span> <span class="n">Funny</span> <span class="n">F</span> <span class="n">A</span> <span class="n">B</span>
</code></pre></div>
<p>where one would start with the instance marked with <code>.{0}</code> if it exists, then the one marked with <code>.{1}</code> if it exists, and then the remaining ones (which are not solved by unification) from left to right?</p>



<a name="313299308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313299308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313299308">(Dec 01 2022 at 15:00)</a>:</h4>
<p>This actually already exists</p>



<a name="313299384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313299384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313299384">(Dec 01 2022 at 15:00)</a>:</h4>
<p><code>@[infer_tc_goals_rl]</code></p>



<a name="313299436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313299436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313299436">(Dec 01 2022 at 15:00)</a>:</h4>
<p>Not the crazy one though :)</p>



<a name="313299654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313299654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313299654">(Dec 01 2022 at 15:01)</a>:</h4>
<p>Does it help on this issue?</p>



<a name="313299664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313299664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313299664">(Dec 01 2022 at 15:01)</a>:</h4>
<p>I would prefer that any crazy extensions have crazy syntax confined to the attribute itself</p>



<a name="313300980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313300980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313300980">(Dec 01 2022 at 15:07)</a>:</h4>
<p>The crazy syntax would have been helpful to me once in mathlib 3. There was an <code>[is_R_or_C 𝕜]</code> field in the middle of assumptions, and it would have been helpful to start with this one because this can not blow up, restricting <code>𝕜</code> to be reals or complexes, while a later assumption was of the form <code>[module 𝕜 F]</code> not imposing anything on <code>𝕜</code>, so Lean 3 would start with this instance search not knowing anything on <code>𝕜</code> and it would try all the rings it could imagine...</p>
<p>I think this one is solved by the left-to-right rule. But for performance reasons I can imagine situations where one would like to start with a middle instance because that would be the one that imposes the most restrictions and thus be the quickest to solve.</p>



<a name="313308707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313308707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313308707">(Dec 01 2022 at 15:41)</a>:</h4>
<blockquote>
<p>while in Lean 4 we start with the first instance parameter</p>
</blockquote>
<p>Is this behavior desirable?</p>



<a name="313342196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313342196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313342196">(Dec 01 2022 at 18:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/287929-mathlib4/topic/instance.20loop.3F/near/313163944">said</a>:</p>
<blockquote>
<p>I've opened <a href="https://github.com/leanprover/lean4/pull/1901">lean4#1901</a>, but I don't think this is going to be fixed today.</p>
</blockquote>
<p>For people in certain time zones it <a href="https://github.com/leanprover/lean4/commit/ffb0f42aae1e763196213b06e685ec30e4e02996">was fixed</a> the same day <span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span> Thanks Leo!</p>



<a name="313423169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313423169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313423169">(Dec 02 2022 at 04:05)</a>:</h4>
<p>Unfortunately it looks like the fix may need a fix: <a href="https://github.com/leanprover/lean4/pull/1907">lean4#1907</a>. This is holding up <code>Algebra.Hom.Group</code> in <a href="https://github.com/leanprover-community/mathlib4/pull/659">mathlib4#659</a> now.</p>



<a name="313576642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313576642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313576642">(Dec 02 2022 at 19:47)</a>:</h4>
<p>Phew, this is finally solved! There's a little bit of version hell to deal with (we need to wait for nightly-2022-12-03, and also <a href="https://github.com/JLimperg/aesop/pull/32">https://github.com/JLimperg/aesop/pull/32</a>) before we can merge, but all the instance loops are gone now, solved by fixes in Lean 4 core.</p>



<a name="313597422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313597422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313597422">(Dec 02 2022 at 22:07)</a>:</h4>
<p>If we don't mind working with an intermediate-between-nightlies commit of Lean 4, we could merge this today. Otherwise I'll be offline all of tomorrow, but hopefully someone could bump to 2022-12-03 when it is available and merge.</p>



<a name="313597848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313597848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313597848">(Dec 02 2022 at 22:10)</a>:</h4>
<p>I'm fine with an intermediate Lean 4 version.</p>



<a name="313598053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313598053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313598053">(Dec 02 2022 at 22:12)</a>:</h4>
<p>Yeah, let's go with the intermediate version.  We've decided yesterday that waiting 24h+ is just slowing us down with no upsides.</p>



<a name="313606721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/instance%20loop%3F/near/313606721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/instance.20loop.3F.html#313606721">(Dec 02 2022 at 23:21)</a>:</h4>
<p>Merged!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html">Help with Universe Levels</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="321727234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321727234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> zbatt <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321727234">(Jan 16 2023 at 22:34)</a>:</h4>
<p>I'm working on porting <a href="https://github.com/leanprover-community/mathlib4/pull/1607">Data.FinEnum</a> and I'm having some issues with universes. In particular, at the bottom with regard to the <code>Pi.*_enum</code> instances. If I let Lean fill them in on its own, its able to do it with, for example <code>max u u_1</code> but if I try to do what works in Lean3 i..e <code>Type max u v</code> (where <code>u, v</code> are universes declared at the top of the file) it doesn't accept it. Can someone help me understand why this is? Thanks so much!</p>



<a name="321727477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321727477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321727477">(Jan 16 2023 at 22:37)</a>:</h4>
<p>can you show a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="321727509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321727509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321727509">(Jan 16 2023 at 22:37)</a>:</h4>
<p>it's a bit hard to tell from your description what exactly you did and what lean had to say about it</p>



<a name="321728176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321728176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> zbatt <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321728176">(Jan 16 2023 at 22:44)</a>:</h4>
<p>The translation of <code>Pi.enum</code> into Lean4 currently looks like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">enum</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">FinEnum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">FinEnum</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="k">Pi</span> <span class="o">(</span><span class="n">toList</span> <span class="n">α</span><span class="o">)</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">toList</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="n">mem_to_list</span> <span class="n">_</span><span class="o">))</span>
</code></pre></div>
<p>which is parameterized over universes <code>u</code> which is declared in the file and <code>u_1</code> which is not. In mathlib3,  it is given as :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">pi.enum</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">))</span> <span class="o">[</span><span class="n">fin_enum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span><span class="n">a</span><span class="o">,</span> <span class="n">fin_enum</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>
<p>which is parameterized over both <code>u, v</code> which are declared in the file.</p>
<p>Lean4 is filling in the wild card with <code>max u u_1</code>, but if I try to "force" it to be polymorphic over <code>v</code> I get </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">stuck</span> <span class="n">at</span> <span class="n">solving</span> <span class="kd">universe</span> <span class="n">constraint</span>
  <span class="n">max</span> <span class="n">u</span> <span class="bp">?</span><span class="n">u.109735</span> <span class="bp">=?=</span> <span class="n">max</span> <span class="n">u</span> <span class="n">v</span>
<span class="n">while</span> <span class="n">trying</span> <span class="n">to</span> <span class="n">unify</span>
  <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">)</span>
<span class="k">with</span>
  <span class="n">List</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>I think the relevant declarations are</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span> <span class="n">v</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">v</span>
</code></pre></div>
<p>Edit: Let me cook up a better mwe</p>



<a name="321729180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321729180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> zbatt <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321729180">(Jan 16 2023 at 22:54)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Control.Monad.Basic</span>
<span class="kn">import</span> <span class="n">Mathlib.Data.Fintype.Basic</span>
<span class="kn">import</span> <span class="n">Mathlib.Data.List.ProdSigma</span>

<span class="kd">universe</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">open</span> <span class="n">Finset</span>

<span class="kd">class</span> <span class="n">FinEnum</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">card</span> <span class="o">:</span> <span class="n">ℕ</span>
  <span class="n">Equiv</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">Fin</span> <span class="n">card</span>
  <span class="o">[</span><span class="n">decEq</span> <span class="o">:</span> <span class="n">DecidableEq</span> <span class="n">α</span><span class="o">]</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum</span> <span class="n">FinEnum</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">FinEnum.decEq</span>

<span class="kn">namespace</span> <span class="n">FinEnum</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>


<span class="sd">/-- create a `FinEnum` instance from an exhaustive list without duplicates -/</span>
<span class="kd">def</span> <span class="n">ofNodupList</span> <span class="o">[</span><span class="n">DecidableEq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">List.Nodup</span> <span class="n">xs</span><span class="o">)</span> <span class="o">:</span> <span class="n">FinEnum</span> <span class="n">α</span>
    <span class="n">where</span>
  <span class="n">card</span> <span class="o">:=</span> <span class="n">xs.length</span>
  <span class="n">Equiv</span> <span class="o">:=</span>
    <span class="o">⟨</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="n">xs.indexOf</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">List.indexOf_lt_length</span><span class="o">]</span> <span class="bp">;</span> <span class="n">apply</span> <span class="n">h</span><span class="o">⟩,</span> <span class="k">fun</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">=&gt;</span>
      <span class="n">xs.nthLe</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ofNodupList.match_1</span><span class="o">],</span> <span class="k">fun</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">ofNodupList.match_1</span><span class="o">,</span> <span class="bp">*</span><span class="o">]⟩</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum.of_nodup_list</span> <span class="n">FinEnum.ofNodupList</span>

<span class="sd">/-- create a `FinEnum` instance from an exhaustive list; duplicates are removed -/</span>
<span class="kd">def</span> <span class="n">ofList</span> <span class="o">[</span><span class="n">DecidableEq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">xs</span><span class="o">)</span> <span class="o">:</span> <span class="n">FinEnum</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">ofNodupList</span> <span class="n">xs.dedup</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">])</span> <span class="o">(</span><span class="n">List.nodup_dedup</span> <span class="n">_</span><span class="o">)</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum.of_list</span> <span class="n">FinEnum.ofList</span>

<span class="sd">/-- create an exhaustive list of the values of a given type -/</span>
<span class="kd">def</span> <span class="n">toList</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">FinEnum</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">List.finRange</span> <span class="o">(</span><span class="n">card</span> <span class="n">α</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">Equiv</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum.to_list</span> <span class="n">FinEnum.toList</span>

<span class="kn">open</span> <span class="n">Function</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">mem_to_list</span> <span class="o">[</span><span class="n">FinEnum</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">toList</span> <span class="n">α</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">toList</span><span class="o">]</span> <span class="bp">;</span> <span class="n">exists</span> <span class="n">Equiv</span> <span class="n">x</span> <span class="bp">;</span> <span class="n">simp</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum.mem_to_list</span> <span class="n">FinEnum.mem_to_list</span>


<span class="kd">instance</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="mi">100</span><span class="o">)</span> <span class="o">[</span><span class="n">FinEnum</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Fintype</span> <span class="n">α</span>
    <span class="n">where</span>
  <span class="n">elems</span> <span class="o">:=</span> <span class="n">univ.map</span> <span class="o">(</span><span class="n">Equiv</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.toEmbedding</span>
  <span class="n">complete</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">intros</span> <span class="bp">;</span> <span class="n">simp</span>

<span class="sd">/-- For `Pi.cons x xs y f` create a function where every `i ∈ xs` is mapped to `f i` and</span>
<span class="sd">`x` is mapped to `y`  -/</span>
<span class="kd">def</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">cons</span> <span class="o">[</span><span class="n">DecidableEq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">xs</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">a</span>
  <span class="bp">|</span> <span class="n">b</span><span class="o">,</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">h'</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">x</span> <span class="k">then</span> <span class="n">cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h'</span><span class="o">])</span> <span class="n">y</span> <span class="k">else</span> <span class="n">f</span> <span class="n">b</span> <span class="o">(</span><span class="n">List.mem_of_ne_of_mem</span> <span class="n">h'</span> <span class="n">h</span><span class="o">)</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum.pi.cons</span> <span class="n">FinEnum.Pi.cons</span>

<span class="sd">/-- Given `f` a function whose domain is `x :: xs`, produce a function whose domain</span>
<span class="sd">is restricted to `xs`.  -/</span>
<span class="kd">def</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">tail</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">xs</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">a</span>
  <span class="bp">|</span> <span class="n">a</span><span class="o">,</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">(</span><span class="n">List.mem_cons_of_mem</span> <span class="n">_</span> <span class="n">h</span><span class="o">)</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum.pi.tail</span> <span class="n">FinEnum.Pi.tail</span>

<span class="sd">/-- `Pi xs f` creates the list of functions `g` such that, for `x ∈ xs`, `g x ∈ f x` -/</span>
<span class="kd">def</span> <span class="k">Pi</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">DecidableEq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">List</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">))</span> <span class="bp">→</span> <span class="n">List</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">xs</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="k">fun</span> <span class="n">x</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">List.not_mem_nil</span> <span class="n">x</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">,</span> <span class="n">fs</span> <span class="bp">=&gt;</span> <span class="n">FinEnum.Pi.cons</span> <span class="n">x</span> <span class="n">xs</span> <span class="bp">&lt;$&gt;</span> <span class="n">fs</span> <span class="n">x</span> <span class="bp">&lt;*&gt;</span> <span class="k">Pi</span> <span class="n">xs</span> <span class="n">fs</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum.pi</span> <span class="n">FinEnum.Pi</span>

<span class="kd">theorem</span> <span class="n">mem_pi</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">FinEnum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">FinEnum</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span>
    <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">xs</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">∈</span> <span class="k">Pi</span> <span class="n">xs</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">toList</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="gr">sorry</span>

<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum.mem_pi</span> <span class="n">FinEnum.mem_pi</span>

<span class="sd">/-- enumerate all functions whose domain and range are finitely enumerable -/</span>
<span class="kd">def</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">enum</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">FinEnum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">FinEnum</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="k">Pi</span> <span class="o">(</span><span class="n">toList</span> <span class="n">α</span><span class="o">)</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">toList</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="n">mem_to_list</span> <span class="n">_</span><span class="o">))</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum.pi.enum</span> <span class="n">FinEnum.Pi.enum</span>

<span class="kd">theorem</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">mem_enum</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">FinEnum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">FinEnum</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">f</span> <span class="bp">∈</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">enum</span> <span class="n">β</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="k">Pi</span><span class="bp">.</span><span class="n">enum</span><span class="o">]</span> <span class="bp">;</span> <span class="n">refine'</span> <span class="o">⟨</span><span class="k">fun</span> <span class="n">a</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="o">,</span> <span class="n">mem_pi</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum.pi.mem_enum</span> <span class="n">FinEnum.Pi.mem_enum</span>

<span class="kd">instance</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">finEnum</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">FinEnum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">FinEnum</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span> <span class="n">FinEnum</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">ofList</span> <span class="o">(</span><span class="k">Pi</span><span class="bp">.</span><span class="n">enum</span> <span class="n">_</span><span class="o">)</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">mem_enum</span> <span class="n">_</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum.pi.fin_enum</span> <span class="n">FinEnum.Pi.finEnum</span>

<span class="kd">instance</span> <span class="n">pfunFinEnum</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">Decidable</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">hp</span><span class="o">,</span> <span class="n">FinEnum</span> <span class="o">(</span><span class="n">α</span> <span class="n">hp</span><span class="o">)]</span> <span class="o">:</span>
    <span class="n">FinEnum</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="n">α</span> <span class="n">hp</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="k">then</span>
    <span class="n">ofList</span> <span class="o">((</span><span class="n">toList</span> <span class="o">(</span><span class="n">α</span> <span class="n">hp</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">intro</span> <span class="n">x</span> <span class="bp">;</span> <span class="n">simp</span> <span class="bp">;</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">x</span> <span class="n">hp</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)</span>
  <span class="k">else</span> <span class="n">ofList</span> <span class="o">[</span><span class="k">fun</span> <span class="n">hp'</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">hp</span> <span class="n">hp'</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">intro</span> <span class="bp">;</span> <span class="n">simp</span> <span class="bp">;</span> <span class="n">ext</span> <span class="n">hp'</span> <span class="bp">;</span> <span class="n">cases</span> <span class="n">hp</span> <span class="n">hp'</span><span class="o">)</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">fin_enum.pfun_fin_enum</span> <span class="n">FinEnum.pfunFinEnum</span>

<span class="kd">end</span> <span class="n">FinEnum</span>
</code></pre></div>



<a name="321729275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321729275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> zbatt <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321729275">(Jan 16 2023 at 22:55)</a>:</h4>
<p>the piece in question is the last 4 instances which in mathlib3 have an argument <code>β : α → Type  &lt;something involving u and v&gt;</code>. A particular example  would be <code>Pi.enum</code> haing an argument  <code>β : α → Type  (max u v)</code> This is as far as I could cut the file without breaking the bit in quesiton, hopefully its ok.</p>



<a name="321731807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321731807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321731807">(Jan 16 2023 at 23:26)</a>:</h4>
<p>It works if you use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">enum</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">))</span> <span class="o">[</span><span class="n">FinEnum</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">FinEnum</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="k">Pi</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">toList</span> <span class="n">α</span><span class="o">)</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">toList</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="n">mem_to_list</span> <span class="n">_</span><span class="o">))</span>
</code></pre></div>



<a name="321731862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321731862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321731862">(Jan 16 2023 at 23:27)</a>:</h4>
<p>You can't infer the universes purely from the output type being <code>Type (max u v)</code>, since <code>Pi.{u, v}</code> and <code>Pi.{u, max u v}</code> have the same type</p>



<a name="321731986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321731986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321731986">(Jan 16 2023 at 23:28)</a>:</h4>
<p>The reason lean 3 behaves differently here is because the type and value of a <code>def</code> are elaborated separately in lean 4</p>



<a name="321733239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321733239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> zbatt <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321733239">(Jan 16 2023 at 23:45)</a>:</h4>
<p>Ah ok that makes sense. Thank you so much!</p>



<a name="321733326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321733326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> zbatt <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321733326">(Jan 16 2023 at 23:46)</a>:</h4>
<p>A bit tangential, but are there good places to read more about intricacies of lean such as this so I can attempt to debug similar issues in the future?</p>



<a name="321733604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321733604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321733604">(Jan 16 2023 at 23:50)</a>:</h4>
<p>not really... usually "intricacies" are all very diverse things so it's hard to put them all in one collection</p>



<a name="321733615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321733615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> zbatt <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321733615">(Jan 16 2023 at 23:50)</a>:</h4>
<p>Makes sense</p>



<a name="321733630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321733630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> zbatt <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321733630">(Jan 16 2023 at 23:50)</a>:</h4>
<p>Thank you for your help with this!</p>



<a name="321748550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321748550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321748550">(Jan 17 2023 at 03:24)</a>:</h4>
<p>I think my <code>TProd</code> issue is similar:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Data.List.Nodup</span>

<span class="kn">open</span> <span class="n">List</span> <span class="n">Function</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ι</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">ι</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span><span class="o">}</span>

<span class="kn">namespace</span> <span class="n">List</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span>

<span class="sd">/-- The product of a family of types over a list. -/</span>
<span class="kd">def</span> <span class="n">TProd</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span> <span class="o">:=</span>
  <span class="n">l.foldr</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">β</span> <span class="bp">=&gt;</span> <span class="n">α</span> <span class="n">i</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="n">PUnit</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span>

<span class="kn">namespace</span> <span class="n">TProd</span>

<span class="kn">open</span> <span class="n">List</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">mk</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span><span class="o">),</span> <span class="n">TProd</span> <span class="n">α</span> <span class="n">l</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">PUnit.unit</span>
  <span class="bp">|</span> <span class="n">i</span> <span class="o">::</span> <span class="n">is</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">,</span> <span class="n">TProd.mk</span> <span class="n">is</span> <span class="n">f</span><span class="o">)</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">snd_mk</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">TProd.mk</span> <span class="o">(</span><span class="n">i</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">TProd.mk</span> <span class="n">l</span> <span class="n">f</span> <span class="o">:=</span>
  <span class="n">rfl</span>
</code></pre></div>
<p>gives:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">stuck</span> <span class="n">at</span> <span class="n">solving</span> <span class="kd">universe</span> <span class="n">constraint</span>
  <span class="n">max</span> <span class="bp">?</span><span class="n">u.1430</span> <span class="bp">?</span><span class="n">u.1507</span> <span class="bp">=?=</span> <span class="n">max</span> <span class="bp">?</span><span class="n">u.1430</span> <span class="bp">?</span><span class="n">u.1458</span>
<span class="n">while</span> <span class="n">trying</span> <span class="n">to</span> <span class="n">unify</span>
  <span class="o">(</span><span class="n">TProd</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="n">l</span><span class="o">)</span> <span class="n">ι</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="n">l</span>
<span class="k">with</span>
  <span class="o">(</span><span class="n">foldr</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">β</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="n">i</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="n">PUnit</span> <span class="n">l</span><span class="o">)</span> <span class="n">ι</span> <span class="o">(</span><span class="n">foldr</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">β</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="n">i</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="n">PUnit</span> <span class="n">l</span><span class="o">)</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">β</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">foldr</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">β</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="n">i</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="n">PUnit</span> <span class="n">l</span><span class="o">)</span> <span class="o">((</span><span class="k">fun</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="n">β</span><span class="o">)</span>
    <span class="o">(</span><span class="n">foldr</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">β</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="n">i</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="n">PUnit</span> <span class="n">l</span><span class="o">)</span> <span class="n">l</span>
</code></pre></div>
<p>I think the placeholder universes are leading Lean to infer different universe levels here?</p>



<a name="321748656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321748656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321748656">(Jan 17 2023 at 03:26)</a>:</h4>
<p>But explicitly naming my universes doesn't help...</p>



<a name="321748753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321748753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321748753">(Jan 17 2023 at 03:28)</a>:</h4>
<p>Uh, so actually it does.</p>



<a name="321748826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help%20with%20Universe%20Levels/near/321748826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Help.20with.20Universe.20Levels.html#321748826">(Jan 17 2023 at 03:29)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">https://en.wikipedia.org/wiki/Rubber_duck_debugging</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
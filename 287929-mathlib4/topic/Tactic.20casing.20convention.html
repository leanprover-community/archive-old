---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/Tactic.20casing.20convention.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html">Tactic casing convention</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="247599539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247599539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247599539">(Jul 29 2021 at 15:27)</a>:</h4>
<p>Does anyone have opinions about the tactic casing convention? Lean 4 seems to be indecisive about whether tactics should be snake case (<code>simp_all</code>) or camel case (<code>inferInstance</code>, <code>refineLift'</code>), while I went for all camel case in mathport and I think <span class="user-mention" data-user-id="399706">@Aur√©lien Saue</span> is following my syntax descriptions in <a href="https://github.com/leanprover-community/mathlib4/issues/27">mathlib4#27</a>. There are also things like <code>erewrite</code> that are just uncased, should they be <code>eRewrite</code>? <code>eRw</code> seems weird.</p>



<a name="247599678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247599678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247599678">(Jul 29 2021 at 15:28)</a>:</h4>
<p><code>casesM</code>? <code>introV</code>? <code>exFalso</code>? <code>existsI</code>?</p>



<a name="247599805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247599805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247599805">(Jul 29 2021 at 15:29)</a>:</h4>
<p>cc: <span class="user-mention" data-user-id="230999">@Daniel Selsam</span> <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span></p>



<a name="247599996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247599996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247599996">(Jul 29 2021 at 15:31)</a>:</h4>
<p>I vote camelCase everywhere (possibly with special cases for weird ones like <code>eRw</code>)</p>



<a name="247600075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247600075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247600075">(Jul 29 2021 at 15:32)</a>:</h4>
<p>There is some precedence for snake case: most commands like <code>set_option</code>, <code>elab_rules</code>, etc. are snake case</p>



<a name="247600356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247600356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247600356">(Jul 29 2021 at 15:34)</a>:</h4>
<p>the <code>TacticM</code> counterparts of the tactic syntax are regular Lean programs, definitely camelCased, and the tactic syntax feels to me at least like sugar for calling them</p>



<a name="247600446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247600446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247600446">(Jul 29 2021 at 15:35)</a>:</h4>
<p>But I haven't done much interactive proving yet so my intuitions may be out of line</p>



<a name="247600903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247600903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247600903">(Jul 29 2021 at 15:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/287929-mathlib4/topic/Tactic.20casing.20convention/near/247600075">said</a>:</p>
<blockquote>
<p>There is some precedence for snake case: most commands like <code>set_option</code>, <code>elab_rules</code>, etc. are snake case</p>
</blockquote>
<p>Also <code>set_option</code> is in the term grammar; not sure there are many other multi-word keywords in the term grammar</p>



<a name="247600967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247600967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247600967">(Jul 29 2021 at 15:39)</a>:</h4>
<p>With snake case?</p>



<a name="247600978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247600978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247600978">(Jul 29 2021 at 15:39)</a>:</h4>
<p>yes</p>



<a name="247601041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247601041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247601041">(Jul 29 2021 at 15:40)</a>:</h4>
<p><code>def bla := set_option foo 37 in 2 + 2</code></p>



<a name="247601348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247601348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247601348">(Jul 29 2021 at 15:42)</a>:</h4>
<p>I think there is a strong argument for maintaining the parallel between term constructions and tactics for things like <code>have</code> / <code>let</code> / <code>show</code> that maybe generalizes to <code>set_option</code>?</p>



<a name="247601406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247601406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247601406">(Jul 29 2021 at 15:43)</a>:</h4>
<p>Yes, <code>set_option</code> should obviously be the same in command, term, and tactic mode.</p>



<a name="247601423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247601423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247601423">(Jul 29 2021 at 15:43)</a>:</h4>
<p>If <code>set_option</code> becomes a tactic (and why wouldn't it), it would be confusing if it was spelled differently</p>



<a name="247601518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247601518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247601518">(Jul 29 2021 at 15:43)</a>:</h4>
<p>that said, you could just as easily turn it around and argue that commands should be camel cased</p>



<a name="247602255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247602255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247602255">(Jul 29 2021 at 15:49)</a>:</h4>
<p>For reference, in rust keywords are mostly one-word but there are <code>typeof</code> and <code>macro_rules</code> which weakly suggest a snake casing convention; haskell somehow manages to get away with keywords being actual english words (or symbols), with space separated compound keywords like <code>deriving instance</code> or <code>type family</code>; and C++ keywords are snake cased like <code>co_await</code> or mashed lowercase like <code>alignas</code> or <code>sizeof</code></p>



<a name="247602717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247602717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247602717">(Jul 29 2021 at 15:52)</a>:</h4>
<p>Mmh, <code>by infer instance</code>?</p>



<a name="247602814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247602814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247602814">(Jul 29 2021 at 15:53)</a>:</h4>
<p>Why are we mixing conventions now? <a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/Nat/Basic.lean">Nat/Basic.lean</a> hints that defs/lemmas are going to be snake_case in future; is it trying to be a way to easily tell apart tactics vs defs?</p>



<a name="247602918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247602918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247602918">(Jul 29 2021 at 15:54)</a>:</h4>
<p>tactics vs defs are already syntactically distinguishable, so they can overlap or not as we prefer</p>



<a name="247602987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247602987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247602987">(Jul 29 2021 at 15:55)</a>:</h4>
<p>unless we want to introduce a shorthand where <code>e</code> means <code>exact e</code>, which seems like a bad idea since it will probably cause lots of clashes</p>



<a name="247603159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247603159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247603159">(Jul 29 2021 at 15:56)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean-liquid/blob/master/src/hacks_and_tricks/by_exactI_hack.lean">it isn't unheard of tbf</a></p>



<a name="247603177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247603177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247603177">(Jul 29 2021 at 15:56)</a>:</h4>
<p>but I can't imagine it being a good idea</p>



<a name="247603254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247603254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247603254">(Jul 29 2021 at 15:57)</a>:</h4>
<p>lol it's using a zero width keyword</p>



<a name="247603428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247603428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247603428">(Jul 29 2021 at 15:58)</a>:</h4>
<p>strictly speaking that's a user notation, not a tactic, so it lets you skip the <code>by</code> as well as <code>exact</code></p>



<a name="247636274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247636274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247636274">(Jul 29 2021 at 20:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Tactic.20casing.20convention/near/247602255">said</a>:</p>
<blockquote>
<p>For reference, in rust keywords are mostly one-word but there are <code>typeof</code> and <code>macro_rules</code> which weakly suggest a snake casing convention;</p>
</blockquote>
<p>From what I understood from the discussion of when <code>natLit!</code> became <code>nat_lit</code>, I believe that snake case is now the standard in the Lean 4 core for any and all multi-word syntax keywords. This is why <code>set_option</code>, <code>macro_rules</code> and the like are snake case. Things like <code>typeof</code>, <code>erw</code>,  are special exceptions because mish-mashes of short words are often though of as a single (new) word in CS (ex. segfault or <code>exfalso</code>).</p>
<p>The question, I think, is whether tactics are to be thought of as keywords (and thus snake case) or function-like identifiers (and thus camel case). Given that that tactics don't create new keywords, I would go for the latter.</p>



<a name="247636443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247636443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247636443">(Jul 29 2021 at 20:25)</a>:</h4>
<p>they are basically contextual keywords though. If you use a misspelled tactic it doesn't even parse</p>



<a name="247636631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247636631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247636631">(Jul 29 2021 at 20:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  true, to the parser, they are symbols and thus functionally keywords, but I would consider that an implementation detail.</p>



<a name="247636991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247636991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247636991">(Jul 29 2021 at 20:29)</a>:</h4>
<p>I mean, unlike a regular function where you can still understand what comes next without the name making reference to anything, a tactic is a new piece of syntax with its own parsing rules, so if you don't recognize the tactic nothing after it makes sense</p>



<a name="247637009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247637009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247637009">(Jul 29 2021 at 20:29)</a>:</h4>
<p>Also, the Lean 4 core seems to lean in this direction as every multi-word tactic is in camel case outside <code>simp_all</code> (which I suspect may be an oversight).</p>



<a name="247637907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247637907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247637907">(Jul 29 2021 at 20:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span>  Well, yeah, I certainly don't consider tactics to be regular functions. However, I do consider them to be <em>like</em> functions in that they are are pieces of notation identified by a single name with a singular function. Keywords, however, I view as common parser tokens that may appear in many different pieces of syntax (ex.  <code>where</code>, <code>do</code>, <code>by</code>, <code>let</code>, etc.).</p>



<a name="247638102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247638102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247638102">(Jul 29 2021 at 20:38)</a>:</h4>
<p>Currently, the fact that most tactics start with a keyword seems to be a mere convention inherited from lean 3, where this practice is required. I don't know if we're going to see more infix and mixfix tactics in lean 4 going forward</p>



<a name="247638304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247638304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247638304">(Jul 29 2021 at 20:40)</a>:</h4>
<p>I wonder whether ssreflect has any good ideas for tactic operators</p>



<a name="247638384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247638384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247638384">(Jul 29 2021 at 20:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> well the fact that tactics start with a symbol (identifier) is rather key to its parsing, as the tactic parser only makes the lead symbol not a keyword (and the whole 'leading behavior' of parser categories seems to have been specifically designed for this purpose). A symbol in any other location would create real keywords.</p>



<a name="247638440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247638440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247638440">(Jul 29 2021 at 20:41)</a>:</h4>
<p>You can have non-keyword symbols anywhere using <code>&amp;"foo"</code></p>



<a name="247638512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247638512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247638512">(Jul 29 2021 at 20:42)</a>:</h4>
<p>I believe that the auto-non-keyword thing is a mere convenience</p>



<a name="247638531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247638531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247638531">(Jul 29 2021 at 20:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> that is entirely separate concept from the kind of pseudo-keyword a tactic is.</p>



<a name="247638565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247638565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247638565">(Jul 29 2021 at 20:43)</a>:</h4>
<p>I don't see how</p>



<a name="247638699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247638699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247638699">(Jul 29 2021 at 20:44)</a>:</h4>
<p>for example, <code>simp</code> uses an optional <code>(config = ...)</code> argument, and the word <code>config</code> is written as <code>&amp;"config"</code> so that you can use config as a variable or function name elsewhere</p>



<a name="247638972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247638972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247638972">(Jul 29 2021 at 20:47)</a>:</h4>
<p>they are parsed very differently? the leading behavior parser uses the leading identifier to disambiguate between parsers to run. Without the special leading behavior and just using a non-reserved symbol (i.e., <code>&amp;"foo"</code>), every tactic would look like it begin with <code>ident</code> to the parser. Thus, no disambiguation would occur and <em>every</em> parser would be run (it wouldn't even stop on the first success due to the longest-match behavior of the parser). Thus the former is O(log n) in parsers (as <code>TokenMap</code> us an <code>RBMap</code>) whereas the later is O(n).</p>



<a name="247639453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247639453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247639453">(Jul 29 2021 at 20:51)</a>:</h4>
<p>that sounds like an implementation issue; non-reserved symbols shouldn't make it any slower in principle</p>



<a name="247640321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247640321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247640321">(Jul 29 2021 at 20:58)</a>:</h4>
<p>I disagree. In my view, there is a major conceptual difference between non-reserved symbols and parser leading behavior.</p>



<a name="247640337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247640337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247640337">(Jul 29 2021 at 20:58)</a>:</h4>
<p>But maybe one of Lean 4 developers (e.g., <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span>) would have better insight than me. Especially since he, as I understand it, was largely responsible for the Lean 4 parser.</p>



<a name="247640621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247640621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247640621">(Jul 29 2021 at 21:00)</a>:</h4>
<p>However, I should note, as I am not an expert in this matter, I may be understanding this all wrong.</p>



<a name="247642022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247642022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247642022">(Jul 29 2021 at 21:12)</a>:</h4>
<p>That is, if you have n different parsers that differ only in a single place where they each have different non-reserved symbols, it should be possible to distinguish them in O(log n) using a discrimination tree</p>



<a name="247642093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247642093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247642093">(Jul 29 2021 at 21:13)</a>:</h4>
<p>It's possible that this has been special-cased in the case of the initial symbol in a tactic, but it works generally</p>



<a name="247652970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247652970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247652970">(Jul 29 2021 at 23:11)</a>:</h4>
<p>I would think that to get that to work generally would require knowing/storing much more information about the parsers than is usually feasible (especially in Lean where parsers can be arbitrary functions without any clear grammar).</p>



<a name="247654908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247654908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247654908">(Jul 29 2021 at 23:35)</a>:</h4>
<p>Why? <code>&amp;"foo"</code> is a very declarative way to say "match an ident that is equal to <code> `foo</code>"</p>



<a name="247654996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247654996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247654996">(Jul 29 2021 at 23:36)</a>:</h4>
<p>it's not essentially different from <code>"foo"</code> which says "match a token that is equal to <code>"foo"</code>"</p>



<a name="247660606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247660606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247660606">(Jul 30 2021 at 01:09)</a>:</h4>
<p>At the <code>syntax</code> level, yes, you could probably do such inferences. However, at the <code>Parser</code>/<code>ParserFn</code> level it is no longer so declarative. Furthermore, <code>syntax</code> can  actually reference arbitrary parsers so any <code>syntax</code> doing so would also be unable to be analyzed in such a manner.</p>



<a name="247660852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247660852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247660852">(Jul 30 2021 at 01:14)</a>:</h4>
<p>I am also a little confused, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> . I know that you have fiddled with parsers in-depth before and realized that they keep very little information about their grammar (i.e., when you wanted to print all the grammars of in a parser category and discovered that wasn't really feasible). So, as I feel like you probably already know some of the points I am making, I suspect I may be misunderstanding whatever you are trying to convey.</p>



<a name="247660981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247660981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247660981">(Jul 30 2021 at 01:16)</a>:</h4>
<p>I'm talking about the parsers as they are expressed at the <code>syntax</code> level. In order to preserve the distinction to the compiled level, one would need to retain that <code>TokenMap</code> like structure in the parser tables</p>



<a name="247661355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247661355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247661355">(Jul 30 2021 at 01:25)</a>:</h4>
<p>I'm still confused as to what you are proposing. Maybe a concrete example will help. <br>
For something like <code>syntax foo &amp;"and" bar : term</code> where <code>foo</code> and <code>bar</code> are parser aliases (ex., almost any built-in Lean syntax kind), how are you proposing this discriminates from other parsers with a different token at "and"?</p>



<a name="247661896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247661896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247661896">(Jul 30 2021 at 01:37)</a>:</h4>
<p>That syntax gets compiled down to a bunch of transitions in a state machine (a token trie), and so there will be an initial state corresponding to <code>term</code> , followed by an edge along <code>foo</code> (if <code>foo</code> is a terminal or nonterminal; if it is an abbreviation for something then it might be multiple edges) to a state <code>s1</code>, which has a <code>&amp;"and"</code> edge to <code>s2</code> which has a <code>bar</code> edge to <code>s3</code> which is an accepting state (marked with the reduction rule "apply <code>term_and_</code>").</p>
<p>The important part in this case is what an <code>&amp;"and"</code> edge is. This is a terminal, so it directs the tokenizer to parse a token, and then assert that the parsed token is <code>"and"</code>. This is exactly the same as what would happen with <code>"and"</code>; the only difference is that one considers <code>Syntax.atom</code> tokens and the other considers <code>Syntax.ident</code></p>



<a name="247661967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247661967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247661967">(Jul 30 2021 at 01:38)</a>:</h4>
<p>When multiple parsers are added that all pass through state <code>s1</code>, it will acquire many out-edges like <code>&amp;"and"</code>, <code>&amp;"or"</code> and so on. These can be stored in a <code>TokenMap</code> in order to get O(log n) lookup</p>



<a name="247662051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247662051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247662051">(Jul 30 2021 at 01:40)</a>:</h4>
<p>AFAIK this is exactly what is already happening for regular (reserved) tokens, but it's possible that it is not being done for non-reserved tokens</p>



<a name="247662678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247662678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247662678">(Jul 30 2021 at 01:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/Tactic.20casing.20convention/near/247661967">said</a>:</p>
<blockquote>
<p>When multiple parsers are added that all pass through state <code>s1</code>, it will acquire many out-edges like <code>&amp;"and"</code>, <code>&amp;"or"</code> and so on. These can be stored in a <code>TokenMap</code> in order to get O(log n) lookup</p>
</blockquote>
<p>Note that, afaik, in the current Lean 4 parser implementation <code>TokenMap</code> lookups only occur for the leading token of a category parser. A normal parser does not do any such lookups. That is, if I have the syntax <code>"foo" "bar"</code> <code>"foo" "baz"</code> and <code>"foo" "bam"</code> there is no lookup on the second token. Furthermore, parsers are not guaranteed to even have first token information much less 2nd/3rd/4th information. Parsers are not guaranteed to parse tokens either, they can just parse the raw input stream (nor are they guaranteed to be deterministic or terminate).</p>



<a name="247662690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247662690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247662690">(Jul 30 2021 at 01:54)</a>:</h4>
<p>Looking at the code some more, I think the lean 4 parser setup is a bit flatter than this. What I described is how lean 3 notations are compiled, but in lean 4 it appears that it only looks one token deep, and special cases the leading parser and trailing parser cases (corresponding to the initial state and the state after a <code>term</code> edge) to have proper token trees, and all other states are simply stuck in one big list. This means that while it can efficiently handle things like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="s2">"lead1"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">...</span>
<span class="n">syntax</span> <span class="s2">"leadn"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">term</span>

<span class="n">syntax</span> <span class="n">term</span> <span class="s2">"trail1"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">...</span>
<span class="n">syntax</span> <span class="n">term</span> <span class="s2">"trailn"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">term</span>
</code></pre></div>
<p>it will have linear time performance on</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="s2">"a"</span> <span class="s2">"lead1"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">...</span>
<span class="n">syntax</span> <span class="s2">"a"</span> <span class="s2">"leadn"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">term</span>

<span class="n">syntax</span> <span class="s2">"a"</span> <span class="n">term</span> <span class="s2">"trail1"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">...</span>
<span class="n">syntax</span> <span class="s2">"a"</span> <span class="n">term</span> <span class="s2">"trailn"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">term</span>
</code></pre></div>



<a name="247662778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247662778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247662778">(Jul 30 2021 at 01:56)</a>:</h4>
<p>It would still be possible to implement this even in the presence of arbitrary parsers; you would just have a token tree for the ones generated by syntax and an "other" list for all the manually implemented parsers</p>



<a name="247662856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247662856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247662856">(Jul 30 2021 at 01:58)</a>:</h4>
<p>Yep, you more-or-less got to what I was saying before I finished saying it. :P</p>



<a name="247662863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247662863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247662863">(Jul 30 2021 at 01:58)</a>:</h4>
<p>That would handle things like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="s2">"properly"</span> <span class="s2">"organized"</span> <span class="s2">"tokens"</span> <span class="n">thenCallMyArbitraryParser</span> <span class="o">:</span> <span class="n">term</span>
</code></pre></div>



<a name="247663123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247663123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247663123">(Jul 30 2021 at 02:02)</a>:</h4>
<p>Note that what you are suggesting is essentially turning every parser into a (closed?) parser category.  You could thus already simulate this in that manner.</p>



<a name="247663144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247663144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247663144">(Jul 30 2021 at 02:03)</a>:</h4>
<p>Not closed, it would be added to whenever you add to the parent category</p>



<a name="247663153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247663153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247663153">(Jul 30 2021 at 02:03)</a>:</h4>
<p>although maybe you can't directly add to it through <code>syntax</code></p>



<a name="247663182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247663182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247663182">(Jul 30 2021 at 02:04)</a>:</h4>
<p>For your example, this would look like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">declare_syntax_cat</span> <span class="n">properly</span>
<span class="n">syntax</span> <span class="s2">"properly"</span> <span class="n">properly</span> <span class="o">:</span> <span class="n">term</span>
<span class="n">declare_syntax_cat</span> <span class="n">organized</span>
<span class="n">syntax</span> <span class="s2">"organized"</span> <span class="n">organized</span> <span class="o">:</span> <span class="n">properly</span>
<span class="n">declare_syntax_cat</span> <span class="n">tokens</span>
<span class="n">syntax</span> <span class="s2">"tokens"</span> <span class="n">tokens</span> <span class="o">:</span> <span class="n">organized</span>
<span class="n">syntax</span> <span class="n">thenCallMyArbitraryParser</span> <span class="o">:</span> <span class="n">tokens</span>
</code></pre></div>



<a name="247663231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247663231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247663231">(Jul 30 2021 at 02:05)</a>:</h4>
<p>Similarly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">declare_syntax_cat</span> <span class="n">termA</span>
<span class="n">syntax</span> <span class="s2">"a"</span> <span class="n">termA</span> <span class="o">:</span> <span class="n">term</span>
<span class="n">syntax</span> <span class="s2">"lead1"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">termA</span>
<span class="bp">...</span>
<span class="n">syntax</span> <span class="s2">"leadn"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">termA</span>

<span class="n">syntax</span> <span class="n">term</span> <span class="s2">"trail1"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">termA</span>
<span class="bp">...</span>
<span class="n">syntax</span> <span class="n">term</span> <span class="s2">"trailn"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">termA</span>
</code></pre></div>



<a name="247663317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247663317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247663317">(Jul 30 2021 at 02:06)</a>:</h4>
<p>Although I guess you have to declare in advance whether you expect many <code>"foo"</code> parsers or many <code>&amp;"foo"</code> parsers by setting the <code>LeadingIdentBehavior</code> appropriately</p>



<a name="247663537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Tactic%20casing%20convention/near/247663537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/Tactic.20casing.20convention.html#247663537">(Jul 30 2021 at 02:10)</a>:</h4>
<p>I suspect that this approach may result in some less-than-ideal performance overhead (either in memory or runtime) if used universally.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
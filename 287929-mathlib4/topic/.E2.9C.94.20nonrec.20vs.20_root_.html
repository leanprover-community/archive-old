---
layout: archive
title: Zulip Chat Archive
permalink: /stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/index.html">mathlib4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html">âœ” nonrec vs _root_</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="323223607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323223607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323223607">(Jan 24 2023 at 11:17)</a>:</h4>
<p>Although according to <a href="#narrow/stream/287929-mathlib4/topic/synport.20experimentation/near/250236474">this Zulip thread</a> it seems that <code>nonrec</code> was introduced specifically for this purpose.</p>



<a name="323243933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323243933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323243933">(Jan 24 2023 at 12:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/data.2Ebitvec.2Ecore.20mathlib4.231731/near/323223607">said</a>:</p>
<blockquote>
<p>Although according to <a href="#narrow/stream/287929-mathlib4/topic/synport.20experimentation/near/250236474">this Zulip thread</a> it seems that <code>nonrec</code> was introduced specifically for this purpose.</p>
</blockquote>
<p>My take on this is that in this specific instance, we have a name resolution issue because of identical names from different namespaces. namespaces exist for this purpose, to allow reuse of the same name in different contexts without exhausting the set of names available globally and disambiguating when there is a collision.</p>



<a name="323245023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323245023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323245023">(Jan 24 2023 at 13:00)</a>:</h4>
<p>Right, <code>_root_</code> (or in general, explicit namespace qualifiers) exists to disambiguate with local names that are in the context, <code>nonrec</code> exists to stop the local name being in the context in the first place.</p>



<a name="323245129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323245129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323245129">(Jan 24 2023 at 13:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/data.2Ebitvec.2Ecore.20mathlib4.231731/near/323245023">said</a>:</p>
<blockquote>
<p>Right, <code>_root_</code> exists to disambiguate with local names that are in the context, <code>nonrec</code> exists to stop the local name being in the context in the first place.</p>
</blockquote>
<p>When I say local, I mean file scope.</p>



<a name="323245200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323245200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323245200">(Jan 24 2023 at 13:01)</a>:</h4>
<p>I think you are referring to scope inside the lemma proof</p>



<a name="323245360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323245360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323245360">(Jan 24 2023 at 13:02)</a>:</h4>
<p>In any case this idea of separating non-recursive and recursive calls in strictly evaluated functional languages is deeper than just disambiguating names.</p>



<a name="323245501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323245501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323245501">(Jan 24 2023 at 13:03)</a>:</h4>
<p>Sure, but you're attaching a meaning to <code>nonrec</code> based on what it means in other languages, not on what it means in Lean</p>



<a name="323245535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323245535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323245535">(Jan 24 2023 at 13:03)</a>:</h4>
<p><code>nonrec def foo</code> means "I do not want to refer to <code>foo</code> inside the definition of itself"</p>



<a name="323245603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323245603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323245603">(Jan 24 2023 at 13:03)</a>:</h4>
<p>It also means I can do evaluation and type-checking differently.</p>



<a name="323245779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323245779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323245779">(Jan 24 2023 at 13:04)</a>:</h4>
<p>This possibility remains open for the future. By using <code>nonrec</code> in these situations where it is not needed, we are making any such changes in the future, should the need arise, difficult.</p>



<a name="323245860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323245860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323245860">(Jan 24 2023 at 13:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="466334">Shreyas Srinivas</span> <a href="#narrow/stream/287929-mathlib4/topic/data.2Ebitvec.2Ecore.20mathlib4.231731/near/323245603">said</a>:</p>
<blockquote>
<p>It also means I can do evaluation and type-checking differently.</p>
</blockquote>
<p>I don't see how this could be the case</p>



<a name="323245946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323245946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323245946">(Jan 24 2023 at 13:05)</a>:</h4>
<p>I think the version of <code>nonrec</code> actually implemented by Lean makes the meaning you want it to have irrelevant</p>



<a name="323246009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323246009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323246009">(Jan 24 2023 at 13:05)</a>:</h4>
<p><a href="https://cs.stackexchange.com/questions/101152/let-rec-recursive-expression-static-typing-rule/101174#101174">https://cs.stackexchange.com/questions/101152/let-rec-recursive-expression-static-typing-rule/101174#101174</a></p>



<a name="323246241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323246241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323246241">(Jan 24 2023 at 13:06)</a>:</h4>
<p>It is not about the meaning I want it to have now. Lean is still a language in active development. The difference is a conceptual one, cutting across languages, so one never knows if lean might want it to incorporate this meaning in the future.</p>



<a name="323246476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323246476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323246476">(Jan 24 2023 at 13:08)</a>:</h4>
<p>The whole purpose of namespaces is to disambiguate these names. So it is unlikely that there is a change in the future that makes this disambiguation invalid</p>



<a name="323246542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323246542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323246542">(Jan 24 2023 at 13:08)</a>:</h4>
<p>Based on that viewpoint, is there any scenario in which you believe <code>nonrec</code> should be used?</p>



<a name="323246765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323246765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323246765">(Jan 24 2023 at 13:09)</a>:</h4>
<p>For now, no. In the future if there are benefits to be gained from typechecking or order of evaluation or some such thing (hard to predict) due to changes in <code>nonrec</code>, then yes.</p>



<a name="323247098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323247098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323247098">(Jan 24 2023 at 13:11)</a>:</h4>
<p>Unless there are situations where this message applies : <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/synport.20experimentation.html#250239057">https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/synport.20experimentation.html#250239057</a></p>



<a name="323247282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323247282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323247282">(Jan 24 2023 at 13:12)</a>:</h4>
<p>I suspect that viewpoint that <code>nonrec</code> should never be used doesn't align with thoughts of the Lean4 developers who decided it was a worthwhile language feature</p>



<a name="323247505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323247505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323247505">(Jan 24 2023 at 13:13)</a>:</h4>
<p>Clarification: It should not be used for disambiguating names, where namespaces do the job perfectly well.</p>



<a name="323247571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323247571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323247571">(Jan 24 2023 at 13:13)</a>:</h4>
<p>That is the sole thing that it does though, and the reason it was added</p>



<a name="323247684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323247684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323247684">(Jan 24 2023 at 13:14)</a>:</h4>
<p>For now. But it has a deeper conceptual meaning that lean4 might benefit from</p>



<a name="323247803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323247803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323247803">(Jan 24 2023 at 13:14)</a>:</h4>
<p>24 messages were moved here from <a class="stream-topic" data-stream-id="287929" href="/#narrow/stream/287929-mathlib4/topic/data.2Ebitvec.2Ecore.20mathlib4.231731">#mathlib4 &gt; data.bitvec.core mathlib4#1731</a> by <span class="user-mention silent" data-user-id="310045">Eric Wieser</span>.</p>



<a name="323248088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323248088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323248088">(Jan 24 2023 at 13:16)</a>:</h4>
<p>It seems odd to me to be wary of solving a problem <code>X</code> with a solution <code>Y</code> added explicitly to solve <code>X</code> just in case <code>Y</code> is actually changed to mean something else later.</p>



<a name="323248111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323248111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323248111">(Jan 24 2023 at 13:16)</a>:</h4>
<p>but if you have lots of <code>nonrec</code>s used where the only purpose is to disambiguate names, then any future changes to <code>nonrec</code> would require going through each and every occurrence and making sure that the changes to <code>nonrec</code> don't affect this occurrence</p>



<a name="323248175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323248175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323248175">(Jan 24 2023 at 13:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/nonrec.20vs.20_root_/near/323248088">said</a>:</p>
<blockquote>
<p>It seems odd to me to be wary of solving a problem <code>X</code> with a solution <code>Y</code> added explicitly to solve <code>X</code> just in case <code>Y</code> is actually changed to mean something else later.</p>
</blockquote>
<p>Yes except <code>Y</code> is namespaces</p>



<a name="323248384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323248384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323248384">(Jan 24 2023 at 13:17)</a>:</h4>
<p>namespaces have one job, conceptually and in lean 4. To disambiguate names</p>



<a name="323248415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323248415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323248415">(Jan 24 2023 at 13:17)</a>:</h4>
<p>I still struggle to see what meaning you expect <code>nonrec</code> to have in future. Do you expect these two functions to have different meanings?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">nonrec</span> <span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">Nat</span>  <span class="o">:=</span> <span class="bp">...</span>
<span class="kd">def</span> <span class="n">f2</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>The post you linked to was about <code>let</code> vs <code>let rec</code>, which doesn't seem super applicable here.</p>



<a name="323248674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323248674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323248674">(Jan 24 2023 at 13:18)</a>:</h4>
<p>It does.  The only superficial difference is that<code>lean4 </code> allows <code>def</code>s to be recursive by default, so you mark the non-recursive ones with <code>nonrec</code> instead of the other way around.</p>



<a name="323248885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323248885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323248885">(Jan 24 2023 at 13:19)</a>:</h4>
<p>This only would matter if the <code>def</code> doesn't have an explicit type though, right?</p>



<a name="323248936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323248936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323248936">(Jan 24 2023 at 13:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/nonrec.20vs.20_root_/near/323248415">said</a>:</p>
<blockquote>
<p>I still struggle to see what meaning you expect <code>nonrec</code> to have in future. Do you expect these two functions to have different meanings?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">nonrec</span> <span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">Nat</span>  <span class="o">:=</span> <span class="bp">...</span>
<span class="kd">def</span> <span class="n">f2</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>The post you linked to was about <code>let</code> vs <code>let rec</code>, which doesn't seem super applicable here.</p>
</blockquote>
<p>I expect that the typechecker and evaluation can work more efficiently on the first one than the second.</p>



<a name="323249074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323249074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323249074">(Jan 24 2023 at 13:20)</a>:</h4>
<p>But that is speculation for now.</p>



<a name="323249484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323249484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323249484">(Jan 24 2023 at 13:22)</a>:</h4>
<p>The reason I linked it is to show that there is an algorithmic difference in the way the typechecker can work. Similarly, evaluation can proceed differently if I know that there are no recursive calls inside a proof. Again this is speculation, since I haven't considered how this would work in CIC, but that's another story.</p>



<a name="323250724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323250724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323250724">(Jan 24 2023 at 13:27)</a>:</h4>
<p>Point is, in this case, there is a feature, namely namespaces, which has one job: disambiguating names. If namespaces  can do the job, I don't see the point of introducing another notion <code>nonrec</code> which has other conceptual meanings that might (can't be certain) come in handy later. It is another matter if namespaces cannot handle <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/synport.20experimentation.html#250239057">this</a></p>



<a name="323250866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323250866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323250866">(Jan 24 2023 at 13:28)</a>:</h4>
<p>Note there is <a href="https://github.com/leanprover-community/mathlib4/blame/805f2c31304edc654c1634d1d1b93a89f0797e61/Mathlib/Tactic/Core.lean#L33">a comment in mathlib4 already</a> by <span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> saying</p>
<blockquote>
<p><code>-- nonrec only matters for name resolution, so is irrelevant (?)</code></p>
</blockquote>
<p>(it's used in <a href="https://github.com/search?q=repo%3Aleanprover-community%2Fmathlib4%20nonrec&amp;type=code">a handful of places</a>)</p>



<a name="323252494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323252494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323252494">(Jan 24 2023 at 13:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/nonrec.20vs.20_root_/near/323250866">said</a>:</p>
<blockquote>
<p>Note there is <a href="https://github.com/leanprover-community/mathlib4/blame/805f2c31304edc654c1634d1d1b93a89f0797e61/Mathlib/Tactic/Core.lean#L33">a comment in mathlib4 already</a> by <span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> saying</p>
<blockquote>
<p><code>-- nonrec only matters for name resolution, so is irrelevant (?)</code></p>
</blockquote>
<p>(it's used in <a href="https://github.com/search?q=repo%3Aleanprover-community%2Fmathlib4%20nonrec&amp;type=code">a handful of places</a>)</p>
</blockquote>
<p>I can't speak for the justification of usage in each instance. But in general, the less unnecessary conceptual overload in the features we use, the better.  As you say, if <code>X</code> is designed to do <code>Y</code> and does the job, why have another feature <code>Z</code> which might do the job but introduce refactoring headaches later, when the need to give <code>Z</code> its full conceptual meaning might eventually arise.</p>



<a name="323253174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323253174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323253174">(Jan 24 2023 at 13:38)</a>:</h4>
<blockquote>
<p>I can't speak for the justification of usage in each instance. </p>
</blockquote>
<p>If you look through the zulip / PR history you will find that all the uses were motivated by resolving namespace issues, and not wanting to qualify the name.</p>



<a name="323254489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323254489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323254489">(Jan 24 2023 at 13:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/nonrec.20vs.20_root_/near/323253174">said</a>:</p>
<blockquote>
<blockquote>
<p>I can't speak for the justification of usage in each instance. </p>
</blockquote>
<p>If you look through the zulip / PR history you will find that all the uses were motivated by resolving namespace issues, and not wanting to qualify the name.</p>
</blockquote>
<p>Well then if someone ever thinks about expanding on <code>nonrec</code>,  they have to consider how their change affects each of these PRs. If I use namespace disambiguation then I am ensuring that there is one less PR to consider. Plus it's not like one of those long Java names which are a pain to qualify.</p>



<a name="323274287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323274287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323274287">(Jan 24 2023 at 15:01)</a>:</h4>
<p><code>nonrec</code> does have an effect on the typechecker: it does not put a certain auxiliary local variable in the context representing the definition itself. Besides this it does nothing.</p>
<p>Lean automatically detects whether definitions are recursive. This is a very important thing for the kernel and for users, because recursive definitions have to have a termination argument one way or another so it's hard to miss, and this is what actually matters, not the presence or absence of the <code>nonrec</code> modifier which is only affecting name resolution by putting that auxiliary local decl in.</p>



<a name="323274662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323274662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323274662">(Jan 24 2023 at 15:02)</a>:</h4>
<p>It's generally a fool's errand to try to protect against future changes to language features, because those are incredibly hard to predict. Rather, the onus is on the later development to fix all existing uses of the language feature if it changes</p>



<a name="323276265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323276265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323276265">(Jan 24 2023 at 15:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/nonrec.20vs.20_root_/near/323274287">said</a>:</p>
<blockquote>
<p><code>nonrec</code> does have an effect on the typechecker: it does not put a certain auxiliary local variable in the context representing the definition itself. Besides this it does nothing.</p>
<p>Lean automatically detects whether definitions are recursive. This is a very important thing for the kernel and for users, because recursive definitions have to have a termination argument one way or another so it's hard to miss, and this is what actually matters, not the presence or absence of the <code>nonrec</code> modifier which is only affecting name resolution by putting that auxiliary local decl in.</p>
</blockquote>
<p>If lean knows this information (recursive or not), why have a separate keyword to just avoid putting this auxiliary variable in the context?</p>



<a name="323276777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323276777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323276777">(Jan 24 2023 at 15:10)</a>:</h4>
<p>or maybe the correct question is (I am not sure): what is the benefit of having this variable in the context when type-checking a non-recursive definition?</p>



<a name="323276987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323276987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323276987">(Jan 24 2023 at 15:11)</a>:</h4>
<p>because the <code>nonrec</code> keyword isn't about whether the definition is in fact recursive or not, it is about what <code>foo</code> refers to inside the body of <code>def foo := ...</code>: does it refer to the declaration itself, or to the last thing opened / in namespace scope with name <code>foo</code>?</p>



<a name="323277127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323277127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323277127">(Jan 24 2023 at 15:12)</a>:</h4>
<p>Of course if you use <code>nonrec</code> then you can't refer to <code>foo</code> in its own declaration so a forteriori the declaration is non-recursive</p>



<a name="323277258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323277258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323277258">(Jan 24 2023 at 15:12)</a>:</h4>
<p>but you can (and in most cases, we do) write non-recursive definitions that are not <code>nonrec</code></p>



<a name="323277464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323277464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323277464">(Jan 24 2023 at 15:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="466334">Shreyas Srinivas</span> <a href="#narrow/stream/287929-mathlib4/topic/nonrec.20vs.20_root_/near/323276777">said</a>:</p>
<blockquote>
<p>or maybe the correct question is (I am not sure): what is the benefit of having this variable in the context when type-checking a non-recursive definition?</p>
</blockquote>
<p>The benefit is that you don't have to say whether the definition is recursive or not, lean just does the right thing regardless</p>



<a name="323277599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323277599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323277599">(Jan 24 2023 at 15:13)</a>:</h4>
<p>the <code>nonrec</code> modifier was added specifically to fix the name resolution issues</p>



<a name="323277888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323277888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323277888">(Jan 24 2023 at 15:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/nonrec.20vs.20_root_/near/323276987">said</a>:</p>
<blockquote>
<p>because the <code>nonrec</code> keyword isn't about whether the definition is in fact recursive or not, it is about what <code>foo</code> refers to inside the body of <code>def foo := ...</code>: does it refer to the declaration itself, or to the last thing opened / in namespace scope with name <code>foo</code>?</p>
</blockquote>
<p>I get this part. What I don't get is why this is not the default behaviour for a def that is seen as non-recursive. If there is a non-recursive <code>def foo</code>,  what is the purpose served by a <code>foo</code> in the context, that refers to the declaration itself?</p>



<a name="323278006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323278006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323278006">(Jan 24 2023 at 15:14)</a>:</h4>
<p>in particular, it is relevant for lean 3 porting, since lean 3 acts like all definitions are <code>nonrec</code> unless they use the equation compiler style (<code>def foo | _ := ...</code>)</p>



<a name="323278172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323278172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323278172">(Jan 24 2023 at 15:15)</a>:</h4>
<blockquote>
<p>I get this part. What I don't get is why this is not the default behaviour for a def that is seen as non-recursive. If there is a non-recursive def foo, what is the purpose served by a foo in the context, that refers to the declaration itself?</p>
</blockquote>
<p>How would lean know that the definition is not recursive if it refers to <code>foo</code>?</p>



<a name="323278218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323278218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323278218">(Jan 24 2023 at 15:15)</a>:</h4>
<p>if I write <code>def foo := foo</code> is it recursive or not?</p>



<a name="323278305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323278305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323278305">(Jan 24 2023 at 15:15)</a>:</h4>
<p>it could be either one, depending on what <code>foo</code> is supposed to resolve to</p>



<a name="323278407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323278407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323278407">(Jan 24 2023 at 15:16)</a>:</h4>
<p>lean doesn't know the user's intent in advance in this situation</p>



<a name="323278542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323278542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323278542">(Jan 24 2023 at 15:16)</a>:</h4>
<p>But you said this : " Lean automatically detects whether definitions are recursive. This is a very important thing for the kernel and for users, because recursive definitions have to have a termination argument one way or another so it's hard to miss"</p>



<a name="323278592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323278592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323278592">(Jan 24 2023 at 15:16)</a>:</h4>
<p>yes</p>



<a name="323278779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323278779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323278779">(Jan 24 2023 at 15:17)</a>:</h4>
<p>the answer to my question is: lean 4 will say that <code>def foo := foo</code> is a recursive definition, because the second <code>foo</code> is determined to refer to the first one</p>



<a name="323278831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323278831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323278831">(Jan 24 2023 at 15:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/nonrec.20vs.20_root_/near/323278218">said</a>:</p>
<blockquote>
<p>if I write <code>def foo := foo</code> is it recursive or not?</p>
</blockquote>
<p>presumably lean can't find this termination argument, and concludes that this is non-recursive.</p>



<a name="323279022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323279022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323279022">(Jan 24 2023 at 15:18)</a>:</h4>
<p>no, that's not how it works, the termination argument comes later, long after name resolution</p>



<a name="323279099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323279099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323279099">(Jan 24 2023 at 15:18)</a>:</h4>
<p>lean 3 will say that <code>def foo := foo</code> is not a recursive definition, and assuming that some other <code>foo</code> is in scope we have declared an alias to it</p>



<a name="323279231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323279231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323279231">(Jan 24 2023 at 15:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="466334">Shreyas Srinivas</span> <a href="#narrow/stream/287929-mathlib4/topic/nonrec.20vs.20_root_/near/323278542">said</a>:</p>
<blockquote>
<p>But you said this : " Lean automatically detects whether definitions are recursive. This is a very important thing for the kernel and for users, because recursive definitions have to have a termination argument one way or another so it's hard to miss"</p>
</blockquote>
<p>I am reluctant to add to the amount of words already spent on this topic, but:<br>
Lean determines whether the definition is recursive <em>after</em> resolving names (and executing tactics, and maybe other things).<br>
<code>nonrec</code> affects how the process of resolving names (and executing tactics) happens, because it affects whether <code>foo</code> is in scope in its own definition.</p>



<a name="323279236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323279236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323279236">(Jan 24 2023 at 15:18)</a>:</h4>
<p>if there is no <code>foo</code> in scope prior to that point it will just give an error "<code>foo</code> is unknown identifier"</p>



<a name="323279288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323279288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323279288">(Jan 24 2023 at 15:19)</a>:</h4>
<p>Yes that's correct</p>



<a name="323279400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323279400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323279400">(Jan 24 2023 at 15:19)</a>:</h4>
<p>that's why we are saying that <code>nonrec</code> is about name resolution</p>



<a name="323279609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323279609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323279609">(Jan 24 2023 at 15:20)</a>:</h4>
<p>(Note that WRT the original motivation for this thread, I pushed a commit that uses <code>protected</code> instead of either <code>_root_</code> or <code>nonrec</code>, since I think the actual problem in that PR is that a new name clash appeared that wasn't present in mathlib3)</p>



<a name="323279620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323279620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323279620">(Jan 24 2023 at 15:20)</a>:</h4>
<p>As regards the title question, I don't have any particular preference one way or another</p>



<a name="323279737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323279737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323279737">(Jan 24 2023 at 15:20)</a>:</h4>
<p>I think we should allow both methods based on whatever looks cleaner in context</p>



<a name="323280144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323280144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323280144">(Jan 24 2023 at 15:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/287929-mathlib4/topic/nonrec.20vs.20_root_/near/323279231">said</a>:</p>
<blockquote>
<p>I am reluctant to add to the amount of words already spent on this topic, but:<br>
Lean determines whether the definition is recursive <em>after</em> resolving names (and executing tactics, and maybe other things).<br>
<code>nonrec</code> affects how the process of resolving names (and executing tactics) happens, because it affects whether <code>foo</code> is in scope in its own definition.</p>
</blockquote>
<p>Ah, so concluding from this comment and Mario's about lean3, the behaviour  (determines whether the definition is recursive after resolving names) you describe is specific to lean 4. Is that correct?</p>



<a name="323280522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323280522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323280522">(Jan 24 2023 at 15:23)</a>:</h4>
<p>you could say that in lean 3 the <code>nonrec</code> modifier was implicitly specified by whether the definition was written like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ty</span><span class="o">)</span> <span class="o">:</span> <span class="n">ty</span> <span class="o">:=</span> <span class="n">e</span> <span class="c1">-- nonrec</span>
</code></pre></div>
<p>or </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">ty</span> <span class="bp">-&gt;</span> <span class="n">ty</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">e</span> <span class="c1">-- recursive</span>
</code></pre></div>



<a name="323280715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323280715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323280715">(Jan 24 2023 at 15:24)</a>:</h4>
<p>Lean3 has no equivalent of Lean4's <code>partial def foo := foo</code>, right? I can't find a way to match on no arguments</p>



<a name="323280859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323280859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323280859">(Jan 24 2023 at 15:24)</a>:</h4>
<p>right, you need at least one argument to use the equation compiler, which is good since recursive values are nonsensical</p>



<a name="323281372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323281372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323281372">(Jan 24 2023 at 15:26)</a>:</h4>
<p>sometimes it requires rewriting the definition in an odd style, see for example <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.rcases_patt_parse_hi'/src">src#tactic.rcases_patt_parse_hi'</a></p>



<a name="323282109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323282109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323282109">(Jan 24 2023 at 15:29)</a>:</h4>
<p>Btw, is this internal stuff documented somewhere in one place? Seems useful.</p>



<a name="323283153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323283153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323283153">(Jan 24 2023 at 15:33)</a>:</h4>
<p>the answer is always no :P but doc improvements are always welcome</p>



<a name="323285876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323285876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323285876">(Jan 24 2023 at 15:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/287929-mathlib4/topic/nonrec.20vs.20_root_/near/323283153">said</a>:</p>
<blockquote>
<p>the answer is always no :P but doc improvements are always welcome</p>
</blockquote>
<p>Writing proper documentation is highly non-trivial. For instance I might naively add all this stuff to, say, the doc page of <code>nonrec</code>. But the information about when lean4 classifies definitions as recursive (and comparison with how lean3 does this), might be of broader interest. </p>
<p>For the moment I will content myself with starred messages.</p>



<a name="323289763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323289763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323289763">(Jan 24 2023 at 15:59)</a>:</h4>
<p>Does <code>nonrec</code> even have a doc page?</p>



<a name="323292998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323292998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323292998">(Jan 24 2023 at 16:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/287929-mathlib4/topic/nonrec.20vs.20_root_/near/323289763">said</a>:</p>
<blockquote>
<p>Does <code>nonrec</code> even have a doc page?</p>
</blockquote>
<p>No idea. It was a hypothetical example to illustrate how things could go wrong.</p>



<a name="323296245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/%E2%9C%94%20nonrec%20vs%20_root_/near/323296245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/287929-mathlib4/topic/.E2.9C.94.20nonrec.20vs.20_root_.html#323296245">(Jan 24 2023 at 16:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="466334">Shreyas Srinivas</span> has marked this topic as resolved.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/can't.20find.20instance.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html">can't find instance</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="304201094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304201094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304201094">(Oct 15 2022 at 13:29)</a>:</h4>
<p>Hi, I'm trying to refactor the <code>quiver</code> code a bit and got into some instance troubles.<br>
<a href="https://github.com/bottine/mathlib/blob/3263f73f5f6d243f38f8bf64ce886739d23bd6ad/src/combinatorics/quiver/connected_component.lean#L57">here</a>, lean doesn't find the necessary <code>quiver</code> instance on <code>V</code>, even though I have an instance as a variable.<br>
I'm pretty sure it's related to universe incompatibilities, but can't really figure out where they come from.<br>
I can't really get a MWE out of that: what kind of approach should I take to debug this?</p>



<a name="304201966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304201966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304201966">(Oct 15 2022 at 13:37)</a>:</h4>
<p>Try <code>set_option pp.universes true</code></p>



<a name="304202191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304202191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304202191">(Oct 15 2022 at 13:39)</a>:</h4>
<p>OK, I get</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">quiver.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u</span><span class="o">}</span> <span class="n">V</span><span class="o">,</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">wide_subquiver.</span><span class="o">{</span><span class="n">u</span> <span class="bp">?</span><span class="n">l_1</span><span class="o">}</span> <span class="o">(</span><span class="n">symmetrify.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">V</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="n">quiver.</span><span class="o">{</span><span class="bp">?</span><span class="n">l_2</span><span class="bp">+</span><span class="mi">1</span> <span class="n">u</span><span class="o">}</span> <span class="n">V</span>
</code></pre></div>
<p>which I guess is related to the transition to <code>psum</code>, maybe?</p>



<a name="304202286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304202286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304202286">(Oct 15 2022 at 13:39)</a>:</h4>
<p>Yeah, very possible...</p>



<a name="304203103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304203103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304203103">(Oct 15 2022 at 13:45)</a>:</h4>
<p>Alright… I'm a bit clueless as to how to fix that so I might leave that aside for a while. Thanks!</p>



<a name="304203480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304203480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304203480">(Oct 15 2022 at 13:49)</a>:</h4>
<p>This feels like a <code>Type</code> vs <code>Sort</code> issue</p>



<a name="304204534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304204534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304204534">(Oct 15 2022 at 13:59)</a>:</h4>
<p>Indeed, but no idea what's the cause</p>



<a name="304205025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304205025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304205025">(Oct 15 2022 at 14:02)</a>:</h4>
<p>Do things become more obvious if you use <code>[quiver.{v} V]</code> for a new universe <code>v</code>?</p>



<a name="304205286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304205286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304205286">(Oct 15 2022 at 14:05)</a>:</h4>
<p>I would guess that <code>quiver.{v+1} V</code> solves the issue</p>



<a name="304205357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304205357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304205357">(Oct 15 2022 at 14:05)</a>:</h4>
<p>let me see</p>



<a name="304205391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304205391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304205391">(Oct 15 2022 at 14:05)</a>:</h4>
<p>lol, it does…</p>



<a name="304205472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304205472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304205472">(Oct 15 2022 at 14:06)</a>:</h4>
<p>But am I risking a kind of domino effect here where the <code>+1</code> has to be appended everytime?</p>



<a name="304206009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304206009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304206009">(Oct 15 2022 at 14:10)</a>:</h4>
<p>I expect the real solution is to change a <code>Type</code> to a <code>Sort</code> somewhere</p>



<a name="304206492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304206492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304206492">(Oct 15 2022 at 14:14)</a>:</h4>
<p>One of the thing I did was change <code>symmetrify</code> from being defined as  <code>sum (x --&gt; y) (y --&gt; X)</code> to <code>psum …</code>, so that I can symmetrify a <code>Prop</code>ositional quiver. This could mean that this is simply incompatible with doing things cleanly?</p>



<a name="304206957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304206957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304206957">(Oct 15 2022 at 14:19)</a>:</h4>
<p>Does <code>V : Sort*</code> work?</p>



<a name="304207352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304207352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304207352">(Oct 15 2022 at 14:22)</a>:</h4>
<p>quivers take <code>V : Type*</code>, so doing that would imply redefining quivers themselves, no?</p>



<a name="304207377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304207377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304207377">(Oct 15 2022 at 14:22)</a>:</h4>
<p>I'm trying, but it's not entirely mechanical afaict</p>



<a name="304207467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304207467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304207467">(Oct 15 2022 at 14:23)</a>:</h4>
<p>(and redefining quivers would redefine categories I guess… which looks quite dangerous to me)</p>



<a name="304207469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304207469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304207469">(Oct 15 2022 at 14:23)</a>:</h4>
<p>Do they? <a href="https://leanprover-community.github.io/mathlib_docs/find/quiver">docs#quiver</a></p>



<a name="304207556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304207556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304207556">(Oct 15 2022 at 14:24)</a>:</h4>
<p>Yes, there's a difference between the index type and the return type of the homs.</p>



<a name="304207574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304207574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304207574">(Oct 15 2022 at 14:24)</a>:</h4>
<p>Yes. Then my <code>Sort</code> suggestion is a bad idea!</p>



<a name="304207642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304207642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304207642">(Oct 15 2022 at 14:24)</a>:</h4>
<p>(haha I'm relieved I don't have to go there :) )</p>



<a name="304207869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304207869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304207869">(Oct 15 2022 at 14:26)</a>:</h4>
<p>Maybe <a href="https://leanprover-community.github.io/mathlib_docs/find/wide_subquiver">docs#wide_subquiver</a> is the issue?</p>



<a name="304208523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304208523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304208523">(Oct 15 2022 at 14:32)</a>:</h4>
<p>Mmh, that would make sense, and then I'd only have to "up" the level there, but I actually get other errors somewhere else also related to bad universes.</p>
<p>To be more precise: now it's <code>category_theory/groupoid/free_groupoid.lean</code> that complains: the abbreviations at the beginning fail already.</p>



<a name="304208760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304208760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304208760">(Oct 15 2022 at 14:34)</a>:</h4>
<p>Doesn't <code>set</code> support <code>Prop</code> types?</p>



<a name="304209357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304209357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304209357">(Oct 15 2022 at 14:39)</a>:</h4>
<p>Bargh, got to go, thanks for the help debugging this!</p>



<a name="304210595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304210595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304210595">(Oct 15 2022 at 14:49)</a>:</h4>
<p>Scott Morrison once tried to generalise the category theory library so that it allowed morphisms to take values in Sort u rather than Type u and after some struggling he gave up on the idea and reverted. This feels like the same sort of thing</p>



<a name="304210780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304210780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304210780">(Oct 15 2022 at 14:51)</a>:</h4>
<p>... which is really a shame, because that would allow us to unify orders and categories.</p>



<a name="304217797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/304217797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#304217797">(Oct 15 2022 at 15:54)</a>:</h4>
<p>mmh, that's sad indeed</p>



<a name="315305321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/315305321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#315305321">(Dec 12 2022 at 07:45)</a>:</h4>
<p>The <code>symmetrify</code> code has been ported to mathlib4, and it seems the universe problem disappears, so that one should be able to take <code>symmetrify V</code> as a <code>PSum</code> rather than a <code>Sum</code>. Is making such a change incompatible with the port having to be kind of 1-1 ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Copyright (c) 2021 David Wärn. All rights reserved.</span>
<span class="cm">Released under Apache 2.0 license as described in the file LICENSE.</span>
<span class="cm">Authors: David Wärn</span>
<span class="cm">Ported by: Joël Riou</span>
<span class="cm">-/</span>
<span class="kn">import</span> <span class="n">Mathlib.Combinatorics.Quiver.Subquiver</span>
<span class="kn">import</span> <span class="n">Mathlib.Combinatorics.Quiver.Path</span>
<span class="kn">import</span> <span class="n">Mathlib.Data.Sum.Basic</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm">## Weakly connected components</span>

<span class="cm">For a quiver `V`, we build a quiver `Symmetrify V` by adding a reversal of every edge.</span>
<span class="cm">Informally, a path in `Symmetrify V` corresponds to a 'zigzag' in `V`. This lets us</span>
<span class="cm">define the type `WeaklyConnectedComponent V` as the quotient of `V` by the relation which</span>
<span class="cm">identifies `a` with `b` if there is a path from `a` to `b` in `Symmetrify V`. (These</span>
<span class="cm">zigzags can be seen as a proof-relevant analogue of `EqvGen`.)</span>

<span class="cm">Strongly connected components have not yet been defined.</span>
<span class="cm">-/</span>

<span class="kd">universe</span> <span class="n">v</span> <span class="n">u</span>

<span class="kn">namespace</span> <span class="n">Quiver</span>

<span class="sd">/-- A type synonym for the symmetrized quiver (with an arrow both ways for each original arrow).</span>
<span class="sd">    NB: this does not work for `Prop`-valued quivers. It requires `[Quiver.{v+1} V]`. -/</span>
<span class="c1">-- Porting note: no hasNonemptyInstnace linter yet</span>
<span class="kd">def</span> <span class="n">Symmetrify</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">V</span>

<span class="kd">instance</span> <span class="n">symmetrifyQuiver</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Quiver</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="n">Quiver</span> <span class="o">(</span><span class="n">Symmetrify</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="k">fun</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">↦</span> <span class="n">PSum</span> <span class="o">(</span><span class="n">a</span> <span class="bp">⟶</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="bp">⟶</span> <span class="n">a</span><span class="o">)⟩</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Quiver</span> <span class="n">V</span><span class="o">]</span>

<span class="sd">/-- A quiver `HasReverse` if we can reverse an arrow `p` from `a` to `b` to get an arrow</span>
<span class="sd">    `p.reverse` from `b` to `a`.-/</span>
<span class="kd">class</span> <span class="n">HasReverse</span> <span class="n">where</span>
  <span class="sd">/-- the map which sends an arrow to its reverse -/</span>
  <span class="n">reverse'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="o">(</span><span class="n">a</span> <span class="bp">⟶</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">b</span> <span class="bp">⟶</span> <span class="n">a</span><span class="o">)</span>

<span class="sd">/-- Reverse the direction of an arrow. -/</span>
<span class="kd">def</span> <span class="n">reverse</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">[</span><span class="n">Quiver</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">HasReverse</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">⟶</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">b</span> <span class="bp">⟶</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">HasReverse.reverse'</span>

<span class="sd">/-- A quiver `HasInvolutiveReverse` if reversing twice is the identity.`-/</span>
<span class="kd">class</span> <span class="n">HasInvolutiveReverse</span> <span class="kd">extends</span> <span class="n">HasReverse</span> <span class="n">V</span> <span class="n">where</span>
  <span class="sd">/-- `reverse` is involutive -/</span>
  <span class="n">inv'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">⟶</span> <span class="n">b</span><span class="o">),</span> <span class="n">reverse</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">reverse_reverse</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">[</span><span class="n">Quiver</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">HasInvolutiveReverse</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">⟶</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">reverse</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">h.inv'</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">HasReverse</span> <span class="o">(</span><span class="n">Symmetrify</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="k">fun</span> <span class="n">e</span> <span class="bp">↦</span> <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
            <span class="bp">|</span> <span class="o">(</span><span class="n">PSum.inl</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">PSum.inr</span> <span class="n">f</span>
            <span class="bp">|</span> <span class="o">(</span><span class="n">PSum.inr</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">PSum.inl</span> <span class="n">f</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span>
    <span class="n">HasInvolutiveReverse</span>
      <span class="o">(</span><span class="n">Symmetrify</span> <span class="n">V</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">toHasReverse</span> <span class="o">:=</span> <span class="o">⟨</span><span class="k">fun</span> <span class="n">e</span> <span class="bp">↦</span>
    <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">PSum.inl</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">PSum.inr</span> <span class="n">f</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">PSum.inr</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">PSum.inl</span> <span class="n">f</span><span class="o">⟩</span>
  <span class="n">inv'</span> <span class="n">e</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">PSum.inl</span> <span class="n">_</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">PSum.inr</span> <span class="n">_</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>

<span class="sd">/-- Reverse the direction of a path. -/</span>
<span class="kd">@[simp]</span>
<span class="kd">def</span> <span class="n">Path.reverse</span> <span class="o">[</span><span class="n">HasReverse</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">b</span><span class="o">},</span> <span class="n">Path</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">Path</span> <span class="n">b</span> <span class="n">a</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">Path.nil</span> <span class="bp">=&gt;</span> <span class="n">Path.nil</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">Path.cons</span> <span class="n">p</span> <span class="n">e</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">Quiver.reverse</span> <span class="n">e</span><span class="o">)</span><span class="bp">.</span><span class="n">toPath.comp</span> <span class="n">p.reverse</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">Path.reverse_toPath</span> <span class="o">[</span><span class="n">HasReverse</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">⟶</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">f.toPath.reverse</span> <span class="bp">=</span> <span class="o">(</span><span class="n">Quiver.reverse</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">toPath</span> <span class="o">:=</span>
  <span class="n">rfl</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">quiver.path.reverse_to_path</span> <span class="n">Quiver.Path.reverse_toPath</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">Path.reverse_comp</span> <span class="o">[</span><span class="n">HasReverse</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Path</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Path</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">p.comp</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">reverse</span> <span class="bp">=</span> <span class="n">q.reverse.comp</span> <span class="n">p.reverse</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction'</span> <span class="n">q</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span>
  <span class="bp">·</span> <span class="n">simp</span>
  <span class="bp">·</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">Path.reverse_reverse</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">HasInvolutiveReverse</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Path</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">p.reverse.reverse</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction'</span> <span class="n">p</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span>
  <span class="bp">·</span> <span class="n">simp</span>
  <span class="bp">·</span> <span class="n">rw</span> <span class="o">[</span><span class="n">Path.reverse</span><span class="o">,</span> <span class="n">Path.reverse_comp</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">Path.reverse_toPath</span><span class="o">,</span> <span class="n">Quiver.reverse_reverse</span><span class="o">]</span>
    <span class="n">rfl</span>

<span class="sd">/-- The inclusion of a quiver in its symmetrification -/</span>
<span class="kd">def</span> <span class="n">Symmetrify.of</span> <span class="o">:</span> <span class="n">Prefunctor</span> <span class="n">V</span> <span class="o">(</span><span class="n">Symmetrify</span> <span class="n">V</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">obj</span> <span class="o">:=</span> <span class="n">id</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="n">PSum.inl</span>

<span class="sd">/-- Given a quiver `V'` with reversible arrows, a prefunctor to `V'` can be lifted to one from</span>
<span class="sd">    `Symmetrify V` to `V'` -/</span>
<span class="kd">def</span> <span class="n">Symmetrify.lift</span> <span class="o">{</span><span class="n">V'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">Quiver</span> <span class="n">V'</span><span class="o">]</span> <span class="o">[</span><span class="n">HasReverse</span> <span class="n">V'</span><span class="o">]</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">Prefunctor</span> <span class="n">V</span> <span class="n">V'</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">Prefunctor</span> <span class="o">(</span><span class="n">Symmetrify</span> <span class="n">V</span><span class="o">)</span> <span class="n">V'</span> <span class="n">where</span>
  <span class="n">obj</span> <span class="o">:=</span> <span class="n">φ.obj</span>
  <span class="n">map</span> <span class="n">f</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">f</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">PSum.inl</span> <span class="n">g</span> <span class="bp">=&gt;</span> <span class="n">φ.map</span> <span class="n">g</span>
  <span class="bp">|</span> <span class="n">PSum.inr</span> <span class="n">g</span> <span class="bp">=&gt;</span> <span class="n">reverse</span> <span class="o">(</span><span class="n">φ.map</span> <span class="n">g</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">Symmetrify.lift_spec</span> <span class="o">(</span><span class="n">V'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">Quiver</span> <span class="n">V'</span><span class="o">]</span> <span class="o">[</span><span class="n">HasReverse</span> <span class="n">V'</span><span class="o">]</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">Prefunctor</span> <span class="n">V</span> <span class="n">V'</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">Symmetrify.of.comp</span> <span class="o">(</span><span class="n">Symmetrify.lift</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">φ</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">fapply</span> <span class="n">Prefunctor.ext</span>
  <span class="bp">·</span> <span class="n">rintro</span> <span class="n">X</span>
    <span class="n">rfl</span>
  <span class="bp">·</span> <span class="n">rintro</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span>
    <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">Symmetrify.lift_reverse</span> <span class="o">(</span><span class="n">V'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">Quiver</span> <span class="n">V'</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">HasInvolutiveReverse</span> <span class="n">V'</span><span class="o">]</span>
    <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">Prefunctor</span> <span class="n">V</span> <span class="n">V'</span><span class="o">)</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Symmetrify</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">Symmetrify.lift</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">Quiver.reverse</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Quiver.reverse</span> <span class="o">((</span><span class="n">Symmetrify.lift</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">Symmetrify.lift</span><span class="o">]</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">f</span>
  <span class="bp">·</span> <span class="n">simp</span> <span class="n">only</span>
    <span class="n">rfl</span>
  <span class="bp">·</span> <span class="n">simp</span> <span class="n">only</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">h.inv'</span><span class="o">]</span>
    <span class="n">rfl</span>

<span class="sd">/-- `lift φ` is the only prefunctor extending `φ` and preserving reverses. -/</span>
<span class="kd">theorem</span> <span class="n">Symmetrify.lift_unique</span> <span class="o">(</span><span class="n">V'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">Quiver</span> <span class="n">V'</span><span class="o">]</span> <span class="o">[</span><span class="n">HasReverse</span> <span class="n">V'</span><span class="o">]</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">Prefunctor</span> <span class="n">V</span> <span class="n">V'</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">Φ</span> <span class="o">:</span> <span class="n">Prefunctor</span> <span class="o">(</span><span class="n">Symmetrify</span> <span class="n">V</span><span class="o">)</span> <span class="n">V'</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="bp">Φ</span> <span class="o">:</span> <span class="n">Symmetrify.of.comp</span> <span class="bp">Φ</span> <span class="bp">=</span> <span class="n">φ</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h</span><span class="bp">Φ</span><span class="n">inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Symmetrify</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">),</span>
      <span class="bp">Φ.</span><span class="n">map</span> <span class="o">(</span><span class="n">Quiver.reverse</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Quiver.reverse</span> <span class="o">(</span><span class="bp">Φ.</span><span class="n">map</span> <span class="n">f</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">Φ</span> <span class="bp">=</span> <span class="n">Symmetrify.lift</span> <span class="n">φ</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">subst_vars</span>
  <span class="n">fapply</span> <span class="n">Prefunctor.ext</span>
  <span class="bp">·</span> <span class="n">rintro</span> <span class="n">X</span>
    <span class="n">rfl</span>
  <span class="bp">·</span> <span class="n">rintro</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span>
    <span class="n">cases</span> <span class="n">f</span>
    <span class="bp">·</span> <span class="n">rfl</span>
    <span class="bp">·</span> <span class="n">exact</span> <span class="n">h</span><span class="bp">Φ</span><span class="n">inv</span> <span class="o">(</span><span class="n">PSum.inl</span> <span class="n">_</span><span class="o">)</span>
<span class="bp">#</span><span class="n">align</span> <span class="n">quiver.symmetrify.lift_unique</span> <span class="n">Quiver.Symmetrify.lift_unique</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">V</span><span class="o">)</span>

<span class="sd">/-- Two vertices are related in the zigzag setoid if there is a</span>
<span class="sd">    zigzag of arrows from one to the other. -/</span>
<span class="kd">def</span> <span class="n">zigzagSetoid</span> <span class="o">:</span> <span class="n">Setoid</span> <span class="n">V</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="k">fun</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↦</span> <span class="n">Nonempty</span> <span class="o">(</span><span class="bp">@</span><span class="n">Path</span> <span class="o">(</span><span class="n">Symmetrify</span> <span class="n">V</span><span class="o">)</span> <span class="n">_</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">↦</span> <span class="o">⟨</span><span class="n">Path.nil</span><span class="o">⟩,</span> <span class="k">fun</span> <span class="o">⟨</span><span class="n">p</span><span class="o">⟩</span> <span class="bp">↦</span>
    <span class="o">⟨</span><span class="n">p.reverse</span><span class="o">⟩,</span> <span class="k">fun</span> <span class="o">⟨</span><span class="n">p</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">q</span><span class="o">⟩</span> <span class="bp">↦</span> <span class="o">⟨</span><span class="n">p.comp</span> <span class="n">q</span><span class="o">⟩⟩</span>

<span class="sd">/-- The type of weakly connected components of a directed graph. Two vertices are</span>
<span class="sd">    in the same weakly connected component if there is a zigzag of arrows from one</span>
<span class="sd">    to the other. -/</span>
<span class="kd">def</span> <span class="n">WeaklyConnectedComponent</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
  <span class="n">Quotient</span> <span class="o">(</span><span class="n">zigzagSetoid</span> <span class="n">V</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">WeaklyConnectedComponent</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span>

<span class="sd">/-- The weakly connected component corresponding to a vertex. -/</span>
<span class="kn">protected</span> <span class="kd">def</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">WeaklyConnectedComponent</span> <span class="n">V</span> <span class="o">:=</span>
  <span class="bp">@</span><span class="n">Quotient.mk'</span> <span class="n">_</span> <span class="o">(</span><span class="n">zigzagSetoid</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">CoeTC</span> <span class="n">V</span> <span class="o">(</span><span class="n">WeaklyConnectedComponent</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">WeaklyConnectedComponent.mk</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="n">Inhabited</span> <span class="o">(</span><span class="n">WeaklyConnectedComponent</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="k">show</span> <span class="n">V</span> <span class="k">from</span> <span class="n">default</span><span class="o">⟩</span>

<span class="kn">protected</span> <span class="kd">theorem</span> <span class="n">eq</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">WeaklyConnectedComponent</span> <span class="n">V</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">Nonempty</span> <span class="o">(</span><span class="bp">@</span><span class="n">Path</span> <span class="o">(</span><span class="n">Symmetrify</span> <span class="n">V</span><span class="o">)</span> <span class="n">_</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">Quotient.eq'</span>

<span class="kd">end</span> <span class="n">WeaklyConnectedComponent</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span>

<span class="c1">-- Without the explicit universe level in `Quiver.{v+1}` Lean comes up with</span>
<span class="c1">-- `Quiver.{max u_2 u_3 + 1}`. This causes problems elsewhere, so we write `Quiver.{v+1}`.</span>
<span class="sd">/-- A wide subquiver `H` of `Symmetrify V` determines a wide subquiver of `V`, containing an</span>
<span class="sd">    an arrow `e` if either `e` or its reversal is in `H`. -/</span>
<span class="kd">def</span> <span class="n">wideSubquiverSymmetrify</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">WideSubquiver</span> <span class="o">(</span><span class="n">Symmetrify</span> <span class="n">V</span><span class="o">))</span> <span class="o">:</span> <span class="n">WideSubquiver</span> <span class="n">V</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">↦</span> <span class="o">{</span> <span class="n">e</span> <span class="bp">|</span> <span class="n">H</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">PSum.inl</span> <span class="n">e</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">H</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">PSum.inr</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">Quiver</span>
</code></pre></div>



<a name="315308404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/can%27t%20find%20instance/near/315308404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/can't.20find.20instance.html#315308404">(Dec 12 2022 at 08:06)</a>:</h4>
<p>My instinct is that the port should be 1-1 and any refractors should be done after it's complete.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/equality.20of.20types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html">equality of types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="232219842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232219842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232219842">(Mar 29 2021 at 05:21)</a>:</h4>
<p>I have the feeling that I don't fully understand yet the boundaries of how I can use the fact that two types are equal. Here's a MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>

<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">q</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">X</span>
<span class="kd">lemma</span> <span class="n">W_eq_X</span> <span class="o">:</span> <span class="n">W</span> <span class="bp">=</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">exists_X_eq_p</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">W</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- This fails:</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">    rewrite tactic failed, motive is not type correct</span>
<span class="cm">      λ (_a : Type ?), (∃ (x : W), q x) = p = ((∃ (x : _a), q x) = p)</span>
<span class="cm">    state:</span>
<span class="cm">    ⊢ (∃ (x : W), q x) = p</span>
<span class="cm">  -/</span>
  <span class="n">rw</span> <span class="n">W_eq_X</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">exists_X_eq_p</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">W</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- But this works, and does basically the same thing:</span>
  <span class="n">transitivity</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">),</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">exists_X_eq_p</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232219980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232219980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232219980">(Mar 29 2021 at 05:24)</a>:</h4>
<p>Here the types W and X are the same. But if I try to use that equality with <code>rw</code> / <code>rewrite</code>, I get an error.</p>
<p>But then on the other hand I can accomplish exactly the same thing -- that is, make exactly the same change to what the goal is, effectively replacing W with X -- by using <code>transitivity</code> with an appropriate argument, and then <code>refl</code>.</p>



<a name="232220367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232220367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232220367">(Mar 29 2021 at 05:30)</a>:</h4>
<p>One piece of this which I definitely don't understand is the error message: "motive is not type correct". I've seen "motive" mentioned in the documentation, in the context of explaining <code>rec</code> / <code>rec_on</code> for inductive types. So one specific question is: is this "motive" from a <code>rec</code> call that <code>rewrite</code> is using internally?</p>
<p>I don't really have a firm grasp of what it means there either, though, and would be grateful for any explanation of that.</p>
<p>Then: which piece of this is the "motive" that is not type correct? Is it that whole equality on the next line of the message? And what is the <code>_a : Type ?</code> in that equality?</p>



<a name="232220744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232220744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232220744">(Mar 29 2021 at 05:36)</a>:</h4>
<p>Stepping back from the specifics of the error message, I think I have an idea -- thanks to the process of producing this MWE -- of what may be the reason why the <code>rw W_eq_X</code> isn't accepted while the <code>transitivity …, refl</code> is.</p>
<p>I think perhaps the point is something to do with Lean wanting to verify that the types are not just equal, but definitionally equal, before accepting one as a substitute for another when it's being used in the type of some other variable. So the <code>transitivity</code> just introduces a new goal, which is fine, an equality between two expressions of type <code>Prop</code>, which is fine. And then <code>refl</code> asks Lean to look and see that in fact the types tucked inside, along with everything else, are definitionally equal and to discharge that goal.</p>



<a name="232220764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232220764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232220764">(Mar 29 2021 at 05:37)</a>:</h4>
<p>But in <code>rw W_eq_X</code>, I'm asking Lean to use the fact that those types are merely <em>equal</em>, as previously proven, and merely-equal isn't good enough.</p>



<a name="232220847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232220847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232220847">(Mar 29 2021 at 05:39)</a>:</h4>
<p>It happens that indeed that equality is a definitional equality -- in fact it was proven in the first place with just <code>rfl</code>. But the fact which I'm giving <code>rw</code> to try to use is the fact of mere equality.</p>



<a name="232221414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232221414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232221414">(Mar 29 2021 at 05:49)</a>:</h4>
<p>If that's right, then my practical question is: let's imagine that in a real development, W is some definition and X is the details of its construction, and I want to be able to refer to the thing by its name, W, in the statements of theorems, but then in their proofs I want to unpack it into its implementation X in order to get at the details.</p>
<p>I'd like to take the fact that W equals X, and package it up into some simp lemmas: maybe one for <code>W = X</code> itself, or maybe several for things like projections out of it. Or even non-simp lemmas -- but just lemmas that I can refer to by name, so I can pass them to <code>rw</code> or <code>simp</code> to specify what to do with some expression involving <code>W</code>.</p>
<p>And that works great, except that with the tools I've learned how to use so far, this doesn't seem to be possible where <code>W</code> is being used in a type. What are ways that people handle this?</p>



<a name="232222510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232222510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232222510">(Mar 29 2021 at 06:07)</a>:</h4>
<p>If <code>W = X</code> is a <code>rfl</code>, then <code>dsimp</code> should be able to apply it anywhere, incl. inside types.</p>



<a name="232222572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232222572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232222572">(Mar 29 2021 at 06:08)</a>:</h4>
<p>(though we don't use this style in mathlib, so I'm not completely sure that it'll work in all cases)</p>



<a name="232226395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232226395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232226395">(Mar 29 2021 at 07:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113489-new-members/topic/equality.20of.20types/near/232222510">said</a>:</p>
<blockquote>
<p>If <code>W = X</code> is a <code>rfl</code>, then <code>dsimp</code> should be able to apply it anywhere, incl. inside types.</p>
</blockquote>
<p>Oh very interesting, thanks!</p>



<a name="232226581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232226581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232226581">(Mar 29 2021 at 07:07)</a>:</h4>
<p>If this style isn't used in mathlib, what are the alternative idioms that are used instead?</p>
<p>Or perhaps the answer is that it depends a lot on the details -- in that case I can try to expand the example to be concrete enough for an answer.</p>



<a name="232226976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232226976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232226976">(Mar 29 2021 at 07:12)</a>:</h4>
<p>Trying out <code>dsimp</code> in my example, this works great:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">W</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">W_eq_X</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">exists_X_eq_p</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232236676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232236676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232236676">(Mar 29 2021 at 08:57)</a>:</h4>
<p>I think <code>subst W_eq_X</code> would work too</p>



<a name="232238472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232238472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232238472">(Mar 29 2021 at 09:13)</a>:</h4>
<p><code>dsimp</code> is fine; also <code>dunfold</code> and <code>delta</code> will do definitional rewriting</p>



<a name="232238672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232238672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232238672">(Mar 29 2021 at 09:15)</a>:</h4>
<p>The "motive is not type correct" error is because rewrite needs to generalize the variable in the position of <code>W</code>/<code>X</code>, and this variable is not defeq to either <code>W</code> or <code>X</code>, meaning that things that depend on it, like <code>Exists</code> in this case, will fail to type check</p>



<a name="232239131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232239131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232239131">(Mar 29 2021 at 09:19)</a>:</h4>
<p>This is a limitation of Lean's tactics, rather than a limitation of dependent type theory, right?</p>



<a name="232297448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232297448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232297448">(Mar 29 2021 at 16:40)</a>:</h4>
<p><code>subst</code> fails but for an unrelated reason:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">W</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  subst tactic failed, given expression is not a local constant</span>
<span class="cm">  state:</span>
<span class="cm">  ⊢ (∃ (x : W), q x) = p</span>
<span class="cm">  -/</span>
  <span class="n">subst</span> <span class="n">W_eq_X</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">exists_X_eq_p</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232297906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232297906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232297906">(Mar 29 2021 at 16:44)</a>:</h4>
<p>I think it's saying that it will only work if the thing being replaced, here <code>W</code>, is a local constant i.e. from the local context. I'm pretty sure I've run into this in situations where that applied, too, so that may also come in handy.</p>



<a name="232298031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232298031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232298031">(Mar 29 2021 at 16:45)</a>:</h4>
<p>Right, at least one side of the equality has to be a variable for <code>subst</code> to apply</p>



<a name="232298211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232298211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232298211">(Mar 29 2021 at 16:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/equality.20of.20types/near/232238472">said</a>:</p>
<blockquote>
<p><code>dsimp</code> is fine; also <code>dunfold</code> and <code>delta</code> will do definitional rewriting</p>
</blockquote>
<p>These also work, thanks! I had not seen those tactics before.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">W</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dunfold</span> <span class="n">W</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">exists_X_eq_p</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">W</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">delta</span> <span class="n">W</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">exists_X_eq_p</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232298263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232298263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232298263">(Mar 29 2021 at 16:46)</a>:</h4>
<p>you shouldn't use <code>delta</code> under normal circumstances, it's a very low level tactic</p>



<a name="232298409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232298409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232298409">(Mar 29 2021 at 16:47)</a>:</h4>
<p>I'm not actually sure what the difference between <code>dsimp</code> and <code>dunfold</code> is; they have slightly different configuration options but both call in to the same underlying rewriting mechanism</p>



<a name="232298451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232298451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232298451">(Mar 29 2021 at 16:48)</a>:</h4>
<p>(the syntax is a bit different)</p>



<a name="232298478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232298478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232298478">(Mar 29 2021 at 16:48)</a>:</h4>
<p>The docstring for <code>delta</code> says:</p>
<blockquote>
<p>Similar to <code>dunfold</code>, but performs a raw delta reduction, rather than using an equation associated with the defined constants.</p>
</blockquote>
<p>The term "delta reduction" is new to me. The web tells me it means evaluating a primitive function on given arguments -- a lot like a beta reduction, it seems, but with a primitive rather than an explicit lambda expression.</p>



<a name="232298589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232298589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232298589">(Mar 29 2021 at 16:48)</a>:</h4>
<p>delta reduction is replacing a constant defined with <code>def</code> with the body of the definition, i.e. the original meaning of "true by definition"</p>



<a name="232298709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232298709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232298709">(Mar 29 2021 at 16:49)</a>:</h4>
<p>this is what makes <code>def</code> different from, say, <code>constant</code></p>



<a name="232298821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232298821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232298821">(Mar 29 2021 at 16:50)</a>:</h4>
<p>Ah interesting, that's a bit different from the definition I'd found (in a non-Lean context), then -- though clearly related</p>



<a name="232298980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232298980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232298980">(Mar 29 2021 at 16:51)</a>:</h4>
<p>What is it that <code>dunfold</code> does, or <code>unfold</code> for that matter? The docstring for <code>dunfold</code> points at <code>unfold</code>, and the latter says it uses "equational lemmas associated with the definition".</p>



<a name="232299127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232299127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232299127">(Mar 29 2021 at 16:52)</a>:</h4>
<p>But I'm not sure what an "equational lemma" is. Is it just a lemma which has an equality as its conclusion?</p>



<a name="232299285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232299285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232299285">(Mar 29 2021 at 16:53)</a>:</h4>
<p>It's a set of automatically generated lemmas created with every definition made using the equation compiler</p>



<a name="232299450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232299450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232299450">(Mar 29 2021 at 16:54)</a>:</h4>
<p>Hmm, I see, and:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">W : Type u</span>
<span class="cm">W.equations._eqn_1 : W = X</span>
<span class="cm">-/</span>
<span class="k">#print</span> <span class="kd">prefix</span> <span class="n">W</span>
</code></pre></div>



<a name="232299501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232299501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232299501">(Mar 29 2021 at 16:54)</a>:</h4>
<p>So I guess that's the equational lemma there.</p>



<a name="232299517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232299517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232299517">(Mar 29 2021 at 16:54)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="mi">1</span>

<span class="k">#print</span> <span class="n">foo.equations._eqn_1</span>
<span class="c1">-- @[_refl_lemma]</span>
<span class="c1">-- theorem ALC.foo.equations._eqn_1 : foo = 1 :=</span>
<span class="c1">-- eq.refl foo</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="k">#print</span> <span class="kd">prefix</span> <span class="n">bar.equations</span>
<span class="c1">-- bar.equations._eqn_1 : bar 0 = 1</span>
<span class="c1">-- bar.equations._eqn_2 : ∀ (n : ℕ), bar (n + 1) = 0</span>
</code></pre></div>



<a name="232299575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232299575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232299575">(Mar 29 2021 at 16:55)</a>:</h4>
<p>yes, that's right</p>



<a name="232299783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232299783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232299783">(Mar 29 2021 at 16:56)</a>:</h4>
<p>The idea is that when "unfolding" <code>bar</code>, you would much rather see those equations than the actual definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">bar._main</span>
<span class="c1">-- def bar._main : ℕ → ℕ :=</span>
<span class="c1">-- λ (ᾰ : ℕ), ᾰ.cases_on (id_rhs ℕ 1) (λ (ᾰ : ℕ), id_rhs ℕ 0)</span>
</code></pre></div>
<p>Using <code>delta bar</code> will give you this</p>



<a name="232300177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232300177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232300177">(Mar 29 2021 at 16:59)</a>:</h4>
<p>Hmm, yeah, I see.</p>



<a name="232300874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232300874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232300874">(Mar 29 2021 at 17:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/equality.20of.20types/near/232238672">said</a>:</p>
<blockquote>
<p>The "motive is not type correct" error is because rewrite needs to generalize the variable in the position of <code>W</code>/<code>X</code>, and this variable is not defeq to either <code>W</code> or <code>X</code>, meaning that things that depend on it, like <code>Exists</code> in this case, will fail to type check</p>
</blockquote>
<p>Interesting. So <code>rewrite</code> in order to operate needs the thing it's rewriting to be generalizable -- meaning I guess that it can be replaced with anything with the same type, and the expression as a whole would still type-check. So in particular this is unlikely to work with anything that's used in the type of something else.</p>
<p>Whereas <code>dsimp</code>, <code>dunfold</code>, <code>delta</code>, and perhaps <code>subst</code> but I haven't tested it, are able to use the more specific identity of what they're substituting in, and the fact that it's defeq to the thing being replaced.</p>



<a name="232305497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232305497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232305497">(Mar 29 2021 at 17:33)</a>:</h4>
<p><code>subst</code> isn't in the same category of the others, but <code>change</code> also deserves a place on that list. These tactics all change the goal to something definitionally equal, and they do it by basically doing nothing - the next term you give will simply have the changed type, and the kernel will end up being responsible for checking that any type mismatches that arise are correct up to defeq</p>



<a name="232306028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232306028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232306028">(Mar 29 2021 at 17:37)</a>:</h4>
<p><code>subst</code> is kind of like <code>rw</code>, except it can't fail (assuming the target equality has a variable on one side) because it essentially comes "pre-generalized": the type-correctness of the typing context itself ensures that the operation of the tactic will go without a hitch. You can think of <code>rw (e : a = b)</code> as doing <code>have h : a = b := e, generalize : a = x, subst h</code>, and the <code>generalize</code> step is the one that can possibly fail if there are reasons why some occurrence of <code>a</code> in the context has to be specifically <code>a</code> and not just any term.</p>



<a name="232306306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232306306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232306306">(Mar 29 2021 at 17:38)</a>:</h4>
<p>Very interesting, thanks!</p>



<a name="232307403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232307403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232307403">(Mar 29 2021 at 17:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/equality.20of.20types/near/232305497">said</a>:</p>
<blockquote>
<p>and they do it by basically doing nothing - the next term you give will simply have the changed type, and the kernel will end up being responsible for checking that any type mismatches that arise are correct up to defeq</p>
</blockquote>
<p>This touches on something else I'd like to understand better: what the interface looks like between the kernel, and the machinery on top of it that we interact with when writing proofs.</p>
<p>Does this example translate to the following? We had a goal, which was the expected type of a proof term to stick into the hole we're currently working to fill in our proof-being-written. And then we change the goal, just meaning that we now decide on a different type we're going to use for the proof term we actually write. So then the kernel will be handed a proof term where when it gets to the subterm we're currently writing, it expects one type, but ends up judging it to have another, and it has to check that those types are defeq.</p>



<a name="232309130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232309130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232309130">(Mar 29 2021 at 17:55)</a>:</h4>
<p>That's right</p>



<a name="232309822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232309822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232309822">(Mar 29 2021 at 18:00)</a>:</h4>
<p>Actually, I lied a bit when I said the tactics do nothing; they could validly do nothing to the term under construction but in practice they instead add an identity function to the term, i.e. if the current partial proof term is <code>(_ : T)</code> and you <code>change U</code> then this changes the proof term to <code>(@id U _ : T)</code>. The reason for this so that the precise form of the term <code>U</code> is retained in the proof term, and we ensure that the kernel will actually be faced with a defeq goal of the form <code>T = U</code> and not <code>T = V</code> where <code>V</code> is the actual type of whatever you give next. Since <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">definitional equality in lean is not transitive</a>, this can actually impact the type correctness of some terms, but usually it just impacts performance.</p>



<a name="232309961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232309961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232309961">(Mar 29 2021 at 18:01)</a>:</h4>
<p>Ah interesting</p>



<a name="232310427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/equality%20of%20types/near/232310427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/equality.20of.20types.html#232310427">(Mar 29 2021 at 18:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/equality.20of.20types/near/232309822">said</a>:</p>
<blockquote>
<p>Since <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">definitional equality in lean is not transitive</a></p>
</blockquote>
<p>I'd seen a brief mention of this fact in the docs somewhere. But it looks like this is a rather more detailed discussion, thanks! I'll have to come back and read more later.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
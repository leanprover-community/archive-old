---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html">questions about the Z3 theorem prover</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="262674936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262674936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262674936">(Nov 25 2021 at 07:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Defining.20a.20table.20type/near/262670589">said</a>:</p>
<blockquote>
<p>Probably not, but you are welcome to try</p>
</blockquote>
<p>I'm trying to translate logical clause expressed in First Order Logic into Z3 (Python version). For example, the logical clause may look like this:<br>
<code>exists l.(language(l) &amp; exists n.(name(n) &amp; :op1(n,"English") &amp; :name(l,n)))</code><br>
which corresponds to the expression in natural language "language is English". <br>
The idea is to be able to translate it into some form of axiom which can be understood by an Automated Theorem Prover such as Z3. And then reuse it for further inference. For example, I can extract knowledge from the axioms if I construct the right query (code in Z3) for it... </p>
<p>I was initially thinking about using Lean for this, but it looks more like an "interactive theorem prover" (which required human in the middle) rather than "automated theorem prover" which can automate logical proofs.</p>
<p>So the ultimate goal is to create a system capable of accumulating formal knowledge and perform some sort of reasoning with it.</p>



<a name="262675097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262675097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262675097">(Nov 25 2021 at 07:53)</a>:</h4>
<p>Are you the person who asked <a href="https://stackoverflow.com/questions/70090927/how-can-i-convert-logical-clause-to-lean">https://stackoverflow.com/questions/70090927/how-can-i-convert-logical-clause-to-lean</a>? What's going on with this clause?</p>



<a name="262675188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262675188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262675188">(Nov 25 2021 at 07:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/262675097">said</a>:</p>
<blockquote>
<p>Are you the person who asked <a href="https://stackoverflow.com/questions/70090927/how-can-i-convert-logical-clause-to-lean">https://stackoverflow.com/questions/70090927/how-can-i-convert-logical-clause-to-lean</a>? What's going on with this clause?</p>
</blockquote>
<p>yes, I asked that question in StackOverflow as well. The guy who answered it then recommended looking towards Z3 (and recommended asking on this forum as well) So here I am :)</p>



<a name="262675303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262675303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262675303">(Nov 25 2021 at 07:56)</a>:</h4>
<p>could you help <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> this problem for us? What are you actually trying to do that resulted in investigating how to render that clause in Z3 / lean?</p>



<a name="262675464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262675464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262675464">(Nov 25 2021 at 07:59)</a>:</h4>
<blockquote>
<p>So the ultimate goal is to create a system capable of accumulating formal knowledge and perform some sort of reasoning with it.</p>
</blockquote>
<p>What sort of knowledge, and what sort of reasoning? Could you show a not-entirely-trivial example where the automation is value added?</p>



<a name="262675493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262675493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262675493">(Nov 25 2021 at 07:59)</a>:</h4>
<p>I struggle to think of any interesting questions to ask about the clause "language is english" that doesn't already restate the answer in the question</p>



<a name="262676280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262676280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262676280">(Nov 25 2021 at 08:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/262675464">said</a>:</p>
<blockquote>
<blockquote>
<p>So the ultimate goal is to create a system capable of accumulating formal knowledge and perform some sort of reasoning with it.</p>
</blockquote>
<p>What sort of knowledge, and what sort of reasoning? Could you show a not-entirely-trivial example where the automation is value added?</p>
</blockquote>
<p>We can start with answering "surface questions" like "&lt;unknown&gt; is English" or "language is &lt;unknown&gt;" which can find answers from the context of the existing axioms. Then we can try to answer the Yes/No questions like "Is English a language?". Then we can possibly extend it to other types of reasoning, involving many axioms at the same time.</p>



<a name="262676499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262676499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262676499">(Nov 25 2021 at 08:13)</a>:</h4>
<p>The idea is to be able to create a knowledge base which would not only store knowledge but also have a means to reason with it. I tried using Knowledge Graphs for it. But KGs usually don’t have built-in mechanisms for inference. I can retrieve data using SPARLQ queries, for example. But then the problem is how translate natural language question into SPARQL formal query… you have to use some heuristics or machine learning methods to find the correct answer space (best matching sub-graph) and infer the answer from it. But even that approach may not be able to answer questions which require reasoning and logical inference. They can mainly answer the so called “surface questions” where the answers are readily available in the context.  So I looked at automated theorem provers. They look like a perfect solution for that task. They store knowledge as “axioms”. They can build further knowledge based on the existing axioms or add new ones. And, unlike KG heuristic search with "fuzzy" results, their answers can be mathematically (logically) sound. So it looks like the way to go…</p>



<a name="262676852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262676852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262676852">(Nov 25 2021 at 08:18)</a>:</h4>
<p>In that case, I think the single clause <code>is(language, english)</code> would do fine for encoding this in an ATP. You might also consider Prolog for answering those forward/backward questions like <code>&lt;unknown&gt; is English</code></p>



<a name="262677399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262677399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262677399">(Nov 25 2021 at 08:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/262676852">said</a>:</p>
<blockquote>
<p>In that case, I think the single clause <code>is(language, english)</code> would do fine for encoding this in an ATP. You might also consider Prolog for answering those forward/backward questions like <code>&lt;unknown&gt; is English</code></p>
</blockquote>
<p>can you help me translate the whole thing into Z3 ? I mean the axiom itself and the possible query.</p>



<a name="262677621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262677621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262677621">(Nov 25 2021 at 08:28)</a>:</h4>
<p>It depends on the interface you are working with, but maybe <a href="https://colab.research.google.com/github/philzook58/z3_tutorial/blob/master/Z3%20Tutorial.ipynb">https://colab.research.google.com/github/philzook58/z3_tutorial/blob/master/Z3%20Tutorial.ipynb</a> will help?</p>



<a name="262678495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262678495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262678495">(Nov 25 2021 at 08:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/262677621">said</a>:</p>
<blockquote>
<p>It depends on the interface you are working with, but maybe <a href="https://colab.research.google.com/github/philzook58/z3_tutorial/blob/master/Z3%20Tutorial.ipynb">https://colab.research.google.com/github/philzook58/z3_tutorial/blob/master/Z3%20Tutorial.ipynb</a> will help?</p>
</blockquote>
<p>Thanks, I read it through already. But I'm stuck with translation of the axiom. In standard Z3 syntaxis it would look like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">declare</span><span class="bp">-</span><span class="n">const</span> <span class="n">name</span> <span class="o">(</span><span class="n">String</span><span class="o">))</span>
<span class="o">(</span><span class="n">declare</span><span class="bp">-</span><span class="n">const</span> <span class="n">language</span> <span class="o">(</span><span class="n">String</span><span class="o">))</span>
<span class="o">(</span><span class="n">assert</span> <span class="o">(</span><span class="n">exists</span> <span class="o">((</span><span class="n">l</span> <span class="n">language</span><span class="o">))</span> <span class="o">(</span><span class="n">and</span> <span class="o">(</span><span class="n">language</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">exists</span> <span class="o">((</span><span class="n">n</span> <span class="n">name</span><span class="o">))</span> <span class="o">(</span><span class="n">and</span> <span class="o">(</span><span class="n">name</span> <span class="n">n</span><span class="o">)</span> <span class="o">(:</span><span class="n">op1</span> <span class="n">n</span> <span class="s2">"English"</span><span class="o">)</span> <span class="o">(:</span><span class="n">name</span> <span class="n">l</span> <span class="n">n</span><span class="o">))))))</span>
</code></pre></div>
<p>But in Python implementation I try this code, for example:</p>
<div class="codehilite" data-code-language="Python"><pre><span></span><code><span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Object</span> <span class="o">=</span> <span class="n">DeclareSort</span><span class="p">(</span><span class="s1">'Object'</span><span class="p">)</span>
<span class="n">name</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>
<span class="n">language</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'language'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>
<span class="n">op1</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'op1'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>

<span class="n">l</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'l'</span><span class="p">,</span> <span class="n">Object</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'n'</span><span class="p">,</span> <span class="n">Object</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ForAll</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">Implies</span><span class="p">(</span><span class="n">language</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">Exists</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">And</span><span class="p">(</span><span class="n">name</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">op1</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">"English"</span><span class="p">),</span> <span class="n">name</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">))))))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
</code></pre></div>
<p>but it gives an error</p>



<a name="262678934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/262678934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#262678934">(Nov 25 2021 at 08:42)</a>:</h4>
<ol>
<li>You used <code>ForAll</code> instead of <code>Exists</code>, that looks suspicious</li>
<li>I don't think you need that axiom / it doesn't say what you want. I don't use python/z3 so I'm projecting syntax but I guess it would be something like:</li>
</ol>
<div class="codehilite" data-code-language="Python"><pre><span></span><code><span class="n">Object</span> <span class="o">=</span> <span class="n">DeclareSort</span><span class="p">(</span><span class="s1">'Object'</span><span class="p">)</span>
<span class="n">language</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'language'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>
<span class="n">english</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'English'</span><span class="p">,</span> <span class="n">Object</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">language</span><span class="p">(</span><span class="n">english</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
</code></pre></div>



<a name="263100794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263100794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263100794">(Nov 30 2021 at 04:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/262678934">said</a>:</p>
<blockquote>
<ol>
<li>You used <code>ForAll</code> instead of <code>Exists</code>, that looks suspicious</li>
<li>I don't think you need that axiom / it doesn't say what you want. I don't use python/z3 so I'm projecting syntax but I guess it would be something like:</li>
</ol>
<p><div class="codehilite" data-code-language="Python"><pre><span></span><code><span class="n">Object</span> <span class="o">=</span> <span class="n">DeclareSort</span><span class="p">(</span><span class="s1">'Object'</span><span class="p">)</span>
<span class="n">language</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'language'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>
<span class="n">english</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'English'</span><span class="p">,</span> <span class="n">Object</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">language</span><span class="p">(</span><span class="n">english</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I played more with Z3, and it looks like I can make it answer boolean questions. See example code below:</p>
<div class="codehilite" data-code-language="Python"><pre><span></span><code><span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Object</span> <span class="o">=</span> <span class="n">DeclareSort</span><span class="p">(</span><span class="s1">'Object'</span><span class="p">)</span>
<span class="n">Languages</span> <span class="o">=</span> <span class="n">DeclareSort</span><span class="p">(</span><span class="s1">'Languages'</span><span class="p">)</span>

<span class="n">Human</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Human'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>
<span class="n">Mortal</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Mortal'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>

<span class="n">socrates</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'socrates'</span><span class="p">,</span> <span class="n">Object</span><span class="p">)</span>
<span class="n">pavel</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'pavel'</span><span class="p">,</span> <span class="n">Object</span><span class="p">)</span>
<span class="n">Something</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Something'</span><span class="p">,</span>  <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>

<span class="n">Whiskers</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Whiskers'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>
<span class="n">Tail</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Tail'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>
<span class="n">Cat</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Cat'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>

<span class="n">Language</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Language'</span><span class="p">,</span> <span class="n">Languages</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>
<span class="n">english</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'English'</span><span class="p">,</span> <span class="n">Languages</span><span class="p">)</span>
<span class="n">french</span><span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'French'</span><span class="p">,</span> <span class="n">Languages</span><span class="p">)</span>
<span class="n">Name</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Name'</span><span class="p">,</span> <span class="n">Languages</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>

<span class="c1"># free variables used in forall must be declared Const in python</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'x'</span><span class="p">,</span> <span class="n">Object</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'y'</span><span class="p">,</span> <span class="n">Languages</span><span class="p">)</span>

<span class="n">axioms</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span><span class="n">Implies</span><span class="p">(</span><span class="n">Human</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Mortal</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span>
    <span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span><span class="n">Implies</span><span class="p">(</span><span class="n">Cat</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="n">Whiskers</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Tail</span><span class="p">(</span><span class="n">x</span><span class="p">)))),</span>
    <span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span><span class="n">Implies</span><span class="p">(</span><span class="n">Cat</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Not</span><span class="p">(</span><span class="n">Human</span><span class="p">(</span><span class="n">x</span><span class="p">)))),</span>
    <span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span><span class="n">Implies</span><span class="p">(</span><span class="n">Cat</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Mortal</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span>
    <span class="n">ForAll</span><span class="p">([</span><span class="n">y</span><span class="p">],</span><span class="n">Implies</span><span class="p">(</span><span class="n">Language</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="n">Name</span><span class="p">(</span><span class="n">y</span><span class="p">))))</span>
<span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">axioms</span><span class="p">)</span>

<span class="n">assumptions</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Cat</span><span class="p">(</span><span class="n">socrates</span><span class="p">),</span>
    <span class="n">Human</span><span class="p">(</span><span class="n">pavel</span><span class="p">),</span>
    <span class="c1">#Cat(pavel) # &lt;- this assumption makes model unsat because cat(x) is not human(x)</span>
    <span class="n">Name</span><span class="p">(</span><span class="n">english</span><span class="p">),</span>
    <span class="n">Name</span><span class="p">(</span><span class="n">french</span><span class="p">)</span>
<span class="p">]</span>

<span class="k">if</span> <span class="n">unsat</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">assumptions</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'UNSAT: </span><span class="si">{</span><span class="n">s</span><span class="o">.</span><span class="n">unsat_core</span><span class="p">()</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'SAT:</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
    <span class="c1">#print(m)</span>
    <span class="c1">#print(m.eval(Cat(english))) &lt;- error "sort mismatch"</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">Human</span><span class="p">(</span><span class="n">socrates</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Mortal</span><span class="p">(</span><span class="n">socrates</span><span class="p">),</span><span class="n">Tail</span><span class="p">(</span><span class="n">socrates</span><span class="p">))))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">Tail</span><span class="p">(</span><span class="n">socrates</span><span class="p">)))</span>
    <span class="c1">#print(m.eval(Tail(french))) &lt;- error "sort mismatch"</span>
</code></pre></div>
<p>The above code has several axioms and assumptions. Then it generates a model which can be evaluated. So far so good. But how can I make it answer "Wh-questions"?  For example, "what languages do you know?" or "how many languages is there?"</p>



<a name="263104284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263104284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263104284">(Nov 30 2021 at 05:49)</a>:</h4>
<p><span class="user-mention" data-user-id="459811">@Pavel Kulko</span> I think you need some actual data types for this to work, since <code>socrates</code>, <code>pavel</code>, <code>english</code>, and <code>french</code> are actually variables (it's just called a <code>Const</code>).  To enumerate answers, you can do <code>s.check</code> in a loop, and each time you add in an additional assumption that the variable doesn't equal the value you just got.  Here's answering all the mortals in the model:</p>
<div class="codehilite" data-code-language="Python"><pre><span></span><code><span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Object_</span> <span class="o">=</span> <span class="n">Datatype</span><span class="p">(</span><span class="s1">'Object'</span><span class="p">)</span>
<span class="n">Object_</span><span class="o">.</span><span class="n">declare</span><span class="p">(</span><span class="s2">"socrates"</span><span class="p">)</span>
<span class="n">Object_</span><span class="o">.</span><span class="n">declare</span><span class="p">(</span><span class="s2">"pavel"</span><span class="p">)</span>
<span class="n">Object</span> <span class="o">=</span> <span class="n">Object_</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>

<span class="n">Languages_</span> <span class="o">=</span> <span class="n">Datatype</span><span class="p">(</span><span class="s1">'Languages'</span><span class="p">)</span>
<span class="n">Languages_</span><span class="o">.</span><span class="n">declare</span><span class="p">(</span><span class="s2">"English"</span><span class="p">)</span>
<span class="n">Languages_</span><span class="o">.</span><span class="n">declare</span><span class="p">(</span><span class="s2">"French"</span><span class="p">)</span>
<span class="n">Languages</span> <span class="o">=</span> <span class="n">Languages_</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>

<span class="n">Human</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Human'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>
<span class="n">Mortal</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Mortal'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>

<span class="n">Something</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Something'</span><span class="p">,</span>  <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>

<span class="n">Whiskers</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Whiskers'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>
<span class="n">Tail</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Tail'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>
<span class="n">Cat</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Cat'</span><span class="p">,</span> <span class="n">Object</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>

<span class="n">Language</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Language'</span><span class="p">,</span> <span class="n">Languages</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>
<span class="n">Name</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'Name'</span><span class="p">,</span> <span class="n">Languages</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>

<span class="c1"># free variables used in forall must be declared Const in python</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'x'</span><span class="p">,</span> <span class="n">Object</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'y'</span><span class="p">,</span> <span class="n">Languages</span><span class="p">)</span>

<span class="n">axioms</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span><span class="n">Implies</span><span class="p">(</span><span class="n">Human</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Mortal</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span>
    <span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span><span class="n">Implies</span><span class="p">(</span><span class="n">Cat</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="n">Whiskers</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Tail</span><span class="p">(</span><span class="n">x</span><span class="p">)))),</span>
    <span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span><span class="n">Implies</span><span class="p">(</span><span class="n">Cat</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Not</span><span class="p">(</span><span class="n">Human</span><span class="p">(</span><span class="n">x</span><span class="p">)))),</span>
    <span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span><span class="n">Implies</span><span class="p">(</span><span class="n">Cat</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Mortal</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span>
    <span class="n">ForAll</span><span class="p">([</span><span class="n">y</span><span class="p">],</span><span class="n">Implies</span><span class="p">(</span><span class="n">Language</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="n">Name</span><span class="p">(</span><span class="n">y</span><span class="p">))))</span>
<span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">axioms</span><span class="p">)</span>

<span class="n">assumptions</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Cat</span><span class="p">(</span><span class="n">Object</span><span class="o">.</span><span class="n">socrates</span><span class="p">),</span>
    <span class="n">Human</span><span class="p">(</span><span class="n">Object</span><span class="o">.</span><span class="n">pavel</span><span class="p">),</span>
    <span class="c1">#Cat(Object.pavel), # &lt;- this assumption makes model unsat because cat(x) is not human(x)</span>
    <span class="n">Name</span><span class="p">(</span><span class="n">Languages</span><span class="o">.</span><span class="n">English</span><span class="p">),</span>
    <span class="n">Name</span><span class="p">(</span><span class="n">Languages</span><span class="o">.</span><span class="n">French</span><span class="p">)</span>
<span class="p">]</span>

<span class="n">s</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>

<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>

<span class="n">v</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'v'</span><span class="p">,</span> <span class="n">Object</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Mortal</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

<span class="k">while</span> <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="o">==</span> <span class="n">sat</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"v = </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>

<span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div>



<a name="263120852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263120852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263120852">(Nov 30 2021 at 09:47)</a>:</h4>
<p>That works nicely! Thank you <span class="user-mention" data-user-id="306601">@Kyle Miller</span> Now that we are able to answer simple Wh-queries, what about more complex ones? Can we return a clause, for example?  Lets say I want to ask "what does cat have?" And it should return "And(Whiskers(x), Tail(x))". Can we do that?</p>



<a name="263225147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263225147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263225147">(Nov 30 2021 at 23:44)</a>:</h4>
<p><span class="user-mention" data-user-id="459811">@Pavel Kulko</span> That query sounds very ambiguous. Why is it not returning <code>[Whiskers(x), Tail(x), Not(Human(x)), Mortal(x)]</code>?</p>



<a name="263231008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263231008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263231008">(Dec 01 2021 at 00:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/263225147">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="459811">Pavel Kulko</span> That query sounds very ambiguous. Why is it not returning <code>[Whiskers(x), Tail(x), Not(Human(x)), Mortal(x)]</code>?</p>
</blockquote>
<p>Well, the code below returns constant "v = socrates". But how can I make it return some clause? </p>
<div class="codehilite" data-code-language="Python"><pre><span></span><code><span class="n">v</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="s1">'v'</span><span class="p">,</span> <span class="n">Object</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Cat</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

<span class="k">while</span> <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="o">==</span> <span class="n">sat</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"v = </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
</code></pre></div>



<a name="263233398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263233398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263233398">(Dec 01 2021 at 01:24)</a>:</h4>
<p>what clause?</p>



<a name="263233447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263233447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263233447">(Dec 01 2021 at 01:25)</a>:</h4>
<p>the question isn't uniquely determined; there are an infinite number of clauses that are true about anything satisfying <code>Cat(x)</code></p>



<a name="263235299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263235299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263235299">(Dec 01 2021 at 01:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/263233447">said</a>:</p>
<blockquote>
<p>the question isn't uniquely determined; there are an infinite number of clauses that are true about anything satisfying <code>Cat(x)</code></p>
</blockquote>
<p>In this case we should only return the clause (or part of it) which was provided in the axioms.. or maybe I should formulate the question differently. Currently I can extract all the satisfying predicates from the model based on the appearance of the variable "socrates" in the else_value(): [Whiskers(x), Cat(x), Tail(x), Mortal(x)].</p>



<a name="263236640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263236640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263236640">(Dec 01 2021 at 02:16)</a>:</h4>
<p>If you have a list of candidate formulas, you can see which ones are derivable from <code>Cat(x)</code> by seeing if <code>Cat(x) =&gt; P</code> is derivable</p>



<a name="263237428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263237428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263237428">(Dec 01 2021 at 02:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/263236640">said</a>:</p>
<blockquote>
<p>If you have a list of candidate formulas, you can see which ones are derivable from <code>Cat(x)</code> by seeing if <code>Cat(x) =&gt; P</code> is derivable</p>
</blockquote>
<p>yes, that could work. I'm just trying different query now. For example <code>s.add(Implies(Tail(v),Human(v)))</code> will return constant "pavel". But what I'm trying to ask with this clause is "does the human have tail?" Is the clause formulated correctly?</p>



<a name="263237706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263237706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263237706">(Dec 01 2021 at 02:37)</a>:</h4>
<p>You need a quantifier. Do you mean to ask whether <em>any</em> human has a tail or <em>all</em>?</p>



<a name="263238044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263238044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263238044">(Dec 01 2021 at 02:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/263237706">said</a>:</p>
<blockquote>
<p>You need a quantifier. Do you mean to ask whether <em>any</em> human has a tail or <em>all</em>?</p>
</blockquote>
<p>Thanks. Indeed, this query works <code>s.add(ForAll([v],Implies(Tail(v),Human(v))))</code></p>



<a name="263240798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263240798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263240798">(Dec 01 2021 at 03:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459811">Pavel Kulko</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/263238044">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/263237706">said</a>:</p>
<blockquote>
<p>You need a quantifier. Do you mean to ask whether <em>any</em> human has a tail or <em>all</em>?</p>
</blockquote>
<p>Thanks. Indeed, this query works <code>s.add(ForAll([v],Implies(Tail(v),Human(v))))</code></p>
</blockquote>
<p>what if I want to ask "is pavel mortal"? How can I encode it?</p>



<a name="263241013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263241013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263241013">(Dec 01 2021 at 03:43)</a>:</h4>
<p>add <code>Mortal(pavel)</code> and see if it is unsat, and similarly for <code>!Mortal(pavel)</code>:</p>
<ul>
<li>If adding <code>Mortal(pavel)</code> makes it unsat, then pavel is immortal</li>
<li>If adding <code>!Mortal(pavel)</code> makes it unsat, then pavel is mortal</li>
<li>If neither makes it unsat, then the given axioms are not enough to determine whether pavel is mortal or not</li>
</ul>



<a name="263241019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263241019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263241019">(Dec 01 2021 at 03:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459811">Pavel Kulko</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/263240798">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="459811">Pavel Kulko</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/263238044">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover/near/263237706">said</a>:</p>
<blockquote>
<p>You need a quantifier. Do you mean to ask whether <em>any</em> human has a tail or <em>all</em>?</p>
</blockquote>
<p>Thanks. Indeed, this query works <code>s.add(ForAll([v],Implies(Tail(v),Human(v))))</code></p>
</blockquote>
<p>what if I want to ask "is pavel mortal"? How can I encode it?</p>
</blockquote>
<p>Would it be enough to just add <code>s.add(Mortal(Object.pavel))</code> and then check if the solver returns "sat" ? So that would mean true. Otherwise, if it returns "unsat" then it is either False or Unknown?</p>



<a name="263241109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263241109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263241109">(Dec 01 2021 at 03:45)</a>:</h4>
<p>Not quite. Notice that I said to look for "unsat", not "sat". If adding <code>Mortal(pavel)</code> returns "sat" that doesn't mean that pavel is mortal, it means that we cannot exclude the possibility that pavel is mortal</p>



<a name="263241128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263241128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263241128">(Dec 01 2021 at 03:45)</a>:</h4>
<p>to prove that pavel is mortal we instead want to add <code>!Mortal(pavel)</code> and get a contradiction</p>



<a name="263241542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263241542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263241542">(Dec 01 2021 at 03:54)</a>:</h4>
<p>ah ok, and to check if the answer is Unknown we just need to run it two times, once with the original query and the second time with the negated query. If both original and negated query return "sat" then the answer is unknown. is that correct?</p>



<a name="263241909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263241909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263241909">(Dec 01 2021 at 04:00)</a>:</h4>
<p>yes, although it's more like "independent" than "unknown". "Unknown" would be if you got at least one "Unknown" response to those queries, which means the sat solver couldn't prove or disprove the assertion within the time limit</p>



<a name="263385210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263385210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263385210">(Dec 02 2021 at 02:10)</a>:</h4>
<p>How can I answer the question "who is pavel"? That is, given the constant (Object.pavel), I want to find all the predicates where this constant can be applied.</p>



<a name="263390799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263390799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pavel Kulko <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263390799">(Dec 02 2021 at 04:05)</a>:</h4>
<p>currently I'm solving that problem by evaluating all the predicates known by the model. </p>
<div class="codehilite" data-code-language="Python"><pre><span></span><code><span class="k">for</span> <span class="n">decl</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">decls</span><span class="p">():</span>
                <span class="n">interp</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_interp</span><span class="p">(</span><span class="n">decl</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interp</span><span class="p">,</span> <span class="n">FuncInterp</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1">#check if predicate can be evaluated with the constant argument</span>
                        <span class="n">m</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">decl</span><span class="p">(</span><span class="n">const</span><span class="p">))</span>
                        <span class="n">predicates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decl</span><span class="p">)</span>
                        <span class="n">is_sat</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">decl</span><span class="si">}</span><span class="s1"> != </span><span class="si">{</span><span class="n">const</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
</code></pre></div>
<p>But is this the only way? It doesn't seem to be very efficient.</p>



<a name="263393862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/263393862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#263393862">(Dec 02 2021 at 05:12)</a>:</h4>
<p>It sounds like you just want a list of all predicates which have an argument of type <code>Object</code>. I don't know if Z3's object representation is optimized for that, but probably if you can get all the decls you can ask what their types are and whether one of them is <code>Object</code></p>



<a name="313791380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/313791380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Bies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#313791380">(Dec 04 2022 at 10:49)</a>:</h4>
<p>Is there some way to figure out what z3 does for a specific SMT instance?</p>
<p>I have a set of problems that vary in size, and I tried to find solutions for them using z3. In my tests, I noticed that z3 is absurdly fast for smaller problems but then hits a brick wall at some point. For problem sizes 2 to 11, it takes about 40ms to 50ms to find a solution, but for size 12 it doesn't find anything within an hour.</p>
<p>What I <em>think</em> is happening is that z3 has multiple strategies for solving these SMT instances and it chooses the wrong one for those problems with size 12 and above. So is there a way for me to tell what strategy it's using for a given SMT instance? If so, is there a way for me to force it to use a strategy I know to be effective?</p>



<a name="313791460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/313791460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#313791460">(Dec 04 2022 at 10:50)</a>:</h4>
<p>Just an FYI, this isn't a forum for Z3 questions</p>



<a name="313791507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/313791507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Bies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#313791507">(Dec 04 2022 at 10:51)</a>:</h4>
<p>Do you know of a forum for z3? I tried looking for one, but didn't find anything</p>



<a name="313791651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/313791651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#313791651">(Dec 04 2022 at 10:52)</a>:</h4>
<p>There is <a href="https://github.com/Z3Prover/z3/discussions">https://github.com/Z3Prover/z3/discussions</a>, no idea whether that is the best place for it but I'm sure asking there will find a better place if there is one</p>



<a name="313791908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/questions%20about%20the%20Z3%20theorem%20prover/near/313791908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Bies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/questions.20about.20the.20Z3.20theorem.20prover.html#313791908">(Dec 04 2022 at 10:55)</a>:</h4>
<p>Alright, I'll repost my question there</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
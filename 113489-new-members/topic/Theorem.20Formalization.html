---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Theorem.20Formalization.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html">Theorem Formalization</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="240429477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240429477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240429477">(May 27 2021 at 07:33)</a>:</h4>
<p>In Lean, how to state/formalize a theorem involving a1,..., an for an arbitrary pos integer n, taking the following trivial theorem as an example: for any pos integer n, for any real numbers a1,..., an, a1^2+...+an^2&gt;=0.</p>



<a name="240429810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240429810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240429810">(May 27 2021 at 07:36)</a>:</h4>
<p><span class="user-mention" data-user-id="408694">@Alex Zhang</span> There are two ways to approach this:<br>
(1) Pick a function from <code>fin n</code> to the real numbers. <code>fin n</code> is the type of numbers <code>{0, 1, ..., n-1}</code>.</p>



<a name="240429882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240429882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240429882">(May 27 2021 at 07:37)</a>:</h4>
<p>(2) Pick an infinite sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo separator="true">,</mo><mo>…</mo><mtext> </mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_0, a_1, \dots, a_n, \dots)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">)</span></span></span></span> and only talk about the first <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> elements.</p>



<a name="240429956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240429956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240429956">(May 27 2021 at 07:38)</a>:</h4>
<p>What I would actually do is to drop the <code>n</code> completely, and prove this for arbitrary finite sums, indexed by any finite set.</p>



<a name="240430224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240430224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240430224">(May 27 2021 at 07:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">lemma</span> <span class="n">sum_of_squares_nonneg</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="n">i</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="240430473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240430473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240430473">(May 27 2021 at 07:42)</a>:</h4>
<p>The next thing I would do, is try to generalize <code>real</code> away. Because the theorem also holds for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\mathbb Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord mathbb">Q</span></span></span></span>.</p>



<a name="240430495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240430495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240430495">(May 27 2021 at 07:42)</a>:</h4>
<p>So then I wonder if it's true in any <code>linear_ordered_comm_semiring</code>.</p>



<a name="240430528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240430528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240430528">(May 27 2021 at 07:43)</a>:</h4>
<p>And that might actually not be true. I frankly don't know.</p>



<a name="240431090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240431090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240431090">(May 27 2021 at 07:49)</a>:</h4>
<p>Many thanks, Johan!<br>
 To prove the first trivial theorem, I think the next thing I will do is to do induction on the cardinal of s. I am still quite new to Lean.. I know how to do induction, but the achieve the next step, how do I know what files do I need to import to use "cardinal" and where to find a manual illustrating the use of "cardinal"?</p>



<a name="240431195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240431195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240431195">(May 27 2021 at 07:50)</a>:</h4>
<p><span class="user-mention" data-user-id="408694">@Alex Zhang</span> in fact, you can do induction on <code>s</code> itself.<br>
Try</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">finset.induction_on</span> <span class="n">s</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="240431242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240431242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240431242">(May 27 2021 at 07:51)</a>:</h4>
<p>That will give you to goals: (i) prove it for empty <code>s</code>, and (ii) prove it for <code>s \union {x}</code> assuming you know the theorem for <code>s</code></p>



<a name="240431554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240431554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240431554">(May 27 2021 at 07:55)</a>:</h4>
<p>Thanks, Johan! Could you please explain, if I do want to use something like "cardinal" in the future, how should I figure out the above questions?</p>



<a name="240431697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240431697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240431697">(May 27 2021 at 07:56)</a>:</h4>
<p>In VScode you can click the <span aria-label="magnifying glass" class="emoji emoji-1f50d" role="img" title="magnifying glass">:magnifying_glass:</span> button in the bar on the left, and search for <code>cardinal</code>. If that doesn't give you what you want, asking here should usually give you a fast answer as well.</p>



<a name="240433278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240433278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240433278">(May 27 2021 at 08:15)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal</span>

<span class="k">#eval</span> <span class="n">cardinal.mk</span> <span class="n">ℝ</span>
</code></pre></div>
<p>This gives me the error message <code>result type does not have an instance of type class 'has_repr', dumping internal representation</code>.</p>



<a name="240433305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240433305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240433305">(May 27 2021 at 08:15)</a>:</h4>
<p>What are you expecting the answer to be?</p>



<a name="240433331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240433331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240433331">(May 27 2021 at 08:15)</a>:</h4>
<p>It says "this is some random equivalence class which doesn't have a string attached to it so I don't know what string to print"</p>



<a name="240433426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240433426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240433426">(May 27 2021 at 08:16)</a>:</h4>
<p><code>#eval</code> means "turn the internal representation of this object into a string, by "evaluating" it in some way, and print the string"</p>



<a name="240433574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240433574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240433574">(May 27 2021 at 08:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">list.cons</span> <span class="mi">4</span> <span class="n">list.nil</span> <span class="c1">-- [4]</span>
</code></pre></div>
<p>This works because someone wrote some code which takes a list and turns it into a string starting with a <code>[</code> and puts commas between the string representations of the elements of the list etc etc</p>



<a name="240434212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240434212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240434212">(May 27 2021 at 08:26)</a>:</h4>
<p>What does "induction on a <a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal">docs#cardinal</a>" mean for uncountable cardinalities?</p>



<a name="240434459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240434459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240434459">(May 27 2021 at 08:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Theorem.20Formalization/near/240433305">said</a>:</p>
<blockquote>
<p>What are you expecting the answer to be?</p>
</blockquote>
<p>I would expect  <code>cardinal.mk ℝ</code> can give me c (or what is used to represent this in Lean), and expect <code>cardinal.mk (fin 5)</code> can give me 5, but <code>cardinal.mk</code> does not work as I thought.</p>



<a name="240434507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240434507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240434507">(May 27 2021 at 08:29)</a>:</h4>
<p>It is a <em>theorem</em> that <code>cardinal.mk (fin 5)</code> is 5.</p>



<a name="240434857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240434857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240434857">(May 27 2021 at 08:32)</a>:</h4>
<p>Is there any function already defined in Lean which outputs the cardinal of S as a natural number when S is finite and given as input?</p>



<a name="240434929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240434929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240434929">(May 27 2021 at 08:33)</a>:</h4>
<p><code>fintype.card</code></p>



<a name="240434956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240434956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240434956">(May 27 2021 at 08:33)</a>:</h4>
<p>But depending on what you input, it cannot compute the natural number.</p>



<a name="240435018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240435018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240435018">(May 27 2021 at 08:34)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.card">docs#fintype.card</a></p>



<a name="240435032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240435032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240435032">(May 27 2021 at 08:34)</a>:</h4>
<p>We also have <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card">docs#finset.card</a>, which is better if you started with a finset.</p>



<a name="240435076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240435076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240435076">(May 27 2021 at 08:35)</a>:</h4>
<p>For example,  Lean will probably timeout on <code>fintype.card {p : fin 100 // nat.prime p}</code></p>



<a name="240435142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240435142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240435142">(May 27 2021 at 08:36)</a>:</h4>
<p>Will timeout <em>if you use <code>#eval</code> / <code>#reduce</code></em>, I assume you mean</p>



<a name="240435501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240435501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240435501">(May 27 2021 at 08:39)</a>:</h4>
<p>any analogical function for infinite sets or countable sets?</p>



<a name="240435609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240435609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240435609">(May 27 2021 at 08:40)</a>:</h4>
<p>There is no function which takes an arbitrary type and, for example, figures out magically whether it is countable or uncountable, no. Such a function cannot exist.</p>



<a name="240435620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240435620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240435620">(May 27 2021 at 08:40)</a>:</h4>
<p>That's <code>cardinal.mk</code></p>



<a name="240436554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240436554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240436554">(May 27 2021 at 08:51)</a>:</h4>
<p>Sure there is, <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.dec">docs#classical.dec</a> is "for any statement p, figure out magically if it's true". Unfortunately you're just not allowed to ask lean what its conclusion was!</p>



<a name="240436796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240436796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240436796">(May 27 2021 at 08:54)</a>:</h4>
<p>I guess we have different mental models of <code>or</code>.</p>



<a name="240444698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240444698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240444698">(May 27 2021 at 10:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Theorem.20Formalization/near/240435076">said</a>:</p>
<blockquote>
<p>For example,  Lean will probably timeout on <code>fintype.card {p : fin 100 // nat.prime p}</code></p>
</blockquote>
<p>(For the record, <code>#eval</code> is still quite fast on natural numbers. Only around <code>#eval fintype.card {p : fin 100000 // nat.prime p}</code> does it start to take over a second on my machine.)</p>



<a name="240444792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240444792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240444792">(May 27 2021 at 10:19)</a>:</h4>
<p>(Meanwhile, <code>#reduce</code> takes longer than I care to wait on <code>#reduce fintype.card {p : fin 4 // nat.prime p}</code>.)</p>



<a name="240450116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240450116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240450116">(May 27 2021 at 11:13)</a>:</h4>
<p>Ooh, right! But for proofs it is <code>#reduce</code> which is what matters, right?</p>



<a name="240452087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240452087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240452087">(May 27 2021 at 11:35)</a>:</h4>
<p>Interestingly <code>#reduce fintype.card {p : fin 3 // nat.prime p}</code> is instant</p>



<a name="240452269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240452269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240452269">(May 27 2021 at 11:37)</a>:</h4>
<p>This makes it faster:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">nat.decidable_prime_1</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">12</span> <span class="bp">//</span> <span class="n">nat.prime</span> <span class="n">p</span><span class="o">}</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="k">#reduce</span> <span class="n">fintype.card</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">12</span> <span class="bp">//</span> <span class="n">nat.prime</span> <span class="n">p</span><span class="o">}</span>
</code></pre></div>



<a name="240541688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/240541688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#240541688">(May 27 2021 at 22:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Theorem.20Formalization/near/240450116">said</a>:</p>
<blockquote>
<p>Ooh, right! But for proofs it is <code>#reduce</code> which is what matters, right?</p>
</blockquote>
<p>Not exactly. <code>rfl</code> is similar but not quite as "thorough" as <code>#reduce</code>, and so it is usually a lot faster</p>



<a name="244129405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244129405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244129405">(Jun 28 2021 at 11:12)</a>:</h4>
<p>I defined Kronecker product to be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>  <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="n">p</span> <span class="n">q</span> <span class="n">s</span> <span class="n">t</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">Kronecker</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span>
<span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">q</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span>
<span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">m</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">q</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>I omitted the exact definition.<br>
Then I want to formalize the associativity.<br>
But <code>lemma K_assoc : (A ⊗ (B ⊗ C) = (A ⊗ B) ⊗ C :=sorry</code> gives me the error message:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">Kronecker</span> <span class="o">(</span><span class="n">A</span><span class="bp">⊗</span><span class="n">B</span><span class="o">)</span>
<span class="n">term</span>
  <span class="n">A</span><span class="bp">⊗</span><span class="n">B</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">m</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">q</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span> <span class="n">α</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">α</span>
</code></pre></div>
<p>How can I fix this issue? Could anyone please give me a help?</p>



<a name="244129495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244129495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244129495">(Jun 28 2021 at 11:14)</a>:</h4>
<p>Can you please post a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> ?</p>



<a name="244129537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244129537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244129537">(Jun 28 2021 at 11:14)</a>:</h4>
<p>But I know what the problem will be :-)</p>



<a name="244129790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244129790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244129790">(Jun 28 2021 at 11:17)</a>:</h4>
<p>Lean sees your lemma, and figures that it's an equality of two terms of a type, but it doesn't immediately know what the type is. So it looks at the left hand side to figure it out, and realises that the type is <code>matrix (fin (m * (p * s)) (fin (n * (q * t))</code> or something (this is where having a mwe would help me), and then it tries to make sense of the RHS, and it sees _ otimes C so decides that C should have type matrix (fin (ps)) (fin (qt)) and _ should have type matrix (fin m) (fin n), and then it takes a look at _ and realises that it can figure out the type and that it's not that.</p>



<a name="244130010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130010">(Jun 28 2021 at 11:19)</a>:</h4>
<p>The issue is that <code>a * (b * c)</code> is equal, but not definitionally equal, to <code>(a * b) * c</code>, and hence Lean is reluctant to identify <code>fin (a * (b * c))</code> and <code>fin ((a * b) * c)</code> as equal. It would rather you used <code>eq.subst</code> to get a map from one to the other.</p>



<a name="244130041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130041">(Jun 28 2021 at 11:20)</a>:</h4>
<p>I understand this is a type mismatch problem, but have no idea how to fix it :(<br>
Here is a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>. I tried to make is as short as possible.</p>



<a name="244130094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130094">(Jun 28 2021 at 11:20)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.matrix.notation</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="n">p</span> <span class="n">q</span> <span class="n">s</span> <span class="n">t</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">Kronecker</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span>
<span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">q</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span>
<span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">m</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">q</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">default</span> <span class="n">α</span>

<span class="n">localized</span> <span class="s2">"infix `⊗`:100 := Kronecker"</span> <span class="k">in</span> <span class="n">Kronecker</span>

<span class="kd">variables</span>
<span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">q</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">t</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">K_assoc</span> <span class="o">:</span>
<span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="o">(</span><span class="n">B</span> <span class="bp">⊗</span> <span class="n">C</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">)</span> <span class="bp">⊗</span> <span class="n">C</span> <span class="o">:=</span><span class="gr">sorry</span>
</code></pre></div>



<a name="244130313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130313">(Jun 28 2021 at 11:22)</a>:</h4>
<p>I could do the unhelpful thing of inserting the eq.rec into the statement of the lemma so that it compiles, but that would not solve the problem of how to prove the lemma, which would probably be a pretty nasty one.</p>



<a name="244130542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130542">(Jun 28 2021 at 11:24)</a>:</h4>
<p>Let's take a step back. Your Kronecker product is really two constructions. Firstly there is a much more natural (from the point of view of functional programming at least) multiplication <code>matrix F1 F2 alpha -&gt; matrix F3 F4 alpha -&gt; matrix (F1 x F2) (F3 x F4) alpha</code>. Your Kronecker is this composed with some functorial map coming from matrices and a construction <code>fin m x fin n -&gt; fin (m*n)</code></p>



<a name="244130574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130574">(Jun 28 2021 at 11:25)</a>:</h4>
<p>I am going to prove the lemma myself (and I gave an incorrect definition in the first place in the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> anyway).<br>
The trouble I am facing is just there is an error in the statement.</p>



<a name="244130602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130602">(Jun 28 2021 at 11:25)</a>:</h4>
<p>yes, but want to explain how there is something odd about the statement</p>



<a name="244130674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130674">(Jun 28 2021 at 11:26)</a>:</h4>
<p>The map <code>fin m x fin n -&gt; fin (m*n)</code> is rather artificial, there are many such maps.</p>



<a name="244130694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130694">(Jun 28 2021 at 11:26)</a>:</h4>
<p>It would also be great if you can help to fix the problem by rewriting the defn.</p>



<a name="244130722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130722">(Jun 28 2021 at 11:26)</a>:</h4>
<p>That will in some sense make the problem worse</p>



<a name="244130739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130739">(Jun 28 2021 at 11:27)</a>:</h4>
<p>because what I am getting around to suggesting is that you should be proving something more abstract first</p>



<a name="244130801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130801">(Jun 28 2021 at 11:27)</a>:</h4>
<p>The multiplication I indicated above, with products of finite sets, is a more low-level object and the problem already arises there, and my instinct is that we should deal with it there before we get into all the mess of the combinatorics of bijections fin m x fin n -&gt; fin (mn).</p>



<a name="244130958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244130958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244130958">(Jun 28 2021 at 11:29)</a>:</h4>
<p>Now an interesting question is how to state associativity of this more fundamental product, and here you see that we still have the problem that it cannot be stated naively in Lean, because one matrix has type <code>matrix ((F1 x F3) x F5) ((F2 x F4) x F6) alpha</code> and the other has type <code>matrix (F1 x (F3 x F5)) (F2 x (F4 x F6)) alpha</code> and these types are not equal, they're just canonically isomorphic</p>



<a name="244131091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244131091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244131091">(Jun 28 2021 at 11:31)</a>:</h4>
<p>so one should define, or perhaps just find in Lean because it's probably already there, the way to move between <code>matrix A B alpha</code> and <code>matrix  C D alpha</code> given maps from C to A and D to B (maybe it will be called <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.comap">docs#matrix.comap</a> or something)</p>



<a name="244131129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244131129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244131129">(Jun 28 2021 at 11:31)</a>:</h4>
<p>and then the statement of associativity would say that mapping a matrix along such a map gave you another matrix</p>



<a name="244131233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244131233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244131233">(Jun 28 2021 at 11:32)</a>:</h4>
<p>so then you can solve that knotty problem without all the extra fin noise, and then build the fin stuff on top where you'll have to prove some elementary number theory lemma saying that your two maps fin a -&gt; fin b -&gt; fin c -&gt; fin (abc) coincide (where you do the multiplications in two different orders)</p>



<a name="244131401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244131401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244131401">(Jun 28 2021 at 11:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Theorem.20Formalization/near/244130958">said</a>:</p>
<blockquote>
<p>Now an interesting question is how to state associativity of this more fundamental product, and here you see that we still have the problem that it cannot be stated in Lean, because one matrix has type <code>matrix ((F1 x F3) x F5) ((F2 x F4) x F6) alpha</code> and the other has type <code>matrix (F1 x (F3 x F5)) (F2 x (F4 x F6)) alpha</code> and these types are not equal, they're just canonically isomorphic</p>
</blockquote>
<p>Yes. Thanks for your explanations! At this step, we still face the same (almost) problem. (By the way, I think it would be more convenient to use <code>fin n</code> for the defn than using <code>n</code> as a fintpye as I do want elements to have orders to define the Kronecker product.)</p>



<a name="244131541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244131541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244131541">(Jun 28 2021 at 11:36)</a>:</h4>
<p>I don't know if it's there already, but you seem to need a map <code>equiv A B -&gt; equiv C D -&gt; equiv (matrix A C alpha) (matrix B D alpha)</code>. This construction (for it's a definition, not a theorem) will be needed in your statement of the more foundational product.</p>



<a name="244131616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244131616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244131616">(Jun 28 2021 at 11:37)</a>:</h4>
<p>Could you please a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> illustrating your way of solving this?</p>



<a name="244131693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244131693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244131693">(Jun 28 2021 at 11:38)</a>:</h4>
<p>The relevant map is either <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.reindex">docs#matrix.reindex</a> (if you don't care whether the equivalence is linear) or <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.reindex_linear_equiv">docs#matrix.reindex_linear_equiv</a>.</p>



<a name="244131734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244131734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244131734">(Jun 28 2021 at 11:38)</a>:</h4>
<p>(There is also <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.reindex_alg_equiv">docs#matrix.reindex_alg_equiv</a> if you only want to work with square matrices)</p>



<a name="244132095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244132095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244132095">(Jun 28 2021 at 11:42)</a>:</h4>
<p>Thank you both! I have to leave for a moment... before going back to solve the problem.</p>



<a name="244132356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244132356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244132356">(Jun 28 2021 at 11:45)</a>:</h4>
<p>Why do you need the elements to have an order to define the Kronecker product? Perhaps proofs about the definition might use the order. But the definition itself need not have it.</p>



<a name="244132973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244132973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244132973">(Jun 28 2021 at 11:52)</a>:</h4>
<p>I haven't left. Basically,  I used this to define the product (omitted many things here)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">q</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>  <span class="n">A</span> <span class="o">(</span><span class="n">i</span> <span class="bp">/</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="bp">/</span> <span class="n">q</span><span class="o">)</span> <span class="bp">*</span> <span class="n">B</span> <span class="o">(</span><span class="n">i</span> <span class="bp">%</span> <span class="n">p</span><span class="o">)(</span><span class="n">j</span> <span class="bp">%</span> <span class="n">q</span><span class="o">)</span>
</code></pre></div>
<p>What is the way not using indices?</p>



<a name="244133444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244133444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244133444">(Jun 28 2021 at 11:57)</a>:</h4>
<p>(deleted)</p>



<a name="244134360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244134360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244134360">(Jun 28 2021 at 12:07)</a>:</h4>
<p>I think Kevin's point here holds, about two separate constructions. First you make the "full" product, then you can use matrix.reindex or matrix.minor</p>



<a name="244135882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244135882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244135882">(Jun 28 2021 at 12:23)</a>:</h4>
<p>In my <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> code, <br>
<code>(A ⊗ B) ⊗ C</code> has type <code>A⊗B⊗C : matrix (fin (s * (p * m))) (fin (t * (q * n))) α</code><br>
the other has type <code>A⊗(B⊗C) : matrix (fin (s * p * m)) (fin (t * q * n)) α</code>.<br>
<code>fin (s * (p * m))</code> is not only isomorphic but also IDENTICAL to <code>fin (s * p * m)</code>.<br>
It is trivial to prove this fact</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">aux1</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">s</span> <span class="bp">*</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">m</span><span class="o">))</span> <span class="bp">=</span> <span class="n">fin</span> <span class="o">(</span><span class="n">s</span> <span class="bp">*</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">ring_nf</span>
<span class="kd">def</span> <span class="n">aux2</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">t</span> <span class="bp">*</span> <span class="o">(</span><span class="n">q</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span> <span class="n">fin</span> <span class="o">(</span><span class="n">t</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">ring_nf</span>
</code></pre></div>
<p>How can I make Lean to recognise these two identities when parsing the statement of the lemma in <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> (perhaps by adding attributes to <code>aux</code>?)?</p>



<a name="244136079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244136079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244136079">(Jun 28 2021 at 12:25)</a>:</h4>
<p><a href="#narrow/stream/267928-condensed-mathematics/topic/Kronecker.20product/near/244007513">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/Kronecker.20product/near/244007513</a> might be relevant. It's also about Kronecker products</p>



<a name="244136680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244136680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244136680">(Jun 28 2021 at 12:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="408694">Alex Zhang</span> <a href="#narrow/stream/113489-new-members/topic/Theorem.20Formalization/near/244135882">said</a>:</p>
<blockquote>
<p>In my <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> code, <br>
<code>(A ⊗ B) ⊗ C</code> has type <code>A⊗B⊗C : matrix (fin (s * (p * m))) (fin (t * (q * n))) α</code><br>
the other has type <code>A⊗(B⊗C) : matrix (fin (s * p * m)) (fin (t * q * n)) α</code>.<br>
<code>fin (s * (p * m))</code> is not only isomorphic but also IDENTICAL to <code>fin (s * p * m)</code>.<br>
It is trivial to prove this fact</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">aux1</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">s</span> <span class="bp">*</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">m</span><span class="o">))</span> <span class="bp">=</span> <span class="n">fin</span> <span class="o">(</span><span class="n">s</span> <span class="bp">*</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">ring_nf</span>
<span class="kd">def</span> <span class="n">aux2</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">t</span> <span class="bp">*</span> <span class="o">(</span><span class="n">q</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span> <span class="n">fin</span> <span class="o">(</span><span class="n">t</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">ring_nf</span>
</code></pre></div>
<p>How can I make Lean to recognise these two identities when parsing the statement of the lemma in <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> (perhaps by adding attributes to <code>aux</code>?)?</p>
</blockquote>
<p>Right, it's also about the Kronecer product. I didn't find things relevant to this particular question, however.</p>



<a name="244136986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244136986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244136986">(Jun 28 2021 at 12:32)</a>:</h4>
<p>Agreed that it's not relevant to your question. I should have said "just wanna make sure you are aware of this other effort going on".</p>



<a name="244137226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244137226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244137226">(Jun 28 2021 at 12:34)</a>:</h4>
<p>In this case, I think Lean is very bad at using the equalities <code>aux1</code> and <code>aux2</code>. So I would turn them into  <code>equiv</code>s, and then use <code>reindex</code> mentioned above.</p>



<a name="244137301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244137301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244137301">(Jun 28 2021 at 12:35)</a>:</h4>
<p>Alex, you need to use something like <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.cast">docs#equiv.cast</a>, and compose in your definition. Or use <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.cast">docs#fin.cast</a>. But it'll be easier if you generalize away from actual fin multiplication</p>



<a name="244137644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244137644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244137644">(Jun 28 2021 at 12:37)</a>:</h4>
<p>Your claim that they're identical requires a proof. Just because it's a relatively trivial proof doesn't mean it can be skipped, when doing type manipulations. And I don't know if I would call it "trivial" if you used a pretty heavy-handed tactic like ring_nf to prove it.</p>



<a name="244137949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244137949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244137949">(Jun 28 2021 at 12:40)</a>:</h4>
<p>I guess <code>congr_arg _ (mul_assoc _ _ _)</code> might also prove it...</p>



<a name="244138013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244138013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244138013">(Jun 28 2021 at 12:41)</a>:</h4>
<p>Another <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>. Is there a way to fix the error occurring in the statement of <code>silly</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">variables</span> <span class="n">m</span> <span class="n">n</span><span class="o">:</span> <span class="kt">Type</span>
<span class="kd">variables</span> <span class="n">h</span><span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">f</span><span class="o">:</span><span class="n">m</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="kd">def</span> <span class="n">g</span><span class="o">:</span><span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">silly</span><span class="o">:</span> <span class="n">f</span><span class="bp">=</span><span class="n">g</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="244138030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244138030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244138030">(Jun 28 2021 at 12:41)</a>:</h4>
<p>Of course, but there isn't support for inferring what is or isn't simple type proof munging. One could imagine having a "fin (BB(n))".</p>



<a name="244138236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244138236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244138236">(Jun 28 2021 at 12:42)</a>:</h4>
<p>Johan, thank you for letting me know.</p>



<a name="244138273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244138273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244138273">(Jun 28 2021 at 12:43)</a>:</h4>
<p>First, you are working with different types. It's only a proposition that they're equal. And you haven't included that proposition in your lemma. You might also have a proposition that they're not equal! What should the system infer then about the types?</p>



<a name="244138416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244138416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244138416">(Jun 28 2021 at 12:44)</a>:</h4>
<p>what if I include it in the lemma <code>lemma silly (h: m=n): f=g := sorry</code></p>



<a name="244138521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244138521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244138521">(Jun 28 2021 at 12:45)</a>:</h4>
<p>As a rule of thumb: equality of types is evil, bad-behaved, and should be avoided, unless it is definitional equality.</p>



<a name="244138562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244138562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244138562">(Jun 28 2021 at 12:45)</a>:</h4>
<p>(Note: a rule of thumb is exactly that: a rule of thumb.)</p>



<a name="244138912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244138912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244138912">(Jun 28 2021 at 12:48)</a>:</h4>
<p>Alex, equality of two terms of different types will always be an error. Do you mean, that for all inputs, the two functions are the same, modulo type modification?</p>



<a name="244138995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244138995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244138995">(Jun 28 2021 at 12:49)</a>:</h4>
<p>That requires an axiom (functional extensionality) to prove, and using equiv.cast or other casts to state.</p>



<a name="244138997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244138997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244138997">(Jun 28 2021 at 12:49)</a>:</h4>
<p>In the previous one <code>fin (s * (p * m)) = fin (s * p * m)</code> is decidedly equal if I am correct. The trouble is that I don't know how to make Lean recognise this when parsing.</p>



<a name="244139096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244139096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244139096">(Jun 28 2021 at 12:50)</a>:</h4>
<p>The trouble is not how to prove it. It is that the statement reports an error.</p>



<a name="244139097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244139097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244139097">(Jun 28 2021 at 12:50)</a>:</h4>
<p>One way to make it recognize it is by providing the explicit cast, which is fin.cast (your_proof)</p>



<a name="244139207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244139207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244139207">(Jun 28 2021 at 12:50)</a>:</h4>
<p>Thanks, Yakov. Could you please give a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="244139538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244139538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244139538">(Jun 28 2021 at 12:53)</a>:</h4>
<p>It might be enlightening for you to read <a href="https://xenaproject.wordpress.com/2020/07/03/equality-specifications-and-implementations/">https://xenaproject.wordpress.com/2020/07/03/equality-specifications-and-implementations/</a></p>



<a name="244139551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244139551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244139551">(Jun 28 2021 at 12:53)</a>:</h4>
<p>What I'm saying is that lean+mathlib doesn't do arbitrary type equality "fixing" like you're trying to do unless you tell it to, using cast or its relatives. And the proof can of course be a tactic, or any strength you like. "cast" and its relatives are exactly the ways to get it to consider types as equal.</p>



<a name="244139930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244139930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244139930">(Jun 28 2021 at 12:57)</a>:</h4>
<p>Here's an example from mathlib:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Given a finset `s` of cardinality `k` in a linear order `α`, the map `order_iso_of_fin s h`</span>
<span class="sd">is the increasing bijection between `fin k` and `s` as an `order_iso`. Here, `h` is a proof that</span>
<span class="sd">the cardinality of `s` is `k`. We use this instead of an iso `fin s.card ≃o s` to avoid</span>
<span class="sd">casting issues in further uses of this function. -/</span>
<span class="kd">def</span> <span class="n">order_iso_of_fin</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s.card</span> <span class="bp">=</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">≃</span><span class="n">o</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">order_iso.trans</span> <span class="o">(</span><span class="n">fin.cast</span> <span class="o">((</span><span class="n">length_sort</span> <span class="o">(</span><span class="bp">≤</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="bp">$</span>
  <span class="o">(</span><span class="n">s.sort_sorted_lt.nth_le_iso</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="bp">$</span> <span class="n">order_iso.set_congr</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">$</span>
    <span class="n">set.ext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">mem_sort</span> <span class="n">_</span>
</code></pre></div>



<a name="244140043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244140043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244140043">(Jun 28 2021 at 12:58)</a>:</h4>
<p><span class="user-mention" data-user-id="408694">@Alex Zhang</span> Sorry, I messed up. My rule of thumb should have mentioned "definitional equality" not decidable equality.</p>



<a name="244140188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244140188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244140188">(Jun 28 2021 at 12:59)</a>:</h4>
<p>With the caveat that definitional equality might hide a very expensive computation.</p>



<a name="244141892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244141892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244141892">(Jun 28 2021 at 13:12)</a>:</h4>
<p>Suppose a = b is a propositional equality and <code>h: a=b</code>. Is there a way to "cheat" Lean such that Lean will recognise <code>a=b</code> as a definitional equality after?</p>



<a name="244142142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244142142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244142142">(Jun 28 2021 at 13:14)</a>:</h4>
<p>What do you mean by cheat? That expressions like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">examples</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>are valid expressions?</p>



<a name="244142151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244142151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244142151">(Jun 28 2021 at 13:14)</a>:</h4>
<p>Nope. I'm not an expert, but I think you are looking for an extensional type theory, or something like that. Those exist, but have their own set of problems...</p>



<a name="244142619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244142619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244142619">(Jun 28 2021 at 13:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Theorem.20Formalization/near/244142142">said</a>:</p>
<blockquote>
<p>What do you mean by cheat? That expressions like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">examples</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>are valid expressions?</p>
</blockquote>
<p>Yes, just like this.</p>



<a name="244142668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244142668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244142668">(Jun 28 2021 at 13:19)</a>:</h4>
<p>That shouldn't typecheck, right?</p>



<a name="244142713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244142713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244142713">(Jun 28 2021 at 13:19)</a>:</h4>
<p>Correct, that is not a valid expression. But this is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">cast</span> <span class="n">h.symm</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="244142741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244142741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244142741">(Jun 28 2021 at 13:19)</a>:</h4>
<p>Equality needs both arguments to be of the same type. You either need a cast with <code>h</code> or use <code>heq</code> instead</p>



<a name="244143010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244143010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244143010">(Jun 28 2021 at 13:21)</a>:</h4>
<p>You could extend lean (probably easier in lean4) to try to unify types more aggressively. That might approximate what you want. For example (also, don't do this please!)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.basic</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="n">x</span> <span class="bp">`</span> <span class="bp">=</span><span class="n">F</span> <span class="bp">`</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">cast</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span> <span class="n">y</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span><span class="n">F</span> <span class="n">y</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="244143199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244143199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244143199">(Jun 28 2021 at 13:23)</a>:</h4>
<p>There are probably some scary type-theory contradictions or undecidability issues with approaches like this, having to do with <code>\omega</code> and <code>\Omega</code>. One could probably write a heuristic based unifier that could avoid such issues and have pretty errors...</p>



<a name="244143355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244143355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244143355">(Jun 28 2021 at 13:24)</a>:</h4>
<p>OR just use <code>cast</code> and its relatives explicitly when you want to do type equality. This is nice because you can get other nice properties, for example, <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.cast">docs#fin.cast</a> is order-preserving. There are many lemmas about <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.cast">docs#equiv.cast</a> and how it operates when used in composition and simplifies.</p>



<a name="244143461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244143461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244143461">(Jun 28 2021 at 13:25)</a>:</h4>
<p>But this topic is some of the friction of formalization. And the ways to formalize a particular statement require using the tools of formalization, rather than trying to cram set-theoretic like operations into the formalization.</p>



<a name="244143604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244143604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244143604">(Jun 28 2021 at 13:26)</a>:</h4>
<p>What are you referring to by omega?</p>



<a name="244143680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244143680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244143680">(Jun 28 2021 at 13:26)</a>:</h4>
<p>Kevin's, Anne's, and others' suggestions regarding generalizing your definitions to arbitrary types, breaking them up into digestable functions, etc -- these came from much experience working with the formalization and internalizing approaches that don't hit the "issue" you're faced with at the moment.</p>



<a name="244143951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244143951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244143951">(Jun 28 2021 at 13:29)</a>:</h4>
<p><span class="user-mention" data-user-id="329243">@Horatiu Cheval</span> There was a recent paper shared in Zulip about forming expressions that do not terminate when trying to normalize them, that had to do with the Omega combinator. Let me see if I can find it.</p>



<a name="244144156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244144156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244144156">(Jun 28 2021 at 13:30)</a>:</h4>
<p>Oh, I heard about that. No need to search for it</p>



<a name="244144271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244144271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244144271">(Jun 28 2021 at 13:31)</a>:</h4>
<p>I just didn't know if it was that, or some other well established omega terminology I didn't know</p>



<a name="244154211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244154211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244154211">(Jun 28 2021 at 14:36)</a>:</h4>
<p>Many thanks to all of you!!</p>



<a name="244156628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244156628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244156628">(Jun 28 2021 at 14:52)</a>:</h4>
<p>Although I can now get around this problem by using cast as Yakov suggested or using coercions, Kevin's suggestion of defining the product in a more general setting seems pretty good, and I may change my defn later and change my current defn to like <code>fin_Kronecker_prodcut</code>.</p>



<a name="244157667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244157667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244157667">(Jun 28 2021 at 14:59)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  Thank you for letting me know this. As I noticed that the more abstract tensor product has already been in the matlib, I am working with the Kronecker product in a direct and non-abstract way. It seems that that thread is doing a very abstract way as well. If you have any suggestion, please let me know!</p>



<a name="244372003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244372003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244372003">(Jun 30 2021 at 02:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Kevin, in your way of getting around this problem, should the statement of the associativity actually be'' A  \ox B \ox C isomorphic to A  \ox (B \ox C)''?</p>



<a name="244376976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244376976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244376976">(Jun 30 2021 at 04:43)</a>:</h4>
<p><span class="user-mention" data-user-id="408694">@Alex Zhang</span> yes, isomorphisms are the way to go</p>



<a name="244380953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244380953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244380953">(Jun 30 2021 at 06:07)</a>:</h4>
<p>I have the goal</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">×</span> <span class="n">M</span><span class="o">),</span> <span class="o">(</span><span class="n">A</span><span class="bp">⊗</span><span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="n">i</span> <span class="bp">*</span> <span class="o">(</span><span class="n">C</span><span class="bp">⊗</span><span class="n">D</span><span class="o">)</span> <span class="n">i</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i_1</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="n">A</span> <span class="n">i</span> <span class="n">i_1</span> <span class="bp">*</span> <span class="n">C</span> <span class="n">i_1</span> <span class="n">k</span><span class="o">)</span><span class="bp">⊗λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i_1</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">B</span> <span class="n">i</span> <span class="n">i_1</span> <span class="bp">*</span> <span class="n">D</span> <span class="n">i_1</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span>
</code></pre></div>
<p>after using <code>simp [dot_product]</code>.<br>
But I do want to have <code>i</code> in the goal written as the form <code>( , )</code>. What can I do?</p>



<a name="244381006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244381006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244381006">(Jun 30 2021 at 06:08)</a>:</h4>
<p>Wait, in your question above, are <code>A</code>, <code>B</code>, <code>C</code> matrices or rings?</p>



<a name="244381060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244381060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244381060">(Jun 30 2021 at 06:09)</a>:</h4>
<p>Johan, they are matrices.</p>



<a name="244381282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244381282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244381282">(Jun 30 2021 at 06:12)</a>:</h4>
<p>Hmm, then I'm confused. What do you mean by matrices being isomorphic?</p>



<a name="244381389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244381389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244381389">(Jun 30 2021 at 06:15)</a>:</h4>
<p>Oh, sorry for the confusion. I am just asking a question unrelated to the previous one.</p>



<a name="244381516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244381516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244381516">(Jun 30 2021 at 06:17)</a>:</h4>
<p>The problem is just that I would like to express the first <code>i</code> in the goal after using <code>simp [dot_product]</code> as a pair... but I don't know if there is a way to doing this.</p>



<a name="244381780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244381780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244381780">(Jun 30 2021 at 06:21)</a>:</h4>
<p>Well, that means you need to show that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mo stretchy="false">(</mo><mi>i</mi><mo>:</mo><mi>J</mi><mo>×</mo><mi>M</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>a</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">\sum (i : J \times M), foobar</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">oo</span><span class="mord mathnormal">ba</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> is the same as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mo stretchy="false">(</mo><msub><mi>i</mi><mn>1</mn></msub><mo>:</mo><mi>J</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>∑</mo><mo stretchy="false">(</mo><msub><mi>i</mi><mn>2</mn></msub><mo>:</mo><mi>M</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>a</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">\sum (i_1 : J), \sum (i_2 : M), foobar</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">oo</span><span class="mord mathnormal">ba</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>.</p>



<a name="244381827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244381827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244381827">(Jun 30 2021 at 06:22)</a>:</h4>
<p>There must be some lemmas about <code>sum</code> and <code>product</code>.</p>



<a name="244381864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244381864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244381864">(Jun 30 2021 at 06:23)</a>:</h4>
<p><code>rw</code> to the left with <code>finset.univ_product_univ</code>, and then use <code>finset.sum_product</code></p>



<a name="244382153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244382153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244382153">(Jun 30 2021 at 06:27)</a>:</h4>
<p>Thanks a lot! I think your answer is one step further from my question. As Lean know that <code>i</code> has type <code> J prod M</code>, my question is simply to represent <code>i</code> as a pair somehow. I am not sure whether Lean supports such a feature. Anyway, I think your solution does help!</p>



<a name="244382220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244382220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244382220">(Jun 30 2021 at 06:29)</a>:</h4>
<p>If you know a way of just rewriting <code>i</code> without split the sum into two sums, please also let me know!</p>



<a name="244382425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244382425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244382425">(Jun 30 2021 at 06:32)</a>:</h4>
<p>It seems that lean does not allow me to naively rewrite <code>i</code> to say <code>\&lt;i1, i2&gt;</code> as <code>i</code> is not in the context.</p>



<a name="244382727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Theorem%20Formalization/near/244382727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Theorem.20Formalization.html#244382727">(Jun 30 2021 at 06:37)</a>:</h4>
<p>You could try to simp backwards with something like <code>prod.eta</code> or whatever it is called.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
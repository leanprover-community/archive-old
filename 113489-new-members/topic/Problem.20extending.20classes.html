---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Problem.20extending.20classes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html">Problem extending classes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="212585722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212585722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212585722">(Oct 07 2020 at 16:39)</a>:</h4>
<p>Hi,</p>
<p>I am trying to formalize Hilbert's axioms for the plane (again) using nice notation so that students can play with them. So I want undefined terms Point and Line (which I finally realized should be Types) and many axioms on them. In order to make the axioms (and subsequent theorems) easy to parse, I want to introduce concepts like Segment, Ray, Angle, Triangle,...<br>
The place where I get stuck is when I try to use a structure that I created (namely Segment) inside the definition of the class. I guess that I need to add parameters to the definition, but I don't see how to do it. Maybe this MWE is illustrative:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">class</span> <span class="n">PreHilbertPlane</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
    <span class="o">(</span><span class="n">Line</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>

    <span class="o">(</span><span class="n">belongs</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

    <span class="o">(</span><span class="kd">notation</span> <span class="n">A</span> <span class="bp">`∈`</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">belongs</span> <span class="n">A</span> <span class="n">ℓ</span><span class="o">)</span>

    <span class="o">(</span><span class="n">I1</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">(</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">))</span>
    <span class="o">(</span><span class="n">I2</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span>
    <span class="o">(</span><span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>


<span class="kd">variable</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="n">PreHilbertPlane</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">ℓ</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Line</span><span class="o">}</span>

<span class="kd">notation</span> <span class="n">A</span> <span class="bp">`*`</span> <span class="n">B</span> <span class="bp">`*`</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">PreHilbertPlane.between</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span>
<span class="kd">notation</span> <span class="n">A</span> <span class="bp">`∈`</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">PreHilbertPlane.belongs</span> <span class="n">A</span> <span class="n">ℓ</span>

<span class="kd">def</span> <span class="n">line_to_set</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Line</span> <span class="bp">→</span> <span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ℓ</span> <span class="o">,</span> <span class="o">{</span> <span class="n">P</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Point</span> <span class="bp">|</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">line_to_set_coe</span> <span class="o">:</span>
  <span class="n">has_coe</span> <span class="o">(</span><span class="bp">Ω.</span><span class="n">Line</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">line_to_set</span><span class="o">⟩</span>

<span class="kd">structure</span> <span class="n">Segment</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">)</span>
    <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">)</span>

<span class="kd">notation</span> <span class="n">A</span> <span class="bp">`⬝`</span><span class="o">:</span><span class="mi">100</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">Segment.mk</span> <span class="n">A</span> <span class="n">B</span>

<span class="kd">def</span> <span class="n">segment_to_set</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="n">PreHilbertPlane</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span> <span class="o">:=</span>
    <span class="o">{</span><span class="n">S.A</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">S.B</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">C</span> <span class="bp">|</span> <span class="n">S.A</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">S.B</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">segment_to_set_coe</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="n">PreHilbertPlane</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">has_coe</span> <span class="o">(</span><span class="n">Segment</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">segment_to_set</span><span class="o">⟩</span>

<span class="kd">class</span> <span class="n">HilbertPlane</span> <span class="kd">extends</span> <span class="n">PreHilbertPlane</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">seg_cong</span> <span class="o">:</span> <span class="n">Segment</span> <span class="bp">→</span> <span class="n">Segment</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≅`</span><span class="o">:</span><span class="mi">1</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">seg_cong</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>

    <span class="o">(</span><span class="n">C21</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="n">U</span> <span class="o">:</span> <span class="n">Segment</span><span class="o">}:</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">T</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">T</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">))</span>
    <span class="o">(</span><span class="n">C3</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span><span class="bp">⬝</span><span class="n">B</span> <span class="bp">≅</span> <span class="n">D</span><span class="bp">⬝</span><span class="n">E</span> <span class="bp">→</span> <span class="n">B</span><span class="bp">⬝</span><span class="n">C</span> <span class="bp">≅</span> <span class="n">E</span><span class="bp">⬝</span><span class="n">F</span> <span class="bp">→</span> <span class="n">A</span><span class="bp">⬝</span><span class="n">C</span> <span class="bp">≅</span> <span class="n">D</span><span class="bp">⬝</span><span class="n">F</span><span class="o">))</span>
</code></pre></div>

<p>(Beware: the axioms are NOT correct, they need extra assumptions which I don't care about in this question)</p>
<p>After defining PreHilbertPlane with some axioms (and the notions of Point and Line, and belong), in order to introduce new axioms I need to have the (undefined) notion of "congruent segments". This can be thought foundationally as <code>Point \imp Point \imp Point \imp Point \imp Prop</code>, but I want to instead consider it as <code>Segment \imp Segment \imp Prop</code>. This will be more practical with later axioms, that would involve angles (and 6 points at least), and also with theorems that involve several segments and angles.</p>
<p>I want to define a structure called Segment that essentially remembers the two points that created it, and that can be thought of as a set when needed. In the HilbertPlane class I need to use this notion both to define "congruence" and to state axioms C21 and C3. But I can't make it to typecheck...</p>
<p>Any hints?</p>



<a name="212585887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212585887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212585887">(Oct 07 2020 at 16:41)</a>:</h4>
<p>It would be easier to guess if you mentioned which part doesn't type check, and with what error.</p>



<a name="212585944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212585944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212585944">(Oct 07 2020 at 16:41)</a>:</h4>
<p>But I'm suspicious that you write <code>Ω.Point</code> but not <code>Ω.Segment</code>; so I'm guessing that Lean has no way to work out what <code>Ω</code> you consider segments in.</p>



<a name="212586145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212586145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212586145">(Oct 07 2020 at 16:43)</a>:</h4>
<p>The first error is at C21. If I comment that line out, then C3 also errs.</p>



<a name="212586330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212586330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212586330">(Oct 07 2020 at 16:45)</a>:</h4>
<p>And yes, the problem is that I want the Omega in my segments appearing in C21 and C3 to be something like "this". That is, a term of type <code>HilbertPlane</code>, which I am just defining!</p>



<a name="212586788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212586788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212586788">(Oct 07 2020 at 16:48)</a>:</h4>
<p>This is a bit awkward and not necessarily the best way but something like <code>(seg_cong : @Segment to_PreHilbertPlane → @Segment to_PreHilbertPlane → Prop)</code> should be enough for Lean to get the right idea</p>



<a name="212587546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212587546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212587546">(Oct 07 2020 at 16:54)</a>:</h4>
<p>Thanks! What would be the Lean way to do it, then?</p>
<p>This works (I just added parentheses to avoid precedence fight):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">HilbertPlane</span> <span class="kd">extends</span> <span class="n">PreHilbertPlane</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">seg_cong</span> <span class="o">:</span> <span class="bp">@</span><span class="n">Segment</span> <span class="n">to_PreHilbertPlane</span> <span class="bp">→</span> <span class="bp">@</span><span class="n">Segment</span> <span class="n">to_PreHilbertPlane</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≅`</span><span class="o">:</span><span class="mi">1</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">seg_cong</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>

    <span class="o">(</span><span class="n">C21</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="n">U</span> <span class="o">:</span> <span class="n">Segment</span><span class="o">}:</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">T</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">T</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">))</span>
    <span class="o">(</span><span class="n">C3</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">:</span> <span class="o">((</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">D</span><span class="bp">⬝</span><span class="n">E</span><span class="o">))</span> <span class="bp">→</span> <span class="o">((</span><span class="n">B</span><span class="bp">⬝</span><span class="n">C</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">E</span><span class="bp">⬝</span><span class="n">F</span><span class="o">))</span> <span class="bp">→</span> <span class="o">((</span><span class="n">A</span><span class="bp">⬝</span><span class="n">C</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">D</span><span class="bp">⬝</span><span class="n">F</span><span class="o">)))</span>
</code></pre></div>



<a name="212666902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212666902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212666902">(Oct 08 2020 at 09:40)</a>:</h4>
<p>I encountered a new problem. When working with the Plane, it is convenient to being able to think of many objects (lines, segments, rays, ...) as sets, so that if S is a segment and L is a line, it should make sense to write S \subseteq L. The first example is (though stupid) that the underlying set of a line <code>L</code> is the set of points <code>P</code> such that <code>belong P L</code> to it, where <code>belong</code> is the undefined notion. When I write something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">namespace</span> <span class="n">hilbertplane</span>

<span class="kd">class</span> <span class="n">PreHilbertPlane</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
    <span class="o">(</span><span class="n">Line</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
        <span class="o">(</span><span class="n">belongs</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="n">I1</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">(</span> <span class="n">belongs</span> <span class="n">A</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">belongs</span> <span class="n">B</span> <span class="n">ℓ</span> <span class="o">))</span>

<span class="kd">variable</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="n">PreHilbertPlane</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">ℓ</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Line</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">line_to_set</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Line</span> <span class="bp">→</span> <span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ℓ</span> <span class="o">,</span> <span class="o">{</span> <span class="n">P</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Point</span> <span class="bp">|</span> <span class="n">PreHilbertPlane.belongs</span> <span class="n">P</span> <span class="n">ℓ</span><span class="o">}</span>

<span class="kd">@[priority 10]</span> <span class="kd">instance</span> <span class="n">line_to_set_coe</span> <span class="o">:</span>
  <span class="n">has_coe</span> <span class="o">(</span><span class="bp">Ω.</span><span class="n">Line</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">line_to_set</span><span class="o">⟩</span>

<span class="kd">@[priority 10]</span> <span class="kd">instance</span> <span class="n">line_to_set_coe_t</span> <span class="o">:</span>
  <span class="n">has_coe_t</span> <span class="o">(</span><span class="bp">Ω.</span><span class="n">Line</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">line_to_set</span><span class="o">⟩</span>

<span class="kd">@[priority 10]</span> <span class="kd">instance</span> <span class="n">line_to_set_lift</span> <span class="o">:</span>
  <span class="n">has_lift</span> <span class="o">(</span><span class="bp">Ω.</span><span class="n">Line</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">line_to_set</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">I11</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Line</span><span class="o">),</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">exists_of_exists_unique</span> <span class="o">(</span><span class="n">PreHilbertPlane.I1</span> <span class="n">h</span><span class="o">),</span>
<span class="kd">end</span>
<span class="kd">end</span> <span class="n">hilbertplane</span>
</code></pre></div>

<p>then lemma I11 doesn't typecheck because Lean doesn't understand <code>A ∈ ℓ</code>. I know that I could define notation in this case, or that <code>A ∈  (ℓ : set Ω.Point)</code> does work, but I'd like to avoid manual coercions. I'd hope that by opening set (or something similar) Lean would decide that the thing on the left has to be a set, and do the coercion automatically. Is this doable?</p>



<a name="212757000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212757000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212757000">(Oct 08 2020 at 22:28)</a>:</h4>
<p>Why not just define a <code>has_mem</code> instance?</p>



<a name="212787856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212787856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212787856">(Oct 09 2020 at 06:35)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, <code>has_mem</code> would work in the same way that <code>notation A `∈` r` := belongs A r</code> would, but then for segments, rays,... I would need to write all the set-theory-like instances ( subset, intersect, union,...) as well, and that doesn't seem the right way. I want that statements like <code>A#B \subseteq B#A</code> work well (where A#B means the Segment A B). I want also that <code>A#B \subseteq ray A B</code> typechecks (the segment is contained in the ray originating at A through B) and so on.<br>
I'd be willing to sacrifice the <code>∈</code> notation for the undefined concept of "belongs" so that everything except points is a set whenever needed.</p>



<a name="212788286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212788286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212788286">(Oct 09 2020 at 06:43)</a>:</h4>
<p>I'm no expert at infrastructure but maybe you could put a simp lemma making it unfold to what you want it to unfold to?</p>



<a name="212788372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212788372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212788372">(Oct 09 2020 at 06:44)</a>:</h4>
<p>When I tried I couldn't make the <em>statements</em> of lemmas to typecheck. Simp lemmas help with the simp tactic, right? But do not work automatically, when writing statements, if I understand that correctly.</p>



<a name="212788395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212788395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212788395">(Oct 09 2020 at 06:45)</a>:</h4>
<p>Maybe I don't understand the question properly, sorry</p>



<a name="212788452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212788452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212788452">(Oct 09 2020 at 06:46)</a>:</h4>
<p>I'll try to work out a more illustrative <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>.</p>



<a name="212788468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212788468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212788468">(Oct 09 2020 at 06:46)</a>:</h4>
<p>I'm sorry, I just rushed through your question -- I am in teaching hell for another week</p>



<a name="212788909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212788909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212788909">(Oct 09 2020 at 06:55)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> I don't think <code>has_mem</code> is able to automatically insert a <code>coe</code> for you -- part of it is that typeclass resolution is unable to infer that <code>ℓ</code> should be coerced to a set.  I'll write some instances in just a moment for how to use <code>has_mem</code> and probably what <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> is talking about with simp lemmas.</p>



<a name="212789254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212789254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212789254">(Oct 09 2020 at 07:00)</a>:</h4>
<p>Here is the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> I promised. I would like the four lemmas to typecheck, but only the first 2 do.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.set</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">class</span> <span class="n">PreHilbertPlane</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
    <span class="o">(</span><span class="n">Line</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>

    <span class="o">(</span><span class="n">belongs</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

    <span class="o">(</span><span class="kd">notation</span> <span class="n">A</span> <span class="bp">`∈`</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">belongs</span> <span class="n">A</span> <span class="n">ℓ</span><span class="o">)</span>

    <span class="o">(</span><span class="n">I1</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">(</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">))</span>
    <span class="o">(</span><span class="n">I2</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span>
    <span class="o">(</span><span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>


<span class="kd">variable</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="n">PreHilbertPlane</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">ℓ</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Line</span><span class="o">}</span>

<span class="kd">notation</span> <span class="n">A</span> <span class="bp">`*`</span> <span class="n">B</span> <span class="bp">`*`</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">PreHilbertPlane.between</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span>
<span class="kd">notation</span> <span class="n">A</span> <span class="bp">`∈`</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">PreHilbertPlane.belongs</span> <span class="n">A</span> <span class="n">ℓ</span>

<span class="kd">def</span> <span class="n">line_to_set</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Line</span> <span class="bp">→</span> <span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ℓ</span> <span class="o">,</span> <span class="o">{</span> <span class="n">P</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Point</span> <span class="bp">|</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">line_to_set_coe</span> <span class="o">:</span>
  <span class="n">has_coe</span> <span class="o">(</span><span class="bp">Ω.</span><span class="n">Line</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">line_to_set</span><span class="o">⟩</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">    A segment is created by giving two points.</span>
<span class="cm">-/</span>
<span class="kd">structure</span> <span class="n">Segment</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">)</span>
    <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">)</span>

<span class="kd">notation</span> <span class="n">A</span> <span class="bp">`⬝`</span><span class="o">:</span><span class="mi">100</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">Segment.mk</span> <span class="n">A</span> <span class="n">B</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">    When thought of as a set, it is the the set consisting of the endpoints</span>
<span class="cm">    and all the points between them</span>
<span class="cm">-/</span>
<span class="kd">def</span> <span class="n">segment_to_set</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="n">PreHilbertPlane</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span> <span class="o">:=</span>
    <span class="o">{</span><span class="n">S.A</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">S.B</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">C</span> <span class="bp">|</span> <span class="n">S.A</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">S.B</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">segment_to_set_coe</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="n">PreHilbertPlane</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">has_coe</span> <span class="o">(</span><span class="n">Segment</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">segment_to_set</span><span class="o">⟩</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">    Here we write some axioms about an undefined notion of 'congruence of segments'</span>
<span class="cm">-/</span>
<span class="kd">class</span> <span class="n">HilbertPlane</span> <span class="kd">extends</span> <span class="n">PreHilbertPlane</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">seg_cong</span> <span class="o">:</span> <span class="bp">@</span><span class="n">Segment</span> <span class="n">to_PreHilbertPlane</span> <span class="bp">→</span> <span class="bp">@</span><span class="n">Segment</span> <span class="n">to_PreHilbertPlane</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≅`</span><span class="o">:</span><span class="mi">1</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">seg_cong</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>

    <span class="o">(</span><span class="n">C21</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="n">U</span> <span class="o">:</span> <span class="n">Segment</span><span class="o">}:</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">T</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">T</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">))</span>
    <span class="o">(</span><span class="n">C3</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">:</span> <span class="o">((</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">D</span><span class="bp">⬝</span><span class="n">E</span><span class="o">))</span> <span class="bp">→</span> <span class="o">((</span><span class="n">B</span><span class="bp">⬝</span><span class="n">C</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">E</span><span class="bp">⬝</span><span class="n">F</span><span class="o">))</span> <span class="bp">→</span> <span class="o">((</span><span class="n">A</span><span class="bp">⬝</span><span class="n">C</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">D</span><span class="bp">⬝</span><span class="n">F</span><span class="o">)))</span>

<span class="kd">lemma</span> <span class="n">first_lemma</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="bp">Ω.</span><span class="n">Line</span><span class="o">),</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="c1">-- checks</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">second_lemma</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω.</span><span class="n">Point</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">B</span><span class="bp">⬝</span><span class="n">A</span> <span class="o">:=</span> <span class="c1">-- checks</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">third_lemma</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">)</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">B</span><span class="bp">⬝</span><span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="c1">-- fails</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">fourth_lemma</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℓ</span> <span class="bp">∩</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span> <span class="c1">-- fails</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="212789859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212789859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212789859">(Oct 09 2020 at 07:10)</a>:</h4>
<p>At some point I was sold the idea that implementing the Hilbert Plane using types for both Point and Line was better than using sets. I saw the advantage, and I am trying to push it to the rest of objects. It is much nicer to have a lemma that says</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">nice_lemma</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="n">r</span><span class="o">:</span> <span class="n">Segment</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">≅</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">≅</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">≅</span> <span class="n">r</span>
</code></pre></div>

<p>than one saying</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">not_so_nice_lemma</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span><span class="bp">⬝</span><span class="n">B</span> <span class="bp">≅</span> <span class="n">C</span><span class="bp">⬝</span><span class="n">D</span> <span class="bp">→</span> <span class="n">A</span><span class="bp">⬝</span><span class="n">B</span> <span class="bp">≅</span> <span class="n">E</span><span class="bp">⬝</span><span class="n">F</span> <span class="bp">→</span> <span class="n">C</span><span class="bp">⬝</span><span class="n">D</span> <span class="bp">≅</span> <span class="n">E</span><span class="bp">⬝</span><span class="n">F</span>
</code></pre></div>

<p>The nice_lemma has the advantage that I would easily impose that a segment requires two distinct points, and then the statement wouldn't have to change, whereas the not_so_nice_lemma would have to include a hypothesis for each pair of points. I regard the first solution as Lean's take on encapsulation, which is great.</p>



<a name="212791294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212791294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212791294">(Oct 09 2020 at 07:32)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span>  I have an idea for how to get subsets and such to work, but in the meantime here are some modifications to your code so far.  One thing is that classes should have parameters so that they can actually play a role in the typeclass inference system.  It seems reasonable to make <code>Point</code> a parameter, and then have <code>variables {Plane : Type*} [PreHilbertPlane Plane]</code> and speak of points <code>X Y : Plane</code>.  Another is that custom notation should probably be different from built-in notation since Lean's disambiguation system doesn't always work out.</p>
<p>What I'm going to investigate is having Lines be sets <em>outside</em> the definition of the class.  This would let you use subset notation.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.set</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="c1">-- don't want this to be a class since it's not attached to any type, so there's nothing to infer.</span>
<span class="c1">-- Maybe if the points type were the type the plane is associated with then it would be a good class?</span>
<span class="kd">class</span> <span class="n">PreHilbertPlane</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Line</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">belongs</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kd">notation</span> <span class="n">A</span> <span class="bp">`∈`</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">belongs</span> <span class="n">A</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">I1'</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">(</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">))</span>
<span class="o">(</span><span class="n">I2'</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">I3'</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>

<span class="kn">namespace</span> <span class="n">PreHilbertPlane</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">PreHilbertPlane</span> <span class="n">Plane</span><span class="o">]</span>

<span class="kd">instance</span> <span class="n">Line.has_mem</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Plane</span> <span class="o">(</span><span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">ℓ</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">ℓ</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">line_to_set</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span> <span class="o">:=</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">Plane</span> <span class="bp">|</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">Line.has_coe</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">line_to_set</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">points_between</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span> <span class="o">:=</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">Plane</span> <span class="bp">|</span> <span class="n">between</span> <span class="n">A</span> <span class="n">P</span> <span class="n">B</span><span class="o">}</span>

<span class="c1">-- Put the axioms in terms of this has_mem</span>
<span class="kd">lemma</span> <span class="n">I1</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I1'</span> <span class="n">h</span>
<span class="kd">lemma</span> <span class="n">I2</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I2'</span> <span class="n">ℓ</span>
<span class="kd">lemma</span> <span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I3'</span>

<span class="kd">end</span> <span class="n">PreHilbertPlane</span>

<span class="kn">open</span> <span class="n">PreHilbertPlane</span>

<span class="c1">-- it's best not to overload notation if you can help it.</span>
<span class="c1">--notation A `*` B `*` C := PreHilbertPlane.between A B C</span>
<span class="c1">--notation A `∈` ℓ := PreHilbertPlane.belongs A ℓ</span>

<span class="sd">/-- A segment is created by giving two points. -/</span>
<span class="kd">structure</span> <span class="n">Segment</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span>
<span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span>

<span class="kd">notation</span> <span class="n">A</span> <span class="bp">`⬝`</span><span class="o">:</span><span class="mi">100</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">Segment.mk</span> <span class="n">A</span> <span class="n">B</span>

<span class="kn">namespace</span> <span class="n">Segment</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">PreHilbertPlane</span> <span class="n">Plane</span><span class="o">]</span>

<span class="sd">/--</span>
<span class="sd">When thought of as a set, it is the the set consisting of the endpoints</span>
<span class="sd">and all the points between them</span>
<span class="sd">-/</span>
<span class="kd">def</span> <span class="n">to_set</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">S.A</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">S.B</span><span class="o">}</span> <span class="bp">∪</span> <span class="n">points_between</span> <span class="n">S.A</span> <span class="n">S.B</span>

<span class="kd">instance</span> <span class="n">has_coe_to_set</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">to_set</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="n">Segment</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Here we write some axioms about an undefined notion of 'congruence of segments'</span>
<span class="cm">-/</span>
<span class="kd">class</span> <span class="n">HilbertPlane</span> <span class="o">(</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">PreHilbertPlane</span> <span class="n">Plane</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">seg_cong</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="n">Segment</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≅`</span><span class="o">:</span><span class="mi">50</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">seg_cong</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">(</span><span class="n">C21</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="n">U</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">}:</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">T</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">T</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">))</span>
<span class="o">(</span><span class="n">C3</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">}</span> <span class="o">:</span> <span class="o">((</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">D</span><span class="bp">⬝</span><span class="n">E</span><span class="o">))</span> <span class="bp">→</span> <span class="o">((</span><span class="n">B</span><span class="bp">⬝</span><span class="n">C</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">E</span><span class="bp">⬝</span><span class="n">F</span><span class="o">))</span> <span class="bp">→</span> <span class="o">((</span><span class="n">A</span><span class="bp">⬝</span><span class="n">C</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">D</span><span class="bp">⬝</span><span class="n">F</span><span class="o">)))</span>

<span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≅`</span><span class="o">:</span><span class="mi">50</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">HilbertPlane.seg_cong</span> <span class="n">X</span> <span class="n">Y</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">HilbertPlane</span> <span class="n">Plane</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">first_lemma</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">),</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="c1">-- checks</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">second_lemma</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">B</span><span class="bp">⬝</span><span class="n">A</span> <span class="o">:=</span> <span class="c1">-- checks</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">third_lemma</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">)</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">B</span><span class="bp">⬝</span><span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="c1">-- fails</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">fourth_lemma</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℓ</span> <span class="bp">∩</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span> <span class="c1">-- fails</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="212791668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212791668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212791668">(Oct 09 2020 at 07:38)</a>:</h4>
<p>Some example <code>simp</code> lemmas you might have in the <code>PreHilbertSpace</code> namespace are</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_to_mem</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_set_to_mem</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">line_to_set</span> <span class="n">ℓ</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>
</code></pre></div>

<p>These normalize things to be in terms of <code>between</code>, which is how the <code>has_mem</code> instance is defined.</p>



<a name="212791734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212791734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212791734">(Oct 09 2020 at 07:38)</a>:</h4>
<p>I wonder if we can redefine <code>subset</code> using something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">subset</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">{{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}},</span> <span class="n">x</span> <span class="bp">∈</span><span class="n">s</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span>
</code></pre></div>



<a name="212791765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212791765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212791765">(Oct 09 2020 at 07:39)</a>:</h4>
<p>I'm not sure if Lean is good enough at finding <code>α</code> based on <code>has_mem</code> instances to make it work.</p>



<a name="212791781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212791781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212791781">(Oct 09 2020 at 07:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> What do you think?</p>



<a name="212791796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212791796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212791796">(Oct 09 2020 at 07:39)</a>:</h4>
<p>This would solve, e.g., some duplication of lemmas between sets and finsets.</p>



<a name="212791856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212791856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212791856">(Oct 09 2020 at 07:40)</a>:</h4>
<p>And we'll be able to say <code>s ⊆ t</code> for <code>(s : set α)</code> and <code>(t : finset α)</code> without any coercions.</p>



<a name="212791925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212791925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212791925">(Oct 09 2020 at 07:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Problem.20extending.20classes/near/212791668">said</a>:</p>
<blockquote>
<p>Some example <code>simp</code> lemmas you might have in the <code>PreHilbertSpace</code> namespace are</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_to_mem</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_set_to_mem</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">line_to_set</span> <span class="n">ℓ</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>
</code></pre></div>

<p>These normalize things to be in terms of <code>between</code>, which is how the <code>has_mem</code> instance is defined.</p>
</blockquote>
<p>Thanks! I assume you mean <code>belongs</code> and not <code>between</code> :-). I'll try to see how this plays with the other definitions...</p>



<a name="212792145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212792145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212792145">(Oct 09 2020 at 07:42)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> I think I don't need to work with finset at this time... I just want the set notation to work with all my objects. Ideally, without defining each of <code>subset</code>, <code>intersect</code>,...</p>



<a name="212792213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212792213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212792213">(Oct 09 2020 at 07:43)</a>:</h4>
<p>Indeed <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>.  These sorts of simp lemmas exist pretty much whenever a <code>has_coe_to_fun</code> instance or a <code>has_coe</code> instance with a <code>has_mem</code> instance exist.  In the latter case, you can see it with <code>submonoid</code>.  (and <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> is just thinking about the design of Lean/mathlib in general)</p>



<a name="212792488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212792488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212792488">(Oct 09 2020 at 07:46)</a>:</h4>
<p>You'll have to define <code>intersect</code> anyway because you want it to act on bundled objects, not their coercions to <code>set α</code>.</p>



<a name="212792578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212792578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212792578">(Oct 09 2020 at 07:46)</a>:</h4>
<p>And yes, I'm thinking how can we refactor <code>mathlib</code> to make it easier to add more "bundled sets"</p>



<a name="212792603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212792603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212792603">(Oct 09 2020 at 07:47)</a>:</h4>
<p>And <code>finset</code> is just a example.</p>



<a name="212792623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212792623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212792623">(Oct 09 2020 at 07:47)</a>:</h4>
<p>Bringing in <code>submonoid</code>s raises more questions (e.g., set notation vs lattice notation).</p>



<a name="212797227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212797227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212797227">(Oct 09 2020 at 08:38)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> I can't see a way to get set-like notation to work without having a coercion function.  Maybe you'll be ok with the one below, which is a function <code>pts</code> that can take things to their set of points.  It's like <code>has_coe</code>, but the thing being turned into the set of points gets to decide the points type. (I also added extension of segments to lines.)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.set</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">class</span> <span class="n">PreHilbertPlane</span> <span class="o">(</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Line</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">belongs</span> <span class="o">:</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="n">Line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kd">notation</span> <span class="n">A</span> <span class="bp">`∈`</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">belongs</span> <span class="n">A</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">I1'</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">(</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">))</span>
<span class="o">(</span><span class="n">I2'</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">I3'</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>

<span class="kd">class</span> <span class="n">has_points</span> <span class="o">(</span><span class="n">point_type</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">pts</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">point_type</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">has_points</span> <span class="o">(</span><span class="n">pts</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">PreHilbertPlane</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">PreHilbertPlane</span> <span class="n">Plane</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_points</span> <span class="n">Plane</span> <span class="o">(</span><span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pts</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">Plane</span> <span class="bp">|</span> <span class="n">belongs</span> <span class="n">P</span> <span class="n">ℓ</span><span class="o">}</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">Line.has_coe</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pts</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">points_between</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span> <span class="o">:=</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">Plane</span> <span class="bp">|</span> <span class="n">between</span> <span class="n">A</span> <span class="n">P</span> <span class="n">B</span><span class="o">}</span>

<span class="c1">-- Put the axioms in terms of this has_mem</span>
<span class="kd">lemma</span> <span class="n">I1</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I1'</span> <span class="n">h</span>
<span class="kd">lemma</span> <span class="n">I2</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I2'</span> <span class="n">ℓ</span>
<span class="kd">lemma</span> <span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">C</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I3'</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_coe_to_mem_pts</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">end</span> <span class="n">PreHilbertPlane</span>

<span class="kn">open</span> <span class="n">PreHilbertPlane</span>

<span class="sd">/-- A segment is created by giving two points. -/</span>
<span class="kd">structure</span> <span class="n">Segment</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span>
<span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span>

<span class="kd">notation</span> <span class="n">A</span> <span class="bp">`⬝`</span><span class="o">:</span><span class="mi">100</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">Segment.mk</span> <span class="n">A</span> <span class="n">B</span>

<span class="kn">namespace</span> <span class="n">Segment</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">PreHilbertPlane</span> <span class="n">Plane</span><span class="o">]</span>

<span class="sd">/--</span>
<span class="sd">When thought of as a set, it is the the set consisting of the endpoints</span>
<span class="sd">and all the points between them</span>
<span class="sd">-/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_points</span> <span class="n">Plane</span> <span class="o">(</span><span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pts</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span><span class="o">,</span> <span class="o">{</span><span class="n">S.A</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">S.B</span><span class="o">}</span> <span class="bp">∪</span> <span class="n">points_between</span> <span class="n">S.A</span> <span class="n">S.B</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">has_coe_to_set</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pts</span><span class="o">⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_coe_to_mem_pts</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">S</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_pts</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">S</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">=</span> <span class="n">S.A</span> <span class="bp">∨</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">S.B</span> <span class="bp">∨</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">points_between</span> <span class="n">S.A</span> <span class="n">S.B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dunfold</span> <span class="n">pts</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">conv_lhs</span> <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="n">rw</span> <span class="n">or.comm</span><span class="o">,</span> <span class="o">},</span> <span class="n">rw</span> <span class="n">or.assoc</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">Segment</span>


<span class="c">/-</span><span class="cm"></span>
<span class="cm">Here we write some axioms about an undefined notion of 'congruence of segments'</span>
<span class="cm">-/</span>
<span class="kd">class</span> <span class="n">HilbertPlane</span> <span class="o">(</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">PreHilbertPlane</span> <span class="n">Plane</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">seg_cong</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="n">Segment</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≅`</span><span class="o">:</span><span class="mi">50</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">seg_cong</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">(</span><span class="n">C21</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="n">U</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">}:</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">T</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">T</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">))</span>
<span class="o">(</span><span class="n">C3</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">}</span> <span class="o">:</span> <span class="o">((</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">D</span><span class="bp">⬝</span><span class="n">E</span><span class="o">))</span> <span class="bp">→</span> <span class="o">((</span><span class="n">B</span><span class="bp">⬝</span><span class="n">C</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">E</span><span class="bp">⬝</span><span class="n">F</span><span class="o">))</span> <span class="bp">→</span> <span class="o">((</span><span class="n">A</span><span class="bp">⬝</span><span class="n">C</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">D</span><span class="bp">⬝</span><span class="n">F</span><span class="o">)))</span>

<span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≅`</span><span class="o">:</span><span class="mi">50</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">HilbertPlane.seg_cong</span> <span class="n">X</span> <span class="n">Y</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">HilbertPlane</span> <span class="n">Plane</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span>

<span class="sd">/-- first_lemma, which is just `PreHilbertPlane.I1` but for a `HilbertPlane`, so not really necessary. -/</span>
<span class="kd">lemma</span> <span class="n">I1</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">),</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I1</span> <span class="n">h</span>

<span class="kd">def</span> <span class="n">Segment.extend</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S.A</span> <span class="bp">≠</span> <span class="n">S.B</span><span class="o">)</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span> <span class="o">:=</span> <span class="n">classical.some</span> <span class="o">(</span><span class="n">I1</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">Segment.extend_spec</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S.A</span> <span class="bp">≠</span> <span class="n">S.B</span><span class="o">)</span> <span class="o">:</span> <span class="n">S.A</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">S.extend</span> <span class="n">h</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">S.B</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">S.extend</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">classical.some_spec</span> <span class="o">(</span><span class="n">I1</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">lemma</span> <span class="n">Segment.extend_unique</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S.A</span> <span class="bp">≠</span> <span class="n">S.B</span><span class="o">)</span> <span class="o">(</span><span class="n">S'</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">S'.A</span> <span class="bp">≠</span> <span class="n">S'.B</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h''</span> <span class="o">:</span> <span class="n">S.A</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">S'.extend</span> <span class="n">h'</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">S.B</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">S'.extend</span> <span class="n">h'</span><span class="o">))</span> <span class="o">:</span> <span class="n">S'.extend</span> <span class="n">h'</span> <span class="bp">=</span> <span class="n">S.extend</span> <span class="n">h</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">classical.some_spec</span> <span class="o">(</span><span class="n">I1</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">S'.extend</span> <span class="n">h'</span><span class="o">)</span> <span class="n">h''</span>

<span class="kd">lemma</span> <span class="n">second_lemma</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">B</span><span class="bp">⬝</span><span class="n">A</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">or.assoc</span><span class="o">,</span> <span class="n">conv</span> <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="n">rw</span> <span class="n">or.comm</span> <span class="o">},</span> <span class="n">rw</span> <span class="n">or.assoc</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- needs commutativity of `between`</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">third_lemma</span> <span class="o">:</span> <span class="n">pts</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">pts</span> <span class="o">(</span><span class="n">B</span><span class="bp">⬝</span><span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">fourth_lemma</span> <span class="o">:</span> <span class="o">(</span><span class="n">pts</span> <span class="n">ℓ</span> <span class="bp">∩</span> <span class="n">pts</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="212797482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212797482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212797482">(Oct 09 2020 at 08:40)</a>:</h4>
<p>I removed the <code>has_mem</code> instances because <code>pts</code> suffices.  You could also remove the <code>has_coe</code> instances unless you find you need them for some reason.</p>



<a name="212798921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212798921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212798921">(Oct 09 2020 at 08:54)</a>:</h4>
<p>Actually, it seems like <code>has_mem</code> is the way to go along with an extra definition</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">pts</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">}</span>
</code></pre></div>

<p>This is a coercion to sets such that <code>β</code> determines <code>α</code>.  You mostly don't need to use <code>pts</code> below unless you deal with, for example, subsets or intersections.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.set</span>

<span class="kd">def</span> <span class="n">pts</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_pts</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">S</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">class</span> <span class="n">PreHilbertPlane</span> <span class="o">(</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Line</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">belongs</span> <span class="o">:</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="n">Line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kd">notation</span> <span class="n">A</span> <span class="bp">`∈`</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">belongs</span> <span class="n">A</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">I1'</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">(</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">))</span>
<span class="o">(</span><span class="n">I2'</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">I3'</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>

<span class="kn">namespace</span> <span class="n">PreHilbertPlane</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">PreHilbertPlane</span> <span class="n">Plane</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Plane</span> <span class="o">(</span><span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">belongs</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">Line.has_coe</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pts</span><span class="o">⟩</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_coe_to_mem</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">def</span> <span class="n">points_between</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span> <span class="o">:=</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">Plane</span> <span class="bp">|</span> <span class="n">between</span> <span class="n">A</span> <span class="n">P</span> <span class="n">B</span><span class="o">}</span>

<span class="c1">-- Put the axioms in terms of this has_mem</span>
<span class="kd">lemma</span> <span class="n">I1</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I1'</span> <span class="n">h</span>
<span class="kd">lemma</span> <span class="n">I2</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I2'</span> <span class="n">ℓ</span>
<span class="kd">lemma</span> <span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I3'</span>

<span class="kd">end</span> <span class="n">PreHilbertPlane</span>

<span class="kn">open</span> <span class="n">PreHilbertPlane</span>

<span class="sd">/-- A segment is created by giving two points. -/</span>
<span class="kd">structure</span> <span class="n">Segment</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span>
<span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span>

<span class="kd">notation</span> <span class="n">A</span> <span class="bp">`⬝`</span><span class="o">:</span><span class="mi">100</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">Segment.mk</span> <span class="n">A</span> <span class="n">B</span>

<span class="kn">namespace</span> <span class="n">Segment</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">PreHilbertPlane</span> <span class="n">Plane</span><span class="o">]</span>

<span class="sd">/--</span>
<span class="sd">When thought of as a set, it is the the set consisting of the endpoints</span>
<span class="sd">and all the points between them</span>
<span class="sd">-/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Plane</span> <span class="o">(</span><span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">P</span> <span class="n">S</span><span class="o">,</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">S.A</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">S.B</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">points_between</span> <span class="n">S.A</span> <span class="n">S.B</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">has_coe_to_set</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pts</span><span class="o">⟩</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_coe_to_mem_pts</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">S</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_pts</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">S</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">P</span> <span class="bp">=</span> <span class="n">S.A</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">S.B</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">points_between</span> <span class="n">S.A</span> <span class="n">S.B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">refl</span>

<span class="kd">end</span> <span class="n">Segment</span>


<span class="c">/-</span><span class="cm"></span>
<span class="cm">Here we write some axioms about an undefined notion of 'congruence of segments'</span>
<span class="cm">-/</span>
<span class="kd">class</span> <span class="n">HilbertPlane</span> <span class="o">(</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">PreHilbertPlane</span> <span class="n">Plane</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">seg_cong</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="n">Segment</span> <span class="n">Plane</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≅`</span><span class="o">:</span><span class="mi">50</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">seg_cong</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">(</span><span class="n">C21</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="n">U</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">}:</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">T</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">T</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">))</span>
<span class="o">(</span><span class="n">C3</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">}</span> <span class="o">:</span> <span class="o">((</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">D</span><span class="bp">⬝</span><span class="n">E</span><span class="o">))</span> <span class="bp">→</span> <span class="o">((</span><span class="n">B</span><span class="bp">⬝</span><span class="n">C</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">E</span><span class="bp">⬝</span><span class="n">F</span><span class="o">))</span> <span class="bp">→</span> <span class="o">((</span><span class="n">A</span><span class="bp">⬝</span><span class="n">C</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">D</span><span class="bp">⬝</span><span class="n">F</span><span class="o">)))</span>

<span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≅`</span><span class="o">:</span><span class="mi">50</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">HilbertPlane.seg_cong</span> <span class="n">X</span> <span class="n">Y</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">Plane</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">HilbertPlane</span> <span class="n">Plane</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">)</span>

<span class="sd">/-- first_lemma, which is just `PreHilbertPlane.I1` but for a `HilbertPlane`, so not really necessary. -/</span>
<span class="kd">lemma</span> <span class="n">I1</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span><span class="o">),</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I1</span> <span class="n">h</span>

<span class="kd">def</span> <span class="n">Segment.extend</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S.A</span> <span class="bp">≠</span> <span class="n">S.B</span><span class="o">)</span> <span class="o">:</span> <span class="n">Line</span> <span class="n">Plane</span> <span class="o">:=</span> <span class="n">classical.some</span> <span class="o">(</span><span class="n">I1</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">Segment.extend_spec</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S.A</span> <span class="bp">≠</span> <span class="n">S.B</span><span class="o">)</span> <span class="o">:</span> <span class="n">S.A</span> <span class="bp">∈</span> <span class="n">S.extend</span> <span class="n">h</span> <span class="bp">∧</span> <span class="n">S.B</span> <span class="bp">∈</span> <span class="n">S.extend</span> <span class="n">h</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">classical.some_spec</span> <span class="o">(</span><span class="n">I1</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">lemma</span> <span class="n">Segment.extend_unique</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S.A</span> <span class="bp">≠</span> <span class="n">S.B</span><span class="o">)</span> <span class="o">(</span><span class="n">S'</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Plane</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">S'.A</span> <span class="bp">≠</span> <span class="n">S'.B</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h''</span> <span class="o">:</span> <span class="n">S.A</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">S'.extend</span> <span class="n">h'</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">S.B</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">S'.extend</span> <span class="n">h'</span><span class="o">))</span> <span class="o">:</span> <span class="n">S'.extend</span> <span class="n">h'</span> <span class="bp">=</span> <span class="n">S.extend</span> <span class="n">h</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">classical.some_spec</span> <span class="o">(</span><span class="n">I1</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">S'.extend</span> <span class="n">h'</span><span class="o">)</span> <span class="n">h''</span>

<span class="kd">lemma</span> <span class="n">second_lemma</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Plane</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">B</span><span class="bp">⬝</span><span class="n">A</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">or.assoc</span><span class="o">,</span> <span class="n">conv</span> <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="n">rw</span> <span class="n">or.comm</span> <span class="o">},</span> <span class="n">rw</span> <span class="n">or.assoc</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- needs commutativity of `between`</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">third_lemma</span> <span class="o">:</span> <span class="n">pts</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">pts</span> <span class="o">(</span><span class="n">B</span><span class="bp">⬝</span><span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">fourth_lemma</span> <span class="o">:</span> <span class="o">(</span><span class="n">pts</span> <span class="n">ℓ</span> <span class="bp">∩</span> <span class="n">pts</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="212802957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Problem%20extending%20classes/near/212802957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Problem.20extending.20classes.html#212802957">(Oct 09 2020 at 09:41)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="306601">@Kyle Miller</span> ! I had hoped that this pts function was unnecessary, but maybe it's not so bad after all. I'll see if I can adapt all the code to it.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
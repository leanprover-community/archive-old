---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html">f.g. free modules</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="199041852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199041852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199041852">(May 28 2020 at 15:56)</a>:</h4>
<p>How do I construct the free R-module <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">R^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> (including its R-module structure) for a natural number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>? Ideally this would be done in a way that I can keep around <code>n : ℕ</code> for doing things like induction, should I wish to.</p>
<p>(The motivation is that I am trying to formalize the lemma that a torsion-free f.g. module over a domain injects into a f.g. free module. I might not actually <em>need</em> the standard f.g. free modules <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">R^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> for this purpose, but in thinking about this I realized that it might be nice to know how to do things with them.)</p>
<p>Given a <code>[fintype n]</code> instance, the material in linear_algebra/basic.lean (in the <code>pi</code> section) produces the canonical R-module structure on <code>n → R</code>. </p>
<p>But when I attempted to work with the standard basis elements indexed by <code>(i : n)</code> corresponding to the maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>↦</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi><mo>↦</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i\mapsto 1, i\neq j\mapsto 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.67052em;vertical-align:-0.011em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, I ran into what I think are universe issues. (Which seems funny because set-theoretic considerations cannot possibly be relevant when working with finite products, can they?) Here is a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> of what I am working on:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span> <span class="n">tactic</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basis</span>

<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="n">def</span> <span class="n">free</span> <span class="o">:=</span> <span class="bp">∃</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">,</span> <span class="n">is_basis</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">free_of_fg_free</span> <span class="o">:</span> <span class="n">free</span> <span class="n">R</span> <span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">-- From linear_algebra/matrix.lean, it seems to me I want to use the following in the proof:</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">n</span><span class="o">)</span>
 <span class="c1">-- #check linear_map.std_basis R (λ_:n, R) i</span>
</code></pre></div>


<p>The commented out <code>#check</code> statement mostly "works" but it raises the error</p>
<div class="codehilite"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">n</span><span class="o">,</span>
<span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="n">R</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_3</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">M</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_4</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">,</span>
<span class="n">i</span> <span class="o">:</span> <span class="n">n</span>
<span class="err">⊢</span> <span class="n">decidable_eq</span> <span class="n">n</span>
</code></pre></div>


<p>From unravelling the definitions, it seems that <code>linear_map.std_basis R (λ_:n, R) i</code> is indeed the canonical <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-linear map</p>
<div class="codehilite"><pre><span></span><code><span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">x</span> <span class="o">:</span> <span class="n">n</span><span class="o">),</span> <span class="n">R</span><span class="o">)</span> <span class="n">i</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">n</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">x</span> <span class="o">:</span> <span class="n">n</span><span class="o">),</span> <span class="n">R</span><span class="o">)</span> <span class="n">i</span>
</code></pre></div>


<p>where the source is the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> th copy of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>R</mi><msub><mo stretchy="false">}</mo><mrow><mi>i</mi><mo>:</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\{R \}_{i:n}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">:</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and the target is the product <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><mi>i</mi><mo>:</mo><mi>n</mi></mrow></msub><mi>R</mi><mo>≅</mo><msup><mi>R</mi><mi>n</mi></msup><mo>≅</mo><msub><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">\prod_{i:n}R  \cong R^n \cong \mathrm{ Hom}_\mathrm{Set}(n, R)=</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">:</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">o</span><span class="mord mathrm">m</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">S</span><span class="mord mathrm mtight">e</span><span class="mord mathrm mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span> <code>n→ R</code>. Namely this map is the section to the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> th projection which is zero on all the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo mathvariant="normal">≠</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j\neq i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> factors, so the image of <code>1</code> under it is indeed the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> th standard basis element.</p>
<p>Hence I think my ultimate question is really the following:</p>
<p><strong>If I promise only to ever care about finitely generated modules over Noetherian rings, can I somehow set things up so that things like <code>decidable_eq n</code> "just work" and I never need to care or think about universes at all?</strong></p>



<a name="199042426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199042426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199042426">(May 28 2020 at 16:01)</a>:</h4>
<p>Putting <code>open_locale classical</code> right after your imports may work. <code>decidable_eq</code> doesn't have to do with universes, by the way. It's basically asking for an algorithm to decide equality of elements. If you don't care about "computing" with the objects you construct, then working with classical logic will make these all go away.</p>



<a name="199042594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199042594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199042594">(May 28 2020 at 16:02)</a>:</h4>
<p>Shouldn't equality of elements of a finite type be decidable in non-classical logic too?</p>



<a name="199042635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199042635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199042635">(May 28 2020 at 16:02)</a>:</h4>
<p>But thanks for that suggestion, it does sound like a pragmatic solution!</p>



<a name="199042723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199042723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199042723">(May 28 2020 at 16:03)</a>:</h4>
<p>Yes, that does indeed fix it, thanks <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> !</p>



<a name="199043273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199043273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199043273">(May 28 2020 at 16:08)</a>:</h4>
<p>Aha, I had missed the fact that linear_algebra/basic.lean has <code>open_locale classical</code> buried in various places, and uses the classical tactic in others. Is another solution simply to put <code>variables [deciable_eq n]</code> somewhere in my file?</p>



<a name="199044010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199044010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199044010">(May 28 2020 at 16:14)</a>:</h4>
<p>If <code>open_locale classical</code> is active, then you should be able to delete the occurrences of the <code>classical</code> tactic. I think we prefer using <code>open_locale classical</code> in most of mathlib. I don't have too much experience here, but I think you can run into situations where Lean gets two different <code>decidable_eq</code> assumptions and then gets confused.</p>



<a name="199046837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199046837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199046837">(May 28 2020 at 16:36)</a>:</h4>
<p><span class="user-mention" data-user-id="246647">@Sam Lichtenstein</span> You can use <code>(fin n) → R</code> if you want to use a natural number <code>n</code>. The type <code>fin n</code> is the "canonical" type of cardinality <code>n</code>.</p>



<a name="199046897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199046897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199046897">(May 28 2020 at 16:37)</a>:</h4>
<p>But probably you want to do as much as possible for general <code>fintype</code>s</p>



<a name="199047049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199047049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199047049">(May 28 2020 at 16:38)</a>:</h4>
<p>If you want an example of how to do induction in such a setting, you can look at the proof of the Hilbert basis theorem, or the fact that <code>R[X_1,...X_n]</code> is an integral domain.</p>



<a name="199047177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199047177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199047177">(May 28 2020 at 16:39)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/polynomial.html#mv_polynomial.integral_domain_fintype">https://leanprover-community.github.io/mathlib_docs/ring_theory/polynomial.html#mv_polynomial.integral_domain_fintype</a></p>



<a name="199276515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199276515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199276515">(May 30 2020 at 21:22)</a>:</h4>
<p>I still have a basic question tangentially related to the above. Suppose I want to introduce the notation <code>free R ι </code> for the free module on a discrete type <code>ι</code>, i.e.  <code>direct_sum ι (λ _:ι, R)</code>. (For example, because I want to avoid typing <code>(λ _:ι, R)</code> over and over.) If I want Lean to "know" about my chosen notation, I figured out (eventually) that I can write:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">direct_sum_module</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">u₁</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span>

<span class="n">def</span> <span class="n">free</span> <span class="o">:=</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">free</span> <span class="n">R</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:=</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">add_comm_group</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">free</span> <span class="n">R</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:=</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">module</span>

<span class="c1">-- these now work:</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">free</span> <span class="n">R</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span> <span class="n">free</span> <span class="n">R</span> <span class="n">ι</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">free</span> <span class="n">R</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span> <span class="n">free</span> <span class="n">R</span> <span class="n">ι</span> <span class="o">:=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span>
</code></pre></div>


<p>Here are my questions:</p>
<p>Question 1a: Is this the "right" way to express the fact that I want to use some externally-defined structures with my own notation? <br>
Question 1b: Is there a way I can "skip" specifying the <code>add_comm_group</code> instance, and have <code>direct_sum.module</code> infer it automatically (this boils down to inferring the additive structure on each copy of <code>R</code>, which <code>direct_sum.add_comm_group</code> seems to be perfectly able to do on its own).</p>
<p>Question 2: What if I want to work with this <code>R</code>-module structure <em>without</em> defining my <code>free R ι</code> notation for <code>direct_sum ι (λ _:ι, R)</code>? Consider these examples:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- This works</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">))</span> <span class="o">:</span> <span class="n">free</span> <span class="n">R</span> <span class="n">ι</span> <span class="o">:=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span>
<span class="c1">-- This fails:</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">))</span> <span class="o">:</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span>
<span class="c1">-- these fail, complaining that &quot;a declaration named &#39;direct_sum.add_comm_group&#39; has already been declared&quot;</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="o">(</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">))</span> <span class="o">:=</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">add_comm_group</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">))</span> <span class="o">:=</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">module</span>
</code></pre></div>


<p>What exactly am I supposed to do to get <code>example (x : direct_sum ι (λ _:ι, R)) : direct_sum ι (λ _:ι, R) := r • x</code> to work?</p>



<a name="199276730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199276730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199276730">(May 30 2020 at 21:29)</a>:</h4>
<p>BTW, for Question 2, I know that I can do:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">))</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">):</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">haveI</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">direct_sum</span><span class="bp">.</span><span class="n">module</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
<span class="k">from</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span>
<span class="kn">end</span>
</code></pre></div>


<p>I want to know what the analogue of the <code>haveI</code> is at the top level.</p>



<a name="199276814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199276814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199276814">(May 30 2020 at 21:31)</a>:</h4>
<p>why not just use <code>\io \to\0 R</code></p>



<a name="199276867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199276867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199276867">(May 30 2020 at 21:32)</a>:</h4>
<p>It probably already has an R-module structure if you import the right thing</p>



<a name="199276899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199276899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199276899">(May 30 2020 at 21:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> :</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span> <span class="c1">-- definition &#39;_example&#39; is noncomputable, it depends on &#39;finsupp.has_scalar&#39;</span>
</code></pre></div>



<a name="199276902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199276902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199276902">(May 30 2020 at 21:34)</a>:</h4>
<p><code>noncomputable example</code></p>



<a name="199276956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199276956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199276956">(May 30 2020 at 21:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> yes, I assume I just need to know the right thing to import. I thought the instance <code>direct_sum.module</code> <em>was</em> the right thing, though</p>



<a name="199314446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199314446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199314446">(May 31 2020 at 17:44)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Given <code>s : finset x</code> for an arbitrary type <code>x</code>, what's the right way to produce a bijection from <code>s</code> to <code>fin s.card</code>? It seems like there is a lemma <code>finset.mono_of_fin</code> that I could use if I somehow were to invoke the axiom of choice to put a decidable linear order on <code>x</code>, but that shouldn't be necessary, should it?</p>



<a name="199314536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199314536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199314536">(May 31 2020 at 17:47)</a>:</h4>
<p>(I suppose that in the spirit of <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> I should mention: I am trying to convert the hypothesis <code>(⊤ : submodule R M).fg</code> to the existence of a surjective <code>R</code>-linear map from a finitely generated free <code>R</code>-module to <code>M</code>.)</p>



<a name="199317287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199317287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199317287">(May 31 2020 at 19:10)</a>:</h4>
<p>I'm sorry I'm not giving this thread more attention, I'm very much interested in it but I don't have much time for Lean right now. Why not just use the f.g. free module generated by the generating set of M?</p>



<a name="199321384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199321384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199321384">(May 31 2020 at 21:12)</a>:</h4>
<p>yes, that's indeed the one I want to use. but it's a little awkward to "get your hands on" the generating set of M. You get it as <code>s : finset M</code>. So you can construct a corresponding free module, either using <code>s</code> itself as the index type, or possibly more conveniently replacing the index type by <code>fin s.card</code>.  I think I prefer the latter? Maybe I shouldn't. I wanted to state the lemma as </p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">surj_free_of_fg</span>
    <span class="o">(</span><span class="n">hfg</span> <span class="o">:</span> <span class="o">(</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">fg</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">free</span> <span class="n">R</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span><span class="o">),</span> <span class="o">(</span><span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">π</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>(Note that <code>free R ι</code> is an abbreviation for <code>direct_sum ι (λ _:ι, R)</code> aka <code>ι  →₀ R</code>.) Here the existential quantification is over <code>ℕ</code>, which is not so scary. If you rephrase this as</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">surj_free_of_fg</span>
    <span class="o">(</span><span class="n">hfg</span> <span class="o">:</span> <span class="o">(</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">fg</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">ι</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">,</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">free</span> <span class="n">R</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span><span class="o">),</span> <span class="o">(</span><span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">π</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>then the advantage is that the <code>s : finset M</code> you get from <code>hfg</code> is precisely the <code>ι</code> you are looking for. But the disadvantage is that the conclusion involves existential quantification for the <code>ι</code>, which I was scared of doing (because  it involves a <code>fintype</code> instance in the ∃, which I am not sure is even allowed, and I think we also need to worry about a <code>decidable_eq</code> instance unless we've done <code>open_locale classical</code>). </p>
<p>Thus for now I was preferring the formulation in terms of <code>fin n</code>. To get the surjection from this free module to <code>M</code> you can invoke the universal property of coproducts, which requires really "having" a collection of maps <code>R --&gt; M</code> indexed by the index type in question, i.e. an object of type <code>Π(i:fin s.card), R --&gt; M</code> or <code>Π(i:s), R --&gt; M</code>. These are the obvious maps that send <code>1</code> to the chosen generators.  But the <code>Prop</code> that <code>M</code> (or rather its <code>⊤</code> submodule) is finitely-generated just gives the <code>s : finset M</code>, not  an <em>enumeration</em> of that set. So to get a collection of maps of type <code>Π (i:fin s.card), R --&gt; M</code> I need to choose such a bijection <code>s --&gt; (fin s.card)</code>, which was the motivation for my question to Johan.</p>



<a name="199321518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199321518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199321518">(May 31 2020 at 21:16)</a>:</h4>
<p>BTW what I am <em>really</em> trying to do is prove the structure theorem for modules over a PID, starting with the lemma about torsion-free modules on p. 35 of Pete Clark's notes <a href="http://math.uga.edu/~pete/integral.pdf">http://math.uga.edu/~pete/integral.pdf</a>. And what I am <em>really really</em> trying to do is formalize the existence of Jordan canonical form (with an eye towards applications such as Johan's feature request for Sylvester's law of inertia)</p>



<a name="199323029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199323029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199323029">(May 31 2020 at 22:06)</a>:</h4>
<p>I think all of this is on Amelia's job list but she still has exams. I am interested in having Jordan canonical form in lean because it's essentially the only thing in Imperial's second year algebra course which isn't in it (we also don't have generalised eigenspaces but these will come with it basically). We also state the classification of finite abelian groups so I figured if we had the structure theorem we'd be able to kill two birds with one stone</p>



<a name="199323046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199323046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199323046">(May 31 2020 at 22:07)</a>:</h4>
<p>I'll try to take a look at this asap but I am snowed under for hopefully at most one more day</p>



<a name="199323340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199323340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199323340">(May 31 2020 at 22:16)</a>:</h4>
<p>I am certainly not trying to step on anyone's toes if you already have a student (?) working on this stuff. It just seemed like an obvious gap in the library to me which I felt vaguely qualified to try to fill as a learning project. I'd be happy to defer to her if she is waiting to PR the same material, or to collaborate if she is looking for a collaborator.</p>



<a name="199323700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199323700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199323700">(May 31 2020 at 22:29)</a>:</h4>
<p>I'm loath to bother her right now but if you're learning lean by working on this then I would keep going and not worry too much. Amelia is also involved in a huge refactor of localisations so she has plenty on her plate right now and although I don't want to put words in her mouth, it would not surprise me if she would be happy to collaborate. We can alert her to this thread on Tuesday when she's done</p>



<a name="199332891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199332891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199332891">(Jun 01 2020 at 03:02)</a>:</h4>
<p><span class="user-mention" data-user-id="246647">@Sam Lichtenstein</span> Coming back to your question, I think there is a lemma <code>fintype.exists_equiv</code> or something like that.</p>



<a name="199332907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199332907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199332907">(Jun 01 2020 at 03:03)</a>:</h4>
<p>Voila: <code>src/data/fintype/basic.lean:theorem exists_equiv_fin (α) [fintype α] : ∃ n, nonempty (α ≃ fin n) :=</code><br>
I think that's what you want.</p>



<a name="199333082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199333082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199333082">(Jun 01 2020 at 03:07)</a>:</h4>
<p><span class="user-mention" data-user-id="246647">@Sam Lichtenstein</span> You could prove both versions. Use the second version of <code>surj_free_of_fg</code> to prove the first one. The <code>\exists \iota [fintype \iota]</code> is definitely allowed. I think <code>open_locale classical</code> is unexpected (even encouraged?!) in this part of the library.</p>



<a name="199358168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199358168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199358168">(Jun 01 2020 at 11:32)</a>:</h4>
<p>I'm trying to catch up with this thread. I am confused by this doesn't work:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span> <span class="n">tactic</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basis</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">direct_sum_module</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="c1">--noncomputable instance foo : module R (direct_sum ι (λ _:ι, R)) := by apply_instance</span>

<span class="n">noncomputable</span> <span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">))</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span>
</code></pre></div>


<p>If I comment out the instance, which apparently is already there, it works.</p>



<a name="199359297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199359297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199359297">(Jun 01 2020 at 11:47)</a>:</h4>
<p>I didn’t know I could fix this error by writing “noncomputable” before example</p>



<a name="199359916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199359916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199359916">(Jun 01 2020 at 11:56)</a>:</h4>
<p>You still get the error with the smul, but if I comment out the instance it fixes it</p>



<a name="199363492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199363492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199363492">(Jun 01 2020 at 12:39)</a>:</h4>
<p>OK so I'm catching up with the issues raised in this thread. <code>direct_sum</code> is for an arbitrary direct sum of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-modules (and in particular is a dependent finsupp). This specific case of free <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-modules is somehow easier because it's not dependent, but there is a cost to introducing a new definition like <code>free</code>: Kenny's suggestion of just using <code>ι →₀ R</code> has advantages and disadvantages. On the other hand the concept of a free module is so ubiquitous that probably one has to make the definition. </p>
<p>The second point is that I suspect there's no coercion from <code>finset</code> to <code>Type</code> :-( </p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="o">(</span><span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span> <span class="c1">-- fails</span>
</code></pre></div>


<p>There's a coercion from <code>finset X</code> to <code>set X</code> and then from there to <code>Type*</code>, but I don't seem to be able to get there directly.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="err">↑</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
</code></pre></div>


<p>Should there be a coercion from <code>finset X</code> to <code>Type</code> directly?</p>



<a name="199363632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199363632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199363632">(Jun 01 2020 at 12:41)</a>:</h4>
<p>We could define <code>free</code> in terms of <code>ι →₀ R</code></p>



<a name="199363665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199363665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199363665">(Jun 01 2020 at 12:41)</a>:</h4>
<p>I often write <code>{ x // x \in s }</code>. But of course that's a very roundabout way to make a Type out of a finset</p>



<a name="199366220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199366220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199366220">(Jun 01 2020 at 13:09)</a>:</h4>
<p>Kevin, how should I think about the "cost" of introducing a new definition? Is the point that this is just one more thing that needs to be unfolded, so it introduces some fixed amount of overhead for <code>simp</code> etc in all downstream code?</p>



<a name="199372242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/f.g.%20free%20modules/near/199372242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules.html#199372242">(Jun 01 2020 at 13:57)</a>:</h4>
<p>This topic was moved by <span class="user-mention silent" data-user-id="110596">Rob Lewis</span> to <a class="stream-topic" data-stream-id="116395" href="/#narrow/stream/116395-maths/topic/f.2Eg.2E.20free.20modules">#maths &gt; f.g. free modules</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
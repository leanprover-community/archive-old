---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html">Exercises in Theorem Proving in Lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="242578870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242578870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242578870">(Jun 14 2021 at 10:42)</a>:</h4>
<p>I am trying to do the following exercise from the book: As exercises, we encourage you to develop a notion of composition for partial functions from α to β and β to γ, and show that it behaves as expected.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">option</span>

<span class="kd">def</span> <span class="n">my_comp</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span><span class="o">):</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="k">if</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">none</span> <span class="k">then</span> <span class="n">none</span>
     <span class="k">else</span> <span class="gr">sorry</span>
</code></pre></div>
<p>reports error </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="o">,</span>
<span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="o">,</span>
<span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">,</span>
<span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="bp">⊢</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span>
</code></pre></div>
<p>How can I fix it?</p>



<a name="242579172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242579172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242579172">(Jun 14 2021 at 10:46)</a>:</h4>
<p>You can either fix it by assuming that <code>option beta</code> has decidable equality (e.g. with <code>open_locale classical</code>) or you can do the problem the way you're expected to do it, without using <code>if</code> and instead splitting on the constructors, like the way addition is defined on the naturals: we don't write "a+b = if b = 0 then a else ...", we write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">add</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">a</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">...</span>
</code></pre></div>



<a name="242579672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242579672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242579672">(Jun 14 2021 at 10:52)</a>:</h4>
<p>It seems that the first approach</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">open</span> <span class="n">option</span>

<span class="kd">def</span> <span class="n">my_comp</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span><span class="o">):</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="k">if</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">none</span> <span class="k">then</span> <span class="n">none</span>
     <span class="k">else</span> <span class="gr">sorry</span>
</code></pre></div>
<p>gives me another error message: <code>command expected </code> for <code>open_locale</code>.</p>



<a name="242579704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242579704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242579704">(Jun 14 2021 at 10:52)</a>:</h4>
<p><code>import tactic</code> at the top</p>



<a name="242579751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242579751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242579751">(Jun 14 2021 at 10:52)</a>:</h4>
<p>but let me stress that this is not the way you are expected to do the problem.</p>



<a name="242580412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242580412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242580412">(Jun 14 2021 at 10:59)</a>:</h4>
<p>Yeah Yeah. I am doing the second way.</p>



<a name="242580643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242580643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242580643">(Jun 14 2021 at 11:01)</a>:</h4>
<p>The difference with the two methods is that the "use the equation compiler" method will give you better definitional equalities; "x = if (true thing) then x else y" is not true by definition, it's true because of the theorem <code>if_pos</code>, whereas using the equation compiler you'll get more stuff true by definition (for example x + 0 = x is true for naturals by definition in Lean).</p>



<a name="242702909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242702909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242702909">(Jun 15 2021 at 08:35)</a>:</h4>
<p>I am trying to do the exercise "We also encourage you to show that bool and nat are inhabited, that the product of two inhabited types is inhabited, and that the type of functions to an inhabited type is inhabited".<br>
But I am not sure what "to show that bool and nat are inhabited" exactly asks me to do. Am I expected to write a theorem claiming this or something else?</p>



<a name="242703236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242703236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242703236">(Jun 15 2021 at 08:38)</a>:</h4>
<p>I would say that for the case of nat, the exercise is to replace that <code>sorry</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">nat</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="242716014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242716014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242716014">(Jun 15 2021 at 10:49)</a>:</h4>
<p>Is there a more concise way to prove the following?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">inhabited</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">inhabited</span> <span class="n">β</span><span class="o">)</span>
<span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">prod</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">inhabited.mk</span> <span class="o">(</span><span class="n">inhabited.cases_on</span> <span class="n">a</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span><span class="n">a</span><span class="o">),</span> <span class="n">inhabited.cases_on</span> <span class="n">b</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span><span class="n">b</span><span class="o">))</span>
</code></pre></div>



<a name="242735376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242735376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242735376">(Jun 15 2021 at 13:52)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">inhabited</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨⟨</span><span class="n">arbitrary</span> <span class="n">α</span><span class="o">,</span> <span class="n">arbitrary</span> <span class="n">β</span><span class="o">⟩⟩</span>
</code></pre></div>



<a name="242735705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242735705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242735705">(Jun 15 2021 at 13:54)</a>:</h4>
<p><code>inhabited</code> is a class, so the idiomatic thing to do would be to use rectangular brackets and not name the term of type <code>inhabited alpha</code>. Lean gives it some auto-generated name like <code>_inst_37</code> or something, but more importantly it also adds it to the typeclass system, meaning that functions like <code>arbitrary</code> (which expect to find an <code>inhabited</code> instance using type class inference) will work.</p>
<p>The first pointy brackets is <code>inhabited.mk</code>, the second is <code>prod.mk</code>. This pointy bracket trick is why you see a lot less of <code>mk</code> functions than you might expect.</p>



<a name="242741369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242741369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242741369">(Jun 15 2021 at 14:31)</a>:</h4>
<p>Thanks a lot!</p>



<a name="242743087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242743087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242743087">(Jun 15 2021 at 14:43)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">inhabited</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨⟨</span><span class="n">default</span> <span class="n">α</span><span class="o">,</span> <span class="n">default</span> <span class="n">β</span><span class="o">⟩⟩</span>
</code></pre></div>
<p>I have no idea which is the best proof.</p>



<a name="242760737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242760737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242760737">(Jun 15 2021 at 16:27)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">β</span><span class="o">],</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)⟩</span>
</code></pre></div>



<a name="242760856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242760856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242760856">(Jun 15 2021 at 16:28)</a>:</h4>
<p>kevin's is probably the best proof though</p>



<a name="242769200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242769200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242769200">(Jun 15 2021 at 17:28)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/default">docs#default</a> is usually better than <a href="https://leanprover-community.github.io/mathlib_docs/find/arbitrary">docs#arbitrary</a>, I think</p>



<a name="242833083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242833083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242833083">(Jun 16 2021 at 06:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean/near/242760737">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">β</span><span class="o">],</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)⟩</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Could you please explain the syntax of <code>| ⟨a⟩ ⟨b⟩ </code>?</p>



<a name="242833166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242833166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242833166">(Jun 16 2021 at 06:04)</a>:</h4>
<p>It's the same syntax as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">a</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span><span class="n">a</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>
<p>It's explained in chapter 8 (IIRC) of <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a></p>



<a name="242833167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/242833167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#242833167">(Jun 16 2021 at 06:04)</a>:</h4>
<p>it's a pattern match on <code>inhabited A</code>, which is an inductive type wrapping a single element of type <code>A</code></p>



<a name="243238106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243238106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243238106">(Jun 19 2021 at 08:46)</a>:</h4>
<p>''Under the hood, this definition is compiled down to a single inductive type with an index i in a two-valued type (such as bool), where i encodes which of even or odd is intended. ''</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">mutual</span> <span class="kd">inductive</span> <span class="n">even</span><span class="o">,</span> <span class="n">odd</span>
<span class="k">with</span> <span class="n">even</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">even_zero</span> <span class="o">:</span> <span class="n">even</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">even_succ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">odd</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">even</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">with</span> <span class="n">odd</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">odd_succ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">even</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">odd</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>What is the single inductive type it  is compiled down to?</p>



<a name="243238942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243238942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243238942">(Jun 19 2021 at 09:08)</a>:</h4>
<p>I think the output of <code>#print even._mut_</code> is the type that definition compiles to</p>



<a name="243239016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243239016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243239016">(Jun 19 2021 at 09:11)</a>:</h4>
<p>Of course, that's not very human-friendly. You can write that inductive using a bool index like this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">even_odd</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">even_zero</span> <span class="o">{</span><span class="n">even</span> <span class="o">:</span> <span class="n">bool</span><span class="o">}</span> <span class="o">:</span> <span class="n">even</span> <span class="bp">→</span> <span class="n">even_odd</span> <span class="n">tt</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">even_succ</span> <span class="o">{</span><span class="n">even</span> <span class="o">:</span> <span class="n">bool</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">even_odd</span> <span class="n">ff</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">even_odd</span> <span class="n">tt</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">odd_succ</span> <span class="o">{</span><span class="n">even</span> <span class="o">:</span> <span class="n">bool</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">even_odd</span> <span class="n">tt</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">even_odd</span> <span class="n">ff</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="243239075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243239075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243239075">(Jun 19 2021 at 09:13)</a>:</h4>
<p>Basically, you write <code>even_odd tt</code> for <code>even</code> and <code>even_odd ff</code> for <code>odd</code></p>



<a name="243246547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243246547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243246547">(Jun 19 2021 at 12:06)</a>:</h4>
<p>We tend to stay away from mutual inductives in Lean. The reason is this: whilst it no doubt gets compiled down to a single inductive type, it is almost certainly nowhere near as nice as the clean version which Horatiu has posted. Mario's recommendation is always to do the compiling-down yourself. Fortunately our experience in mathematics is that it is quite rare that one needs mutual inductive types, indeed it's surprisingly rare to need inductive types other than structures at all, at least in the kind of mathematics which I have been doing in Lean. Nat itself is a very weird outlier. Even and odd don't need to be defined mutually, and indeed in mathlib they are defined independently.</p>



<a name="243293339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243293339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243293339">(Jun 20 2021 at 08:36)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">mutual</span> <span class="kd">inductive</span> <span class="n">even</span><span class="o">,</span> <span class="n">odd</span>
<span class="k">with</span> <span class="n">even</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">even_zero</span> <span class="o">:</span> <span class="n">even</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">even_succ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">odd</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">even</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">with</span> <span class="n">odd</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">odd_succ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">even</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">odd</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="c1">-- BEGIN</span>
<span class="kn">open</span> <span class="n">even</span> <span class="n">odd</span>

<span class="kd">theorem</span> <span class="n">not_odd_zero</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">odd</span> <span class="mi">0</span><span class="bp">.</span>
</code></pre></div>
<p>Why does this theorem can be closed by a period?</p>



<a name="243294947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243294947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243294947">(Jun 20 2021 at 09:24)</a>:</h4>
<p>Because the equation compiler, which basically knows something about induction, can do enough calculations dealing with cases itself to realise that no cases need to be dealt with by the human</p>



<a name="243295040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243295040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243295040">(Jun 20 2021 at 09:28)</a>:</h4>
<p>The logic is this: we need to prove false given an input of <code>odd 0</code>. That term of type <code>odd 0</code> needs to come from a constructor of <code>odd</code>. The only constructor of <code>odd</code> ultimately makes a term of type <code>odd (n+1)</code> so before we figure out exactly what to ask the user for we had better find all solutions of n+1=0. The definition of n+1 is succ n so we had better ask the user to deal with all n such that succ n is zero. But these are different constructors for nat so there can't be any solutions at all and so we don't have to ask the user to do anything. Some argument of that nature is happening internally</p>



<a name="243296102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243296102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243296102">(Jun 20 2021 at 10:01)</a>:</h4>
<p>If I were very stubborn and insist on proving this by myself, what can I do then to close the following proof?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">mutual</span> <span class="kd">inductive</span> <span class="n">even</span><span class="o">,</span> <span class="n">odd</span>
<span class="k">with</span> <span class="n">even</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">even_zero</span> <span class="o">:</span> <span class="n">even</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">even_succ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">odd</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">even</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">with</span> <span class="n">odd</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">odd_succ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">even</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">odd</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="c1">-- BEGIN</span>
<span class="kn">open</span> <span class="n">even</span> <span class="n">odd</span>

<span class="kd">theorem</span> <span class="n">not_odd_zero</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">odd</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">h</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="243297774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243297774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243297774">(Jun 20 2021 at 10:52)</a>:</h4>
<p><code>cases h</code> would be the next step</p>



<a name="243298874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243298874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243298874">(Jun 20 2021 at 11:26)</a>:</h4>
<p>and presumably the last step?</p>



<a name="243304469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243304469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243304469">(Jun 20 2021 at 14:07)</a>:</h4>
<p>Yes!</p>



<a name="243305068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243305068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243305068">(Jun 20 2021 at 14:23)</a>:</h4>
<p>This is an example copied from the book:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>

<span class="kd">inductive</span> <span class="n">vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">vector</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span>   <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">vector</span>
<span class="kn">local</span> <span class="kd">notation</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">cons</span> <span class="n">h</span> <span class="n">t</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="c1">-- BEGIN</span>
<span class="kd">def</span> <span class="n">add</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span>
<span class="bp">|</span> <span class="bp">.</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>   <span class="n">nil</span>                <span class="n">nil</span>        <span class="o">:=</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="bp">.</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">cons</span> <span class="bp">.</span><span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="n">n</span> <span class="n">a</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">cons</span> <span class="n">b</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cons</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">add</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
<span class="c1">-- END</span>

<span class="kd">end</span> <span class="n">vector</span>
</code></pre></div>
<p>In the line <code>| .(n+1) (@cons .(α) n a v) (cons b w) := cons (a + b) (add v w)</code>, is there any difference between using <code>.(α)</code> and <code>α</code>?</p>



<a name="243306303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243306303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243306303">(Jun 20 2021 at 14:53)</a>:</h4>
<p>If you change <code>.(n+1)</code> to <code>(n+1)</code> then it breaks, so yes. Perhaps the error you get gives you some sort of idea as to the problems going on here.</p>



<a name="243306382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243306382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243306382">(Jun 20 2021 at 14:55)</a>:</h4>
<p>In this case you can get away with <code>(_+1)</code> by the way.</p>



<a name="243306449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243306449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243306449">(Jun 20 2021 at 14:57)</a>:</h4>
<p>I will say again that the dependent type <code>vector n</code> implemented as an inductive type is very hard to work with and whilst it's good to struggle and learn what is hard, when you've finished becoming miserable about how difficult Lean is and how it can't do something as simple as vectors, I would urge you to try everything that you're doing with the subtype definition and discover how easy it all is again.</p>



<a name="243337163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243337163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243337163">(Jun 21 2021 at 04:00)</a>:</h4>
<p>In the proof of the last theorem, is there a way to match <code>e</code> with the case split in the definition of <code>simp_const</code>? If I do as in the current proof, I will have trouble showing <code>simp_const e = e</code> in the last case.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">aexpr</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">const</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="n">times</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span>

<span class="kn">open</span> <span class="n">aexpr</span>

<span class="kd">def</span> <span class="n">aeval</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="n">n</span><span class="o">)</span>    <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>      <span class="o">:=</span> <span class="n">v</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">plus</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">aeval</span> <span class="n">e₁</span> <span class="bp">+</span> <span class="n">aeval</span> <span class="n">e₂</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">times</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="n">e₁</span> <span class="bp">*</span> <span class="n">aeval</span> <span class="n">e₂</span>

<span class="kd">def</span> <span class="n">simp_const</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">plus</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₁</span><span class="o">)</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₂</span><span class="o">))</span>  <span class="o">:=</span> <span class="n">const</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">times</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₁</span><span class="o">)</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₂</span><span class="o">))</span> <span class="o">:=</span> <span class="n">const</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">*</span> <span class="n">n₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span>                             <span class="o">:=</span> <span class="n">e</span>

<span class="kd">def</span> <span class="n">fuse</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="n">n</span><span class="o">)</span>    <span class="o">:=</span> <span class="n">const</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>      <span class="o">:=</span> <span class="n">var</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">plus</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">simp_const</span> <span class="o">(</span><span class="n">plus</span> <span class="o">(</span><span class="n">fuse</span> <span class="n">e₁</span><span class="o">)</span> <span class="o">(</span><span class="n">fuse</span> <span class="n">e₂</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">times</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">simp_const</span> <span class="o">(</span><span class="n">times</span> <span class="o">(</span><span class="n">fuse</span> <span class="n">e₁</span><span class="o">)</span> <span class="o">(</span><span class="n">fuse</span> <span class="n">e₂</span><span class="o">))</span>


<span class="kd">theorem</span> <span class="n">simp_const_eq</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">e</span> <span class="o">:</span> <span class="n">aexpr</span><span class="o">,</span> <span class="n">aeval</span> <span class="n">v</span> <span class="o">(</span><span class="n">simp_const</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">aeval</span> <span class="n">v</span> <span class="n">e</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">plus</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₁</span><span class="o">)</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₂</span><span class="o">))</span>  <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">aeval</span><span class="o">,</span><span class="n">simp_const</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">times</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₁</span><span class="o">)</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₂</span><span class="o">))</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">aeval</span><span class="o">,</span><span class="n">simp_const</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">e</span>                             <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">h</span><span class="o">:</span><span class="n">simp_const</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">e</span><span class="o">,{</span><span class="gr">sorry</span><span class="o">},</span><span class="n">rw</span> <span class="n">h</span><span class="o">,}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="243350765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243350765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243350765">(Jun 21 2021 at 08:08)</a>:</h4>
<p>Instead of match (which does <code>cases</code>) you could use the <code>induction</code> tactic. Does this help?</p>



<a name="243353042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243353042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243353042">(Jun 21 2021 at 08:33)</a>:</h4>
<p>Thanks for the suggestion, but not quite.. (the actual problem is concerning using the third case in the defn of <code>simp_const</code> as the <code>sorry</code> indicates in the above code)</p>



<a name="243353679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243353679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243353679">(Jun 21 2021 at 08:40)</a>:</h4>
<p>In the third case of the proof, Lean seems not clever enough to know that <code>e</code> is not in the first two cases.</p>



<a name="243359442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243359442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243359442">(Jun 21 2021 at 09:43)</a>:</h4>
<p>Yes that's correct, Lean doesn't know. If you want it to know then you will need to do induction on <code>e</code>. But it is not clear to me that you are proving the right thing. My instinct is that you should just prove "the big theorem" following e.g. the example at the beginning of chapter 2 of "Certified Programming with Dependent Types" by Chlipala (it's written for Coq but a very early exercise I did in Lean was to port this example over to Lean) and then I would imagine that you will be able to deduce everything relatively easily.</p>
<p>If there's one thing I've learnt from examples like this, it's that this kind of structural induction is much harder than a mathematician imagines. Fortunately I also learnt that there are plenty of computer scientists around here who know the tricks, and also that in practice in the kind of mathematics done  by most working mathematicians, this sort of complex induction procedure is rarely if ever needed.</p>



<a name="243359826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243359826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243359826">(Jun 21 2021 at 09:47)</a>:</h4>
<p>If you really want to push this forward, then you need to remember that every definition comes with a cost, and the cost is that you have to make an API for the definition. You have made four definitions without any API at all, and are now trying to prove a theorem relating three of them. What you should be doing is that the moment you have defined <code>simp_const</code> (which, as I've said above, does not look to me like a useful definition, you really want the theorem which says "my compiler is correct" rather than some weaker partial versions) you need to make an API for it, proving things like <code>simp_const (var n) = var n</code> and many other things (you will have to deal with the case <code>simp_const (plus (const n) (times e f))</code> etc etc, it will be horrible). Once you have a robust API for <code>simp_const</code> you can press on. Every definition you make, you need to pay for.</p>



<a name="243360064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243360064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243360064">(Jun 21 2021 at 09:49)</a>:</h4>
<p>Oh I see -- this is an actual exercise in TPIL? :-/ Then probably what I'm saying is inaccurate. Apart from the bit when I said "I worked through the example in CPDT and it taught me a lot".</p>



<a name="243360348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243360348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243360348">(Jun 21 2021 at 09:53)</a>:</h4>
<p>So yes, on further experimentation, you can absolutely do this by doing induction on everything. I don't see how to do it using the method you're using.</p>



<a name="243360686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243360686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243360686">(Jun 21 2021 at 09:57)</a>:</h4>
<div class="spoiler-block"><div class="spoiler-header">
<p>Solution</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">simp_const_eq</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">e</span> <span class="o">:</span> <span class="n">aexpr</span><span class="o">,</span> <span class="n">aeval</span> <span class="n">v</span> <span class="o">(</span><span class="n">simp_const</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">aeval</span> <span class="n">v</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">e</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span> <span class="n">b</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span> <span class="n">b</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="243363617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243363617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243363617">(Jun 21 2021 at 10:31)</a>:</h4>
<p>Thanks for your long explanation, Kevin! Could you let me know what "API" here stands for?</p>



<a name="243363892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243363892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243363892">(Jun 21 2021 at 10:34)</a>:</h4>
<p>A shorter solution using <code>repeat</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">simp_const_eq</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">e</span> <span class="o">:</span> <span class="n">aexpr</span><span class="o">,</span> <span class="n">aeval</span> <span class="n">v</span> <span class="o">(</span><span class="n">simp_const</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">aeval</span> <span class="n">v</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">e</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span> <span class="n">b</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span> <span class="n">b</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">a</span><span class="o">,</span> <span class="n">cases</span> <span class="n">b</span><span class="o">,</span> <span class="n">repeat</span> <span class="o">{</span> <span class="n">refl</span> <span class="o">}},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="243365432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Exercises%20in%20Theorem%20Proving%20in%20Lean/near/243365432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean.html#243365432">(Jun 21 2021 at 10:53)</a>:</h4>
<p>Yes, I thought I'd leave the refls all in there just to show you that at the end of the day we really did have to take it apart into cases. API means "interface". For example you make the reals <code>real</code> as Dedekind cuts or Cauchy sequences (who knows which, the user is not supposed to know) and then you define <code>real.add</code> and <code>real.mul</code> and <code>real.a_non_empty_bounded_set_has_a_LUB</code> and <code>real.field</code> and the proofs of course depend on the definition but the user doesn't look at the proofs. The definition (<code>real</code>) comes with the cost (proving it's a complete archimedean ordered field) and then the user doesn't look at the innards of the definition but just uses the interface you've made for them.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
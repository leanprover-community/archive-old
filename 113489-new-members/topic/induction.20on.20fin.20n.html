---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/induction.20on.20fin.20n.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html">induction on fin n</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="207271034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207271034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207271034">(Aug 18 2020 at 15:06)</a>:</h4>
<p>Currently, when I want to prove a lemma that deals indices in <code>fin (n + 2)</code>, I'm often relying on induction. However, it looks like:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fin</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="n">R</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="n">R</span><span class="o">)</span>

<span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">matrix</span>

<span class="n">def</span> <span class="n">swap_row</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">A</span> <span class="err">∘</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">swap</span> <span class="n">i</span> <span class="n">j</span>

<span class="n">def</span> <span class="n">drop</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">B</span><span class="bp">.</span><span class="n">minor</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">succ_above</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span><span class="bp">.</span><span class="n">succ_above</span><span class="o">)</span>

<span class="n">def</span> <span class="n">det&#39;</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
    <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span> <span class="bp">-&gt;</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">R</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="n">M</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">M</span> <span class="n">i</span> <span class="n">i</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="n">M</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">dite</span> <span class="o">(</span><span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="err">∑</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">M</span> <span class="mi">0</span> <span class="n">j</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">^</span> <span class="o">(</span><span class="n">j</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">*</span> <span class="n">det&#39;</span> <span class="o">(</span><span class="n">drop</span> <span class="n">M</span> <span class="mi">0</span> <span class="n">j</span><span class="o">)</span> <span class="mi">0</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="err">∑</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">^</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">*</span> <span class="n">det&#39;</span> <span class="o">(</span><span class="n">drop</span> <span class="n">M</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">pred</span> <span class="n">i</span> <span class="n">h</span><span class="o">)))</span>

<span class="kn">lemma</span> <span class="n">det_swap_match_eq_neg_det&#39;&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">det&#39;</span> <span class="o">(</span><span class="n">swap_row</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">det&#39;</span> <span class="n">A</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">i</span><span class="o">,</span>
      <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">j</span><span class="o">,</span>
      <span class="n">wlog</span> <span class="n">hl</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rcases</span> <span class="n">lt_trichotomy</span> <span class="n">j</span> <span class="n">i</span> <span class="k">with</span> <span class="n">H</span><span class="bp">|</span><span class="n">rfl</span><span class="bp">|</span><span class="n">H</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">H</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">contradiction</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">H</span> <span class="o">}</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">induction</span> <span class="n">i</span> <span class="k">with</span> <span class="n">i</span> <span class="n">HI</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">cases</span> <span class="n">j</span><span class="o">,</span>
          <span class="o">{</span> <span class="n">contradiction</span> <span class="o">},</span>
          <span class="o">{</span> <span class="n">exact</span> <span class="n">absurd</span> <span class="o">(</span><span class="n">zero_le</span> <span class="n">j</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">(</span><span class="n">not_le_of_lt</span> <span class="n">hl</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">induction</span> <span class="n">j</span> <span class="k">with</span> <span class="n">j</span> <span class="n">HJ</span><span class="o">,</span>
          <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
          <span class="o">{</span> <span class="n">sorry</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">sorry</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="207271163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207271163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207271163">(Aug 18 2020 at 15:07)</a>:</h4>
<p>I have to deconstruct the <code>fin n</code> into <code>obtain ⟨i, hi⟩ := i</code> and then induct on that. That makes dealing with existing lemmas about <code>fin n</code> much harder because of constantly having to convert back and forth between the <code>⟨i, hi⟩</code> syntax and the term itself.</p>



<a name="207271220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207271220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207271220">(Aug 18 2020 at 15:07)</a>:</h4>
<p>Is there some <code>induction i using ...</code> that I don't know about? Or should I write one?</p>



<a name="207271332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207271332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207271332">(Aug 18 2020 at 15:08)</a>:</h4>
<p>I've had some instances where I was able to invoke <code>induction i.val</code> but it didn't reduce the <code>i</code> to <code>0</code> and <code>_</code>. Not sure what it would have reduced it to.</p>



<a name="207271601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207271601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207271601">(Aug 18 2020 at 15:11)</a>:</h4>
<p>Can you either give a simpler example or explanation of what you want to do or translate your Lean code into English?</p>



<a name="207271698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207271698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207271698">(Aug 18 2020 at 15:11)</a>:</h4>
<p>You want to prove something for all <code>i : fin n</code> by induction on <code>i</code> I guess? What's the form of the argument?</p>



<a name="207271765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207271765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207271765">(Aug 18 2020 at 15:12)</a>:</h4>
<p>I am trying to prove that the determinant of a matrix with two rows swapped is the negative of the determinant of the original matrix.</p>



<a name="207271827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207271827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207271827">(Aug 18 2020 at 15:12)</a>:</h4>
<p>What's <code>det'</code>?</p>



<a name="207271888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207271888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207271888">(Aug 18 2020 at 15:12)</a>:</h4>
<p><code>det'</code> is the Laplace expansion of the determinant</p>



<a name="207272010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207272010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207272010">(Aug 18 2020 at 15:12)</a>:</h4>
<p>That expansion requires a row index to evaluate the determinant.</p>



<a name="207272200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207272200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207272200">(Aug 18 2020 at 15:13)</a>:</h4>
<p>The argument is, either the rows that are swapped are (0, greater than 0), or (1 or greater, greater than 1)</p>



<a name="207272269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207272269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207272269">(Aug 18 2020 at 15:14)</a>:</h4>
<p>off-topic, but don't we already basically have this theorem in the form of <code>det_permute</code>?</p>



<a name="207272463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207272463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207272463">(Aug 18 2020 at 15:15)</a>:</h4>
<p>That's totally right. But this is a necessary proof on the way that <code>example : ∀ i, det' A i = det A := sorry</code></p>



<a name="207272517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207272517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207272517">(Aug 18 2020 at 15:16)</a>:</h4>
<p>I want to prove that the Laplace expansion is a valid way of expressing <code>det</code>, that is the big picture.</p>



<a name="207272634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207272634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207272634">(Aug 18 2020 at 15:16)</a>:</h4>
<p>So, I induct on the size of the matrix. The base case (which is dim 2) is just (0, 1) swap. That's easy and I have that.</p>



<a name="207272766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207272766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207272766">(Aug 18 2020 at 15:17)</a>:</h4>
<p>I'm still confused by <code>det'</code>, the extra argument is which row to expand along? Why not always use the top row?</p>



<a name="207272790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207272790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207272790">(Aug 18 2020 at 15:17)</a>:</h4>
<p>Then for (n + 2), the cases are (0, 1), (0, j + 1), (i + 1, j + 1). The (i + 1, j + 1) case is dealt with by the induction hypotheses for submatrices (from the n-induction) and the base cases.</p>



<a name="207272896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207272896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207272896">(Aug 18 2020 at 15:18)</a>:</h4>
<p>Sure, one could always use the top row, and there would be a separate proof saying it does not matter which row you choose.</p>



<a name="207272938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207272938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207272938">(Aug 18 2020 at 15:18)</a>:</h4>
<p>But to be able to prove that, <code>det'</code> has to be formulated to allow any row.</p>



<a name="207272999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207272999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207272999">(Aug 18 2020 at 15:19)</a>:</h4>
<p>That might be useful if one had an explicit matrix with a very sparse row -- use that row.</p>



<a name="207273020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207273020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207273020">(Aug 18 2020 at 15:19)</a>:</h4>
<p>Wouldn't it be easier to use <code>det</code> in the definition of <code>det'</code>?</p>



<a name="207273218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207273218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207273218">(Aug 18 2020 at 15:20)</a>:</h4>
<p>I guess I don't see the big picture</p>



<a name="207273291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207273291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207273291">(Aug 18 2020 at 15:21)</a>:</h4>
<p>We also have <code>adjugate_mul : adjugate A ⬝ A = A.det • 1</code>which seems like roughly the statement you want to prove</p>



<a name="207273722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207273722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207273722">(Aug 18 2020 at 15:24)</a>:</h4>
<p>If you calculate the <code>(i, i)</code> entry of <code>adjugate A ⬝ A</code> it's something like your <code>det' A i</code></p>



<a name="207273881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207273881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207273881">(Aug 18 2020 at 15:25)</a>:</h4>
<p>You're right that they are very related definitions, that's part of what I want to try proving.</p>



<a name="207273991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207273991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207273991">(Aug 18 2020 at 15:26)</a>:</h4>
<p>The Laplace expansion is a slow but sure way of actually calculating the <code>det</code>. The kernel knows:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="n">a</span> <span class="bp">`+`</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">field</span><span class="bp">.</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">local</span> <span class="kn">notation</span> <span class="n">a</span> <span class="bp">`*`</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">field</span><span class="bp">.</span><span class="n">mul</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`-`</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">field</span><span class="bp">.</span><span class="n">neg</span> <span class="n">a</span>
<span class="n">local</span> <span class="kn">notation</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">field</span><span class="bp">.</span><span class="n">zero</span>
<span class="n">local</span> <span class="kn">notation</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">field</span><span class="bp">.</span><span class="n">one</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">det&#39;</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">]]</span> <span class="mi">0</span> <span class="c">/-</span><span class="cm"> a * 1 * d + (b * (-1 * 1) * c + 0) -/</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">matrix</span><span class="bp">.</span><span class="n">det</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">]]</span> <span class="c">/-</span><span class="cm"> (0 + 1) * (a * (d * 1)) + (-(0 + 1) * (c * (b * 1)) + 0) -/</span>
</code></pre></div>



<a name="207274268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207274268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207274268">(Aug 18 2020 at 15:28)</a>:</h4>
<p>For those interested in computation, statements about speed or bounds of matrix calculation would need different examples. So, in this case, Laplace expansion versus anything more common.</p>



<a name="207274368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207274368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207274368">(Aug 18 2020 at 15:29)</a>:</h4>
<p>In any case, is there a way to induction on terms of <code>fin n</code> without first destructing them?</p>



<a name="207274793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207274793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207274793">(Aug 18 2020 at 15:32)</a>:</h4>
<p>isn't there a recursor for fin?</p>



<a name="207275293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207275293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207275293">(Aug 18 2020 at 15:36)</a>:</h4>
<p>How about this strategy for proving your overall result:</p>
<ul>
<li>Prove that <code>det</code> satisfies the same recursions as <code>det'</code>: you can evaluate <code>det</code> by expanding along any row. You can prove it using <code>adjugate_mul</code> (but check the proof of that first to see if it uses another version of this fact).</li>
<li>Conclude that <code>det' = det</code> by induction on <code>n</code>.</li>
</ul>



<a name="207275361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207275361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207275361">(Aug 18 2020 at 15:37)</a>:</h4>
<p>you can also skip step 2</p>



<a name="207275727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207275727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207275727">(Aug 18 2020 at 15:40)</a>:</h4>
<p>Yes, but if you specifically want to do this computation with <code>#reduce</code> or <code>#eval</code> for some reason then you can also not skip it</p>



<a name="207275815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207275815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207275815">(Aug 18 2020 at 15:41)</a>:</h4>
<p>but you also shouldn't use exponential algorithms for that</p>



<a name="207275979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207275979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207275979">(Aug 18 2020 at 15:42)</a>:</h4>
<p>Let's say someone was writing a <code>Linear Algebra Game</code> without all of mathlib around.</p>



<a name="207276251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207276251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207276251">(Aug 18 2020 at 15:44)</a>:</h4>
<p>then you wouldn't have <code>det</code></p>



<a name="207276264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207276264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207276264">(Aug 18 2020 at 15:44)</a>:</h4>
<p>so the theorem couldn't be stated</p>



<a name="207276544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207276544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207276544">(Aug 18 2020 at 15:47)</a>:</h4>
<p>Sorry, I wasn't being clear. If in the game, the definition of <code>det</code> is the Laplace expansion, I'd still like to show the statement about how swapping rows negates the determinant value.</p>



<a name="207276596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207276596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207276596">(Aug 18 2020 at 15:47)</a>:</h4>
<p>Without any reference to <code>det = sum over permutations of products of ...</code></p>



<a name="207276692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207276692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207276692">(Aug 18 2020 at 15:48)</a>:</h4>
<p>Is <del>recursion</del> induction over <code>fin n</code> in general not suggested?</p>



<a name="207276845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207276845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207276845">(Aug 18 2020 at 15:49)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fin.succ_rec">docs#fin.succ_rec</a></p>



<a name="207277289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207277289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207277289">(Aug 18 2020 at 15:53)</a>:</h4>
<p>How is that used with the <code>induction</code> tactic? I've had difficulty understanding how <code>induction ... using ...</code> works.</p>



<a name="207286489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207286489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207286489">(Aug 18 2020 at 17:08)</a>:</h4>
<p>Specifically, here are the errors I get:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">det&#39;</span> <span class="o">(</span><span class="n">swap_row</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">det&#39;</span> <span class="n">A</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">induction</span> <span class="n">i</span> <span class="kn">using</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ_rec</span><span class="o">,</span>
    <span class="c">/-</span><span class="cm"></span>
<span class="cm">induction tactic failed, argument #1 of major premise type</span>
<span class="cm">  fin (nat.succ n + 2)</span>
<span class="cm">is not a variable</span>
<span class="cm">state:</span>
<span class="cm">R : Type u_1,</span>
<span class="cm">_inst_1 : field R,</span>
<span class="cm">n : ℕ,</span>
<span class="cm">hn :</span>
<span class="cm">  ∀ (A : matrix (fin (n + 2)) (fin (n + 2)) R) (i j : fin (n + 2)), i ≠ j → det&#39; (swap_row A i j) i = -det&#39; A 0,</span>
<span class="cm">A : matrix (fin (n.succ + 2)) (fin (n.succ + 2)) R,</span>
<span class="cm">i j : fin (n.succ + 2),</span>
<span class="cm">h : i ≠ j</span>
<span class="cm">⊢ det&#39; (swap_row A i j) i = -det&#39; A 0</span>
<span class="cm">-/</span>

    <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">det&#39;</span> <span class="o">(</span><span class="n">swap_row</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">det&#39;</span> <span class="n">A</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">induction</span> <span class="n">i</span> <span class="kn">using</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ_rec_on</span><span class="o">,</span>
    <span class="c">/-</span><span class="cm"></span>
<span class="cm">invalid user defined recursor, type of the major premise &#39;i&#39; does not contain the recursor parameter &#39;i&#39;</span>
<span class="cm">state:</span>
<span class="cm">R : Type u_1,</span>
<span class="cm">_inst_1 : field R,</span>
<span class="cm">n : ℕ,</span>
<span class="cm">hn :</span>
<span class="cm">  ∀ (A : matrix (fin (n + 2)) (fin (n + 2)) R) (i j : fin (n + 2)), i ≠ j → det&#39; (swap_row A i j) i = -det&#39; A 0,</span>
<span class="cm">A : matrix (fin (n.succ + 2)) (fin (n.succ + 2)) R,</span>
<span class="cm">i j : fin (n.succ + 2),</span>
<span class="cm">h : i ≠ j</span>
<span class="cm">⊢ det&#39; (swap_row A i j) i = -det&#39; A 0</span>
<span class="cm">-/</span>

    <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="207287061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207287061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207287061">(Aug 18 2020 at 17:12)</a>:</h4>
<p>Oh, I don't use <code>induction using</code> much because it's a little flaky. You can just use <code>refine fin.succ_rec_on i _ _ </code></p>



<a name="207287844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207287844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207287844">(Aug 18 2020 at 17:17)</a>:</h4>
<p>For the zero case, it does not provide the hypothesis that <code>i = 0</code>. Is there a way to do that?</p>



<a name="207299625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207299625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207299625">(Aug 18 2020 at 18:52)</a>:</h4>
<p>I'm trying to emulate the hypothesis <code>i = 0</code> by reverting the hypotheses that mention <code>i</code>. But I get a type mismatch, because the newly introduced <code>N</code> does not match with the existing <code>n</code> if I don't also revert <code>j</code>. Is there a way to show that <code>N.succ = n.succ + 2</code> and replace occurrences of <code>N</code> with <code>n.succ + 1</code>? Because the introduced <code>hl</code> hypothesis isn't well-typed if that isn't the case.</p>



<a name="207299797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207299797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207299797">(Aug 18 2020 at 18:54)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fin</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">wlog</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">wlog</span> <span class="n">hl</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span> <span class="kn">using</span> <span class="o">[</span><span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span> <span class="n">i</span><span class="o">],</span>
      <span class="o">{</span> <span class="n">rcases</span> <span class="n">lt_trichotomy</span> <span class="n">j</span> <span class="n">i</span> <span class="k">with</span> <span class="n">H</span><span class="bp">|</span><span class="n">rfl</span><span class="bp">|</span><span class="n">H</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">H</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">contradiction</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">H</span> <span class="o">}</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">revert</span> <span class="n">hl</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">refine</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ_rec_on</span> <span class="n">i</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">intros</span> <span class="n">N</span> <span class="n">hl</span><span class="o">,</span>
          <span class="n">exact</span> <span class="n">absurd</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">zero_le</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">not_le_of_lt</span> <span class="n">hl</span><span class="o">)</span> <span class="o">},</span>
        <span class="c">/-</span><span class="cm"></span>
<span class="cm">type mismatch at application</span>
<span class="cm">  not_le_of_lt hl</span>
<span class="cm">term</span>
<span class="cm">  hl</span>
<span class="cm">has type</span>
<span class="cm">  @has_lt.lt (fin N.succ) (@fin.has_lt N.succ) j 0</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  @has_lt.lt (fin (@has_add.add nat nat.has_add (@has_add.add nat nat.has_add n.succ 1) 1))</span>
<span class="cm">    (@preorder.to_has_lt (fin (@has_add.add nat nat.has_add (@has_add.add nat nat.has_add n.succ 1) 1))</span>
<span class="cm">       (@partial_order.to_preorder (fin (@has_add.add nat nat.has_add (@has_add.add nat nat.has_add n.succ 1) 1))</span>
<span class="cm">          (@semilattice_inf.to_partial_order</span>
<span class="cm">             (fin (@has_add.add nat nat.has_add (@has_add.add nat nat.has_add n.succ 1) 1))</span>
<span class="cm">             (@lattice.to_semilattice_inf (fin (@has_add.add nat nat.has_add (@has_add.add nat nat.has_add n.succ 1) 1))</span>
<span class="cm">                (@lattice_of_decidable_linear_order</span>
<span class="cm">                   (fin (@has_add.add nat nat.has_add (@has_add.add nat nat.has_add n.succ 1) 1))</span>
<span class="cm">                   (@fin.decidable_linear_order</span>
<span class="cm">                      (@has_add.add nat nat.has_add (@has_add.add nat nat.has_add n.succ 1) 1)))))))</span>
<span class="cm">    j</span>
<span class="cm">    0</span>
<span class="cm">state:</span>
<span class="cm">n : ℕ,</span>
<span class="cm">hn : ∀ (i j : fin (n + 2)), i ≠ j → true,</span>
<span class="cm">i j : fin (n.succ + 2),</span>
<span class="cm">N : ℕ,</span>
<span class="cm">hl : j &lt; 0</span>
<span class="cm">⊢ 0 ≠ j → true</span>
<span class="cm">-/</span>

        <span class="o">{</span>  <span class="o">},</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="207299832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207299832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207299832">(Aug 18 2020 at 18:54)</a>:</h4>
<p>Here's how reverting <code>j</code> makes it work.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">wlog</span> <span class="n">hl</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span> <span class="kn">using</span> <span class="o">[</span><span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span> <span class="n">i</span><span class="o">],</span>
      <span class="o">{</span> <span class="n">rcases</span> <span class="n">lt_trichotomy</span> <span class="n">j</span> <span class="n">i</span> <span class="k">with</span> <span class="n">H</span><span class="bp">|</span><span class="n">rfl</span><span class="bp">|</span><span class="n">H</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">H</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">contradiction</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">H</span> <span class="o">}</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">revert</span> <span class="n">hl</span> <span class="n">h</span> <span class="n">j</span><span class="o">,</span>
        <span class="n">refine</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ_rec_on</span> <span class="n">i</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">intros</span> <span class="n">N</span> <span class="n">j</span> <span class="n">hl</span><span class="o">,</span>
          <span class="n">exact</span> <span class="n">absurd</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">zero_le</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">not_le_of_lt</span> <span class="n">hl</span><span class="o">)</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">sorry</span>  <span class="o">},</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="207299857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207299857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207299857">(Aug 18 2020 at 18:54)</a>:</h4>
<p>I guess this is what <code>induction ... generalizing ...</code> does?</p>



<a name="207300213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207300213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207300213">(Aug 18 2020 at 18:57)</a>:</h4>
<p>wait, you are doing two inductions over <code>n</code> here? is that deliberate?</p>



<a name="207300288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207300288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207300288">(Aug 18 2020 at 18:58)</a>:</h4>
<p>I wanted to induct over <code>i : fin (n + 2)</code></p>



<a name="207300305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207300305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207300305">(Aug 18 2020 at 18:58)</a>:</h4>
<p>yeah but what does that mean</p>



<a name="207300345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207300345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207300345">(Aug 18 2020 at 18:58)</a>:</h4>
<p>And use a hypothesis that is valid for <code>fin (n + 1)</code></p>



<a name="207300353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207300353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207300353">(Aug 18 2020 at 18:58)</a>:</h4>
<p><code>fin.succ_rec</code> is doing simultaneous induction over <code>i</code> and <code>n</code> in <code>i : fin n</code></p>



<a name="207300389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207300389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207300389">(Aug 18 2020 at 18:59)</a>:</h4>
<p>which you have to do in order to make something type correct</p>



<a name="207300433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207300433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207300433">(Aug 18 2020 at 18:59)</a>:</h4>
<p>Okay, so I will try to rearrange the <code>fin.succ_rec_on</code> to be the outermost layer, and induct on <code>n</code> inside.</p>



<a name="207300474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207300474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207300474">(Aug 18 2020 at 19:00)</a>:</h4>
<p>the inner one can probably be a <code>cases</code></p>



<a name="207303654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207303654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207303654">(Aug 18 2020 at 19:22)</a>:</h4>
<p>Oh! Your code is broken because a previous tactic gave you a bad state</p>



<a name="207304220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207304220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207304220">(Aug 18 2020 at 19:28)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fin</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">wlog</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">wlog</span> <span class="n">hl</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span> <span class="kn">using</span> <span class="o">[</span><span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span> <span class="n">i</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">revert</span> <span class="n">hl</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ_rec_on</span> <span class="n">i</span> <span class="n">sorry</span> <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>


<p>This gives an error on the <code>wlog</code> line only if the refine line is there</p>



<a name="207304264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207304264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207304264">(Aug 18 2020 at 19:28)</a>:</h4>
<p>the tactic state coming out of <code>wlog</code> is actually malformed</p>



<a name="207305632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207305632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207305632">(Aug 18 2020 at 19:39)</a>:</h4>
<p>so, avoid <code>wlog</code>?</p>



<a name="207305737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207305737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207305737">(Aug 18 2020 at 19:40)</a>:</h4>
<p>I think it might be having trouble with the dependent type?</p>



<a name="207305750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207305750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207305750">(Aug 18 2020 at 19:40)</a>:</h4>
<p>Or do <code>wlog</code> only after all my induction steps?</p>



<a name="207305849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207305849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207305849">(Aug 18 2020 at 19:41)</a>:</h4>
<p>it could also be a bug in <code>refine</code> i.e. the elaborator, but that seems less likely given how much use it gets</p>



<a name="207306180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207306180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207306180">(Aug 18 2020 at 19:44)</a>:</h4>
<p>actually that's exactly the case:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">false</span> <span class="o">:=</span>
<span class="n">fin</span><span class="bp">.</span><span class="n">succ_rec_on</span> <span class="n">i</span> <span class="n">sorry</span> <span class="n">sorry</span>
</code></pre></div>



<a name="207306446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207306446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207306446">(Aug 18 2020 at 19:46)</a>:</h4>
<p>In fact I've seen this issue before, it is the same thing that <code>rw</code> says next to <code>motive is not type correct</code>. It attempted to generalize the goal and got something type incorrect, although it reports the error in a really weird way here</p>



<a name="207306576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207306576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207306576">(Aug 18 2020 at 19:47)</a>:</h4>
<p>More examples of weirdness:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fin</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">type mismatch at application</span>
<span class="cm">  0</span>
<span class="cm">term</span>
<span class="cm">  @fin.has_zero (n + 1)</span>
<span class="cm">has type</span>
<span class="cm">  has_zero (fin (n + 1).succ)</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  has_zero (fin _x)</span>
<span class="cm">-/</span>

<span class="k">begin</span>
  <span class="n">revert</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ_rec_on</span> <span class="n">i</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">N</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">absurd</span> <span class="n">h</span> <span class="o">(</span><span class="n">lt_irrefl</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">N</span><span class="bp">.</span><span class="n">succ</span><span class="o">)))</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">revert</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ_rec_on</span> <span class="n">i</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">N</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">absurd</span> <span class="n">h</span> <span class="o">(</span><span class="n">lt_irrefl</span> <span class="mi">0</span><span class="o">)</span> <span class="o">},</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">type mismatch at application</span>
<span class="cm">  absurd h (lt_irrefl 0)</span>
<span class="cm">term</span>
<span class="cm">  lt_irrefl 0</span>
<span class="cm">has type</span>
<span class="cm">  not (@has_lt.lt ?m_1 (@preorder.to_has_lt ?m_1 ?m_2) 0 0)</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  not (@has_lt.lt (fin N.succ) (@fin.has_lt N.succ) 0 0)</span>
<span class="cm">state:</span>
<span class="cm">n : ℕ,</span>
<span class="cm">i : fin (n + 2),</span>
<span class="cm">N : ℕ,</span>
<span class="cm">h : 0 &lt; 0</span>
<span class="cm">⊢ true</span>
<span class="cm">-/</span>

  <span class="o">{</span> <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="207306888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207306888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207306888">(Aug 18 2020 at 19:49)</a>:</h4>
<p>My first example is your example, but the error is deferred if I don't specify the type of 0 on the <code>absurd</code> line.</p>



<a name="207307125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207307125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207307125">(Aug 18 2020 at 19:51)</a>:</h4>
<p>Should this be a separate thread? I guess I'll go back to </p>
<div class="codehilite"><pre><span></span><code>      <span class="o">{</span> <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">i</span><span class="o">,</span>
        <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">j</span><span class="o">,</span>
        <span class="n">induction</span> <span class="n">i</span> <span class="k">with</span> <span class="n">i</span> <span class="n">IH</span><span class="o">,</span>
          <span class="o">{</span> <span class="n">induction</span> <span class="n">j</span> <span class="k">with</span> <span class="n">j</span> <span class="n">JH</span><span class="o">,</span>
</code></pre></div>



<a name="207307131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207307131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207307131">(Aug 18 2020 at 19:51)</a>:</h4>
<p>You basically should not call <code>fin.succ_rec_on</code> unless the object has type <code>i : fin n</code> where <code>n</code> is a variable. You should <code>generalize e : n + 2 = m</code> beforehand to ensure this if you have to put <code>n+2</code> in the theorem statement, but it would be even better if you avoided that</p>



<a name="207307248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207307248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207307248">(Aug 18 2020 at 19:52)</a>:</h4>
<p>Can't refer to <code>0</code> if it's of type <code>fin n</code>, only <code>fin (n + 1)</code> at best.</p>



<a name="207307318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207307318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207307318">(Aug 18 2020 at 19:52)</a>:</h4>
<p>Just use a variable instead of <code>0</code></p>



<a name="207307341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207307341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207307341">(Aug 18 2020 at 19:52)</a>:</h4>
<p>you wanted to generalize that anyway, right?</p>



<a name="207307350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207307350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207307350">(Aug 18 2020 at 19:52)</a>:</h4>
<p>True. Thanks!</p>



<a name="207308007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207308007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207308007">(Aug 18 2020 at 19:57)</a>:</h4>
<p>Doesn't your</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">false</span> <span class="o">:=</span>
<span class="n">fin</span><span class="bp">.</span><span class="n">succ_rec_on</span> <span class="n">i</span> <span class="n">sorry</span> <span class="n">sorry</span>
</code></pre></div>


<p>have <code>n</code> as a variable?</p>



<a name="207308498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207308498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207308498">(Aug 18 2020 at 20:01)</a>:</h4>
<p>it does, but it did not revert <code>j</code></p>



<a name="207308639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207308639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207308639">(Aug 18 2020 at 20:02)</a>:</h4>
<p>the correct way to set up the induction is</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">false</span> <span class="o">:=</span>
<span class="n">fin</span><span class="bp">.</span><span class="n">succ_rec_on</span> <span class="n">i</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">sorry</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">i</span> <span class="n">IH</span> <span class="n">j</span><span class="o">,</span> <span class="n">sorry</span><span class="o">)</span> <span class="n">j</span>
</code></pre></div>



<a name="207310038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207310038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207310038">(Aug 18 2020 at 20:13)</a>:</h4>
<p>So something like:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">n&#39;</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">i&#39;</span> <span class="n">j&#39;</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">A&#39;</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">i&#39;</span> <span class="bp">&lt;</span> <span class="n">j&#39;</span> <span class="bp">→</span> <span class="n">det&#39;</span> <span class="o">(</span><span class="n">swap_row</span> <span class="n">A&#39;</span> <span class="n">i&#39;</span> <span class="n">j&#39;</span><span class="o">)</span> <span class="n">j&#39;</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">det&#39;</span> <span class="n">A&#39;</span> <span class="n">i&#39;</span> <span class="o">:=</span>
<span class="n">fin</span><span class="bp">.</span><span class="n">succ_rec_on</span> <span class="n">i&#39;</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">j</span> <span class="n">A</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="o">})</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">i</span> <span class="n">IH</span> <span class="n">j</span> <span class="n">A</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="o">})</span> <span class="n">j&#39;</span> <span class="n">A&#39;</span>
</code></pre></div>



<a name="207310812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207310812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207310812">(Aug 18 2020 at 20:19)</a>:</h4>
<p>But basically, that also means that I can't also induct on <code>j</code> within.</p>



<a name="207314832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207314832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207314832">(Aug 18 2020 at 20:52)</a>:</h4>
<p>you can case on <code>j</code></p>



<a name="207315092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207315092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207315092">(Aug 18 2020 at 20:55)</a>:</h4>
<p>One thing that's not clear to me is what the overall structure of your induction is. Suppose the theorem you want to prove is <code>P n i j</code>. What are the relations between the <code>P</code>'s at different arguments that you want to prove? Is it <code>i &lt; j -&gt; P n i j -&gt; P (n+1) (i+1) (j+1)</code> and <code>P (n+1) 0 0</code> or something else?</p>



<a name="207316919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207316919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207316919">(Aug 18 2020 at 21:10)</a>:</h4>
<p>Roughly following the proof here:<br>
<a href="https://www.quora.com/What-is-the-proof-for-the-Laplace-expansion-for-calculating-determinants">https://www.quora.com/What-is-the-proof-for-the-Laplace-expansion-for-calculating-determinants</a><br>
but I think this proof they outline has a circular argument.</p>



<a name="207557880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20on%20fin%20n/near/207557880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20on.20fin.20n.html#207557880">(Aug 20 2020 at 18:34)</a>:</h4>
<p>Does <a href="https://github.com/leanprover-community/mathlib/issues/3869">#3869</a> help at all for fin comparisons? Relatedly, can one use <code>\bot</code> to refer to <code>0</code> and <code>\top</code> for <code>fin.last _</code>?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html">`finset` of `fintype`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209462767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209462767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209462767">(Sep 09 2020 at 01:16)</a>:</h4>
<p>I have <code>s : set bool</code> and would like to turn it into <code>s : finset bool</code>. (My goal has the form <code>p s</code>.) Also, is there an elegant way to do exhaustive "cases" on <code>s : set bool</code>, considering there are only 4 possibility it would be fine (but a way to do it for any <code>fintype</code> would be welcome).</p>



<a name="209463078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209463078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209463078">(Sep 09 2020 at 01:22)</a>:</h4>
<p>I think it's (very nearly) <code>set_fintype</code> in <code>data.fintype.basic</code></p>



<a name="209463103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209463103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209463103">(Sep 09 2020 at 01:23)</a>:</h4>
<p>That only gives you <code>fintype s</code>, though, but then I think you can use <code>set.to_finset</code>.</p>



<a name="209463306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209463306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209463306">(Sep 09 2020 at 01:27)</a>:</h4>
<p>Apparently this works:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">bool</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">s</span><span class="o">]</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">s</span><span class="bp">.</span><span class="n">to_finset</span>
</code></pre></div>



<a name="209463522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209463522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209463522">(Sep 09 2020 at 01:31)</a>:</h4>
<p>Oh, great! Thank you.</p>



<a name="209463553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209463553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209463553">(Sep 09 2020 at 01:31)</a>:</h4>
<p>With that <code>finset.induction_on</code> is what I want ("an elegant way to do exhaustive "cases" on <code>s : set bool</code>").</p>



<a name="209463842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209463842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209463842">(Sep 09 2020 at 01:37)</a>:</h4>
<p>It looks like <code>fin_cases s</code> works for <code>s : set bool</code> when there is a <code>decidable_pred s</code> instance.  You can also use <code>fin_cases s</code> for <code>finset</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">card</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">fin_cases</span> <span class="n">s</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="209463925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209463925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209463925">(Sep 09 2020 at 01:39)</a>:</h4>
<p>Wow, amazing! I didn't know this tactic, very useful!</p>



<a name="209464332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209464332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209464332">(Sep 09 2020 at 01:48)</a>:</h4>
<p>Is the <code>decidable_pred</code> necessary because one could have a</p>
<div class="codehilite"><pre><span></span><code><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">DoesSomeComplexTuringMachineOfLength1000Terminate</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="n">term</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">|</span> <span class="n">DoesSomeComplexTuringMachineOfLength1000Terminate</span> <span class="n">term</span><span class="o">}</span> <span class="c1">-- set bool</span>
</code></pre></div>


<p>but you can't necessarily prove what finset it is specifically?</p>



<a name="209464871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209464871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209464871">(Sep 09 2020 at 02:00)</a>:</h4>
<p>With classical logic one can "decide" that. Also, <code>fin_cases</code> apparently uses <code>classical.dec_pred</code> automatically, as I didn't have <code>decidable_pred</code> in the context for the set I specified.</p>



<a name="209465088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209465088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209465088">(Sep 09 2020 at 02:06)</a>:</h4>
<p>Is there a way to make <code>fin_cases</code> <em>not</em> delete the intermediate equality hypothesis it creates (e.i. not rewrite the goal and clear the hypothesis, but give the hypothesis to me)?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s</span> <span class="err">∪</span> <span class="err">∅</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- No `decidable_pred s` in context.</span>
  <span class="n">fin_cases</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- The goal becomes `↑{val := 0, ...} = ↑{val := 0, ...} ∪ ∅`</span>
    <span class="n">simp</span> <span class="o">},</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s</span> <span class="err">∪</span> <span class="err">∅</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">haveI</span> <span class="n">inst</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">dec_pred</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">fin_cases</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- I have a hypothesis `h : s = ↑{val := 0, nodup := _}` in the context.</span>
    <span class="c1">-- `fin_cases` probably created it and clears it, but was stopped because</span>
    <span class="c1">-- `inst` depends on it.</span>
    <span class="n">simp</span> <span class="o">},</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="209465515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209465515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209465515">(Sep 09 2020 at 02:17)</a>:</h4>
<p>I think no. You can read the implementation of <code>fin_cases</code> and just do it yourself, I guess.</p>



<a name="209493882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209493882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209493882">(Sep 09 2020 at 10:27)</a>:</h4>
<p>I think rather <code>fin_cases</code> tried to <code>subst</code> the intermediate equality hypothesis but failed because <code>inst</code> is a frozen instance--if you change <code>haveI</code> to <code>have</code> then you end up with the first behavior again.</p>



<a name="209493900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209493900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209493900">(Sep 09 2020 at 10:27)</a>:</h4>
<p>In any case, isn't your second example an answer to your question? Or do you want a more robust way to do it?</p>



<a name="209494365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60finset%60%20of%20%60fintype%60/near/209494365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60finset.60.20of.20.60fintype.60.html#209494365">(Sep 09 2020 at 10:33)</a>:</h4>
<p>One approach (many variants are possible) is:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s</span> <span class="err">∪</span> <span class="err">∅</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="bp">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">t</span><span class="o">,</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">fin_cases</span> <span class="n">t</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- s : set bool,</span>
    <span class="c1">-- ht : ↑{val := 0, nodup := _} = s</span>
    <span class="c1">-- ⊢ s = s ∪ ∅</span>
    <span class="n">simp</span> <span class="o">},</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
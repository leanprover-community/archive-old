---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/NNG.20world.209.20level.204.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/NNG.20world.209.20level.204.html">NNG world 9 level 4</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="271093035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/NNG%20world%209%20level%204/near/271093035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Yan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/NNG.20world.209.20level.204.html#271093035">(Feb 08 2022 at 08:10)</a>:</h4>
<p><a href="https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/?world=9&amp;level=4">world 9 level 4</a> shows an example where a stronger (more general) version of the theorem is provable but (supposedly) a weaker version can't be proved. This is very counter-intuitive. Is this a limitation of Lean? And honestly I can't tell the differences between the "stronger" theorem <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mtext> </mtext><mi>c</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo separator="true">,</mo><mi>h</mi><mi>a</mi><mo>:</mo><mi>a</mi><mo mathvariant="normal">≠</mo><mn>0</mn><mo>⊢</mo><mi mathvariant="normal">∀</mi><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi>b</mi><mo>=</mo><mi>a</mi><mi>c</mi><mo>⇒</mo><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex"> a \, c: \N, ha: a \ne 0 \vdash \forall b, ab = ac \Rightarrow b = c </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathbb">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ha</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ab</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> and the "weaker" theorem <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mtext> </mtext><mi>b</mi><mtext> </mtext><mi>c</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo separator="true">,</mo><mi>h</mi><mi>a</mi><mo>:</mo><mi>a</mi><mo mathvariant="normal">≠</mo><mn>0</mn><mo>⊢</mo><mi>a</mi><mi>b</mi><mo>=</mo><mi>a</mi><mi>c</mi><mo>⇒</mo><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex"> a\, b\, c : \N,  ha: a \ne 0 \vdash ab = ac \Rightarrow b = c </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathbb">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ha</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ab</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>. It feels a bit weird to have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex"> \forall </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">∀</span></span></span></span> in the game for the first time (a mix of set-theoretic language and type-theoretic language)?</p>



<a name="271093680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/NNG%20world%209%20level%204/near/271093680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/NNG.20world.209.20level.204.html#271093680">(Feb 08 2022 at 08:18)</a>:</h4>
<p>That's very common with induction, isn't it? You sometimes have to strengthen the induction hypothesis for the induction to carry through.</p>



<a name="271094874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/NNG%20world%209%20level%204/near/271094874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/NNG.20world.209.20level.204.html#271094874">(Feb 08 2022 at 08:32)</a>:</h4>
<p>Ha no it's not a limitation of Lean! It's the way mathematics works.</p>



<a name="271094934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/NNG%20world%209%20level%204/near/271094934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Yan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/NNG.20world.209.20level.204.html#271094934">(Feb 08 2022 at 08:32)</a>:</h4>
<p>Guess I'll just have to step up my induction game. Personally, I think there is a more intuitive proof without modifying the theorem, which can't be used somehow? If you just do a basic <code>induction c with n hn</code>, you'll end up with <code>hn: ab = an -&gt; b=n</code>. In a classical proof, I would immediately discuss by cases: <br>
Case 1.  ab = an is true<br>
this can then nicely substituted into the goal to show it's vacuously true (the antecedent becomes a = 0 and is false)<br>
Case 2. ab = an is false<br>
this means the induction hypothesis is vacously true and anything follows.</p>
<p>I remember doing similar stuff with <code>by_cases</code> to a term of Proposition type...but somehow this can't be done for <code>a = b</code> types?</p>



<a name="271095479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/NNG%20world%209%20level%204/near/271095479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/NNG.20world.209.20level.204.html#271095479">(Feb 08 2022 at 08:37)</a>:</h4>
<p>Wait what is your goal in that context?</p>



<a name="271095500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/NNG%20world%209%20level%204/near/271095500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/NNG.20world.209.20level.204.html#271095500">(Feb 08 2022 at 08:37)</a>:</h4>
<p>Probably the way to think about this is to step back and actually ask yourself "what <em>is</em> induction?" . Here's what it is. You have some context (some variables, or whatever, which are fixed and which you can use to make mathematical statements) and then infinitely many true-false statements P(0), P(1), P(2), ... . You want to prove them all. The principle of induction says that if you prove P(0) and "forall n, P(n) - P(n+1)" then you can deduce them all. The subtlety in this level is that if you have some stuff in your context, like a variable b, then that variable is fixed. If the P(n) all depend on b then b can't change as you start manipulating the P(n). However if your context doesn't contain the variable b but P(n) is of the form "for all b, (something to do with b and n)" then this is different, because if you know P(n) then you know a statement about all b, and you might want to prove P(n+1) for a specific b by using P(n) for b+1 or something like that. You can't do this if b is in your context, you can only do it if it's being universally quantified over as part of P.</p>
<p>In short, when you're doing induction to prove a statement P, in a language like Lean, you have to really think hard about precisely what P says, and in particular which variables are free and which are bound.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/.E2.9C.94.20Failed.20to.20synthesize.20type.20class.20instance.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Failed.20to.20synthesize.20type.20class.20instance.html">✔ Failed to synthesize type class instance</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="282766922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Failed%20to%20synthesize%20type%20class%20instance/near/282766922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Failed.20to.20synthesize.20type.20class.20instance.html#282766922">(May 18 2022 at 10:18)</a>:</h4>
<p>You should use <code>haveI</code> instead of <code>have</code>, so that typeclass inference knows about it.</p>



<a name="282766993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Failed%20to%20synthesize%20type%20class%20instance/near/282766993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Failed.20to.20synthesize.20type.20class.20instance.html#282766993">(May 18 2022 at 10:19)</a>:</h4>
<p>Oh, that worked. Thanks a lot.</p>



<a name="282767009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Failed%20to%20synthesize%20type%20class%20instance/near/282767009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Failed.20to.20synthesize.20type.20class.20instance.html#282767009">(May 18 2022 at 10:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="488648">Xavier Roblot</span> has marked this topic as resolved.</p>



<a name="282783178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Failed%20to%20synthesize%20type%20class%20instance/near/282783178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Failed.20to.20synthesize.20type.20class.20instance.html#282783178">(May 18 2022 at 12:58)</a>:</h4>
<p>The CS crowd don't like <code>lemma1</code> (and they convinced me they had a point!). But probably the "mathlib name" of your lemma is pretty long :-/</p>
<p>Your <code>h₂</code> doesn't say what you think it says. Equality of types is a dangerous thing. If you want to say that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span> is not all of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> then you should say an equality of terms: <code>(h₂ : subgroup.center G ≠ ⊤)</code>. In Lean, <code>ℕ = ℤ </code> is undecidable!</p>
<p><code>fintype</code> is constructive finiteness, it's not just the statement "I am finite", it's the data of the collection of all the elements. So it should be <code>letI  rr : fintype Q</code> -- this is because <code>fintype Q : Type</code> (or <code>Type u</code> in your case).</p>



<a name="282784132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Failed%20to%20synthesize%20type%20class%20instance/near/282784132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Failed.20to.20synthesize.20type.20class.20instance.html#282784132">(May 18 2022 at 13:03)</a>:</h4>
<p>Do we have a version of <code>is_field</code> for commutativity (apart from <code>commutative</code> and <code>is_commutative</code>, which don't have any API)? If so, that would be the right way to spell <code>subgroup.center G ≠ ⊤</code>.</p>



<a name="282784224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Failed%20to%20synthesize%20type%20class%20instance/near/282784224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Failed.20to.20synthesize.20type.20class.20instance.html#282784224">(May 18 2022 at 13:04)</a>:</h4>
<p><code>is_abelian</code> doesn't seem to be a thing, so I guess not.</p>



<a name="282787668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Failed%20to%20synthesize%20type%20class%20instance/near/282787668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Failed.20to.20synthesize.20type.20class.20instance.html#282787668">(May 18 2022 at 13:29)</a>:</h4>
<p>Kevin, thanks for the advice. I can see that things are a bit more complicated than I thought. </p>
<p>In any case, I'll work on improving my lemma's names once I can finish a proof <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="282793150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Failed%20to%20synthesize%20type%20class%20instance/near/282793150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Failed.20to.20synthesize.20type.20class.20instance.html#282793150">(May 18 2022 at 14:08)</a>:</h4>
<p>Learning quickly the difference between a type and a term is useful, and knowing which universe things are happening in is also useful (I tell my students that there are two universes, <code>Prop</code> and <code>Type</code>, although you seem to have already discovered that in fact there are infinitely many universes <code>Type u</code> indexed by the naturals; my feeling is that this is to a large extent of the axiom in type theory saying that everything must have a type, even <code>Type</code> itself; I am not sure this is relevant to mathematics until you get to e.g. etale cohomology and start having to worry about taking limits over things which are not sets). I don't know why we don't have a <code>Prop</code> stating that a type is finite; people have often talked about adding it but it hasn't quite happened yet. </p>
<p>The type/term thing is happening because "a subgroup is not a group". A subgroup of G is a term, of type <code>subgroup G</code>. Of course one sometimes wants to make it into a group, and one does this using that "promote a term to a type" up-arrow which you might have spotted in your version of h2: <code>G ≠ ↥(subgroup.center G)</code>.  I suspect that even if G were abelian, <code>h2</code> might still be true, although it would probably also be unprovable. The problem is that if you take a type and then start playing around with it, making it into a term and then back into a type, the new type carries the same data as the old type but it's all wrapped up in a different way so it would probably not <em>equal</em> to the old type. An example which is perhaps less weird would be the statement that if you take a ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> and then quotient out by the zero ideal, you would get a new ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi mathvariant="normal">/</mi><mo stretchy="false">{</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R/\{0\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mopen">{</span><span class="mord">0</span><span class="mclose">}</span></span></span></span> which is not <em>equal</em> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, even though it's canonically isomorphic to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>. You don't tend to get such problems with equality of terms; this concept is much better behaved.</p>



<a name="282797371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Failed%20to%20synthesize%20type%20class%20instance/near/282797371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Failed.20to.20synthesize.20type.20class.20instance.html#282797371">(May 18 2022 at 14:40)</a>:</h4>
<p>Yes, I think that fully understanding the difference between term and type and how to distinguish between the two is something I need to work on. Thanks for the taking the time to explain this to me !</p>



<a name="282798099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Failed%20to%20synthesize%20type%20class%20instance/near/282798099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Failed.20to.20synthesize.20type.20class.20instance.html#282798099">(May 18 2022 at 14:45)</a>:</h4>
<p>It is term : type and type : universe, e.g. pi : real and real : Type, or &lt;proof&gt; : &lt;statement&gt; and &lt;statement&gt; : Prop. I learnt far too late that it was important to keep track of where "usual mathematical objects" lived in this hierarchy. For example if you want to define f : X -&gt; Y then X and Y had better be types (so you can have maps between groups but not between subgroups, unless you promote them from terms to types). Another stupid thing which didn't dawn on me for a long time: X -&gt; Y is itself a type, and <code>f : X -&gt; Y</code> is a term.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
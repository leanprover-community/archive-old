---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/finset.20members.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html">finset members</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="210846287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846287">(Sep 22 2020 at 09:29)</a>:</h4>
<p>Dear All,</p>
<p>I am trying to prove either one of the two lemmas below, but Lean is not allowing me to.  I would like to <code>convert set.mem_union_right ↑s</code>, but I am not able to proceed from there.  As usual, I imagine that Lean is obtaining different sources for something and cannot reconcile them, but I am not able to figure out what.</p>
<p>Thank you!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">lemma</span> <span class="n">mem_in_union</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_union</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)]</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">mem_in_union_singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_union</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">x</span><span class="o">})</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="210846388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846388">(Sep 22 2020 at 09:30)</a>:</h4>
<p>You shouldn't need <code>has_union</code>... Lean should figure it out by itself.</p>



<a name="210846431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846431">(Sep 22 2020 at 09:30)</a>:</h4>
<p>That indeed adds a second (unrelated, out-of-the-blue) notion of union for <code>finset \a</code></p>



<a name="210846541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846541">(Sep 22 2020 at 09:32)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mem_in_union</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">library_search</span>
<span class="kd">end</span>
</code></pre></div>



<a name="210846611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846611">(Sep 22 2020 at 09:32)</a>:</h4>
<p>I added <code>has_union</code> since Lean wanted it, but I will try to remove it again!</p>



<a name="210846618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846618">(Sep 22 2020 at 09:32)</a>:</h4>
<p>The <code>decidable_eq</code> enables the union instance. Without it, lean can't find it. (But then, if you <code>open_locale classical</code> everything works again)</p>



<a name="210846663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846663">(Sep 22 2020 at 09:33)</a>:</h4>
<p>ah, I think that I added first <code>has_union</code>, prompted by Lean, and then added <code>decidable_eq</code> (again prompted by Lean)</p>



<a name="210846669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846669">(Sep 22 2020 at 09:33)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> this is the "eternal(?)" conflict between proving and computing...</p>



<a name="210846693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846693">(Sep 22 2020 at 09:34)</a>:</h4>
<p>I think, if you do maths, you should forget about the <code>decidable_eq</code> stuff, and just use <code>open_locale classical</code> at the top of your files.</p>



<a name="210846743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846743">(Sep 22 2020 at 09:34)</a>:</h4>
<p>But sometimes <code>decidable_*</code> is really powerful.</p>



<a name="210846773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846773">(Sep 22 2020 at 09:34)</a>:</h4>
<p>ok, I will do that!</p>



<a name="210846807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846807">(Sep 22 2020 at 09:35)</a>:</h4>
<p>E.g., if you want to know that squares mod 8 are equal to 0, 1, or 4, then <code>dec_trivial</code> will prove it for you.</p>



<a name="210846835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846835">(Sep 22 2020 at 09:35)</a>:</h4>
<p>And that 1 line proof is of course a lot more convenient than whatever crazy case-split you would have to do otherwise.</p>



<a name="210846958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210846958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210846958">(Sep 22 2020 at 09:36)</a>:</h4>
<p>ok, indeed, with <code>open_locale classical</code> i do not need to add <code>decidable_eq</code>!!  Thank you very much!</p>



<a name="210849104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210849104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210849104">(Sep 22 2020 at 09:56)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> What <code>open_locale classical</code> does, is that it makes every proposition decidable, using LEM. Of course it is "cheating" and using an axiom, and Lean knows this. So you can't use it to decide the truth of you favourite conjecture afterwards. But at the same time, Lean also won't get hung up on the fact that it doesn't know how to decide whether <code>x \in s</code> is true or not.</p>



<a name="210853057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210853057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210853057">(Sep 22 2020 at 10:42)</a>:</h4>
<p>I don't understand why you write "cheating". This has nothing to do with cheating.</p>



<a name="210853148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210853148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210853148">(Sep 22 2020 at 10:42)</a>:</h4>
<p>It is "cheating" in the sense that "decidable" no longer means what it usually means.</p>



<a name="210853151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210853151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210853151">(Sep 22 2020 at 10:43)</a>:</h4>
<p>This command simply gives up hope to get Lean to <em>compute</em> a number of things. That's all. You can still do reasoning, without cheating, but you cannot compute.</p>



<a name="210853204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210853204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210853204">(Sep 22 2020 at 10:43)</a>:</h4>
<p>The command says "don't try to use decidability".</p>



<a name="210853368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210853368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210853368">(Sep 22 2020 at 10:45)</a>:</h4>
<p>If someone tells you that the Riemann Hypothesis is decidable, usually that would mean that you can run an algorithm and it will spit out <code>true</code> or <code>false</code> in the end. But if you have <code>open_locale classical</code>, then everything is decidable, and no such algorithms need to exist.</p>



<a name="210859453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210859453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210859453">(Sep 22 2020 at 12:00)</a>:</h4>
<p>Well, there is an algorithm that spits out <code>true</code> if the Riemann hypothesis is true and <code>false</code> otherwise.  Just no one seems to know which one it is, at the moment!</p>



<a name="210859480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/finset%20members/near/210859480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/finset.20members.html#210859480">(Sep 22 2020 at 12:00)</a>:</h4>
<p>Anyway, I think that I am getting an idea of what is going on here: thank you!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
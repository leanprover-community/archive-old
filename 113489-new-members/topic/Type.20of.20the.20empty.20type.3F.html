---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html">Type of the empty type?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="177088369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177088369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Alan Thompson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177088369">(Oct 01 2019 at 19:17)</a>:</h4>
<p>Beginner here. As I understand it everything in lean has a type. If this is the case then what is the type of the empty type in lean (or type theories more generally)?</p>



<a name="177089134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177089134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177089134">(Oct 01 2019 at 19:26)</a>:</h4>
<p>There are infinitely many empty types. Lean has a hierarchy of type universes <code>Sort 0, Sort 1, Sort 2, ...</code>. You can define an empty inductive type inside any universe. In fact, you can define multiple empty inductive types in the same universe, and you can't prove in Lean that they're equal. The type of an empty type will be <code>Sort i</code> for some <code>i</code>.</p>



<a name="177089667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177089667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Alan Thompson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177089667">(Oct 01 2019 at 19:32)</a>:</h4>
<p>Alright, so as an example, what is the type of the empty type which is used when defining the negation of a proposition? When we say Â¬A is A -&gt; E what is the type of that E?</p>



<a name="177089717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177089717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177089717">(Oct 01 2019 at 19:33)</a>:</h4>
<p>That empty type is named <code>false</code> in Lean. Its type is <code>Sort 0</code>, which also goes by the name <code>Prop</code>.</p>



<a name="177090348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177090348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Alan Thompson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177090348">(Oct 01 2019 at 19:40)</a>:</h4>
<p>Ahh okay thanks. Also when trying to prove something and you end up with false as a hypothesis then you're done right? How does lean know that false proves everything?</p>



<a name="177090393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177090393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177090393">(Oct 01 2019 at 19:41)</a>:</h4>
<p>Yep. The theorem <code>false.elim</code> is what you need. In tactic mode, if you have <code>h : false</code> you can use <code>cases h</code>.</p>



<a name="177090605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177090605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177090605">(Oct 01 2019 at 19:44)</a>:</h4>
<p>This is the recursion principle for an empty inductive type, btw, which is how Lean "knows" it.</p>



<a name="177090607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177090607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177090607">(Oct 01 2019 at 19:44)</a>:</h4>
<p>A variation which is easier to read in tactic mode is: <code>exfalso, exact h</code></p>



<a name="177090684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177090684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177090684">(Oct 01 2019 at 19:45)</a>:</h4>
<p>Or <code>contradiction</code></p>



<a name="177090687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177090687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177090687">(Oct 01 2019 at 19:45)</a>:</h4>
<p>Or the <code>contradiction</code> tactic is even easier to read.</p>



<a name="177090861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177090861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Alan Thompson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177090861">(Oct 01 2019 at 19:47)</a>:</h4>
<p>Can you elaborate on how its "the recursion principle for an empty inductive type" at all? What does that mena?</p>



<a name="177091273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177091273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177091273">(Oct 01 2019 at 19:53)</a>:</h4>
<p>When you define an inductive type <code>T</code>, you give a list of the ways to construct a term of type <code>T</code>. The recursion principle says how to define a function with domain <code>T</code>. For each constructor, you say what the function should do given a term created with that constructor. This is enough to define a function, since the constructors are the only way to create a term of type <code>T</code>.</p>



<a name="177091370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177091370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177091370">(Oct 01 2019 at 19:54)</a>:</h4>
<p>For an empty type like <code>false</code>,  there are no constructors, so there are no inputs to the recursor. It's a function from <code>false</code> to any type.</p>



<a name="177091715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177091715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177091715">(Oct 01 2019 at 19:58)</a>:</h4>
<p>Recursors are generated automatically when you define an inductive type. For a simple non-degenerate example:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">two</span>
<span class="bp">|</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">b</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">two</span><span class="bp">.</span><span class="n">rec_on</span>
</pre></div>


<p>You define a function out of the finite type <code>two</code> by saying what the values should be on <code>a</code> and <code>b</code>. Equivalently, you prove a theorem about all terms of type <code>two</code> by proving it for <code>a</code> and proving it for <code>b</code>.</p>



<a name="177092045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177092045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Alan Thompson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177092045">(Oct 01 2019 at 20:01)</a>:</h4>
<p>Okay, so thats saying youre making a new type called two and that a and b are the only things of type two?</p>



<a name="177092122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177092122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Alan Thompson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177092122">(Oct 01 2019 at 20:02)</a>:</h4>
<p>And if you added a function as well as the a and b then that would be another way of making a thing of type two?</p>



<a name="177092246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177092246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Alan Thompson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177092246">(Oct 01 2019 at 20:03)</a>:</h4>
<p>So with the empty type you simply give no constructors and so to prove anything about terms of the empty type you dont need to do anything at all?</p>



<a name="177092395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177092395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Alan Thompson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177092395">(Oct 01 2019 at 20:04)</a>:</h4>
<p>If thats right then I feel like im getting it, but I dont quite get how that lets you create a function from false to anything at all</p>



<a name="177092482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177092482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177092482">(Oct 01 2019 at 20:05)</a>:</h4>
<p>In order to create a function from A to B, you need to explain where each element of A should go. If there is no element in A then you're done.</p>



<a name="177092488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177092488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177092488">(Oct 01 2019 at 20:05)</a>:</h4>
<blockquote>
<p>Okay, so thats saying youre making a new type called two and that a and b are the only things of type two?</p>
</blockquote>
<p>Yep, exactly. <code>a</code> and <code>b</code> are both constructors of the new type <code>two</code>. The constructors or an inductive type are surjective, meaning any term <code>t : two</code> must be either <code>a</code> or <code>b</code>. They're also injective, meaning <code>a â  b</code> (unless <code>two</code> is a <code>Prop</code>, but that's another rabbit hole).</p>



<a name="177092797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177092797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Alan Thompson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177092797">(Oct 01 2019 at 20:09)</a>:</h4>
<blockquote>
<p>In order to create a function from A to B, you need to explain where each element of A should go. If there is no element in A then you're done.</p>
</blockquote>
<p>That makes sence - when doing the false.elim itll create a function from false to whatever im tryin to prove by going through all the possible things which could be false, then realise there are none becasue theres no constructors and so create the function without a problem</p>



<a name="177093068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177093068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Alan Thompson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177093068">(Oct 01 2019 at 20:11)</a>:</h4>
<blockquote>
<p>Yep, exactly. <code>a</code> and <code>b</code> are both constructors of the new type <code>two</code>. The constructors or an inductive type are surjective, meaning any term <code>t : two</code> must be either <code>a</code> or <code>b</code>. They're also injective, meaning <code>a â  b</code> (unless <code>two</code> is a <code>Prop</code>, but that's another rabbit hole).</p>
</blockquote>
<p>How is = even defined for a and b? is it just part of an inductive type that it defines what = means for terms of the type?</p>



<a name="177093639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177093639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Alan Thompson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177093639">(Oct 01 2019 at 20:16)</a>:</h4>
<p>Also are they any other ways to define types other than by using inductive types?</p>



<a name="177093755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177093755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177093755">(Oct 01 2019 at 20:17)</a>:</h4>
<p>Heh, that's another rabbit hole. Have you read any of Theorem Proving in Lean? (<a href="https://leanprover.github.io/theorem_proving_in_lean/" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/">https://leanprover.github.io/theorem_proving_in_lean/</a>) Short answer, <code>=</code> is a family of inductive propositions, but that might not mean much to you. It's discussed there in chapter 7.</p>



<a name="177094014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20of%20the%20empty%20type%3F/near/177094014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Alan Thompson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20of.20the.20empty.20type.3F.html#177094014">(Oct 01 2019 at 20:20)</a>:</h4>
<p>Haha youre right about it not meaning much. I have had a breif look at it, ill be sure to look at chapter 7 for that explanation</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Transport.20along.20identity.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html">Transport along identity</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="273193133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273193133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273193133">(Feb 25 2022 at 06:21)</a>:</h4>
<p>Hey! Short question: In MLTT, you can pretty much by definition get a map <code>A -&gt; B</code> from equality <code>A = B</code>. Am I right that this is not possible in lean due to <code>eq</code> living in <code>Prop</code> ? Is there an analogous non propositional identity allowing for such transport?</p>



<a name="273194743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273194743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273194743">(Feb 25 2022 at 06:54)</a>:</h4>
<p>Also, how much sense does it make to interpret inductive types defined as living in <code>Prop</code> to be "propositionally truncated" (in the HoTT sense): You first assume your newly defined inductive type to live in whichever large enough universe it would fit, and then take the propositional truncation, which means that (1) your type is now a <code>Prop</code>; and (2) the only way to get _out_ of this type is by mapping to a <code>Prop</code>.</p>



<a name="273200683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273200683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273200683">(Feb 25 2022 at 08:32)</a>:</h4>
<p>You do get <code>A -&gt; B</code> from <code>A = B</code>, see <a href="https://leanprover-community.github.io/mathlib_docs/find/cast">docs#cast</a>. Essentially, <code>eq</code> is an inductive type family with a fully general elimination rule . And <em>also</em>, separately from this, it is a proposition. You're right that for general inductive types, like <code>nat</code>, it wouldn't make sense to both make it a proposition and allow elimination into non-propositions. But it makes sense for some inductive types, including <code>eq</code>. I believe the technical term is "syntactic subsingleton".</p>



<a name="273200938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273200938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273200938">(Feb 25 2022 at 08:35)</a>:</h4>
<p>It is called "large elimination" or "subsingleton elimination" in <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">#leantt</a> . Certain propositional inductive types have a recursor targeting all universes, if they meet a syntactic criterion for being a subsingleton</p>



<a name="273200997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273200997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273200997">(Feb 25 2022 at 08:36)</a>:</h4>
<p>important examples of this are <a href="https://leanprover-community.github.io/mathlib_docs/find/false">docs#false</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/and">docs#and</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/eq">docs#eq</a>, and <a href="https://leanprover-community.github.io/mathlib_docs/find/acc">docs#acc</a></p>



<a name="273201455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273201455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273201455">(Feb 25 2022 at 08:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/113489-new-members/topic/Transport.20along.20identity/near/273194743">said</a>:</p>
<blockquote>
<p>Also, how much sense does it make to interpret inductive types defined as living in <code>Prop</code> to be "propositionally truncated" (in the HoTT sense): You first assume your newly defined inductive type to live in whichever large enough universe it would fit, and then take the propositional truncation, which means that (1) your type is now a <code>Prop</code>; and (2) the only way to get _out_ of this type is by mapping to a <code>Prop</code>.</p>
</blockquote>
<p>This "squash" elaboration of inductive types is explicitly worked out in the "reduction to W-types" chapter of <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">#leantt</a> . The short answer is: except for large eliminating types, this is a correct model for how the inductives work. The "squash to <code>Prop</code>" operator in lean is <a href="https://leanprover-community.github.io/mathlib_docs/find/nonempty">docs#nonempty</a> . For large eliminating types, you need a separate encoding which writes them in terms of <code>eq</code> and <code>acc</code> to preserve the large eliminating behavior</p>



<a name="273322749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273322749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273322749">(Feb 26 2022 at 06:45)</a>:</h4>
<p>Thanks! <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">#leantt</a> is quite a bit more technical than what I can easily digest, but I think i'm slowly getting the gist of it. If I'm not mistaken, inductive families as used in lean were introduced by Dybjer first; is this "subsingleton elimination" thing a "patch" added later on or did he introduce it at the same time?</p>



<a name="273338646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273338646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273338646">(Feb 26 2022 at 12:45)</a>:</h4>
<p>Two more questions if I may:<br>
1) Taking this view of "Propositional inductive types as propositionally truncated": can I expand the analogy to say that "subsingleton elimination" should be interpreted as the inductive type _already_ being a proposition? It at least makes sense intuitively for <code>and</code> and <code>eq</code>, since I think lean has UIP and <code>and</code> preserves the property of being a proposition/subsingleton.<br>
2) Am I correct that any inductive (indexed?) type (family?) can be encoded in terms of W types + equality? It seems to be the case from your paper, but you also mention <code>acc</code>, which I don't exactly understand.</p>



<a name="273353026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273353026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nathaniel Yazdani <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273353026">(Feb 26 2022 at 17:36)</a>:</h4>
<p>I think that (1) is true, but I'm honestly not sure where/when subsingleton elimination was introduced.</p>
<p>As for (2), Dybjer's original work actually presented two equivalent schema for inductive type families: the nowadays standard form ("generalized inductive type families") where each constructor _computes_ its type indices from arguments and an alternative form ("restricted inductive type families") where each constructor _constrains_ its type indices with equality arguments. As a caveat, W-types aren't _quite_ enough to get the proof theory of inductive type families, unless you have functional extensionality.</p>



<a name="273353325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273353325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273353325">(Feb 26 2022 at 17:43)</a>:</h4>
<p>Would you happen to know of a resource explaining/comparing the two approaches (and this W-type not being enough problem)?</p>



<a name="273356607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273356607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nathaniel Yazdani <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273356607">(Feb 26 2022 at 18:54)</a>:</h4>
<p>The only comparison that I can recommend is the introduction of <a href="http://www.cse.chalmers.se/~peterd/papers/Indexed_IR.pdf">this paper from Dybjer</a>, although the rest of the paper is in the more complicated context of inductive-recursive definitions rather than just inductive definitions, <em>i.e.</em>, inductive type families. (Btw, this paper was probably what I was remembering in my previous comment; now i'm unsure whether there is a single Dybjer paper that presents inductive type families with both "computed indices" and "constrained indices.") </p>
<p>As for W-types, <a href="http://www.cse.chalmers.se/~peterd/papers/Setsem_Inductive.pdf">this other Dybjer paper</a> gives a rather concise explanation of why W-types cannot perfectly encode inductive types (as the root problem is the same for inductive type families).</p>



<a name="273357678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273357678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nathaniel Yazdani <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273357678">(Feb 26 2022 at 19:12)</a>:</h4>
<p>oh, <a href="https://mazzo.li/epilogue/index.html%3Fp=324.html">this blog post by Conor McBride</a> is an even better explanation of how W-types and equality relate in dependent type theory!</p>



<a name="273388232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273388232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273388232">(Feb 27 2022 at 07:25)</a>:</h4>
<p>There is also a chapter on reduction to W-types in my thesis <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">#leantt</a> . The short answer is that you can use plain W-types as long as you have eta for structures or the restricted version, eta for pairs and ulift. (Without this, you can get by with indexed W-types.) Also large eliminating props need a different encoding using acc, which is in some sense the equivalent of W for props.</p>



<a name="273388582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273388582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273388582">(Feb 27 2022 at 07:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/113489-new-members/topic/Transport.20along.20identity/near/273322749">said</a>:</p>
<blockquote>
<p>If I'm not mistaken, inductive families as used in lean were introduced by Dybjer first; is this "subsingleton elimination" thing a "patch" added later on or did he introduce it at the same time?</p>
</blockquote>
<p>I'm also not sure who introduced subsingleton elimination or its reasonable-but-complex rules for validity. It's not in the Dybjer papers that lean cites, and deals essentially with the interaction between inductive types and the impredicative and proof-irrelevant <code>Prop</code> universe, which as I understand it was introduced to address some perceived deficiencies in the Coq model (which were later also added to Coq in the form of the <code>SProp</code> universe). Perhaps <span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> might know?</p>



<a name="273404101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273404101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273404101">(Feb 27 2022 at 13:38)</a>:</h4>
<p>Sorry for hijacking this thread, but I'm trying to understand <code>ite</code>, and this is close enough to be related I guess… In the code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">dif_pos</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">decidable</span> <span class="n">c</span><span class="o">]</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">c</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">dite</span> <span class="n">c</span> <span class="n">t</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">t</span> <span class="n">hc</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">h</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">is_true</span> <span class="n">hc</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">is_false</span> <span class="n">hnc</span><span class="o">)</span> <span class="o">:=</span> <span class="n">absurd</span> <span class="n">hc</span> <span class="n">hnc</span>
<span class="kd">end</span>
</code></pre></div>
<p>is it true that we can make use of <code>rfl</code> because <code>c</code> is a <code>Prop</code>, hence a subsingleton? As I see it, if <code>c</code> was a type with more than one element, it wouldn't necessary be the case that the <code>hc</code> of <code>is_true hc</code> is the same as the <code>hc</code> given as a parameter, hence the resulting <code>then</code> branch would maybe result in something different. Am I mistaken?</p>



<a name="273404545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273404545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273404545">(Feb 27 2022 at 13:47)</a>:</h4>
<p>That's correct. The <code>hc</code> in the match is only defeq to the <code>hc</code> passed to the theorem because of proof irrelevance</p>



<a name="273404596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273404596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273404596">(Feb 27 2022 at 13:48)</a>:</h4>
<p>Ah, <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">#leantt</a>, last rule of p. 6! Prop is "judgementally a subsingleton"</p>



<a name="273404611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273404611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273404611">(Feb 27 2022 at 13:49)</a>:</h4>
<p>Thanks a lot, it's nice when things seem to get into place :)</p>



<a name="273404613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273404613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273404613">(Feb 27 2022 at 13:49)</a>:</h4>
<p>also illustrated by <a href="https://leanprover-community.github.io/mathlib_docs/find/proof_irrel/src">src#proof_irrel</a></p>



<a name="273404774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273404774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273404774">(Feb 27 2022 at 13:52)</a>:</h4>
<p>I'm looking at the proof that left inverses behave well assuming choice and all (last part of <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a>) and the combination of it all seems quite magic.</p>



<a name="273404788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273404788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273404788">(Feb 27 2022 at 13:52)</a>:</h4>
<p>lowercase: <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a></p>



<a name="273406720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273406720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273406720">(Feb 27 2022 at 14:34)</a>:</h4>
<p>(deleted)</p>



<a name="273406752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273406752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273406752">(Feb 27 2022 at 14:35)</a>:</h4>
<p>(deleted)</p>



<a name="273410094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273410094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273410094">(Feb 27 2022 at 15:46)</a>:</h4>
<blockquote>
<p>Perhaps Jeremy Avigad might know?</p>
</blockquote>
<p>I am afraid I don't. When I first learned Coq in 2009, Russell O'Connor told me about singleton elimination, and explained how using it with a well-founded predicate can be used to do a search for a natural number satisfying a decidable predicate. Google turned up this: <a href="https://coq.inria.fr/library/Coq.Logic.ConstructiveEpsilon.html">https://coq.inria.fr/library/Coq.Logic.ConstructiveEpsilon.html</a>. </p>
<p>But as as already been noted, subsingleton elimination is implicitly used to justify the elimination rule for equality. The rules for equality types, in the predicate setting, go back to Martin-Löf's formulations of type theory in the 1970s (<a href="https://ncatlab.org/nlab/show/identity+type">https://ncatlab.org/nlab/show/identity+type</a>). I don't really know the history of how equality type was first formulated as an inductive type in the impredicative setting and linked to subsingleton elimination. This 1989 paper by Pfenning and Paulin-Mohring describes equality as an inductive type, but I don't see any elimination rules: <a href="https://www.cs.cmu.edu/~fp/papers/mfps89.pdf">https://www.cs.cmu.edu/~fp/papers/mfps89.pdf</a>. This paper by Coquand and Paulin-Mohring from around the same time mentions the need to restrict elimination from Prop, but I don't see any mention of equality or subsingleton elimination: <a href="http://david.darais.com/assets/Inductively_Defined_Types--Coquand+Paulin.pdf">http://david.darais.com/assets/Inductively_Defined_Types--Coquand+Paulin.pdf</a>. Section 3.3 of the 1993 paper give the inductive characterizations of Acc and Eq, it it seems that they only eliminate to Prop: <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.32.5387&amp;rep=rep1&amp;type=pdf">https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.32.5387&amp;rep=rep1&amp;type=pdf</a>,</p>
<p>There is a lot of history here: <a href="https://coq.inria.fr/refman/history.html">https://coq.inria.fr/refman/history.html</a>. (Search in "inductive" "Paulin" "equality" etc.). There is the following note regarding version 7.3, which was released in the early 2000s:</p>
<p>"Changes in the allowed elimination sorts for certain class of inductive definitions : an inductive definition without constructors of Sort Prop can be eliminated on sorts Set and Type A "singleton" inductive definition (one constructor with arguments in the sort Prop like conjunction of two propositions or equality) can be eliminated directly on sort Type (In V7.2, only the sorts Prop and Set were allowed)."</p>
<p>This might be what we are looking for: one of the first documented instances of using a subsingleton argument to justify elimination from Prop to Type.</p>



<a name="273776715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273776715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273776715">(Mar 02 2022 at 09:17)</a>:</h4>
<p>Another thing: In the sources, I see</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">cast_eq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">cast</span> <span class="n">h</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>which I understand to be true since <code>h</code> is defeq to <code>eq.refl  α</code>, so that casting "along <code>h</code>" is defeq equal to casting "along <code>eq.refl  α</code>", which I want to be equal to the identity. But why exactly is that last claim true? In my "HoTT book understanding", transport is defined using <code>J</code> and the base case is exactly what we need. But here I'm not sure.</p>



<a name="273776861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273776861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273776861">(Mar 02 2022 at 09:18)</a>:</h4>
<p>Lean has proof-irrelevance: since <code>eq</code> is a <code>Prop</code>, every proof of equality is automatically defeq to <code>rfl</code>.</p>



<a name="273777194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273777194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273777194">(Mar 02 2022 at 09:21)</a>:</h4>
<p>But that only covers the fact that <code>h</code> is defeq to <code>rfl</code>, doesn't it? I still have to provide a term of the form <code>cast h a = a</code>.</p>



<a name="273779273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273779273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273779273">(Mar 02 2022 at 09:39)</a>:</h4>
<p>In lean if <code>P : Prop</code> and <code>h1 : P</code> and <code>h2 : P</code> then <code>h1 = h2</code> and the proof is <code>rfl</code>. This is very much not like HoTT.</p>



<a name="273779404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273779404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273779404">(Mar 02 2022 at 09:40)</a>:</h4>
<p><code>cast h a</code> unfolds to <code>eq.rec h a</code> or similar, which as you remark is the same as <code>eq.rec rfl a</code>; and recursors unfold definitionally on constructors</p>



<a name="273786919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273786919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273786919">(Mar 02 2022 at 10:46)</a>:</h4>
<p>Ah, I see what I got wrong: The equality type is "based" in lean, contrary to, say agda (or at least the one I know of), which I didn't take into account.</p>



<a name="273790343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273790343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273790343">(Mar 02 2022 at 11:12)</a>:</h4>
<p>I think the term is "indexed" rather than "based". In any case, is <code>eq</code> implemented this way to allow subsingleton elimination, or am I off-base here?</p>



<a name="273791210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273791210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273791210">(Mar 02 2022 at 11:21)</a>:</h4>
<p>The "based" formulation of <code>eq</code> seems strictly better than the other version, I don't see any downside to it. I assume you are asking why it is defined as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">eq</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">eq</span> <span class="n">a</span>
</code></pre></div>
<p>rather than</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">eq'</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">eq'</span> <span class="n">a</span> <span class="n">a</span>
</code></pre></div>



<a name="273791362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273791362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273791362">(Mar 02 2022 at 11:22)</a>:</h4>
<p>This makes a difference in the recursors:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">eq.rec</span>
<span class="c1">-- protected eliminator eq.rec : Π {α : Sort u} {a : α} {motive : α → Sort l},</span>
<span class="c1">--   motive a → Π {x : α}, a = x → motive x</span>

<span class="k">#print</span> <span class="n">eq'.rec</span>
<span class="c1">-- protected eliminator eq'.rec : Π {α : Sort u_1} {motive : α → α → Sort l},</span>
<span class="c1">--   (Π (a : α), motive a a) → Π {x y : α}, eq' x y → motive x y</span>
</code></pre></div>



<a name="273791428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273791428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273791428">(Mar 02 2022 at 11:22)</a>:</h4>
<p>In order to use the second one, you need both sides of the equality to be variables; in the first one only the RHS has to be a variable</p>



<a name="273791474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273791474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273791474">(Mar 02 2022 at 11:23)</a>:</h4>
<p>You can prove them equivalent, of course, but the first one is easier to use directly</p>



<a name="273791964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273791964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273791964">(Mar 02 2022 at 11:26)</a>:</h4>
<p>So, nothing to do with subsingleton elimination?</p>



<a name="273792119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273792119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273792119">(Mar 02 2022 at 11:28)</a>:</h4>
<p>they are both subsingleton eliminators, which you can tell above by noting that both versions live in <code>Prop</code> and yet have a motive that targets <code>Sort l</code></p>



<a name="273792568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273792568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273792568">(Mar 02 2022 at 11:31)</a>:</h4>
<p>Also, since you're here: </p>
<ol>
<li>Why is <code>eq</code> defined with <code>| refl [] : eq a</code>; why the <code>[]</code> ?</li>
<li>Defining a type <code>eq2</code> which is exactly the same as <code>eq</code> and then <br>
<code>def tr {α : Sort*} {P : α → Sort*} {a b : α} (p : Eq2 a  b) (x : P a) : P b := @eq2.rec α a P x b p</code><br>
  , I get an error: <br>
<code>``failed to generate bytecode for 'tr' code generation failed, inductive predicate 'eq2' is not supported</code>  <br>
  Does that mean <code>eq</code> has some built-in stuff to it?</li>
</ol>



<a name="273792758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273792758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273792758">(Mar 02 2022 at 11:32)</a>:</h4>
<ol>
<li>Compare with and without <code>[]</code>:</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">inductive</span> <span class="n">eq'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">eq'</span> <span class="n">a</span>

<span class="k">#print</span> <span class="n">eq.refl</span>
<span class="c1">-- constructor eq.refl : ∀ {α : Sort u} (a : α), a = a</span>
<span class="k">#print</span> <span class="n">eq'.refl</span>
<span class="c1">-- constructor eq'.refl : ∀ {α : Sort u} {a : α}, eq' a a</span>
</code></pre></div>



<a name="273792817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273792817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273792817">(Mar 02 2022 at 11:33)</a>:</h4>
<p><code>refl</code> with an implicit <code>a</code> argument is also useful, we call it <code>rfl</code>, but for historical reasons that's not the constructor</p>



<a name="273792956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273792956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273792956">(Mar 02 2022 at 11:34)</a>:</h4>
<p>Note that <code>[]</code> used to be the default and <code>{}</code> was not; the default got switched at one point and so <code>eq.refl</code> got a <code>[]</code> to avoid breakage</p>



<a name="273793022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273793022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273793022">(Mar 02 2022 at 11:35)</a>:</h4>
<p>Hum, the only difference I see is <code>eq' a a</code> vs <code>a = a</code>, which I take to be pretty printing. Am I missing something?</p>



<a name="273793188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273793188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273793188">(Mar 02 2022 at 11:36)</a>:</h4>
<p>the braces around <code>a</code></p>



<a name="273793237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273793237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273793237">(Mar 02 2022 at 11:36)</a>:</h4>
<p>ah, right, sorry!</p>



<a name="273793241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273793241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273793241">(Mar 02 2022 at 11:36)</a>:</h4>
<ol start="2">
<li>Yes, inductive predicates could be supported but almost all large eliminating props are written in terms of <code>eq</code> and <code>acc</code> in practice, so the current implementation skimps out and just implements code generation manually on these two types</li>
</ol>



<a name="273793423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273793423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273793423">(Mar 02 2022 at 11:38)</a>:</h4>
<p>there are three other large eliminating predicates in lean: <code>true</code>, <code>false</code>, and <code>and</code>. <code>true.rec</code> is totally useless and never used, <code>false.rec</code> is deliberately unimplemented since it's impossible to call, and <code>and.rec</code>... not sure</p>



<a name="273793527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273793527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273793527">(Mar 02 2022 at 11:39)</a>:</h4>
<p>looks like <code>and.rec</code> works too</p>



<a name="273793774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273793774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273793774">(Mar 02 2022 at 11:40)</a>:</h4>
<p>Actually, </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="kd">inductive</span> <span class="n">eq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
  <span class="bp">|</span> <span class="n">refl</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">eq</span> <span class="n">a</span>
</code></pre></div>
<p>is trippy to read, since the <code>eq a</code> in the second line really is more like <code>eq a a</code>.</p>



<a name="273793822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273793822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273793822">(Mar 02 2022 at 11:41)</a>:</h4>
<p>Iirc, that's because the index is not needed in the constructors.</p>



<a name="273793847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273793847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273793847">(Mar 02 2022 at 11:41)</a>:</h4>
<p>Lean 4 addresses this by making the parameters required to write but must be the same as the inputs</p>



<a name="273793880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273793880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273793880">(Mar 02 2022 at 11:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Thanks a lot for the patient explanations :)</p>



<a name="273803977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273803977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273803977">(Mar 02 2022 at 13:15)</a>:</h4>
<p>Does the "large" in "large eliminating" mean into <code>Sort u</code> vs <code>Type</code>?</p>



<a name="273804133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transport%20along%20identity/near/273804133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transport.20along.20identity.html#273804133">(Mar 02 2022 at 13:17)</a>:</h4>
<p>I think <code>Sort u</code> vs <code>Prop</code>, rather.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/refactoring.20proofs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html">refactoring proofs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="279623483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279623483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279623483">(Apr 21 2022 at 01:02)</a>:</h4>
<p>I have a proof that compiles but takes a while to do so. What tricks can I use to refactor the proof to make it as "minimal" as possible? Here is the proof (the last lemma):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.tensor_product</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">tensor_product</span>
<span class="n">open_locale</span> <span class="n">polynomial</span>
<span class="kn">open</span> <span class="n">algebra.tensor_product</span>
<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">assoc_symm_tmul</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">B</span><span class="o">]</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">algebra.tensor_product.assoc</span> <span class="n">R</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">a</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">c</span><span class="o">))</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">b</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply_fun</span> <span class="o">(</span><span class="n">algebra.tensor_product.assoc</span> <span class="n">R</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">assoc_tmul</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">alg_equiv.apply_symm_apply</span> <span class="o">(</span><span class="n">algebra.tensor_product.assoc</span> <span class="n">R</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">c</span><span class="o">)),</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">function.injective</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- noncomputable def counit : K[X] →ₐ[K] K := polynomial.aeval 0</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">comul</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="o">((</span><span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span><span class="o">))</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comul_1</span> <span class="o">:</span> <span class="n">comul</span> <span class="n">K</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">alg_hom.map_one</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">),</span> <span class="c1">-- ⊢ 1 = 1 ⊗ₜ[K] 1</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comul_X</span> <span class="o">:</span> <span class="n">comul</span> <span class="n">K</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">comul</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">aeval_X</span><span class="o">,</span>
<span class="kd">end</span>


<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">map1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="o">(</span><span class="n">algebra.tensor_product.assoc</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">symm.to_alg_hom.comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">))</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">map2</span> <span class="o">:</span> <span class="o">(</span><span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">)</span> <span class="o">:=</span>  <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span>
<span class="bp">.</span> <span class="c1">-- this tells Lean not to recompile definitions</span>


<span class="kd">lemma</span> <span class="n">coassoc</span> <span class="o">:</span> <span class="n">map1</span> <span class="n">K</span> <span class="bp">=</span> <span class="n">map2</span> <span class="n">K</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">P1</span> <span class="o">:</span> <span class="n">map1</span> <span class="n">K</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">map1</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">tensor_product.tmul_add</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">],</span>

  <span class="k">have</span> <span class="n">P2</span> <span class="o">:</span> <span class="n">map2</span> <span class="n">K</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">map2</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">tensor_product.add_tmul</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">comul_X</span><span class="o">,</span> <span class="n">_root_.map_add</span><span class="o">,</span> <span class="n">map_tmul</span><span class="o">,</span> <span class="n">alg_hom.coe_id</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">comul_1</span><span class="o">],</span>

  <span class="n">ext</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">P1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">P2</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279623894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279623894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279623894">(Apr 21 2022 at 01:09)</a>:</h4>
<p>I haven't played around with your file at all, but <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#squeeze_simp%20/%20squeeze_simpa%20/%20squeeze_dsimp%20/%20squeeze_scope">squeeze_simp</a> is helpful, and <code>set_option profiler true</code> can help determine where Lean is spending its time. You can also comment out portions of proofs (or use <code>sorry</code>), especially if you use tactic blocks.</p>
<p>For example, you can (temporarily) skip the proofs of the two have statements as follows (I think you need Lean 3.41 or 3.42 for this). So if you can't speed up the proof enough, you can at least make it less painful to edit around the file.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">coassoc</span> <span class="o">:</span> <span class="n">map1</span> <span class="n">K</span> <span class="bp">=</span> <span class="n">map2</span> <span class="n">K</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">P1</span> <span class="o">:</span> <span class="n">map1</span> <span class="n">K</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span><span class="o">,</span>
  <span class="gr">sorry</span> <span class="o">{</span> <span class="n">unfold</span> <span class="n">map1</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">tensor_product.tmul_add</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">]</span> <span class="o">},</span>

  <span class="k">have</span> <span class="n">P2</span> <span class="o">:</span> <span class="n">map2</span> <span class="n">K</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span><span class="o">,</span>
  <span class="gr">sorry</span> <span class="o">{</span>  <span class="n">unfold</span> <span class="n">map2</span><span class="o">,</span>
     <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">tensor_product.add_tmul</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">comul_X</span><span class="o">,</span> <span class="n">_root_.map_add</span><span class="o">,</span> <span class="n">map_tmul</span><span class="o">,</span> <span class="n">alg_hom.coe_id</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">comul_1</span><span class="o">]</span> <span class="o">},</span>

  <span class="n">ext</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">P1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">P2</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279632421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279632421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279632421">(Apr 21 2022 at 03:44)</a>:</h4>
<p>I did not actually re-think proofs, I simply restructured the ones that you had and squeezed the simps, as Jireh also suggested.  The last proof still take ~2-3 secs, but the file compiles faster than before:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.tensor_product</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">tensor_product</span>
<span class="n">open_locale</span> <span class="n">polynomial</span>
<span class="kn">open</span> <span class="n">algebra.tensor_product</span>
<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">assoc_symm_tmul</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">B</span><span class="o">]</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">algebra.tensor_product.assoc</span> <span class="n">R</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">a</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">c</span><span class="o">))</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">b</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply_fun</span> <span class="o">(</span><span class="n">algebra.tensor_product.assoc</span> <span class="n">R</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">assoc_tmul</span><span class="o">,</span> <span class="n">alg_equiv.apply_symm_apply</span><span class="o">],</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">embedding_like.comp_injective</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="o">),</span>
<span class="kd">end</span>

<span class="c1">-- noncomputable def counit : K[X] →ₐ[K] K := polynomial.aeval 0</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">comul</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="o">((</span><span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span><span class="o">))</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comul_1</span> <span class="o">:</span> <span class="n">comul</span> <span class="n">K</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">map_one</span><span class="o">,</span> <span class="c1">-- ⊢ 1 = 1 ⊗ₜ[K] 1</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comul_X</span> <span class="o">:</span> <span class="n">comul</span> <span class="n">K</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">comul</span><span class="o">,</span> <span class="n">aeval_X</span><span class="o">]</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">map1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="o">(</span><span class="n">algebra.tensor_product.assoc</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">symm.to_alg_hom.comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">))</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">map2</span> <span class="o">:</span> <span class="o">(</span><span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">)</span> <span class="o">:=</span>  <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span>
<span class="bp">.</span> <span class="c1">-- this tells Lean not to recompile definitions</span>


<span class="kd">lemma</span> <span class="n">coassoc</span> <span class="o">:</span> <span class="n">map1</span> <span class="n">K</span> <span class="bp">=</span> <span class="n">map2</span> <span class="n">K</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">map1</span><span class="o">,</span> <span class="n">map2</span><span class="o">,</span> <span class="n">alg_equiv.to_alg_hom_eq_coe</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">,</span> <span class="n">alg_equiv.coe_alg_hom</span><span class="o">,</span>
    <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">comul_X</span><span class="o">,</span> <span class="n">map_tmul</span><span class="o">,</span> <span class="n">alg_hom.coe_id</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">comul_1</span><span class="o">,</span>
    <span class="n">tensor_product.tmul_add</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">assoc_symm_tmul</span><span class="o">,</span> <span class="n">tensor_product.add_tmul</span><span class="o">,</span> <span class="n">_root_.map_add</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279632444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279632444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279632444">(Apr 21 2022 at 03:45)</a>:</h4>
<p>Note that, placing <code>set_option profiler true</code> somewhere in your file gives you information about all the subsequent compilation times.</p>



<a name="279635774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279635774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279635774">(Apr 21 2022 at 04:47)</a>:</h4>
<p>I am using <code>set_option profiler true</code> as suggested and getting weird results. I have two lemmas that are exactly the same, with the same exact proof except that I give one a little more information. And the one I give more information takes 16 times longer! See the code below</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.tensor_product</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">tensor_product</span>
<span class="n">open_locale</span> <span class="n">polynomial</span>
<span class="kn">open</span> <span class="n">algebra.tensor_product</span>
<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">comul</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="o">((</span><span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span><span class="o">))</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comul_1</span> <span class="o">:</span> <span class="n">comul</span> <span class="n">K</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:=</span> <span class="c1">-- elaboration of comul_1 took 4.18s</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">alg_hom.map_one</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">),</span> <span class="c1">-- ⊢ 1 = 1 ⊗ₜ[K] 1</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comul_1'</span> <span class="o">:</span> <span class="n">comul</span> <span class="n">K</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:=</span> <span class="c1">-- elaboration of comul_1' took 189ms</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">alg_hom.map_one</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279636705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279636705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279636705">(Apr 21 2022 at 05:04)</a>:</h4>
<p>Also, doing something as simple as the following takes 3 seconds! This seems way too long, especially with all the types annotated</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.tensor_product</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">tensor_product</span>
<span class="n">open_locale</span> <span class="n">polynomial</span>
<span class="kn">open</span> <span class="n">algebra.tensor_product</span>
<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">comul</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="o">((</span><span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span><span class="o">))</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">map2</span> <span class="o">:</span> <span class="o">(</span><span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">)</span> <span class="o">:=</span>  <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="c1">-- elaboration of map2 took 2.98s!</span>
</code></pre></div>



<a name="279636727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279636727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279636727">(Apr 21 2022 at 05:05)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> , your proofs compile much faster than mine. How did you know to change the things you changed to make it faster? For example, why is <code>rw alg_hom.map_one</code> faster than <code>rw alg_hom.map_one (comul K)</code>?</p>



<a name="279638949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279638949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279638949">(Apr 21 2022 at 05:46)</a>:</h4>
<p>Honestly, I do not know.  I <em>think</em> that hints are generally good, but sometimes they get Lean into trying to prove some defeq that you want, but it is able to find more quickly some other way.</p>
<p>I have observed similar patterns with <code>localization, mv_polynomial, monoid_algebra</code>.  I suspect that the implementation has several layers of defeqs and lean can get confused.</p>



<a name="279646551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279646551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279646551">(Apr 21 2022 at 07:45)</a>:</h4>
<p>Btw, on my computer (which is not particularly fast and is already over two years old), <code>map2</code> elaborates in approximately .5s.</p>
<p>The slowness on your computer might be due to the fact that you have changed also some files imported by this PR and Lean has to struggle with some incomplete/missing <code>olean</code>s.  Maybe...</p>



<a name="279660444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279660444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279660444">(Apr 21 2022 at 10:18)</a>:</h4>
<p>I would guess that <code>alg_hom.map_one (comul K)</code> is slower than <code>alg_hom.map_one</code> because the first one:</p>
<ul>
<li>Works out all the types for <code>comul</code></li>
<li>Tries to match up all those types in the goal state</li>
<li>Possibly has to unify defeq typeclass diamonds in doing so</li>
</ul>
<p>while the second one:</p>
<ul>
<li>Tries to match any <code>alg_hom</code> in the goal, and deduces the type of <code>comul</code> from there</li>
</ul>



<a name="279701396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279701396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279701396">(Apr 21 2022 at 16:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/refactoring.20proofs/near/279646551">said</a>:</p>
<blockquote>
<p>Btw, on my computer (which is not particularly fast and is already over two years old), <code>map2</code> elaborates in approximately .5s.</p>
<p>The slowness on your computer might be due to the fact that you have changed also some files imported by this PR and Lean has to struggle with some incomplete/missing <code>olean</code>s.  Maybe...</p>
</blockquote>
<p>Huh, this is much faster than on mine. How would I fix this issue with <code>olean</code>s you are referring to?</p>



<a name="279702277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279702277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279702277">(Apr 21 2022 at 16:11)</a>:</h4>
<p>I tried <code>leanproject build</code> but it did not improve the elaboration speed</p>



<a name="279716224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279716224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279716224">(Apr 21 2022 at 17:56)</a>:</h4>
<p>If leanproject built successfully your repository, then this should have taken care of the oleans... I'm not sure what explains the difference in performance, then.</p>



<a name="279755637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279755637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279755637">(Apr 22 2022 at 00:00)</a>:</h4>
<p>I have this proof, which is conceptually very simple: I have proof <code>coinv_left K</code> that two algebra maps are equal, and I want to prove that two set maps that happen to be set_maps of the algebra morphisms are equal (<code>coinv_left'</code>). It seems like it should be quite easy, maybe even just a <code>simp</code>. But I wasn't able to refactor the proof below to something more elegant. Any suggestions?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">coinv_left'</span> <span class="o">:</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">f'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">g'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">f'</span> <span class="bp">=</span> <span class="n">g'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">coinv_left</span> <span class="n">K</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">f'.to_fun</span> <span class="bp">=</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">),</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_hom.to_fun_eq_coe</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">g'.to_fun</span> <span class="bp">=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">),</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_hom.to_fun_eq_coe</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">h2</span><span class="o">,</span> <span class="bp">←</span> <span class="n">h3</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h1</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279755837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279755837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279755837">(Apr 22 2022 at 00:02)</a>:</h4>
<p>Here is the whole file:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.tensor_product</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">tensor_product</span>
<span class="n">open_locale</span> <span class="n">polynomial</span>
<span class="kn">open</span> <span class="n">algebra.tensor_product</span>
<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">assoc_symm_tmul</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">B</span><span class="o">]</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">algebra.tensor_product.assoc</span> <span class="n">R</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">a</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">c</span><span class="o">))</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">b</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply_fun</span> <span class="o">(</span><span class="n">algebra.tensor_product.assoc</span> <span class="n">R</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">assoc_tmul</span><span class="o">,</span> <span class="n">alg_equiv.apply_symm_apply</span><span class="o">],</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">algebra.tensor_product.assoc</span> <span class="n">R</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">injective</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">comul</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="o">((</span><span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span><span class="o">))</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comul_1</span> <span class="o">:</span> <span class="n">comul</span> <span class="n">K</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">alg_hom.map_one</span><span class="o">,</span> <span class="c1">-- ⊢ 1 = 1 ⊗ₜ[K] 1</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comul_X</span> <span class="o">:</span> <span class="n">comul</span> <span class="n">K</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">comul</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">aeval_X</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">counit</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="mi">0</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">counit_X</span> <span class="o">:</span> <span class="n">counit</span> <span class="n">K</span> <span class="n">X</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">counit</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">coe_aeval_eq_eval</span><span class="o">,</span> <span class="n">eval_X</span><span class="o">],</span>
<span class="kd">end</span>

<span class="bp">.</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">coinv</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="o">(</span><span class="bp">-</span><span class="n">X</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coinv_X</span> <span class="o">:</span> <span class="n">coinv</span> <span class="n">K</span> <span class="n">X</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">coinv</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">aeval_X</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">coinv_left</span> <span class="o">:</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">)</span> <span class="o">)</span><span class="bp">=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_hom.coe_comp</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">comul_X</span><span class="o">,</span> <span class="n">_root_.map_add</span><span class="o">,</span> <span class="n">map_tmul</span><span class="o">,</span> <span class="n">coinv_X</span><span class="o">,</span> <span class="n">alg_hom.coe_id</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">_root_.map_one</span><span class="o">,</span> <span class="n">lmul'_apply_tmul</span><span class="o">,</span> <span class="n">_root_.mul_one</span><span class="o">,</span> <span class="n">_root_.one_mul</span><span class="o">,</span> <span class="n">add_left_neg</span><span class="o">,</span> <span class="n">counit_X</span><span class="o">,</span> <span class="n">_root_.map_zero</span><span class="o">],</span>
<span class="kd">end</span>
<span class="bp">.</span>

<span class="kd">lemma</span> <span class="n">coinv_left'</span> <span class="o">:</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">f'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">g'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">f'</span> <span class="bp">=</span> <span class="n">g'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">coinv_left</span> <span class="n">K</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">f'.to_fun</span> <span class="bp">=</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">),</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_hom.to_fun_eq_coe</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">g'.to_fun</span> <span class="bp">=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">),</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_hom.to_fun_eq_coe</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">h2</span><span class="o">,</span> <span class="bp">←</span> <span class="n">h3</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h1</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279756295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279756295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279756295">(Apr 22 2022 at 00:08)</a>:</h4>
<p>Does beginning with <code>ext</code> or <code>funext</code> work better?</p>



<a name="279756679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279756679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279756679">(Apr 22 2022 at 00:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/refactoring.20proofs/near/279756295">said</a>:</p>
<blockquote>
<p>Does beginning with <code>ext</code> or <code>funext</code> work better?</p>
</blockquote>
<p>I think no, because it just gives me an arbitrary element x. I think I  instead  want to use the fact that the algebra maps are equal to imply that their set maps are equal. I came up with the following still-not-elegant proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">coinv_left'</span> <span class="o">:</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">calc</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">)</span>
        <span class="bp">=</span> <span class="o">((</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">)))</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_hom.to_fun_eq_coe</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">((</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">))</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">coinv_left</span><span class="o">]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_hom.to_fun_eq_coe</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">]</span>
</code></pre></div>



<a name="279756913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279756913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279756913">(Apr 22 2022 at 00:17)</a>:</h4>
<p>Since I only use <code>simp</code>s  in the <code>calc</code> block, I would expect this to work but it does not:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">coinv_left'</span> <span class="o">:</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">coinv_left</span><span class="o">,</span> <span class="n">alg_hom.to_fun_eq_coe</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">]</span>
</code></pre></div>



<a name="279757103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279757103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279757103">(Apr 22 2022 at 00:20)</a>:</h4>
<p>I am not sure if others agree, but I find it easier to work with "applied" functions, rather than non-applied ones, in Lean.</p>
<p>That was the reason for suggesting <code>funext</code>.  If it does not work, maybe this just means that this is the one time developing the API that you have to do something awkward... <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="279758374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279758374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279758374">(Apr 22 2022 at 00:38)</a>:</h4>
<p>I decided to change the definition of my class to require equality of algebra maps as opposed to set maps (even though mathematically it's equivalent). I had not realized that it is easier to prove equality of algebra maps than set maps...</p>



<a name="279758727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279758727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279758727">(Apr 22 2022 at 00:41)</a>:</h4>
<p>What should I do if <code>simp</code> works but <code>squeeze_simp</code> times out? I don't want to just keep <code>simp</code> there since it will always take a long time to compile. Instead I want to switch it to <code>simp only [...]</code>.</p>



<a name="279759118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279759118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279759118">(Apr 22 2022 at 00:42)</a>:</h4>
<p>I sometimes save the file with the <code>squeeze_simp</code> in, and the <code>lean --make &lt;path_to_file&gt;</code>.  This has a longer timeout threshold and will print the output.</p>



<a name="279759366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279759366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279759366">(Apr 22 2022 at 00:43)</a>:</h4>
<p>Also, if you can guess what <code>simp</code> will do first, you can try <code>simp only [your guesses], squeeze_simp</code>.</p>



<a name="279759637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279759637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279759637">(Apr 22 2022 at 00:44)</a>:</h4>
<p>What if my guesses include like 20 things and <code>simp only [my guesses]</code> solves it? How do I boil it down?</p>



<a name="279759915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279759915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279759915">(Apr 22 2022 at 00:45)</a>:</h4>
<p>If you squeeze the <code>simp only</code>, as in <code>squeeze_simp only [guesses]</code> also times out?</p>



<a name="279760166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279760166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279760166">(Apr 22 2022 at 00:46)</a>:</h4>
<p>(Anyways, if yes, I would go with the <code>lean --make</code> step)</p>



<a name="279760366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279760366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279760366">(Apr 22 2022 at 00:47)</a>:</h4>
<p>you can also mess with the timeout threshold on VSCode, but I usually prefer not to, since I want things to work quickly when I am proving stuff.</p>



<a name="279760454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279760454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279760454">(Apr 22 2022 at 00:48)</a>:</h4>
<p>You can always put a sorry before the simp, if you know that simp will close the goal and leave it there while you develop the rest of the proof/file.</p>



<a name="279762756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279762756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279762756">(Apr 22 2022 at 00:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/refactoring.20proofs/near/279759915">said</a>:</p>
<blockquote>
<p>If you squeeze the <code>simp only</code>, as in <code>squeeze_simp only [guesses]</code> also times out?</p>
</blockquote>
<p>yea</p>



<a name="279763565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279763565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279763565">(Apr 22 2022 at 00:59)</a>:</h4>
<p>I am also getting a timeout on something pretty unexpected. I include the full file below but only the last two instances and the lemma <code>coassoc</code> are important. My instance times out when I include <code>coassoc K</code> in it and does not time out otherwise. Does it mean I need to make <code>coassoc</code> run faster? If so how can I do it?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.tensor_product</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">tensor_product</span>
<span class="n">open_locale</span> <span class="n">polynomial</span>
<span class="kn">open</span> <span class="n">algebra.tensor_product</span>
<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">K</span><span class="o">]</span>


<span class="kd">variables</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">class</span> <span class="n">hopf_algebra</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">comul</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">V</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">counit</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span>
<span class="o">(</span><span class="n">coinv</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">coassoc</span> <span class="o">:</span> <span class="o">(</span><span class="n">algebra.tensor_product.assoc</span> <span class="n">K</span> <span class="n">V</span> <span class="n">V</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">to_alg_hom.comp</span> <span class="o">((</span><span class="n">map</span> <span class="n">comul</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">V</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span> <span class="n">comul</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">V</span><span class="o">)</span> <span class="n">comul</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">comul</span><span class="o">)</span>
<span class="o">(</span><span class="n">counit_left</span> <span class="o">:</span> <span class="o">(</span><span class="n">algebra.tensor_product.lid</span> <span class="n">K</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">to_alg_hom.comp</span> <span class="o">((</span><span class="n">map</span> <span class="n">counit</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">V</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span> <span class="n">comul</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">V</span><span class="o">))</span>
<span class="o">(</span><span class="n">counit_right</span> <span class="o">:</span> <span class="o">(</span><span class="n">algebra.tensor_product.rid</span> <span class="n">K</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">to_alg_hom.comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">V</span><span class="o">)</span> <span class="n">counit</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">comul</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">V</span><span class="o">))</span>
<span class="o">(</span><span class="n">coinv_right</span> <span class="o">:</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">V</span><span class="o">)</span> <span class="n">coinv</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">comul</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">counit</span><span class="o">)</span>
<span class="o">(</span><span class="n">coinv_left</span> <span class="o">:</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">((</span><span class="n">map</span> <span class="n">coinv</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">V</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span> <span class="n">comul</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">counit</span><span class="o">)</span>

<span class="c1">-- set_option profiler true -- time everything</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">comul</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="o">((</span><span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span><span class="o">))</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comul_1</span> <span class="o">:</span> <span class="n">comul</span> <span class="n">K</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">alg_hom.map_one</span><span class="o">,</span> <span class="c1">-- ⊢ 1 = 1 ⊗ₜ[K] 1</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comul_X</span> <span class="o">:</span> <span class="n">comul</span> <span class="n">K</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">X</span> <span class="bp">⊗ₜ</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">⊗ₜ</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">comul</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">aeval_X</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">coassoc</span> <span class="o">:</span>  <span class="o">(</span><span class="n">algebra.tensor_product.assoc</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">to_alg_hom.comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span> <span class="c1">-- TODO this still takes 10 seconds to elaborate</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">algebra.tensor_product.assoc_tmul</span><span class="o">,</span> <span class="n">alg_equiv.to_alg_hom_eq_coe</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">,</span> <span class="n">alg_equiv.coe_alg_hom</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">comul_X</span><span class="o">,</span> <span class="n">map_tmul</span><span class="o">,</span> <span class="n">alg_hom.coe_id</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">comul_1</span><span class="o">,</span> <span class="n">tensor_product.tmul_add</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">tensor_product.add_tmul</span><span class="o">,</span> <span class="n">_root_.map_add</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">counit</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="mi">0</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">counit_X</span> <span class="o">:</span> <span class="n">counit</span> <span class="n">K</span> <span class="n">X</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">counit</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">coe_aeval_eq_eval</span><span class="o">,</span> <span class="n">eval_X</span><span class="o">],</span>
<span class="kd">end</span>

<span class="bp">.</span>

<span class="kd">lemma</span> <span class="n">counit_left</span> <span class="o">:</span> <span class="o">(</span><span class="n">algebra.tensor_product.lid</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">to_alg_hom.comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">counit</span><span class="o">,</span> <span class="n">alg_equiv.to_alg_hom_eq_coe</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">,</span> <span class="n">alg_equiv.coe_alg_hom</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">comul_X</span><span class="o">,</span> <span class="n">_root_.map_add</span><span class="o">,</span> <span class="n">map_tmul</span><span class="o">,</span> <span class="n">coe_aeval_eq_eval</span><span class="o">,</span> <span class="n">eval_X</span><span class="o">,</span> <span class="n">tensor_product.zero_tmul</span><span class="o">,</span> <span class="n">eval_one</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">lid_tmul</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">counit_right</span> <span class="o">:</span> <span class="o">(</span><span class="n">algebra.tensor_product.rid</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">to_alg_hom.comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">counit</span><span class="o">,</span> <span class="n">alg_equiv.to_alg_hom_eq_coe</span><span class="o">,</span> <span class="n">alg_hom.coe_comp</span><span class="o">,</span> <span class="n">alg_equiv.coe_alg_hom</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">comul_X</span><span class="o">,</span> <span class="n">_root_.map_add</span><span class="o">,</span> <span class="n">map_tmul</span><span class="o">,</span> <span class="n">coe_aeval_eq_eval</span><span class="o">,</span> <span class="n">eval_one</span><span class="o">,</span> <span class="n">eval_X</span><span class="o">,</span> <span class="n">tensor_product.tmul_zero</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">,</span> <span class="n">rid_tmul</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">coinv</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="o">(</span><span class="bp">-</span><span class="n">X</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coinv_X</span> <span class="o">:</span> <span class="n">coinv</span> <span class="n">K</span> <span class="n">X</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">coinv</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">aeval_X</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">coinv_right</span> <span class="o">:</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_hom.coe_comp</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">comul_X</span><span class="o">,</span> <span class="n">_root_.map_add</span><span class="o">,</span> <span class="n">map_tmul</span><span class="o">,</span> <span class="n">alg_hom.coe_id</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">_root_.map_one</span><span class="o">,</span> <span class="n">coinv_X</span><span class="o">,</span> <span class="n">lmul'_apply_tmul</span><span class="o">,</span> <span class="n">_root_.mul_one</span><span class="o">,</span> <span class="n">_root_.one_mul</span><span class="o">,</span> <span class="n">add_right_neg</span><span class="o">,</span> <span class="n">counit_X</span><span class="o">,</span> <span class="n">_root_.map_zero</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">coinv_left</span> <span class="o">:</span> <span class="o">(</span><span class="n">lmul'</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">((</span><span class="n">map</span> <span class="o">(</span><span class="n">coinv</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">comul</span> <span class="n">K</span><span class="o">)</span> <span class="o">)</span><span class="bp">=</span> <span class="o">(</span><span class="n">algebra.of_id</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">counit</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_hom.coe_comp</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">comul_X</span><span class="o">,</span> <span class="n">_root_.map_add</span><span class="o">,</span> <span class="n">map_tmul</span><span class="o">,</span> <span class="n">coinv_X</span><span class="o">,</span> <span class="n">alg_hom.coe_id</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">_root_.map_one</span><span class="o">,</span> <span class="n">lmul'_apply_tmul</span><span class="o">,</span> <span class="n">_root_.mul_one</span><span class="o">,</span> <span class="n">_root_.one_mul</span><span class="o">,</span> <span class="n">add_left_neg</span><span class="o">,</span> <span class="n">counit_X</span><span class="o">,</span> <span class="n">_root_.map_zero</span><span class="o">],</span>
<span class="kd">end</span>
<span class="bp">.</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span> <span class="c1">-- time everything</span>

<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">polynomial_hopf</span> <span class="o">:</span> <span class="n">hopf_algebra</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="o">{</span> <span class="c1">-- TIMEOUT</span>
  <span class="n">comul</span> <span class="o">:=</span> <span class="n">comul</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">counit</span> <span class="o">:=</span> <span class="n">counit</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">coinv</span> <span class="o">:=</span> <span class="n">coinv</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">coassoc</span> <span class="o">:=</span> <span class="n">coassoc</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">counit_left</span> <span class="o">:=</span> <span class="n">counit_left</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">counit_right</span> <span class="o">:=</span> <span class="n">counit_right</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">coinv_right</span> <span class="o">:=</span> <span class="n">coinv_right</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">coinv_left</span> <span class="o">:=</span> <span class="n">coinv_left</span> <span class="n">K</span><span class="o">,</span>
<span class="o">}</span>

<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">polynomial_hopf</span> <span class="o">:</span> <span class="n">hopf_algebra</span> <span class="n">K</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="o">{</span> <span class="c1">-- elaboration of polynomial_hopf took 10.4s</span>
  <span class="n">comul</span> <span class="o">:=</span> <span class="n">comul</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">counit</span> <span class="o">:=</span> <span class="n">counit</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">coinv</span> <span class="o">:=</span> <span class="n">coinv</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">coassoc</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">counit_left</span> <span class="o">:=</span> <span class="n">counit_left</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">counit_right</span> <span class="o">:=</span> <span class="n">counit_right</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">coinv_right</span> <span class="o">:=</span> <span class="n">coinv_right</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">coinv_left</span> <span class="o">:=</span> <span class="n">coinv_left</span> <span class="n">K</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>



<a name="279764655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279764655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279764655">(Apr 22 2022 at 01:03)</a>:</h4>
<p>I did <code>lean --make src/polynomial_example.lean</code> and it did not tell me that it timed out. So I guess it compiled it fine? Here is the output:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">hopf_algebra</span> <span class="o">:</span><span class="n">User</span><span class="bp">\</span><span class="n">Github</span><span class="bp">\</span><span class="n">Hopf</span><span class="bp">\</span><span class="n">src</span><span class="bp">\</span><span class="n">Hopf.lean</span><span class="o">:</span> <span class="n">parsing</span> <span class="n">at</span> <span class="n">line</span> <span class="mi">18</span><span class="bp">←</span><span class="o">[</span><span class="mi">2</span><span class="n">K</span>
<span class="n">cumulative</span> <span class="n">profiling</span> <span class="n">times</span><span class="o">:</span>
        <span class="n">compilation</span> <span class="mi">0</span><span class="bp">.</span><span class="mi">0022</span><span class="n">ms</span>
        <span class="n">decl</span> <span class="n">post</span><span class="bp">-</span><span class="n">processing</span> <span class="mi">103</span><span class="n">ms</span>
        <span class="n">elaboration</span> <span class="mi">27</span><span class="bp">.</span><span class="mi">4</span><span class="n">s</span>
        <span class="n">parsing</span> <span class="mi">0</span><span class="bp">.</span><span class="mi">686</span><span class="n">ms</span>
        <span class="n">type</span> <span class="n">checking</span> <span class="mi">100</span><span class="n">ms</span>
</code></pre></div>



<a name="279767644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279767644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279767644">(Apr 22 2022 at 01:48)</a>:</h4>
<p>If there were an error, you would see what the error was. Since you are only seeing the output of the profiler, you are good.</p>



<a name="279767720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279767720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279767720">(Apr 22 2022 at 01:49)</a>:</h4>
<p>On my computer, your first <code>noncomputable instance polynomial_hopf</code> elaborates in 11s, while the one with the <code>sorry</code>ed <code>coassoc</code> elaborates in 3.5s.</p>
<p>I do not know why your times are so much higher, though.</p>



<a name="279767940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279767940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279767940">(Apr 22 2022 at 01:52)</a>:</h4>
<p>What sort of computer are you using Vasily? Is it a laptop? If it was a small laptop it's conceivable that it could take a few times longer than for others i guess.</p>



<a name="279874829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279874829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vasily Ilin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279874829">(Apr 22 2022 at 20:29)</a>:</h4>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span> , it's a surface pro 6 with Intel i5 CPU.</p>



<a name="279879437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/refactoring%20proofs/near/279879437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/refactoring.20proofs.html#279879437">(Apr 22 2022 at 21:19)</a>:</h4>
<p>Yeah that's a fairly low power device so I'm not surprised lean is taking a long time for you compared with others.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
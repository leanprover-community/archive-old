---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/coinductive.20datatypes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html">coinductive datatypes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="200176840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200176840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200176840">(Jun 09 2020 at 02:27)</a>:</h4>
<p>Is there coinductive datatypes in Lean or a way to mimic it? It's called <code>codatatype</code> in Isabelle/HOL. I kind of need to port something defined by codatatype in Isabelle/HOL to Lean.</p>
<p>Reference: <a href="http://isabelle.in.tum.de/dist/doc/datatypes.pdf">http://isabelle.in.tum.de/dist/doc/datatypes.pdf</a></p>



<a name="200182312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200182312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200182312">(Jun 09 2020 at 04:56)</a>:</h4>
<p>There is no built in support, but a few ways to mimic it</p>



<a name="200182335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200182335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200182335">(Jun 09 2020 at 04:57)</a>:</h4>
<p>The QPF package being developed by <span class="user-mention" data-user-id="110026">@Simon Hudon</span> is the nearest hope to a general facility for this in lean, but in specific cases you can make do with ad hoc encodings</p>



<a name="200196972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200196972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200196972">(Jun 09 2020 at 08:56)</a>:</h4>
<p><a href="https://github.com/avigad/qpf/">https://github.com/avigad/qpf/</a></p>



<a name="200197049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200197049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200197049">(Jun 09 2020 at 08:57)</a>:</h4>
<p>Looks promising</p>



<a name="200197203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200197203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200197203">(Jun 09 2020 at 08:58)</a>:</h4>
<p>I think that version is fixed for the lean together meeting. I'm pretty sure it's been developed since then</p>



<a name="200426112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200426112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200426112">(Jun 10 2020 at 14:48)</a>:</h4>
<p>I'm a little bit confused. It seems that <code>coinductive</code> was once in Lean and removed since v3.4.2 (18 Jan 2019) with comment "To be moved to mathlib instead." And mathlib has <a href="https://github.com/leanprover-community/mathlib/blob/master/src/meta/coinductive_predicates.lean">https://github.com/leanprover-community/mathlib/blob/master/src/meta/coinductive_predicates.lean</a> and some smoke tests show that it basically works. By there's no built in support, do you mean the implementation so far is not complete or not general enough?</p>



<a name="200428390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200428390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200428390">(Jun 10 2020 at 15:03)</a>:</h4>
<p>A friend found <a href="https://github.com/leanprover/lean/wiki/Coinductive-Types">https://github.com/leanprover/lean/wiki/Coinductive-Types</a> , which provides a historical perspective.</p>



<a name="200428560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200428560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200428560">(Jun 10 2020 at 15:04)</a>:</h4>
<p>There are two different things here: coinductive predicates and coinductive types</p>



<a name="200428665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200428665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200428665">(Jun 10 2020 at 15:05)</a>:</h4>
<p>Coinductive predicates were originally in lean core and were moved to mathlib a while ago, and although they haven't gotten any love in the past few years the implementation works as far as I am aware</p>



<a name="200428708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200428708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200428708">(Jun 10 2020 at 15:05)</a>:</h4>
<p>Depending on your use case this may be sufficient</p>



<a name="200428897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200428897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200428897">(Jun 10 2020 at 15:07)</a>:</h4>
<p>These are propositions though, and can be defined fairly easily by using impredicativity of Prop. This construction does not cover coinductive datatypes, which live in Type</p>



<a name="200428941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200428941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200428941">(Jun 10 2020 at 15:07)</a>:</h4>
<p>Do you have any specific examples you are trying to encode? You linked to a book</p>



<a name="200437572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200437572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200437572">(Jun 10 2020 at 16:06)</a>:</h4>
<p>The motivating example:</p>
<blockquote>
<p>We first define concrete data structures. We define a type mvec of a multivector as a codatatype in Isabelle. We could have used a datatype but by defining this notion coalgebraically, we can formalize the various multivector operations more elegantly by considering their grades separately.</p>
</blockquote>
<div class="codehilite"><pre><span></span><code><span class="k">codatatype</span> <span class="n">mvec</span> <span class="o">=</span> <span class="n">Mvec</span> <span class="o">(</span><span class="n">Scalar</span><span class="o">:</span> <span class="n">real</span><span class="o">)</span> <span class="o">(</span><span class="n">Vec</span><span class="o">:</span> <span class="s">&quot;real^3&quot;</span><span class="o">)</span> <span class="o">(</span><span class="n">Bivec</span><span class="o">:</span> <span class="s">&quot;real^3&quot;</span><span class="o">)</span> <span class="o">(</span><span class="n">Trivec</span><span class="o">:</span> <span class="n">real</span><span class="o">)</span>

<span class="k">instantiation</span> <span class="n">mvec</span> <span class="o">::</span> <span class="n">ab_group_add</span>
<span class="k">begin</span>
<span class="k">primcorec</span> <span class="n">zero_mvec</span> <span class="kp">where</span>
  <span class="s">&quot;Scalar 0 = 0&quot;</span>
<span class="o">|</span> <span class="s">&quot;Vec 0 = 0&quot;</span>
<span class="o">|</span> <span class="s">&quot;Bivec 0 = 0&quot;</span>
<span class="o">|</span> <span class="s">&quot;Trivec 0 = 0&quot;</span>

<span class="k">primcorec</span> <span class="n">plus_mvec</span> <span class="kp">where</span>
  <span class="s">&quot;Scalar (x + y) = Scalar x + Scalar y&quot;</span>
<span class="o">|</span> <span class="s">&quot;Vec (x + y) = Vec x + Vec y&quot;</span>
<span class="o">|</span> <span class="s">&quot;Bivec (x + y) = Bivec x + Bivec y&quot;</span>
<span class="o">|</span> <span class="s">&quot;Trivec (x + y) = Trivec x + Trivec y&quot;</span>

<span class="k">primcorec</span> <span class="n">uminus_mvec</span> <span class="kp">where</span>
  <span class="s">&quot;Scalar (-x) = - Scalar x&quot;</span>
<span class="o">|</span> <span class="s">&quot;Vec (-x) = - Vec x&quot;</span>
<span class="o">|</span> <span class="s">&quot;Bivec (-x) = - Bivec x&quot;</span>
<span class="o">|</span> <span class="s">&quot;Trivec (-x) = - Trivec x&quot;</span>

<span class="k">primcorec</span> <span class="n">minus_mvec</span> <span class="kp">where</span>
  <span class="s">&quot;Scalar (x - y) = Scalar x - Scalar y&quot;</span>
<span class="o">|</span> <span class="s">&quot;Vec (x - y) = Vec x - Vec y&quot;</span>
<span class="o">|</span> <span class="s">&quot;Bivec (x - y) = Bivec x - Bivec y&quot;</span>
<span class="o">|</span> <span class="s">&quot;Trivec (x - y) = Trivec x - Trivec y&quot;</span>
<span class="kn">instance</span>
<span class="k">by</span> <span class="n">intro_classes</span> <span class="o">(</span><span class="n">simp_all</span> <span class="n">add</span><span class="o">:</span> <span class="n">mvec_eq_iff</span><span class="o">)</span>
<span class="k">end</span>
</code></pre></div>


<p>(More code omitted, it's from A New Formalization of Origami in Geometric Algebra by Tetsuo Ida, Jacques Fleuriot, and Fadoua Ghourabi )</p>



<a name="200437815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200437815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200437815">(Jun 10 2020 at 16:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/coinductive.20datatypes/near/200428897">said</a>:</p>
<blockquote>
<p>These are propositions though, and can be defined fairly easily by using impredicativity of Prop. This construction does not cover coinductive datatypes, which live in Type</p>
</blockquote>
<p>Ah, I need to read more to tell the difference...They look very similar (not only by name but also by use cases)</p>



<a name="200445185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200445185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200445185">(Jun 10 2020 at 17:03)</a>:</h4>
<p>What? This is not even a recursive structure, so it makes no difference if it is inductive or coinductive</p>



<a name="200445343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200445343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200445343">(Jun 10 2020 at 17:04)</a>:</h4>
<p>I believe that the comments about <code>codatatype</code> over <code>datatype</code> have more to do with details of the datatype package implementation in isabelle than any mathematical notion</p>



<a name="200446177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200446177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200446177">(Jun 10 2020 at 17:11)</a>:</h4>
<p><span class="user-mention" data-user-id="296911">@Utensil Song</span> Here's a rendering of that code snippet in lean:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">pi_instances</span>

<span class="kn">structure</span> <span class="n">mvec</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">scalar</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">vec</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">3</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">bivec</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">3</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">trivec</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">mvec</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="bp">⟩⟩</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">mvec</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="bp">⟨</span><span class="n">x</span><span class="bp">.</span><span class="n">scalar</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">.</span><span class="n">scalar</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">vec</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">.</span><span class="n">vec</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">bivec</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">.</span><span class="n">bivec</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">trivec</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">.</span><span class="n">trivec</span><span class="bp">⟩⟩</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_neg</span> <span class="n">mvec</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨-</span><span class="n">x</span><span class="bp">.</span><span class="n">scalar</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="bp">.</span><span class="n">vec</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="bp">.</span><span class="n">bivec</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="bp">.</span><span class="n">trivec</span><span class="bp">⟩⟩</span>
</code></pre></div>



<a name="200446615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200446615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200446615">(Jun 10 2020 at 17:14)</a>:</h4>
<p>I think the quote is saying that the use of <code>codatatype</code> allows them to define the various components of the operations by specifying all of its projections separately rather than making a constructor which puts them all in one expression. I think this is a minor gain, and in the context of lean certainly not worth the hassle of using a non-builtin datatype with worse defeq. Instead you can use attributes like <code>@[simps]</code> to automatically generate the projection theorems that isabelle's <code>primcorec</code> is creating</p>



<a name="200632680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200632680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200632680">(Jun 12 2020 at 03:53)</a>:</h4>
<p>Thanks for the tips and sorry for the late reply. Yes, the trivial addition case failed to demonstrate the necessity of coinductive types, but we need more general cases:</p>
<ol>
<li>for multiplication, it would need something like </li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">instantiation</span> <span class="n">mvec</span> <span class="o">::</span> <span class="n">monoid_mult</span>
<span class="k">begin</span>
<span class="k">primcorec</span> <span class="n">times_mvec</span> <span class="kp">where</span>
<span class="s">&quot;Scalar (x * y) = Scalar x * Scalar y + (Vec x · Vec y) - (Bivec x · Bivec y) - Trivec x * Trivec y&quot;</span>
<span class="o">|</span> <span class="s">&quot;Vec (x * y) = ...&quot;</span>
<span class="o">|</span> <span class="s">&quot;Bivec (x * y) = ...&quot;</span>
<span class="o">|</span> <span class="s">&quot;Trivec (x * y) = ...&quot;</span>
<span class="k">end</span>
</code></pre></div>


<p>and yes, this is still something that can be solved by plain structures.</p>
<ol start="2">
<li>
<p>we need to generalize to n dimensions not only 3 dimensions</p>
</li>
<li>
<p>there's an infinite dimension version along the way, from it obtain all finite dimensional geometric algebras as subalgebras.</p>
</li>
</ol>
<p>I'm still looking into the possibilities of implementing the above in Lean or Agda. And I'm also learning more about the whole coninductive, corecursive, coinduction thing and its applicability/necessity  to my problem.</p>
<p>I also checked out <code>@[simps]</code> which doesn't seem to solve the multiplication case and is very limited for the addition case.</p>
<p>I'll get back here when I have a more clear picture of what I'm trying to do here.</p>



<a name="200634202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200634202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200634202">(Jun 12 2020 at 04:32)</a>:</h4>
<p>This can all be done with no difficulty</p>



<a name="200634207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200634207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200634207">(Jun 12 2020 at 04:32)</a>:</h4>
<p>there is no argument for coinductive types here besides some trivial syntax</p>



<a name="200634459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/coinductive%20datatypes/near/200634459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/coinductive.20datatypes.html#200634459">(Jun 12 2020 at 04:38)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">normed_space</span><span class="bp">.</span><span class="n">real_inner_product</span>

<span class="kn">structure</span> <span class="n">mvec</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">scalar</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">vec</span> <span class="o">:</span> <span class="n">euclidean_space</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">))</span>
<span class="o">(</span><span class="n">bivec</span> <span class="o">:</span> <span class="n">euclidean_space</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">))</span>
<span class="o">(</span><span class="n">trivec</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">mvec</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">mvec</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="bp">⟨</span><span class="n">x</span><span class="bp">.</span><span class="n">scalar</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">.</span><span class="n">scalar</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">vec</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">.</span><span class="n">vec</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">bivec</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">.</span><span class="n">bivec</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">trivec</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">.</span><span class="n">trivec</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_neg</span> <span class="n">mvec</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨-</span><span class="n">x</span><span class="bp">.</span><span class="n">scalar</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="bp">.</span><span class="n">vec</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="bp">.</span><span class="n">bivec</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="bp">.</span><span class="n">trivec</span><span class="bp">⟩⟩</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="n">mvec</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="o">{</span> <span class="n">scalar</span> <span class="o">:=</span> <span class="n">x</span><span class="bp">.</span><span class="n">scalar</span> <span class="bp">*</span> <span class="n">y</span><span class="bp">.</span><span class="n">scalar</span> <span class="bp">+</span> <span class="n">inner</span> <span class="n">x</span><span class="bp">.</span><span class="n">vec</span> <span class="n">y</span><span class="bp">.</span><span class="n">vec</span> <span class="bp">-</span> <span class="n">inner</span> <span class="n">x</span><span class="bp">.</span><span class="n">bivec</span> <span class="n">y</span><span class="bp">.</span><span class="n">bivec</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">.</span><span class="n">trivec</span> <span class="bp">*</span> <span class="n">y</span><span class="bp">.</span><span class="n">trivec</span><span class="o">,</span>
  <span class="n">vec</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">bivec</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">trivec</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span><span class="bp">⟩</span>
</code></pre></div>


<p>Note that I don't actually know the maths here, I'm just following your indications. There is some complexity in defining the infinite dimensional version but as long as you can give it an inner product structure you can do the same as above.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/My.20first.20original.20result.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html">My first original result</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265819147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265819147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265819147">(Dec 22 2021 at 15:47)</a>:</h4>
<p>My first original result proved in Lean.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">\</span><span class="k">in</span> <span class="o">(</span><span class="mi">2</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">0</span> <span class="o">::</span> <span class="n">list.nil</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
   <span class="n">right</span><span class="o">,</span>
   <span class="n">right</span><span class="o">,</span>
   <span class="n">left</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="265820200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265820200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265820200">(Dec 22 2021 at 15:57)</a>:</h4>
<p>Welcome!</p>



<a name="265822738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265822738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265822738">(Dec 22 2021 at 16:18)</a>:</h4>
<p>Can you get the proof to a single line?</p>



<a name="265822770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265822770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265822770">(Dec 22 2021 at 16:18)</a>:</h4>
<p>Hint: the computer can compute whether or not a given natural is in a list of naturals ;)</p>



<a name="265825261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265825261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265825261">(Dec 22 2021 at 16:42)</a>:</h4>
<p>What I'd really like to understand is how to write this without tactics.  Or, more generally, I confess I don't exactly understand what <code>right</code> and <code>left</code> are doing, from the internal point of view.  I gather that they <code>apply</code> the first and second constructors of an inductive type.  But what is the inductive type under consideration here?  I'm trying to read the source code for the <code>list</code> type but I can't match things up.</p>



<a name="265825464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265825464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265825464">(Dec 22 2021 at 16:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="462625">Jeremy Teitelbaum</span> <a href="#narrow/stream/113489-new-members/topic/My.20first.20original.20result/near/265825261">said</a>:</p>
<blockquote>
<p>What I'd really like to understand is how to write this without tactics.  Or, more generally, I confess I don't exactly understand what <code>right</code> and <code>left</code> are doing, from the internal point of view.  I gather that they <code>apply</code> the first and second constructors of an inductive type.  But what is the inductive type under consideration here?  I'm trying to read the source code for the <code>list</code> type but I can't match things up.</p>
</blockquote>
<p>You can use the <code>#print</code> command to inspect the term that was constructed by a begin-end block:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">my_theorem</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">∈</span> <span class="o">(</span><span class="mi">2</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">0</span> <span class="o">::</span> <span class="n">list.nil</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
   <span class="n">right</span><span class="o">,</span>
   <span class="n">right</span><span class="o">,</span>
   <span class="n">left</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#print</span> <span class="n">my_theorem</span>
<span class="c1">--theorem my_theorem : 0 ∈ [2, 1, 0] :=  or.inr (or.inr (or.inl (eq.refl 0)))</span>
</code></pre></div>



<a name="265825481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265825481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265825481">(Dec 22 2021 at 16:44)</a>:</h4>
<p><code>left</code> and <code>right</code> are tactics that you can use when you want to prove a disjunction of two props <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∨</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \vee q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>. If the goal is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∨</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \vee q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>, then left will replace the goal with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> and right will replace the goal with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>.</p>



<a name="265825568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265825568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265825568">(Dec 22 2021 at 16:45)</a>:</h4>
<p>The <code>has_mem</code> instance for a list is defined recursively so that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>a</mi><mo>:</mo><mo>:</mo><mi>a</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \in (a :: as)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>a</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">x \in as</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span></span></span></span>, and this is why <code>left</code> and/or <code>right</code> work for such a goal.</p>



<a name="265825600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265825600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265825600">(Dec 22 2021 at 16:45)</a>:</h4>
<p>(the base case <code>x \in list.nil</code> is defined to be false.)</p>



<a name="265825727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265825727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265825727">(Dec 22 2021 at 16:47)</a>:</h4>
<p>Jeremy, do you know about <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#show_term">tactic#show_term</a>?</p>



<a name="265825742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265825742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265825742">(Dec 22 2021 at 16:47)</a>:</h4>
<p>The process by which <code>0 \in [0,1,2]</code> gets converted to <code>0=0 \or 0\in [1,2]</code> seems like utter magic.</p>



<a name="265825900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265825900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265825900">(Dec 22 2021 at 16:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="462625">Jeremy Teitelbaum</span> <a href="#narrow/stream/113489-new-members/topic/My.20first.20original.20result/near/265825742">said</a>:</p>
<blockquote>
<p>The process by which <code>0 \in [0,1,2]</code> gets converted to <code>0=0 \or 0\in [1,2]</code> seems like utter magic.</p>
</blockquote>
<p>That comes from the definition of <code>list.mem</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">mem</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">[]</span>       <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">∨</span> <span class="n">mem</span> <span class="n">a</span> <span class="n">l</span>
</code></pre></div>
<p>From this definition we can deduce that <code>0 \in [0,1,2]</code> (which is syntactic sugar for <code>list.mem 0 [0, 1, 2]</code>) means the same as <code>0 = 0 ∨ list.mem 0 [1, 2]</code>.</p>



<a name="265826056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265826056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265826056">(Dec 22 2021 at 16:50)</a>:</h4>
<p>Jeremy, there is this weird non-mathematical concept called definitional equality.</p>



<a name="265826117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265826117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265826117">(Dec 22 2021 at 16:50)</a>:</h4>
<p>For example x+0=x is definitionally true, but 0+x=x is not, you need to prove it by induction.</p>



<a name="265826118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265826118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265826118">(Dec 22 2021 at 16:50)</a>:</h4>
<p>Yes, I see that.  But I can't find this syntax for definition of a function in the manual. (probably just dumb).  I can infer its meaning, but what language mechanism takes a statement like <code>list.mem 0 [0,1,2]</code>, which I gather is a proposition, and rewrites it as the appropriate <code>\or</code> taking into account that <code>[0,1,2]</code> is not null?</p>



<a name="265826219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265826219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265826219">(Dec 22 2021 at 16:51)</a>:</h4>
<p>You don't need manuals, you just right click on what you want to see the definition of</p>



<a name="265826318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265826318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265826318">(Dec 22 2021 at 16:52)</a>:</h4>
<p><code>#check list.mem</code>, right click, see what the definitional equalities are</p>



<a name="265826356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265826356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265826356">(Dec 22 2021 at 16:52)</a>:</h4>
<p>or <code>unfold list.mem</code> in tactic mode</p>



<a name="265826375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265826375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265826375">(Dec 22 2021 at 16:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="462625">Jeremy Teitelbaum</span> <a href="#narrow/stream/113489-new-members/topic/My.20first.20original.20result/near/265826118">said</a>:</p>
<blockquote>
<p>Yes, I see that.  But I can't find this syntax for definition of a function in the manual. (probably just dumb).  I can infer its meaning, but what language mechanism takes a statement like <code>list.mem 0 [0,1,2]</code>, which I gather is a proposition, and rewrites it as the appropriate <code>\or</code> taking into account that <code>[0,1,2]</code> is not null?</p>
</blockquote>
<p>For the syntax, cf. <a href="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#pattern-matching">https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#pattern-matching</a></p>



<a name="265826545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265826545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265826545">(Dec 22 2021 at 16:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="372804">Marcus Rossel</span> <a href="#narrow/stream/113489-new-members/topic/My.20first.20original.20result/near/265826375">said</a>:</p>
<blockquote>
<p>For the syntax, cf. <a href="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#pattern-matching">https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#pattern-matching</a></p>
</blockquote>
<p>Aha.  I am still trying to make sense of the discussion of inductive types in chapter 7.  I will press on. Thanks!</p>



<a name="265826980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265826980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265826980">(Dec 22 2021 at 16:58)</a>:</h4>
<p>The definition of <code>list.mem</code>says that <code>a \in []</code> is defined to be <code>false</code> and <code>a \in b :: l</code> is defined to be <code>a = b \or a \in l</code></p>



<a name="265827095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265827095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265827095">(Dec 22 2021 at 17:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="462625">Jeremy Teitelbaum</span> <a href="#narrow/stream/113489-new-members/topic/My.20first.20original.20result/near/265825261">said</a>:</p>
<blockquote>
<p>What I'd really like to understand is how to write this without tactics.</p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lem</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">∈</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">:=</span> <span class="n">of_as_true</span> <span class="n">trivial</span>
</code></pre></div>



<a name="265827329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265827329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265827329">(Dec 22 2021 at 17:01)</a>:</h4>
<p>you just keep unwinding the definitions and at each point you observe that there is an algorithm to determine whether the proposition is true or not, so you just keep applying the algorithm.</p>



<a name="265827398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/My%20first%20original%20result/near/265827398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/My.20first.20original.20result.html#265827398">(Dec 22 2021 at 17:01)</a>:</h4>
<p>equality is decidable for concrete naturals, and if P and Q are decidable then P or Q is decidable (because you just decide them both and see if either are true)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html">Defining a symmetric function</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="188346483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188346483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188346483">(Feb 17 2020 at 01:04)</a>:</h4>
<p>Suppose I have an enumerated type <code>A</code> (say with <code>7</code> different constructors) and I wish to define a symmetric function <code>A -&gt; A -&gt; nat</code>.</p>
<p>The only way I know how to do is to write the definition for all <code>7 * 7 = 49</code> variations on the arguments.</p>
<p>However, this is rather inefficient. I know that the function I wish to write is symmetric. Is there a way to give Lean only the <code>28</code> different variations and have it fill in the rest automatically by leveraging symmetry?</p>



<a name="188346759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188346759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188346759">(Feb 17 2020 at 01:15)</a>:</h4>
<p>Sure, you can define your relation to be the symmetric closure of a relation <code>R</code> that you define with only 28 inductive constructors</p>



<a name="188346768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188346768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188346768">(Feb 17 2020 at 01:15)</a>:</h4>
<p>It's not a relation.</p>



<a name="188346814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188346814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188346814">(Feb 17 2020 at 01:16)</a>:</h4>
<p>oh, yeah that won't work without a bit of choice if you want to define a nat function</p>



<a name="188346821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188346821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188346821">(Feb 17 2020 at 01:16)</a>:</h4>
<p>I guess a tactic could do it</p>



<a name="188346830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188346830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188346830">(Feb 17 2020 at 01:17)</a>:</h4>
<p>but fundamentally if you have an inductive type with 7 constructors it's difficult to define any binary function without providing 49 pieces of information</p>



<a name="188346924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188346924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188346924">(Feb 17 2020 at 01:20)</a>:</h4>
<p>Oh. In that case do you think it is fair to demand that this be a new feature?</p>



<a name="188346927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188346927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188346927">(Feb 17 2020 at 01:20)</a>:</h4>
<p>Like I said, a tactic could do it. It's not a lean feature and doesn't make sense as one</p>



<a name="188346968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188346968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188346968">(Feb 17 2020 at 01:22)</a>:</h4>
<p>As in I can define the function with 49 pieces and then add a proof (that's the part that uses the tactic) that it is indeed symmetric? Or is there a way to use the tactic in the definition itself?</p>



<a name="188346982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188346982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188346982">(Feb 17 2020 at 01:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Defining.20a.20symmetric.20function/near/188346759" title="#narrow/stream/113489-new-members/topic/Defining.20a.20symmetric.20function/near/188346759">said</a>:</p>
<blockquote>
<p>Sure, you can define your relation to be the symmetric closure of a relation <code>R</code> that you define with only 28 inductive constructors</p>
</blockquote>
<p>Even in the case of the relation, I don't think I understand. Won't lean rejection my definition of <code>R</code> by saying it is a non-exhaustive definition?</p>



<a name="188347031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188347031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188347031">(Feb 17 2020 at 01:24)</a>:</h4>
<p>If it's a relation, you can define it inductively as an <code>inductive</code> rather than a <code>def</code> with a definition by cases</p>



<a name="188347033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188347033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188347033">(Feb 17 2020 at 01:24)</a>:</h4>
<p>in which case it will be false on the cases you omit</p>



<a name="188347514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188347514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188347514">(Feb 17 2020 at 01:42)</a>:</h4>
<p>Here is a terrible tactic that does the job:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span><span class="bp">.</span><span class="n">defs</span>

<span class="kn">namespace</span> <span class="n">tactic</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">match_goals</span> <span class="o">(</span><span class="n">ls</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">))</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">do</span>
  <span class="n">gs</span> <span class="err">←</span> <span class="n">get_goals</span><span class="o">,</span>
  <span class="n">ls</span><span class="bp">.</span><span class="n">mmap&#39;</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">unify</span> <span class="o">(</span><span class="n">gs</span><span class="bp">.</span><span class="n">inth</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">gs</span><span class="bp">.</span><span class="n">inth</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">set_goals</span> <span class="n">gs</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">interactive</span><span class="bp">.</span><span class="n">cases_symmetric</span>
  <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">interactive</span><span class="bp">.</span><span class="n">parse</span> <span class="o">(</span><span class="n">lean</span><span class="bp">.</span><span class="n">parser</span><span class="bp">.</span><span class="n">pexpr</span> <span class="n">std</span><span class="bp">.</span><span class="n">prec</span><span class="bp">.</span><span class="n">max</span><span class="o">))</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">do</span>
  <span class="n">a</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">b</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">env</span> <span class="err">←</span> <span class="n">get_env</span><span class="o">,</span>
  <span class="n">ty</span> <span class="err">←</span> <span class="n">infer_type</span> <span class="n">a</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">(</span><span class="n">env</span><span class="bp">.</span><span class="n">constructors_of</span> <span class="n">ty</span><span class="bp">.</span><span class="n">get_app_fn</span><span class="bp">.</span><span class="n">const_name</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span><span class="o">,</span>
  <span class="o">(()</span> <span class="bp">&lt;</span><span class="err">$</span> <span class="n">cases_core</span> <span class="n">a</span> <span class="o">[])</span><span class="bp">;</span> <span class="o">(()</span> <span class="bp">&lt;</span><span class="err">$</span> <span class="n">cases_core</span> <span class="n">b</span> <span class="o">[]),</span>
  <span class="n">match_goals</span> <span class="err">$</span> <span class="n">do</span>
    <span class="n">a</span> <span class="err">←</span> <span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">b</span> <span class="err">←</span> <span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">guard</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">),</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">n</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span>
<span class="kn">end</span> <span class="n">tactic</span>

<span class="kn">inductive</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">sun</span> <span class="bp">|</span> <span class="n">mon</span> <span class="bp">|</span> <span class="n">tue</span> <span class="bp">|</span> <span class="n">wed</span> <span class="bp">|</span> <span class="n">thu</span> <span class="bp">|</span> <span class="n">fri</span> <span class="bp">|</span> <span class="n">sat</span>

<span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">weekday</span> <span class="bp">→</span> <span class="n">weekday</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">cases_symmetric</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="c1">-- 28 × |- ℕ</span>

  <span class="c1">-- filling with dummy stuff</span>
  <span class="o">(</span><span class="n">do</span> <span class="n">gs</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">get_goals</span><span class="o">,</span>
    <span class="n">gs</span><span class="bp">.</span><span class="n">enum</span><span class="bp">.</span><span class="n">mmap&#39;</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">g</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">do</span>
      <span class="n">tactic</span><span class="bp">.</span><span class="n">unify</span> <span class="n">g</span> <span class="o">(</span><span class="n">reflect</span> <span class="n">n</span><span class="o">))</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">wed</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">thu</span> <span class="bp">=</span> <span class="mi">19</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">foo_symm</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">foo</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">cases</span> <span class="n">m</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">n</span><span class="bp">;</span> <span class="n">refl</span>
</pre></div>



<a name="188348442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188348442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188348442">(Feb 17 2020 at 02:14)</a>:</h4>
<p>Thanks for the code! This is beyond my current level of understanding so I will get started on trying to unravel what it does.</p>



<a name="188349016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188349016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188349016">(Feb 17 2020 at 02:36)</a>:</h4>
<p>The interesting part is this:</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">eval</span> <span class="n">do</span>
    <span class="n">a</span> <span class="err">←</span> <span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="mi">7</span><span class="o">,</span>
    <span class="n">b</span> <span class="err">←</span> <span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="mi">7</span><span class="o">,</span>
    <span class="n">guard</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">),</span>
    <span class="n">return</span> <span class="o">(</span><span class="mi">7</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="mi">7</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span>
</pre></div>


<p>that just creates a list of goal pairs to merge, and then <code>match_goals</code> goes through and unifies these pairwise</p>



<a name="188349032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188349032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188349032">(Feb 17 2020 at 02:37)</a>:</h4>
<p>in other words it's just saying "let goal (1,2) be the same as goal (2,1)" and so on</p>



<a name="188349075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20symmetric%20function/near/188349075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20symmetric.20function.html#188349075">(Feb 17 2020 at 02:38)</a>:</h4>
<p>The downside is that you end up with 28 unmarked identical goals and it's up to you to figure out what they correspond to</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
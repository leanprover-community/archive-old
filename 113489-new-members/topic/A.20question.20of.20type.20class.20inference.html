---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html">A question of type class inference</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="236057763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236057763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236057763">(Apr 25 2021 at 11:13)</a>:</h4>
<p>I am watching talks on Lean for the curious mathematician 2020 and one thing that Kevin mentions in his talk on algebraic hierarchy is how Lean knows that if G and H are groups, then so is G \times H by the virtue of type class inference system. But what would happen if I try to feed it instances which make a certain set in a group in more than one way? Let's say I defined 'If Y is an H-space, then so is Hom(X,Y)', 'If Y is a space, then \OmegaY is an H-space', and 'Hom(\Sigma X, Y) is an H-space'. Then I can define two group structures on Hom(\Sigma X, \Omega Y), and in fact I can prove that they are the same. But will Lean accept this definition or will it complain that the type class inference in ambiguous?</p>



<a name="236058068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058068">(Apr 25 2021 at 11:19)</a>:</h4>
<p>In my understanding of your example there's no ambiguity:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">class</span> <span class="n">is_H_space</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="bp">.</span>

<span class="kd">def</span> <span class="n">omega</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">sigma'</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">pi.is_H_space</span> <span class="o">[</span><span class="n">is_H_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_H_space</span> <span class="o">(</span><span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">is_H_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_H_space</span> <span class="o">(</span><span class="n">omega</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">is_H_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_H_space</span> <span class="o">(</span><span class="n">sigma'</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">set_option</span> <span class="n">pp.implicit</span> <span class="n">true</span>

<span class="kd">instance</span> <span class="n">foo</span> <span class="o">[</span><span class="n">is_H_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_H_space</span> <span class="o">(</span><span class="n">sigma'</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">omega</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">show_term</span> <span class="o">{</span><span class="n">apply_instance</span><span class="o">}</span>
<span class="c1">-- @pi.is_H_space (sigma' X) (omega Y) (@omega.is_H_space Y _inst_1)</span>
</code></pre></div>



<a name="236058146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058146">(Apr 25 2021 at 11:20)</a>:</h4>
<p>(also, you can use <code>$$\LaTeX$$</code> in your zulip posts to make <code>\Sigma X</code> typeset possibly as you want it, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\Sigma X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>)</p>



<a name="236058165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058165">(Apr 25 2021 at 11:21)</a>:</h4>
<p>\Sigma Y is not an H-space!<br>
It is a co-H-space, making Hom(\Sigma X, Y) in an H-space</p>



<a name="236058196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058196">(Apr 25 2021 at 11:21)</a>:</h4>
<p>So I can subtitute Y=\Omega Z to get a group structure</p>



<a name="236058205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058205">(Apr 25 2021 at 11:22)</a>:</h4>
<p>But I then have a different group structure because \Omega Z is an H-space</p>



<a name="236058243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058243">(Apr 25 2021 at 11:22)</a>:</h4>
<p>I should probably withdraw at this point as I have no idea what an H-space structure is! Have I given you enough information to write your problem statement in lean?</p>



<a name="236058265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058265">(Apr 25 2021 at 11:22)</a>:</h4>
<p>And in topology we prove that the two are the same by what's called Eckmann-Hilton argument</p>



<a name="236058292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058292">(Apr 25 2021 at 11:23)</a>:</h4>
<p>eckmann-hilton is absolutely gorgeous btw</p>



<a name="236058299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058299">(Apr 25 2021 at 11:23)</a>:</h4>
<p>Perhaps as a concrete example of this type of "diamond" that doesn't involve anything sophisticated, there are two different algebra structures on <code>nat</code> - <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra.id">docs#algebra.id</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra_nat">docs#algebra_nat</a></p>



<a name="236058368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058368">(Apr 25 2021 at 11:24)</a>:</h4>
<p>Lean will happily pick one or the other, and only complain when it expects one but finds the other; and even then, only if they turn out to actually hold different values</p>



<a name="236058369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058369">(Apr 25 2021 at 11:24)</a>:</h4>
<p>It says 'invalid definition, a declaration named 'pi.is_H_space' has already been declared'</p>



<a name="236058377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058377">(Apr 25 2021 at 11:24)</a>:</h4>
<p>but it says so on the line 'instance [is_H_space Y] : is_H_space (sigma' Y → X)  := sorry'</p>



<a name="236058399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058399">(Apr 25 2021 at 11:25)</a>:</h4>
<p>Which is not where the problem really is</p>



<a name="236058400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058400">(Apr 25 2021 at 11:25)</a>:</h4>
<p>Just give it a different name</p>



<a name="236058406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058406">(Apr 25 2021 at 11:25)</a>:</h4>
<p><code>instance a_different_name_because_the_default_already_existed</code> instead of <code>instance</code></p>



<a name="236058517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058517">(Apr 25 2021 at 11:27)</a>:</h4>
<p>Ok, now it works</p>



<a name="236058519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236058519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236058519">(Apr 25 2021 at 11:27)</a>:</h4>
<p>It says Try this: refine @pi.is_H_space (sigma' X) (omega Y) (omega.is_H_space Y)</p>



<a name="236059256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236059256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236059256">(Apr 25 2021 at 11:40)</a>:</h4>
<p>Right, so it still arbitrarily prefers that path over the other one</p>



<a name="236059278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236059278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236059278">(Apr 25 2021 at 11:41)</a>:</h4>
<p>Is your sigma <a href="https://leanprover-community.github.io/mathlib_docs/find/sigma">docs#sigma</a>, or something else?</p>



<a name="236060083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236060083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236060083">(Apr 25 2021 at 11:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference/near/236059278">said</a>:</p>
<blockquote>
<p>Is your sigma <a href="https://leanprover-community.github.io/mathlib_docs/find/sigma">docs#sigma</a>, or something else?</p>
</blockquote>
<p>My \Sigma is reduced suspension from topology :)<br>
<a href="https://ncatlab.org/nlab/show/suspension">https://ncatlab.org/nlab/show/suspension</a></p>



<a name="236063939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236063939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236063939">(Apr 25 2021 at 13:05)</a>:</h4>
<p>In short, if <code>X</code> is a class then there is supposed to only be one <code>X</code> structure on any type up to definitional equality, and there are tricks to make this happen in situations where you end up with two equal, but not definitionally equal, constructions of an <code>X</code>. For example, the product of two metric spaces becomes a topological space in two different ways, one via product of metric spaces is a metric space and then metric space is a topological space, and the other via metric space is a topological space and product of topological spaces is a topological space. For example the topologies on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\R^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> generated by open discs and open rectangles are equal but not definitionally equal. This is dealt with in Lean by embedding secondary structures within the primary ones, a rather surprising solution, but it works. For example the internal definition of a metric space in Lean also carries a topology plus a proof that the topology is the one generated by the metric (and if the user doesn't supply it, a tactic creates it from the metric). That way, when forming the product of two metric spaces, you can insert the proof that the diagram commutes here and the user is none the wiser that anything sneaky is going on and the system works.</p>



<a name="236064162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236064162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236064162">(Apr 25 2021 at 13:09)</a>:</h4>
<p>See for example <a href="https://github.com/leanprover-community/mathlib/blob/d052c5270f47dc9e20fcc3eda97b2f165533f509/src/algebra/group/defs.lean#L248-L297">this library note</a></p>



<a name="236069550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236069550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236069550">(Apr 25 2021 at 14:34)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="407114">@Stepan Nesterov</span>'s example <code>Hom(\Sigma X, \Omega Y)</code> is an interesting one, and I don't see how it's covered by the technique Kevin has just pointed to.</p>
<p>We would get two instances here, and they would not be definitionally equal.</p>



<a name="236072885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236072885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236072885">(Apr 25 2021 at 15:23)</a>:</h4>
<p>Presumably in that case they're at least propositionally equal?</p>



<a name="236073048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236073048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236073048">(Apr 25 2021 at 15:26)</a>:</h4>
<p>Yes, the two group operations are equal in the respective category, and I was just curious if there is a way to state that in Lean cleanly and/or if there was a recommended detour if we need both for some reason.</p>



<a name="236073089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236073089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236073089">(Apr 25 2021 at 15:27)</a>:</h4>
<p>And maybe in this example we do, because the proof via Eckmann-Hilton argument (<a href="https://ncatlab.org/nlab/show/Eckmann-Hilton+argument">https://ncatlab.org/nlab/show/Eckmann-Hilton+argument</a>) shows that both group laws are commutative, something that is not obvious from their direct definitions</p>



<a name="236073277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236073277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236073277">(Apr 25 2021 at 15:31)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/group_theory/eckmann_hilton.html">https://leanprover-community.github.io/mathlib_docs/group_theory/eckmann_hilton.html</a></p>



<a name="236073332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236073332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236073332">(Apr 25 2021 at 15:32)</a>:</h4>
<p>You should be able to find rather concrete answers at the above link <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="236073549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236073549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236073549">(Apr 25 2021 at 15:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference/near/236073277">said</a>:</p>
<blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/group_theory/eckmann_hilton.html">https://leanprover-community.github.io/mathlib_docs/group_theory/eckmann_hilton.html</a></p>
</blockquote>
<p>But are higher homotopy groups defined in Lean? If so, how is the equality of two group laws stated there?</p>



<a name="236073576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236073576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236073576">(Apr 25 2021 at 15:35)</a>:</h4>
<p>No, they are not defined in mathlib.</p>



<a name="236073764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236073764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236073764">(Apr 25 2021 at 15:39)</a>:</h4>
<p>I guess a simpler example of all this would be to consider <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">\Omega G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span><span class="mord mathnormal">G</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> a topological group and in this case we obtain a nontrivial result that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1(G)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span> is commutative.</p>



<a name="236073844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236073844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236073844">(Apr 25 2021 at 15:40)</a>:</h4>
<p>Is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> also not in mathlib, though?</p>



<a name="236074122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236074122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236074122">(Apr 25 2021 at 15:45)</a>:</h4>
<p>Nope, not in mathlib. Are you wondering if the fact that there are "two essentially different proofs" it is commutative will be a problem?</p>



<a name="236074205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236074205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236074205">(Apr 25 2021 at 15:47)</a>:</h4>
<p>The two constructions only differ in <code>Prop</code> fields, not data, so I don't see why Lean would care. Even if you produced two different <code>comm_group</code> instances this way, Lean will happily agree they were defeq.</p>



<a name="236074454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236074454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236074454">(Apr 25 2021 at 15:51)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> not in mathlib -- that's right. There's absolutely nothing stopping it being in mathlib -- indeed an Imperial undergraduate did <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in Lean in 2018 as a summer project (and proved <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi mathvariant="double-struck">R</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\pi_1(\R)=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">R</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, but never tidied up the code enough to get it into mathlib.</p>



<a name="236074642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236074642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236074642">(Apr 25 2021 at 15:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference/near/236074122">said</a>:</p>
<blockquote>
<p>Nope, not in mathlib. Are you wondering if the fact that there are "two essentially different proofs" it is commutative will be a problem?</p>
</blockquote>
<p>No, I wonder if I can access two instances of group on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">\Omega G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span><span class="mord mathnormal">G</span></span></span></span> in this hypothetical proof if Lean just arbitrarily prefers one over the other.</p>



<a name="236074700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236074700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236074700">(Apr 25 2021 at 15:56)</a>:</h4>
<p>That's what I would do in math: I define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>⋅</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">\gamma \cdot \delta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span> to be the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> multiplication, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>∗</mo><mi>δ</mi><mo>=</mo><mi>λ</mi><mi>t</mi><mo separator="true">,</mo><mi>γ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\gamma * \delta = \lambda t, \gamma(t)\delta(t)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> to be the pointwise multiplication, and then I get the result by Eckmann-Hilton</p>



<a name="236074865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236074865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236074865">(Apr 25 2021 at 15:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference/near/236074205">said</a>:</p>
<blockquote>
<p>The two constructions only differ in <code>Prop</code> fields, not data, so I don't see why Lean would care. Even if you produced two different <code>comm_group</code> instances this way, Lean will happily agree they were defeq.</p>
</blockquote>
<p>How are they defeq? The fact that the two are equal is by Eckmann-Hilton</p>



<a name="236074948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236074948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236074948">(Apr 25 2021 at 16:00)</a>:</h4>
<p>The "pre-multiplications" on the paths are different, but <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is classes of paths, so it's not so clear (to me) that they're not defeq (but I am a bit unclear about how quotients work under the hood)</p>



<a name="236107643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236107643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236107643">(Apr 26 2021 at 01:09)</a>:</h4>
<p>Ah, I had in mind a different proof, where you only ever introduce the \pi_1 multiplication, but then give two different proofs of commutativity (transporting \gamma around \delta, or transporting \delta around \gamma). This doesn't use Eckmann-Hilton directly, and doesn't have any defeq problems, because the two versions only differ at the Prop level.</p>
<p>The usual approach to implement the proof that you had in mind is just to have a type synonym for the "other" multiplication, and then just apply Eckmann-Hilton as it is formulated in the file Patrick linked above.</p>
<p>Type synonyms are an easy and apparently-sufficiently-powerful mechanism to deal with "conflicting" instances, and so far seem to have been sufficient. I like your H-space example above because it's not immediately obvious how to use type synonyms.</p>



<a name="236116419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236116419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236116419">(Apr 26 2021 at 03:50)</a>:</h4>
<p>But only introducing the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-multiplication is not "good enough", in some sense, right? Because sometimes you have only the one and not the other, or vice versa. (I mean, this can show up in topology, in practice.)</p>



<a name="236122162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236122162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236122162">(Apr 26 2021 at 05:25)</a>:</h4>
<p>Yes, that's true. But I think this example doesn't show it super clearly. While both multiplications are very natural, the pointwise multiplication is only natural on honest paths, and it's a pretty specialised application to consider pointwise multiplication on homotopy classes of paths.</p>



<a name="236134980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20question%20of%20type%20class%20inference/near/236134980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20question.20of.20type.20class.20inference.html#236134980">(Apr 26 2021 at 08:05)</a>:</h4>
<p>One group structure is on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1(G, 1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, the other is on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi mathvariant="normal">Ω</mi><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_0(\Omega G)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">Ω</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span> (path components of a topological group is a group). Of course these two types are equivalent, and may or may not end up defeq, but this identification should still be opaque to typeclass inference? I think they're automatically the kind of synonym Scott described</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
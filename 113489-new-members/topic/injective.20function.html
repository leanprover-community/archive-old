---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/injective.20function.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html">injective function</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="215703745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215703745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Busiso Chisala <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215703745">(Nov 05 2020 at 12:21)</a>:</h4>
<p>Is there an easy way to formulate/prove the existence of an <code>injective</code> function from finite set A to B given that the cardinalities (?) allow?  The choose-using tactic  will give a function (I guess) but  ... I have the idea that a finset induction  would do it, but worry there is a trivial way out there will save me the trouble. I want to use this in the 'extend to a basis' manner. Thanks</p>



<a name="215703854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215703854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215703854">(Nov 05 2020 at 12:22)</a>:</h4>
<p>Can you formalise the precise statement which you want?</p>



<a name="215703930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215703930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215703930">(Nov 05 2020 at 12:23)</a>:</h4>
<p>"finite set" can be said in several different ways in Lean and the answer to your question is probably "yes", but  the details will depend on precisely how you want to state the maths assertion in type theory.</p>



<a name="215704018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215704018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215704018">(Nov 05 2020 at 12:24)</a>:</h4>
<p>One thing I learnt very early on is that formalising the question is an important part of asking the question.</p>



<a name="215704193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215704193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215704193">(Nov 05 2020 at 12:26)</a>:</h4>
<p>Another thing I learnt very early on is that choosing a random way to formalise the question and then solving it might lead to problems later when I want to apply the theorem I've already proved. I might find that it doesn't apply, because <code>set.finite</code> and <code>fintype</code> and <code>finset</code> are all different things.</p>



<a name="215704350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215704350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215704350">(Nov 05 2020 at 12:28)</a>:</h4>
<p>In set theory, a set is a primitive notion and there is no question about what is meant. In type theory the type is the primitive notion, and various concepts of finite set can be built on top of this in different ways.</p>



<a name="215710296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215710296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Busiso Chisala <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215710296">(Nov 05 2020 at 13:25)</a>:</h4>
<p>An fintype indexed set of vectors <code>v: ι → E</code> some of which are zero, the rest linearly independent. Say on sets <code>s,t :finset ι</code>,  respectively. Suppose that the dimension of <code>E</code> is <code>|s|+|t|</code> and I have a ready set of <code>|s|</code> vectors to complete my basis (say via a <code>w: k → E</code>). I suppose I am not very happy with how <code>fin m</code>  objects work ... My use case is <code>v: fin n → E</code>. Must I really ?</p>



<a name="215710529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215710529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215710529">(Nov 05 2020 at 13:27)</a>:</h4>
<p>Can you make a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>? A self-contained piece of code containing one <code>sorry</code> which is what you want filled in? This is the precise meaning of my original question.</p>



<a name="215710577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215710577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215710577">(Nov 05 2020 at 13:28)</a>:</h4>
<p>This is an important skill to learn.</p>



<a name="215710685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215710685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Busiso Chisala <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215710685">(Nov 05 2020 at 13:28)</a>:</h4>
<p>I'll try</p>



<a name="215726777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215726777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Busiso Chisala <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215726777">(Nov 05 2020 at 15:26)</a>:</h4>
<p>I had some trouble, so this exercise was well worth it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="n">E</span><span class="o">:</span><span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">ℝ</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℝ</span> <span class="n">E</span><span class="o">]</span>

<span class="c1">-- rather than use 'fin k → E' I have used fintype n for illustration</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`⟪`</span><span class="n">x</span><span class="bp">`</span><span class="o">,</span> <span class="bp">`</span><span class="n">y</span><span class="bp">`⟫`</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">inner</span> <span class="n">ℝ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">x</span> <span class="n">y</span>

<span class="c1">-- to simplify my statements</span>

<span class="kd">def</span> <span class="n">is_orth</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">:</span><span class="n">n</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">→</span> <span class="bp">⟪</span><span class="n">v</span> <span class="n">i</span><span class="o">,</span> <span class="n">v</span> <span class="n">j</span><span class="bp">⟫=</span><span class="mi">0</span>

<span class="kd">def</span> <span class="n">is_nonzero</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">:</span><span class="n">n</span><span class="o">,</span>  <span class="n">v</span> <span class="n">i</span> <span class="bp">≠</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">enlarges</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span><span class="o">:</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">:</span><span class="n">n</span><span class="o">,</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">v</span> <span class="n">i</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">v</span><span class="o">:</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">ho</span><span class="o">:</span> <span class="n">is_orth</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">w</span><span class="o">:</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">E</span><span class="o">,</span> <span class="n">enlarges</span> <span class="n">v</span> <span class="n">w</span>  <span class="bp">∧</span> <span class="n">is_orth</span> <span class="n">w</span>  <span class="bp">∧</span>  <span class="n">is_nonzero</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">i</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">n</span><span class="o">)</span> <span class="bp">|</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">z</span><span class="o">:</span><span class="n">fin</span> <span class="o">(</span><span class="n">s.card</span><span class="o">)</span> <span class="bp">→</span> <span class="n">E</span><span class="o">,</span> <span class="n">is_orth</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">is_nonzero</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">,</span>
  <span class="c1">-- would like to use z, which we can engineer to be in the orthogonal to v.range</span>
  <span class="n">cases</span> <span class="n">this</span> <span class="k">with</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
  <span class="c1">-- how to interweave z with v ?</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>? use .val?</p>



<a name="215834614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215834614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215834614">(Nov 06 2020 at 11:42)</a>:</h4>
<p>Here's what I came up with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.basic</span>

<span class="kd">variables</span> <span class="o">{</span> <span class="n">m</span> <span class="n">p</span> <span class="o">:</span><span class="kt">Type</span> <span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">m</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">p</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">fintype</span>

<span class="kd">example</span>  <span class="o">{</span><span class="n">s</span><span class="o">:</span> <span class="n">finset</span> <span class="n">m</span><span class="o">}</span> <span class="o">{</span><span class="n">h</span><span class="o">:</span> <span class="n">s.card</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">p</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">f</span><span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">m</span><span class="o">,</span> <span class="n">function.injective</span> <span class="n">f</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">:</span><span class="n">m</span><span class="o">,</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">t</span><span class="o">:</span><span class="n">p</span><span class="o">,</span> <span class="n">i</span><span class="bp">=</span><span class="n">f</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">S</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">},</span>
  <span class="k">have</span> <span class="n">hS</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">s.card</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">subtype_card</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">fintype.card_eq</span><span class="o">]</span> <span class="n">at</span> <span class="n">hS</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hS</span> <span class="k">with</span> <span class="n">e</span><span class="o">,</span>
  <span class="c1">-- e is a bijection S -&gt; p</span>
  <span class="n">use</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">e.symm</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">equiv.injective</span> <span class="n">e.symm</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">subtype.ext</span> <span class="n">hxy</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">e</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="215834694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215834694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215834694">(Nov 06 2020 at 11:43)</a>:</h4>
<p>Looking around in the library I found <code>fintype.card_eq</code> which says that if two <code>fintype</code>s have the same cardinality then there's an <code>equiv</code> between them, i.e. a bijection. I built the proof on that.</p>



<a name="215834845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215834845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215834845">(Nov 06 2020 at 11:44)</a>:</h4>
<p><code>s</code> is a finset so it's not a type, it's a term. The corresponding type is <code>S</code>.</p>



<a name="215846396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215846396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Busiso Chisala <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215846396">(Nov 06 2020 at 13:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/injective.20function/near/215834694">said</a>:</p>
<blockquote>
<p>Looking around in the library I found <code>fintype.card_eq</code> which says that if two <code>fintype</code>s have the same cardinality then there's an <code>equiv</code> between them, i.e. a bijection. I built the proof on that.</p>
</blockquote>
<p>Thanks ! I was about to moot an induction. This clears quite a few things <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="215851950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215851950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215851950">(Nov 06 2020 at 14:23)</a>:</h4>
<p>Can you use coe_sort <code>s</code> as the type instead rather than defining <code>S</code>? I can never remember how to input the coe_sort up arrow...</p>



<a name="215880740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215880740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215880740">(Nov 06 2020 at 17:51)</a>:</h4>
<p>Probably -- but I have exactly the same problem!</p>



<a name="215951299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/injective%20function/near/215951299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/injective.20function.html#215951299">(Nov 07 2020 at 11:42)</a>:</h4>
<p>Usually I resort to finding a lemma that does a coercion, and copying it from the goal window...</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
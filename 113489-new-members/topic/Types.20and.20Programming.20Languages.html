---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html">Types and Programming Languages</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="253182932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253182932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253182932">(Sep 14 2021 at 00:55)</a>:</h4>
<p>Did I set this up right? I'm having some trouble proving it.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Types and Programming Languages Kindle Edition by Benjamin C. Pierce (Author) Format: Kindle Edition</span>
<span class="c1">-- Theorem 3.3.4</span>

<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="n">false</span>
  <span class="bp">|</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">iszero</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">ite</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">t2</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">t3</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>


<span class="kd">def</span> <span class="n">size</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">-&gt;</span> <span class="n">nat</span>
  <span class="bp">|</span> <span class="n">term.true</span> <span class="o">:=</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">term.false</span> <span class="o">:=</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">term.zero</span> <span class="o">:=</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">term.succ</span> <span class="n">t1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">size</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">term.pred</span> <span class="n">t1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">size</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">term.iszero</span> <span class="n">t1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">size</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">term.ite</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">size</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">size</span> <span class="n">t2</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">size</span> <span class="n">t3</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>


<span class="c1">-- principle of complete mathematical induction</span>
<span class="kd">axiom</span> <span class="n">PCI</span> <span class="o">:</span>
<span class="k">forall</span> <span class="n">P</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="o">(</span><span class="k">forall</span> <span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="o">(</span><span class="k">forall</span> <span class="n">i</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">i</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span> <span class="bp">-&gt;</span>
<span class="k">forall</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span>


<span class="c1">-- induction on size</span>
<span class="kd">theorem</span> <span class="n">IOS</span> <span class="o">:</span>
<span class="k">forall</span> <span class="n">P</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="o">(</span><span class="k">forall</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="o">(</span><span class="k">forall</span> <span class="n">r</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">size</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">size</span> <span class="n">s</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">r</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span> <span class="bp">-&gt;</span>
<span class="k">forall</span> <span class="n">t</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">P</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">intros</span> <span class="n">P</span><span class="o">,</span>
<span class="k">let</span> <span class="n">Q</span> <span class="o">:=</span> <span class="k">fun</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="k">forall</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="o">(</span><span class="n">size</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">s</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="o">(</span><span class="k">forall</span> <span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="o">(</span><span class="k">forall</span> <span class="n">i</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">Q</span> <span class="n">i</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Q</span> <span class="n">m</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="k">forall</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">Q</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">PCI</span> <span class="n">Q</span><span class="o">,</span>
<span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="253184410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253184410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253184410">(Sep 14 2021 at 01:17)</a>:</h4>
<p>here's a more leanified version, and a good start on the problem. I removed the definition <code>Q</code> because it obscures more than it helps in this proof.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- principle of complete mathematical induction</span>
<span class="kd">theorem</span> <span class="n">PCI</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">nat.strong_induction_on</span> <span class="n">n</span> <span class="n">H</span>

<span class="c1">-- induction on size</span>
<span class="kd">theorem</span> <span class="n">IOS</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">size</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">size</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">PCI</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">size</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">t</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">m</span> <span class="n">ih</span> <span class="n">s</span> <span class="n">e</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="253185243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253185243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253185243">(Sep 14 2021 at 01:30)</a>:</h4>
<p>What is the <code>refine</code> tactic doing?</p>



<a name="253185651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253185651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253185651">(Sep 14 2021 at 01:36)</a>:</h4>
<p>It is like <code>exact</code>, but you can leave some holes using <code>_</code>. If Lean can't figure out what to put in place of those <code>_</code>, it doesn't throw an error, but creates a new goal instead.</p>



<a name="253185789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253185789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253185789">(Sep 14 2021 at 01:39)</a>:</h4>
<p>So is everything after PCI in that line, the hypotheses to PCI?</p>



<a name="253185986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253185986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253185986">(Sep 14 2021 at 01:42)</a>:</h4>
<p>yup</p>



<a name="253186556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253186556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253186556">(Sep 14 2021 at 01:52)</a>:</h4>
<p>Where do the <code>t</code> and the <code>rfl</code> line up?</p>



<a name="253186884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253186884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253186884">(Sep 14 2021 at 01:58)</a>:</h4>
<p><code>PCI</code> has three arguments, but the result is <code>P n</code>, and since in this case we substituted <code>λ (n : nat), ∀ s : term, size s = n → P s</code> for <code>P</code>, the result after substituting the first three arguments is <code>∀ s : term, size s = ?n → P s</code> and we have space to add two more arguments</p>



<a name="253187072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253187072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253187072">(Sep 14 2021 at 02:00)</a>:</h4>
<p>here's a more broken down version of the first line:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">),</span> <span class="n">size</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">size</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span> <span class="o">:=</span>
    <span class="n">PCI</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">size</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="n">size</span> <span class="n">t</span><span class="o">),</span>
  <span class="n">refine</span> <span class="n">this</span> <span class="n">t</span> <span class="n">rfl</span><span class="o">,</span>
</code></pre></div>



<a name="253187213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253187213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253187213">(Sep 14 2021 at 02:02)</a>:</h4>
<p>I see. Thank you.</p>



<a name="253188121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253188121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253188121">(Sep 14 2021 at 02:19)</a>:</h4>
<p>Thank you!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- induction on size</span>
<span class="kd">theorem</span> <span class="n">IOS</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">size</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">size</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">PCI</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">size</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">t</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">m</span> <span class="n">ih</span> <span class="n">s</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">r</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">ih</span> <span class="o">(</span><span class="n">size</span> <span class="n">r</span><span class="o">)),</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kd">end</span>
</code></pre></div>



<a name="253190318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253190318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253190318">(Sep 14 2021 at 02:57)</a>:</h4>
<p>Good job. Now, the cheating way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">IOS</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">size</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">size</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">t</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">measure_wf</span> <span class="n">size</span><span class="o">)</span><span class="bp">.</span><span class="n">induction</span> <span class="n">t</span> <span class="n">H</span>
</code></pre></div>



<a name="253190427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253190427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253190427">(Sep 14 2021 at 02:58)</a>:</h4>
<p>(There are even more cheating ways when you notice that <code>size</code> is the same as <code>term.sizeof</code>, and indeed this particular theorem is applied automatically by lean when you write functions by well founded recursion using the equation compiler.)</p>



<a name="253190875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253190875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253190875">(Sep 14 2021 at 03:04)</a>:</h4>
<p>here's a golfy proof more similar to yours:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">IOS</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">size</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">size</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">PCI</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">size</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="n">size</span> <span class="n">t</span><span class="o">)</span> <span class="n">t</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">m</span> <span class="n">ih</span> <span class="n">s</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">H</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">r</span> <span class="n">h</span><span class="o">,</span> <span class="n">ih</span> <span class="n">_</span> <span class="n">h</span> <span class="n">r</span> <span class="n">rfl</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="253875476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253875476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253875476">(Sep 18 2021 at 15:26)</a>:</h4>
<p>The book defines structural induction as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">If</span><span class="o">,</span> <span class="n">for</span> <span class="n">each</span> <span class="n">term</span> <span class="n">s</span><span class="o">,</span>
<span class="n">given</span> <span class="n">P</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="n">for</span> <span class="n">all</span> <span class="n">immediate</span> <span class="n">subterms</span> <span class="n">r</span> <span class="n">of</span> <span class="n">s</span> <span class="n">we</span> <span class="n">can</span> <span class="k">show</span> <span class="n">P</span><span class="o">(</span><span class="n">s</span><span class="o">),</span>
<span class="k">then</span> <span class="n">P</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="n">holds</span> <span class="n">for</span> <span class="n">all</span> <span class="n">s.</span>
</code></pre></div>
<p>How does one formalize this and show that it follows from weak mathematical induction? Do I define a function <code>is_immediate_subterm : term -&gt; term -&gt; Prop</code> and then:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">forall</span> <span class="n">P</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="o">(</span><span class="k">forall</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="o">(</span><span class="k">forall</span> <span class="n">r</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="o">(</span><span class="n">is_immediate_subterm</span> <span class="n">r</span> <span class="n">s</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">r</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span> <span class="bp">-&gt;</span>
<span class="k">forall</span> <span class="n">t</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">P</span> <span class="n">t</span>
</code></pre></div>
<p>Also, I'm not sure how to go about defining a function <code>f : term -&gt; nat</code> such that <code>f s = (f r) + 1 iff (is_immediate_subterm r s)</code> to use to show that it follows from weak mathematical induction, if that is what I need to do.</p>



<a name="253875977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253875977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253875977">(Sep 18 2021 at 15:37)</a>:</h4>
<p>There might be an even more primitive way of doing this in mathlib, but in core this is done with <a href="https://github.com/leanprover-community/lean/blob/master/library/init/wf.lean">acc</a> and its recursor, then <code>measure_wf</code>, and <code>sizeof_measure_wf</code>, which are other helper functions/lemmas in that file. <code>sizeof</code> is automatically generated for inductives, I think the general rule is just that <code>forall a, sizeof(ctor(a)) = sizeof(a) + 1</code>.</p>



<a name="253876094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253876094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253876094">(Sep 18 2021 at 15:39)</a>:</h4>
<p>Actually it looks like sizeof is defined manually for some primitives, like list and option.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">option.sizeof</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">has_sizeof</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">none</span>     <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">sizeof</span> <span class="n">a</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">list.sizeof</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">has_sizeof</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span>        <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">list.cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">sizeof</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">list.sizeof</span> <span class="n">l</span>
</code></pre></div>



<a name="253876669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253876669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253876669">(Sep 18 2021 at 15:49)</a>:</h4>
<p>That's just because they are needed during bootstrapping. They would normally be created automatically but the sizeof framework isn't yet set up when those inductives are introduced.</p>



<a name="253876857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253876857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253876857">(Sep 18 2021 at 15:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/Types.20and.20Programming.20Languages/near/253875476">said</a>:</p>
<blockquote>
<p>The book defines structural induction as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">If</span><span class="o">,</span> <span class="n">for</span> <span class="n">each</span> <span class="n">term</span> <span class="n">s</span><span class="o">,</span>
<span class="n">given</span> <span class="n">P</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="n">for</span> <span class="n">all</span> <span class="n">immediate</span> <span class="n">subterms</span> <span class="n">r</span> <span class="n">of</span> <span class="n">s</span> <span class="n">we</span> <span class="n">can</span> <span class="k">show</span> <span class="n">P</span><span class="o">(</span><span class="n">s</span><span class="o">),</span>
<span class="k">then</span> <span class="n">P</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="n">holds</span> <span class="n">for</span> <span class="n">all</span> <span class="n">s.</span>
</code></pre></div>
<p>How does one formalize this and show that it follows from weak mathematical induction?</p>
</blockquote>
<p>In lean, this is the wrong way around. Structural induction is <em>primitive</em>; it is true by the axioms associated to each inductive type. Weak induction on nat is a special case of structural induction, as is induction on <code>acc</code> which yields well founded recursion, which proves strong induction using <code>sizeof</code>.</p>



<a name="253876971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253876971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253876971">(Sep 18 2021 at 15:54)</a>:</h4>
<p>The shape of each structural induction theorem looks a little different since it depends on how the inductive is defined. Try <code>#print term.rec</code> to see what it looks like for <code>term</code>.</p>



<a name="253877572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253877572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253877572">(Sep 18 2021 at 16:04)</a>:</h4>
<p>Can it still be proven this way around?</p>



<a name="253878082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253878082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253878082">(Sep 18 2021 at 16:13)</a>:</h4>
<p>The easiest way to prove a theorem using <code>is_immediate_subterm</code> is to define it as an inductive family and then prove it using <code>term.rec</code></p>



<a name="253878287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253878287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253878287">(Sep 18 2021 at 16:16)</a>:</h4>
<p>I guess I'm trying to do the exercise in the book, to prove that it follows from weak mathematical induction, similar to the earlier proof using size.</p>



<a name="253878313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253878313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253878313">(Sep 18 2021 at 16:17)</a>:</h4>
<p>It's not possible to do this from weak nat recursion directly, because one term can have two immediate subterm of different heights. For example <code>ite true (succ zero) zero</code> yields the relations:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">f</span> <span class="o">(</span><span class="n">ite</span> <span class="n">true</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">)</span> <span class="n">zero</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="n">f</span> <span class="o">(</span><span class="n">ite</span> <span class="n">true</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">)</span> <span class="n">zero</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">zero</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="n">f</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">zero</span> <span class="bp">+</span> <span class="mi">1</span>
</code></pre></div>
<p>which are clearly unsolvable. The easy way to derive this using PCI is to just use strong recursion on terms and use that "immediate subterm" implies sizeof strict inequality.</p>



<a name="253878929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253878929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253878929">(Sep 18 2021 at 16:28)</a>:</h4>
<p>I'm sorry, what does strong recursion on terms mean?<br>
Do you mean, define the function <code>is_immediate_subterm: term -&gt; term -&gt; Prop</code>, then prove <code>forall r, s : term, is_immediate_subterm r s -&gt; size r &lt; size s</code>. Then proceed as in the earlier proof?</p>



<a name="253880822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253880822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253880822">(Sep 18 2021 at 17:03)</a>:</h4>
<p>Like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kd">constant</span> <span class="n">size</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">ℕ</span>

<span class="kd">constant</span> <span class="n">is_immediate_subterm</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="kd">lemma</span> <span class="n">subterm_size</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_immediate_subterm</span> <span class="n">r</span> <span class="n">s</span> <span class="bp">-&gt;</span> <span class="n">size</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">size</span> <span class="n">s</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- principle of complete mathematical induction</span>
<span class="kd">theorem</span> <span class="n">PCI</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">nat.strong_induction_on</span> <span class="n">n</span> <span class="n">H</span>

<span class="kd">theorem</span> <span class="n">SI</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">is_immediate_subterm</span> <span class="n">r</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">PCI</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">size</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">t</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">m</span> <span class="n">ih</span> <span class="n">s</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">r</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">ih</span> <span class="o">(</span><span class="n">size</span> <span class="n">r</span><span class="o">)),</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">subterm_size</span> <span class="n">r</span> <span class="n">s</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">refl</span>
<span class="kd">end</span>
</code></pre></div>



<a name="253881484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253881484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253881484">(Sep 18 2021 at 17:15)</a>:</h4>
<p>Thank you. I thought it was more complicated and was heading in the wrong direction.</p>



<a name="253881702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253881702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253881702">(Sep 18 2021 at 17:19)</a>:</h4>
<p>You can actually just apply the previous theorem instead of replaying it</p>



<a name="253881774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/253881774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#253881774">(Sep 18 2021 at 17:20)</a>:</h4>
<p>Yeah, that probably would have been simpler :)</p>



<a name="254792764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254792764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254792764">(Sep 25 2021 at 00:37)</a>:</h4>
<p>3.2.1 Definition [Terms, Inductively]: The set of terms is the smallest set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> such that</p>
<ol>
<li>{true, false, 0} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\subseteq T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>;</li>
<li>if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t_{1} \in T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>, then {succ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, pred <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, iszero <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\subseteq T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>;</li>
<li>if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t_{1} \in T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t_{2} \in T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>3</mn></msub><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t_{3} \in T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>, then if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> else <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">t_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\in T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>.</li>
</ol>
<p>I think the equivalent of Definition 3.2.1 in Lean is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="n">false</span>
  <span class="bp">|</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">iszero</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">ite</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">t2</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">t3</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>
</code></pre></div>
<p>In a similar manner, Is there an equivalent of Definition 3.2.3 in Lean? By equivalent I mean as a translation from set theory to type theory, not the fact that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> are the same set.</p>
<p>3.2.3 Definition [Terms, Concretely]: For each natural number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>, define a set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as follows:<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">S_{0} = \empty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> = {true, false, 0} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∪</span></span></span></span> {succ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, pred <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, iszero <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>t</mi><mn>1</mn></msub><mo>∈</mo><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_{1} | t_{1} \in S_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∪</span></span></span></span> {if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> else <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">t_{3} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>| <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>3</mn></msub><mo>∈</mo><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_{1}, t_{2}, t_{3} \in S_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>}.<br>
Finally, let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo>⋃</mo><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S = \bigcup S_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>



<a name="254793413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254793413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254793413">(Sep 25 2021 at 00:45)</a>:</h4>
<p>Maybe the Lean definition I gave goes with definition 3.2.3 and the question is about an equivalent Lean definition for 3.2.1? I'm not certain.</p>



<a name="254794545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254794545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254794545">(Sep 25 2021 at 01:02)</a>:</h4>
<p>The Lean translation looks good. Definition 3.2.3 is a standard way in set theory to justify Definition 3.2.1, which is not complete as it stands (because a priori there might not be any set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> with this property). You could try to imitate Definition 3.2.3 in Lean, but it would be awkward and it's probably more sensible to just accept that the basic building blocks of type theory are different from in set theory.</p>



<a name="254794927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254794927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254794927">(Sep 25 2021 at 01:08)</a>:</h4>
<p>I see. Thank you!</p>



<a name="254795175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254795175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254795175">(Sep 25 2021 at 01:12)</a>:</h4>
<p>Something like this perhaps?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set</span>
<span class="kn">open</span> <span class="n">set</span>


<span class="c1">-- Terms, Inductively</span>

<span class="kd">constant</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">string</span>

<span class="kd">def</span> <span class="n">rule_1</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">string</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="s2">"true"</span><span class="o">,</span> <span class="s2">"false"</span><span class="o">,</span> <span class="s2">"zero"</span><span class="o">}</span> <span class="bp">⊆</span> <span class="n">S</span>
<span class="kd">def</span> <span class="n">rule_2</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">string</span><span class="o">)</span> <span class="o">:=</span> <span class="k">forall</span> <span class="n">t1</span> <span class="o">:</span> <span class="n">string</span><span class="o">,</span> <span class="n">t1</span> <span class="bp">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="o">{</span><span class="s2">"succ"</span> <span class="bp">++</span> <span class="n">t1</span><span class="o">,</span> <span class="s2">"pred"</span> <span class="bp">++</span> <span class="n">t1</span><span class="o">,</span> <span class="s2">"iszero"</span> <span class="bp">++</span> <span class="n">t1</span><span class="o">}</span> <span class="bp">⊆</span> <span class="n">S</span>
<span class="kd">def</span> <span class="n">rule_3</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">string</span><span class="o">)</span> <span class="o">:=</span> <span class="k">forall</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span> <span class="o">:</span> <span class="n">string</span><span class="o">,</span> <span class="s2">"ite"</span> <span class="bp">++</span> <span class="n">t1</span> <span class="bp">++</span> <span class="n">t2</span> <span class="bp">++</span> <span class="n">t3</span> <span class="bp">∈</span> <span class="n">S</span>

<span class="kd">constant</span> <span class="n">holds</span> <span class="o">:</span> <span class="n">rule_1</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">rule_2</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">rule_3</span> <span class="n">T</span>
<span class="kd">constant</span> <span class="n">smallest</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">string</span><span class="o">,</span> <span class="n">rule_1</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">rule_2</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">rule_3</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">T</span> <span class="bp">⊆</span> <span class="n">S</span>


<span class="c1">-- Terms, Concretely</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">string</span>
  <span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="bp">∅</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
      <span class="o">{</span><span class="s2">"true"</span><span class="o">,</span> <span class="s2">"false"</span><span class="o">,</span> <span class="s2">"zero"</span><span class="o">}</span>
      <span class="bp">∪</span> <span class="o">{(</span><span class="s2">"succ"</span> <span class="bp">++</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">|</span> <span class="n">t1</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">i</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{(</span><span class="s2">"pred"</span> <span class="bp">++</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">|</span> <span class="n">t1</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">i</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{(</span><span class="s2">"iszero"</span> <span class="bp">++</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">|</span> <span class="n">t1</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">i</span><span class="o">}</span>
      <span class="bp">∪</span> <span class="o">{(</span><span class="s2">"ite"</span> <span class="bp">++</span> <span class="n">t1</span> <span class="bp">++</span> <span class="n">t2</span> <span class="bp">++</span> <span class="n">t3</span><span class="o">)</span> <span class="bp">|</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">i</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">S</span> <span class="o">:=</span> <span class="bp">⋃</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">S</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="254797761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254797761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254797761">(Sep 25 2021 at 01:54)</a>:</h4>
<p>It seems you've forgotten spaces between terms. Also, <code>holds</code> seems odd (maybe you meant conjunctions?), and rather than introducing <code>smallest</code> and <code>T</code> as constants, you can prove that <code>S</code> is smallest as a theorem, replacing the <code>example</code>.</p>
<p>One downside with strings is that to be able to use them as terms you have to go through the effort of parsing them.</p>



<a name="254797981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254797981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254797981">(Sep 25 2021 at 01:57)</a>:</h4>
<p>What would be a good alternative to strings?</p>



<a name="254798357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254798357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254798357">(Sep 25 2021 at 02:02)</a>:</h4>
<p>Yes, you are right, I should have defined <code>holds</code> with conjunctions.</p>



<a name="254798509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254798509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254798509">(Sep 25 2021 at 02:04)</a>:</h4>
<p>One option is to add enough parenthesis so parsing is easy (though you still would want to parse). It can also be nice to add some functions to make sure you generate the correct syntax.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kn">namespace</span> <span class="n">pre_term</span>
<span class="kd">def</span> <span class="n">true</span> <span class="o">:=</span> <span class="s2">"true"</span>
<span class="kd">def</span> <span class="n">false</span> <span class="o">:=</span> <span class="s2">"false"</span>
<span class="kd">def</span> <span class="n">zero</span> <span class="o">:=</span> <span class="s2">"zero"</span>
<span class="kd">def</span> <span class="n">succ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:=</span> <span class="s2">"(succ "</span> <span class="bp">++</span> <span class="n">s</span> <span class="bp">++</span> <span class="s2">")"</span>
<span class="kd">def</span> <span class="n">pred</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:=</span> <span class="s2">"(pred "</span> <span class="bp">++</span> <span class="n">s</span> <span class="bp">++</span> <span class="s2">")"</span>
<span class="kd">def</span> <span class="n">iszero</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:=</span> <span class="s2">"(iszero "</span> <span class="bp">++</span> <span class="n">s</span> <span class="bp">++</span> <span class="s2">")"</span>
<span class="kd">def</span> <span class="n">ite</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="n">u</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:=</span> <span class="s2">"(ite "</span> <span class="bp">++</span> <span class="n">s</span> <span class="bp">++</span> <span class="s2">" "</span> <span class="bp">++</span> <span class="n">t</span> <span class="bp">++</span> <span class="s2">" "</span> <span class="bp">++</span> <span class="n">u</span> <span class="bp">++</span> <span class="s2">")"</span>
<span class="kd">end</span> <span class="n">pre_term</span>

<span class="kd">def</span> <span class="n">rule_1</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">string</span> <span class="o">:=</span> <span class="o">{</span><span class="n">pre_term.true</span><span class="o">,</span> <span class="n">pre_term.false</span><span class="o">,</span> <span class="n">pre_term.zero</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">rule_2</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">string</span> <span class="o">:=</span>
<span class="o">{(</span><span class="n">pre_term.succ</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">|</span> <span class="n">t1</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{(</span><span class="n">pre_term.pred</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">|</span> <span class="n">t1</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{(</span><span class="n">pre_term.iszero</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">|</span> <span class="n">t1</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">rule_3</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">string</span> <span class="o">:=</span> <span class="o">{(</span><span class="n">pre_term.ite</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span><span class="o">)</span> <span class="bp">|</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">string</span>
  <span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="bp">∅</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rule_1</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∪</span> <span class="n">rule_2</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∪</span> <span class="n">rule_3</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">S</span> <span class="o">:=</span> <span class="bp">⋃</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span>

<span class="kd">theorem</span> <span class="n">holds</span> <span class="o">:</span> <span class="n">rule_1</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="bp">∧</span> <span class="n">rule_2</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="bp">∧</span> <span class="n">rule_3</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">theorem</span> <span class="n">smallest</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">string</span><span class="o">),</span> <span class="n">rule_1</span> <span class="n">T</span> <span class="bp">⊆</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">rule_2</span> <span class="n">T</span> <span class="bp">⊆</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">rule_3</span> <span class="n">T</span> <span class="bp">⊆</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="254798672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254798672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254798672">(Sep 25 2021 at 02:06)</a>:</h4>
<p>And then you could go on to create the subtype of those strings that are in <code>S</code> and make all the constructors:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">S</span> <span class="c1">-- this is the set coerced to a type</span>

<span class="kn">namespace</span> <span class="n">term</span>
<span class="kd">def</span> <span class="n">true</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pre_term.true</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">use</span> <span class="o">(</span><span class="n">f</span> <span class="mi">1</span><span class="o">),</span> <span class="n">simp</span> <span class="o">[</span><span class="n">f</span><span class="o">,</span> <span class="n">rule_1</span><span class="o">],</span> <span class="n">use</span> <span class="mi">1</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="kd">end</span><span class="o">⟩</span> <span class="c1">-- (not a very pretty proof)</span>
<span class="kd">def</span> <span class="n">false</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">succ</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">pred</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">iszero</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">ite</span> <span class="o">(</span><span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">end</span> <span class="n">term</span>
</code></pre></div>



<a name="254799070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254799070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254799070">(Sep 25 2021 at 02:13)</a>:</h4>
<p>Cool. Thank you!</p>



<a name="254799383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254799383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254799383">(Sep 25 2021 at 02:18)</a>:</h4>
<p>This is another setup that I'd expect to be somewhat easier to parse (and by "parse" I mean writing the recursor). It uses lists of symbols:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kd">inductive</span> <span class="n">symb</span>
<span class="bp">|</span> <span class="n">true</span> <span class="bp">|</span> <span class="n">false</span> <span class="bp">|</span> <span class="n">zero</span> <span class="bp">|</span> <span class="n">succ</span> <span class="bp">|</span> <span class="n">pred</span> <span class="bp">|</span> <span class="n">iszero</span> <span class="bp">|</span> <span class="n">ite</span>

<span class="kn">namespace</span> <span class="n">pre_term</span>
<span class="kd">def</span> <span class="n">true</span> <span class="o">:=</span> <span class="o">[</span><span class="n">symb.true</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">false</span> <span class="o">:=</span> <span class="o">[</span><span class="n">symb.false</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">zero</span> <span class="o">:=</span> <span class="o">[</span><span class="n">symb.zero</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">succ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">symb</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="n">symb.succ</span><span class="o">]</span> <span class="bp">++</span> <span class="n">s</span>
<span class="kd">def</span> <span class="n">pred</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">symb</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="n">symb.pred</span><span class="o">]</span> <span class="bp">++</span> <span class="n">s</span>
<span class="kd">def</span> <span class="n">iszero</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">symb</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="n">symb.iszero</span><span class="o">]</span> <span class="bp">++</span> <span class="n">s</span>
<span class="kd">def</span> <span class="n">ite</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="n">u</span> <span class="o">:</span> <span class="n">list</span> <span class="n">symb</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="n">symb.ite</span><span class="o">]</span> <span class="bp">++</span> <span class="n">s</span> <span class="bp">++</span> <span class="n">t</span> <span class="bp">++</span> <span class="n">u</span>
<span class="kd">end</span> <span class="n">pre_term</span>

<span class="kd">def</span> <span class="n">rule_1</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">list</span> <span class="n">symb</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">pre_term.true</span><span class="o">,</span> <span class="n">pre_term.false</span><span class="o">,</span> <span class="n">pre_term.zero</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">rule_2</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">list</span> <span class="n">symb</span><span class="o">))</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">list</span> <span class="n">symb</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{(</span><span class="n">pre_term.succ</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">|</span> <span class="n">t1</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{(</span><span class="n">pre_term.pred</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">|</span> <span class="n">t1</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{(</span><span class="n">pre_term.iszero</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">|</span> <span class="n">t1</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">rule_3</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">list</span> <span class="n">symb</span><span class="o">))</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">list</span> <span class="n">symb</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{(</span><span class="n">pre_term.ite</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span><span class="o">)</span> <span class="bp">|</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">set</span> <span class="o">(</span><span class="n">list</span> <span class="n">symb</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="bp">∅</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rule_1</span> <span class="bp">∪</span> <span class="n">rule_2</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∪</span> <span class="n">rule_3</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">S</span> <span class="o">:=</span> <span class="bp">⋃</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span>

<span class="kd">theorem</span> <span class="n">holds</span> <span class="o">:</span> <span class="n">rule_1</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="bp">∧</span> <span class="n">rule_2</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="bp">∧</span> <span class="n">rule_3</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">theorem</span> <span class="n">smallest</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">list</span> <span class="n">symb</span><span class="o">)),</span> <span class="n">rule_1</span> <span class="bp">⊆</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">rule_2</span> <span class="n">T</span> <span class="bp">⊆</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">rule_3</span> <span class="n">T</span> <span class="bp">⊆</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">S</span>

<span class="kn">namespace</span> <span class="n">term</span>
<span class="kd">def</span> <span class="n">true</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pre_term.true</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">use</span> <span class="o">(</span><span class="n">f</span> <span class="mi">1</span><span class="o">),</span> <span class="n">simp</span> <span class="o">[</span><span class="n">f</span><span class="o">,</span> <span class="n">rule_1</span><span class="o">],</span> <span class="n">use</span> <span class="mi">1</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="kd">end</span><span class="o">⟩</span>
<span class="kd">def</span> <span class="n">false</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">succ</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">pred</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">iszero</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">ite</span> <span class="o">(</span><span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">end</span> <span class="n">term</span>
</code></pre></div>



<a name="254799667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254799667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254799667">(Sep 25 2021 at 02:23)</a>:</h4>
<p>Nice!</p>



<a name="254943607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254943607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254943607">(Sep 26 2021 at 16:30)</a>:</h4>
<p>Going back to the discussion on induction; in set theory, the principle of mathematical induction follows from the well ordering principle, and is equivalent to complete mathematical induction. In addition, we have just shown that structural induction follows from complete mathematical induction. Do all forms of induction in set theory then follow from the well ordering principle? What about induction on inductively defined propositions? Can I formalize and show this in Lean?</p>



<a name="254943746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254943746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254943746">(Sep 26 2021 at 16:32)</a>:</h4>
<p>I'm not sure how to formalize the well ordering principle in Lean, or what a generic formalization of induction on inductively defined propositions would look like, in a vein similar to:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">forall</span> <span class="n">P</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="o">(</span><span class="k">forall</span> <span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="o">(</span><span class="k">forall</span> <span class="n">i</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">i</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span> <span class="bp">-&gt;</span>
<span class="k">forall</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span>
</code></pre></div>



<a name="254944801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254944801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254944801">(Sep 26 2021 at 16:49)</a>:</h4>
<p>That is, I think we have that all of these are equivalent:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Principle of Mathematical Induction</span>
<span class="kd">def</span> <span class="n">PMI</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">P</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">P</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">→</span>
<span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span>


<span class="c1">-- Principle of Induction from a Starting Point</span>
<span class="kd">def</span> <span class="n">SP</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">P</span> <span class="n">m</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≥</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">P</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="bp">→</span>
<span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span>


<span class="c1">-- Principle of Complete Induction</span>
<span class="kd">def</span> <span class="n">PCI</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span>
<span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span>


<span class="c1">-- Structural induction</span>

<span class="kd">constant</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">size</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">-&gt;</span> <span class="n">ℕ</span>
<span class="kd">constant</span> <span class="n">is_immediate_subterm</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">-&gt;</span> <span class="n">term</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span>

<span class="kd">lemma</span> <span class="n">subterm_size</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">is_immediate_subterm</span> <span class="n">r</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">size</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">size</span> <span class="n">s</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">SI</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">is_immediate_subterm</span> <span class="n">r</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span> <span class="bp">-&gt;</span>
<span class="bp">∀</span> <span class="n">t</span> <span class="o">:</span> <span class="n">term</span><span class="o">,</span> <span class="n">P</span> <span class="n">t</span>
</code></pre></div>
<p>How do we formalize the well ordering principle to show that they all follow from it, and also give a similar formal definition of induction over an inductively defined proposition and show that it follows as well.</p>



<a name="254945847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254945847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254945847">(Sep 26 2021 at 17:04)</a>:</h4>
<p>Proving that <code>PMI</code> follows from well-ordering is as interesting as showing <code>true</code> follows from it, because PMI is true by definition of <code>nat.rec</code></p>



<a name="254945975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254945975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254945975">(Sep 26 2021 at 17:07)</a>:</h4>
<p>If you want to prove the recursor of nat (<code>PMI</code>) follows from something more fundamental, then you can't use the built-in definition of <code>nat</code> or any similar inductive definition of nat because such a definition introduces <code>PMI</code> as an "axiom".</p>



<a name="254946238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254946238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254946238">(Sep 26 2021 at 17:10)</a>:</h4>
<p>I guess I'm not sure how to define <code>nat</code> in Lean in set theoretical terms, and figured I just wouldn't use that fact.</p>



<a name="254946264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254946264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254946264">(Sep 26 2021 at 17:11)</a>:</h4>
<p>But I would be interested in seeing it in Lean in set theoretical terms.</p>



<a name="254946670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254946670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254946670">(Sep 26 2021 at 17:17)</a>:</h4>
<p>Or just how to add in induction on inductively defined propositions with it as it is.</p>



<a name="254947657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254947657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254947657">(Sep 26 2021 at 17:32)</a>:</h4>
<p>Something like?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">constant</span> <span class="n">nat</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">le</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kd">constant</span> <span class="n">lt</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="kd">def</span> <span class="n">WOP</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">nat</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">t</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">u</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">u</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">def</span> <span class="n">PCI</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">lt</span> <span class="n">i</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span>
<span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">WOP</span> <span class="bp">→</span> <span class="n">PCI</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="254952297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254952297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254952297">(Sep 26 2021 at 18:42)</a>:</h4>
<p>That looks unprovable because you have nothing saying how <code>lt</code> and <code>le</code> interact.</p>



<a name="254954441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254954441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254954441">(Sep 26 2021 at 19:13)</a>:</h4>
<p>I was just throwing it together leaving them to be defined.</p>



<a name="254954578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254954578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254954578">(Sep 26 2021 at 19:15)</a>:</h4>
<p>The question I am most interested in, is how to similarly formalize and show (if it holds true) that induction on inductively defined propositions is related to mathematical induction.</p>



<a name="254955488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254955488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254955488">(Sep 26 2021 at 19:29)</a>:</h4>
<p>For example, what is the form of the induction principle on <code>step</code> and can it be related to the principle of mathematical induction:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="n">false</span>
  <span class="bp">|</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">iszero</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">ite</span> <span class="o">(</span><span class="n">t1</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">t2</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">t3</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span>

<span class="c1">-- step x y means that (x, y) is in the evaluation relation</span>
<span class="kd">inductive</span> <span class="n">step</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
  <span class="bp">|</span> <span class="n">e_if_true</span> <span class="o">(</span><span class="n">t2</span> <span class="n">t3</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">step</span> <span class="o">(</span><span class="n">term.ite</span> <span class="n">term.true</span> <span class="n">t2</span> <span class="n">t3</span><span class="o">)</span> <span class="n">t2</span>
  <span class="bp">|</span> <span class="n">e_if_false</span> <span class="o">(</span><span class="n">t2</span> <span class="n">t3</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">step</span> <span class="o">(</span><span class="n">term.ite</span> <span class="n">term.false</span> <span class="n">t2</span> <span class="n">t3</span><span class="o">)</span> <span class="n">t3</span>
  <span class="bp">|</span> <span class="n">e_if</span> <span class="o">(</span><span class="n">t1</span> <span class="n">t1'</span> <span class="n">t2</span> <span class="n">t3</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">step</span> <span class="n">t1</span> <span class="n">t1'</span> <span class="bp">→</span> <span class="n">step</span> <span class="o">(</span><span class="n">term.ite</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span><span class="o">)</span> <span class="o">(</span><span class="n">term.ite</span> <span class="n">t1'</span> <span class="n">t2</span> <span class="n">t3</span><span class="o">)</span>
</code></pre></div>



<a name="254959076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254959076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254959076">(Sep 26 2021 at 20:21)</a>:</h4>
<p>You can ask lean for the "form of induction principle on <code>step</code>" with <code>#check @step.rec</code></p>



<a name="254959306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254959306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254959306">(Sep 26 2021 at 20:24)</a>:</h4>
<p>Can that induction principle be shown to follow from one of the others?</p>



<a name="254959439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254959439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254959439">(Sep 26 2021 at 20:26)</a>:</h4>
<p>If it can be shown, you can't write the proof in lean itself while keeping that definition of <code>step</code>.</p>



<a name="254959558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254959558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254959558">(Sep 26 2021 at 20:28)</a>:</h4>
<p>You'd need to formalize the rules of inductive types in lean itself, and describe <code>step</code> in <em>that</em> language in order to use Lean to show what you're asking.</p>



<a name="254959864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254959864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254959864">(Sep 26 2021 at 20:33)</a>:</h4>
<p>I am guessing that there is an axiom in Lean that all of the various forms of induction in Lean follow from?</p>



<a name="254962525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254962525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254962525">(Sep 26 2021 at 21:13)</a>:</h4>
<p>Every time you use the keyword <code>inductive</code> or <code>structure</code> or <code>class</code> you are essentially introducing a new recursor "axiom" (but not <code>axiom</code>) into lean</p>



<a name="254962745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254962745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254962745">(Sep 26 2021 at 21:16)</a>:</h4>
<p>What ensures that they are permissible?</p>



<a name="254963140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254963140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254963140">(Sep 26 2021 at 21:22)</a>:</h4>
<p>The rules that dictate what is and is not a valid (non-<code>meta</code>)<code>inductive</code> type ensure they are permissible. Lean itself does not provide a proof that they are permissible, that's the foundation you as the user are putting your trust upon.</p>



<a name="254963312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254963312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254963312">(Sep 26 2021 at 21:25)</a>:</h4>
<p>I would expect the paper on lean itself to provide ample references to how exactly that foundation is justified mathematically; but I think those were already linked in your other thread?</p>



<a name="254963700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20and%20Programming%20Languages/near/254963700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20and.20Programming.20Languages.html#254963700">(Sep 26 2021 at 21:32)</a>:</h4>
<p>I see.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
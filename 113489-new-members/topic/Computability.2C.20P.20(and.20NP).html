---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html">Computability, P (and NP)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="208327235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208327235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208327235">(Aug 28 2020 at 10:40)</a>:</h4>
<p>Hi all,<br>
Me and <span class="user-mention" data-user-id="320867">@Daan van Gent</span> have been working on trying to define problems, P and hopefully even NP. We were wondering how exactly this process of development should go, as we feel this subject is something that eventually should be in mathlib.</p>
<p>Right now, our questions are: when is a first version ready to be pushed to mathlib? There are already some definitions and theorems that we believe to be of interest, could they already be PR'ed? Is there stuff that we need to do before it's ready to be PR'ed?  Basically, this is something we're having fun with and want to continue, but we don't know how the process works exactly.</p>
<p>For the interested reader, the state of the project right now: we have forked mathlib to <a href="https://github.com/pimsp/mathlib">this repository</a>, and while this is very much a work in progress (we're doing a partial refactoring now), we currently have</p>
<ul>
<li>A definition of problem</li>
<li>A definition of reduction</li>
<li>A definition of computable (in polytime) (using Turing machines)</li>
<li>
<p>A definition of P<br>
and the lemma's</p>
</li>
<li>
<p>A proof that the identity is (polytime) computable</p>
</li>
<li>A proof that the problem on <code>bool</code> with <code>tt</code> being the only yes-instance is in P<br>
Also, on the TM front we're working on increasing the functional power of a Turing machine, for example by making a call stack and formalising libraries (both still very much a work in progress).</li>
</ul>
<p>Our goals (in order of short term to long term):</p>
<ul>
<li>Prove that the composition of (polytime) computable functions is (polytime) computable (this will give that a problem reducing to a problem in P is itself in P)</li>
<li>Prove that all four problems on <code>bool</code> are in P</li>
<li>Prove that is_even is in P</li>
<li>Prove that is_odd is in P by giving a reduction to is_even</li>
<li>Define NP (this should be very doable already)</li>
<li>Show that P is a subset of NP</li>
<li>Define NPC</li>
<li>Enhance the functional power of Turing machines further</li>
<li>Prove that SAT is in NPC</li>
</ul>



<a name="208328324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208328324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208328324">(Aug 28 2020 at 10:55)</a>:</h4>
<p>Wow! That's a huge list. You make it seem like the LftCM workshop was ages ago!</p>



<a name="208328400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208328400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208328400">(Aug 28 2020 at 10:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Is probably the maintainer who knows best how and what and where this should go in mathlib. He wrote most of the compu/TM stuff that is in mathlib</p>



<a name="208328469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208328469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208328469">(Aug 28 2020 at 10:57)</a>:</h4>
<p>Concerning PR's, just to get a feeling for the process, I would start with a very small PR (say 30 lines).<br>
In general we encourage PRs to be at most (say, roughly) 300 lines. [Of course there are exceptions.]</p>



<a name="208330901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208330901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208330901">(Aug 28 2020 at 11:31)</a>:</h4>
<p>"early and often" is the advice for PRs, I think. As soon as something feels a bit stable (e.g. you've already been through one cycle of throwing it out in disgust and starting over, but this time the next few steps seem to work as well), try to split off that chunk of your work into a PR.</p>



<a name="208379437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208379437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208379437">(Aug 28 2020 at 18:33)</a>:</h4>
<p>I would have suggested a PR by about the second item on the list</p>



<a name="208379464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208379464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208379464">(Aug 28 2020 at 18:33)</a>:</h4>
<p>it sounds like you have 5 or 6 PR's here</p>



<a name="208379842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208379842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208379842">(Aug 28 2020 at 18:36)</a>:</h4>
<p>oops, I missed that the second half is only goals and not completed stuff. I would suggest 2 PR's, one for the definition of P and one for work on the TM library</p>



<a name="208428822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208428822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208428822">(Aug 29 2020 at 11:11)</a>:</h4>
<p>Thanks for all the advice! I didn't mention this, but we work with self-defined encodings instead of encodables (the encodable seems to be better suited for partial recursive functions than Turing machines). This has already been refactored and used, so could that be the first PR? And for the second PR, we can probably do the definitions of (polytime) computable by a Turing machine and the definition of P. Does that make sense?</p>



<a name="208428880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208428880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208428880">(Aug 29 2020 at 11:12)</a>:</h4>
<p>By the way, how do I PR something? Is there a link somewhere where it's explained?</p>



<a name="208428936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208428936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208428936">(Aug 29 2020 at 11:14)</a>:</h4>
<p>You can start <a href="https://leanprover-community.github.io/contribute/index.html">here</a>. Feel free to ask for clarification or help if anything is unclear!</p>



<a name="208432480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208432480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208432480">(Aug 29 2020 at 12:54)</a>:</h4>
<p>Thanks, that's really useful! I see we do need write access to non-master branches of the mathlib repository, can we get that? Our usernames are MadPidgeon and pimsp</p>



<a name="208432940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208432940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208432940">(Aug 29 2020 at 13:05)</a>:</h4>
<p>Invites sent! <a href="https://github.com/leanprover-community/mathlib/invitations">https://github.com/leanprover-community/mathlib/invitations</a></p>



<a name="208450116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208450116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208450116">(Aug 29 2020 at 19:35)</a>:</h4>
<p><span class="user-mention" data-user-id="319356">@Pim Spelier</span> While I understand the reason you need a different encodable interface, I would like to only have one, so you should keep in mind how the existing encodable definitions can be retrofitted on a more TM friendly definition.</p>



<a name="208476911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208476911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208476911">(Aug 30 2020 at 09:38)</a>:</h4>
<p>What exactly do you mean with retrofitting the existing definitions? The difference between <code>encodable</code> and <code>encoding</code> is something we've been thinking about, and our plan was to eventually show that there are two functions <code>f: \N \to list \Gamma\0\1</code> and <code>g: list \Gamma\0\1 \to \N</code> such that $g\circ f$ is primitive recursive and $f \circ g$ is computable by a Turing machine. That should give a way to go from <code>encodable</code>s to <code>encoding</code>s and vice versa.</p>



<a name="208476912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/208476912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#208476912">(Aug 30 2020 at 09:38)</a>:</h4>
<p>Does that sound like a good solution, or do you have other suggestions/comments?</p>



<a name="265910449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/265910449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#265910449">(Dec 23 2021 at 12:04)</a>:</h4>
<p>Hi there! I am really interested in this project! Has it been abandoned completely?</p>



<a name="265911255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/265911255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#265911255">(Dec 23 2021 at 12:16)</a>:</h4>
<p>We should probably tag <span class="user-mention" data-user-id="319356">@Pim Spelier</span> and <span class="user-mention" data-user-id="320867">@Daan van Gent</span> as otherwise it seems unlikely they will read a message posted to a very old thread.</p>



<a name="307701492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/307701492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aporías <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#307701492">(Nov 03 2022 at 11:00)</a>:</h4>
<p>I'm very interested in working on this. Is it a stil on going project?</p>



<a name="307702290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/307702290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#307702290">(Nov 03 2022 at 11:05)</a>:</h4>
<p>The latest work I'm aware of is <a href="https://github.com/prakol16/lean_complexity_theory_polytime_trees">https://github.com/prakol16/lean_complexity_theory_polytime_trees</a> by <span class="user-mention" data-user-id="437861">@Praneeth Kolichala</span></p>



<a name="309526767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/309526767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#309526767">(Nov 14 2022 at 03:34)</a>:</h4>
<p>As you might have seen, the existing encodings don't work for defining P because the encodings of lists (and more generally, any recursive structure) grows exponentially with the size of the structure. In general, working with <code>nat</code> is hard and ugly overall and requires a complicated pairing function, though it is possible (this was originally <a href="https://github.com/leanprover-community/mathlib/pull/13213">#13213</a> before I gave up on that because the encoding function was already complicated, and it has a log-overhead which is still annoying).</p>
<p>Instead, I've been working on using tree-based encodings. These offer several advantages: they are the most natural way to encode recursive structures, including lists; the pairing functions are non-arbitrary, and in particular, satisfy nice definitional equalities; and finally, they still are countable, and have a reasonable encoding/decoding to nat. The main disadvantage is that the literature usually uses nat, and that the existing infrastructure uses nat.</p>
<p>I've started with the PR's <a href="https://github.com/leanprover-community/mathlib/pull/16715">#16715</a> and <a href="https://github.com/leanprover-community/mathlib/pull/16415">#16415</a>, after which <a href="https://github.com/leanprover-community/mathlib/pull/16416">#16416</a> can go through (refactoring primitive recursive to use trees). Obviously this is a pretty big refactor but it is the only way I currently see to be able to define good encodings for objects that make polynomial-time things work.</p>
<p>If anyone is interested in contributing to this project, DM me, because obviously things progress quite slow when it's just me.</p>



<a name="310348208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/310348208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuyang Zhao <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#310348208">(Nov 16 2022 at 06:53)</a>:</h4>
<p>I would like to know how you are going to define LOGSPACE with this method, I am having great difficulties here.</p>



<a name="310720253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%2C%20P%20%28and%20NP%29/near/310720253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.2C.20P.20(and.20NP).html#310720253">(Nov 17 2022 at 23:37)</a>:</h4>
<p>I haven't thought about it too much, but here is a sketch of an idea:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">logspace</span> <span class="o">:</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">tree</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">logspace</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">tree.nil</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">left</span> <span class="o">{</span><span class="n">f</span><span class="o">}</span> <span class="o">:</span> <span class="n">logspace</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">logspace</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">left</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">right</span> <span class="o">{</span><span class="n">f</span><span class="o">}</span> <span class="o">:</span> <span class="n">logspace</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">logspace</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">right</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span><span class="o">}</span> <span class="o">:</span> <span class="n">logspace</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">logspace</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">logspace</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="n">x</span><span class="o">)</span> <span class="bp">△</span> <span class="o">(</span><span class="n">g</span> <span class="n">i</span> <span class="n">x</span><span class="o">))</span> <span class="c1">-- △ is the tree.node function</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span><span class="o">}</span> <span class="o">:</span> <span class="n">logspace</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">logspace</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">logspace</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">cases</span> <span class="o">{</span><span class="n">c</span> <span class="n">f</span> <span class="n">g</span><span class="o">}</span> <span class="o">:</span> <span class="n">logspace</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">logspace</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">logspace</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">logspace</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">c</span> <span class="n">i</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">tree.nil</span> <span class="k">then</span> <span class="n">f</span> <span class="n">i</span> <span class="n">x</span> <span class="k">else</span> <span class="n">g</span> <span class="n">i</span> <span class="n">x</span><span class="o">)</span>
<span class="c1">-- Extra functions: get the input length and get the `n`th bit of the input</span>
<span class="bp">|</span> <span class="n">input_len</span> <span class="o">:</span> <span class="n">logspace</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">_</span><span class="o">,</span> <span class="n">encode</span> <span class="n">i.length</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">get</span> <span class="o">:</span> <span class="n">logspace</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">n</span><span class="o">,</span> <span class="n">encode</span> <span class="o">(</span><span class="n">i.nth</span> <span class="o">(</span><span class="n">decode</span> <span class="n">ℕ</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">iget</span><span class="o">))</span>
<span class="c1">-- Iteration constraint: repeated application of `f i` to `x` uses `O(x)` memory</span>
<span class="bp">|</span> <span class="n">iterate</span> <span class="o">{</span><span class="n">f</span><span class="o">}</span> <span class="o">:</span> <span class="n">logspace</span> <span class="n">f</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">M</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">x</span> <span class="n">i</span><span class="o">,</span> <span class="o">((</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">num_nodes</span> <span class="bp">≤</span> <span class="n">M</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x.num_nodes</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">→</span>
  <span class="c">/-</span><span class="cm"> condition: repeatedly applying `f` terminates -/</span> <span class="gr">sorry</span> <span class="bp">→</span> <span class="n">logspace</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="c">/-</span><span class="cm"> repeatedly applying `f i` to `x` until some condition (e.g. the left branch is nil) becomes true -/</span> <span class="gr">sorry</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">logspace_fun</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">tree</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:=</span> <span class="n">logspace</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">_</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>
<p>Here, <code>logspace_fun</code> is the set of LOGSPACE functions whose outputs are logspace bounded in the input. There are some sorry's to fill in, but the essential idea is that the initial argument <code>list bool</code> is the read-only input, while the second argument is modifiable "working space memory."  Here, we assuming the encoding of nat's uses the usual (efficient) base 2 encoding.</p>
<p>We can easily modify the input to be a tree instead of <code>list bool</code> as well -- we just have to change <code>get</code> to return the <code>n</code>th node via <code>tree.get</code>. It's written with <code>list bool</code> here to more clearly distinguish the input from the working memory.</p>
<p>The slightly tricky bit is with <code>iterate</code>. The idea is straightforward -- we can iterate a function with linear memory overhead until some condition is met. But this function might not terminate, even though we know the only way it doesn't terminate is if it repeats an input (since its range is finite for any particular <code>i</code> and <code>x</code>). Maybe there is a better way to state it, I'll have to think about it more/look at existing definitions of L in the literature.</p>
<p>I do believe that this is contained in <code>L</code> and contains all decision problems in <code>L</code>. Intuitively, given a TM, we can write the step function using the constructors other than iterate and then call iterate to run the Turing machine (and the condition for iterate is satisfied if the TM runs in log space).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Defining.20a.20function.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html">Defining a function</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="300531318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300531318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> King Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300531318">(Sep 24 2022 at 12:31)</a>:</h4>
<p>Say you have a type X and a proof that x : X can only take on n distinct cases. Is it then possible to define a function from X to some type Y using each of those cases without necessarily making X an inductive type?</p>



<a name="300533078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300533078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300533078">(Sep 24 2022 at 12:44)</a>:</h4>
<p>The way to do this depends a lot on the way you prove that <code>x : X</code> can only take on <code>n</code> distinct values. For example, we have the notation <code>![1, 2, 3]</code> for writing a function <code>fin 3 → ℤ</code>. So if you have a surjective function <code>f : fin n → X</code> then you can take the section of <code>f</code> and compose it with a function like <code>![...]</code>.</p>



<a name="300534485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300534485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> King Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300534485">(Sep 24 2022 at 12:57)</a>:</h4>
<p>Good to know! But for the sake of simplicity, let's say there are only two cases: like, maybe <code>x : X</code> is either some object <code>e : X</code> or anything else that isn't <code>e</code>. How would I approach making <code>f : X → Y</code> using these two cases?</p>



<a name="300535071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300535071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300535071">(Sep 24 2022 at 13:02)</a>:</h4>
<p>You can use an <code>if</code> expression: <code>def f (x : X) := if h : x = e then _ else _</code> (see <a href="https://leanprover-community.github.io/mathlib_docs/find/ite">docs#ite</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/dite">docs#dite</a>)</p>



<a name="300535178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300535178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> King Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300535178">(Sep 24 2022 at 13:03)</a>:</h4>
<p>I see, thanks!</p>



<a name="300687580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300687580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> King Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300687580">(Sep 25 2022 at 20:20)</a>:</h4>
<p>Also, is it possible to define a function from a set of ordered pairs, given a proof that it passes the vertical line test?</p>



<a name="300689007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300689007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300689007">(Sep 25 2022 at 20:38)</a>:</h4>
<p>Not without classical.some but yes</p>



<a name="300689818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300689818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> King Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300689818">(Sep 25 2022 at 20:48)</a>:</h4>
<p>I'm fine with classical.some haha. is there any specific API for this task? or is this a lot more complicated than I'm thinking it is</p>



<a name="300690200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300690200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300690200">(Sep 25 2022 at 20:54)</a>:</h4>
<p>Not complicated. What's the set you have? What if the caller of the function gives you a term that isn't in any of the pairs?</p>



<a name="300690704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300690704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> King Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300690704">(Sep 25 2022 at 21:01)</a>:</h4>
<p>right, fair. but let's say you do also have a proof that there's a unique pair for every single object in the domain. would that be enough?</p>



<a name="300690911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300690911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300690911">(Sep 25 2022 at 21:04)</a>:</h4>
<p>I imagine the expression of that assumption is "H : forall x : X, exists p in s, p.1 = x", then your function is "lambda x, (classical.some (H x)).2"</p>



<a name="300690933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300690933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300690933">(Sep 25 2022 at 21:04)</a>:</h4>
<p>You don't even need a unique pair to define the function, just a pair.</p>



<a name="300690955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300690955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> King Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300690955">(Sep 25 2022 at 21:05)</a>:</h4>
<p>oh neat, thanks!</p>



<a name="300691086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20function/near/300691086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20function.html#300691086">(Sep 25 2022 at 21:07)</a>:</h4>
<p>Or you can phrase it like "H : forall x : X, exists y : Y, (x, y) in s", and the function is "lambda x, classical.some (H x)"</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html">'unreachable' code was reached</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="262459404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262459404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262459404">(Nov 23 2021 at 14:04)</a>:</h4>
<p>Lean version 3.35.1</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">id</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span>
</code></pre></div>
<p>Error: <code>'unreachable' code was reached</code>. What does it mean?</p>



<a name="262459768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262459768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262459768">(Nov 23 2021 at 14:07)</a>:</h4>
<p>in this case, it indicates a bug in Lean</p>



<a name="262461487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262461487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262461487">(Nov 23 2021 at 14:20)</a>:</h4>
<p>Do you have a real example?</p>



<a name="262461541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262461541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262461541">(Nov 23 2021 at 14:21)</a>:</h4>
<p>It's hard to guess what feature(s) of <code>id</code> might be relevant</p>



<a name="262461939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262461939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262461939">(Nov 23 2021 at 14:24)</a>:</h4>
<p>In Lean 4 it gives a much better error: <code>only trivial inductive applications supported in premises</code></p>



<a name="262462980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262462980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262462980">(Nov 23 2021 at 14:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached/near/262461487">said</a>:</p>
<blockquote>
<p>Do you have a real example?</p>
</blockquote>
<p>hmm what do you mean by "real example"? <a href="https://tio.run/##y0lNzPv/PzMvpTS5JLMsVSFAwUohoCi/gKtGITcbyM5MAQo9apukEMD1/z8A">I ran exactly that code on TIO and it produced the exact same error</a>, so this is pretty much a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="262463357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262463357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262463357">(Nov 23 2021 at 14:34)</a>:</h4>
<p>An example which achieves something useful</p>



<a name="262545920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262545920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262545920">(Nov 24 2021 at 04:38)</a>:</h4>
<p>You can actually get a whole bunch of distinct errors for various combinations of whether it is a <code>def</code> or <code>abbreviation</code>, and whether it is constructing a simple kernel inductive or a nested inductive in the end:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">X</span>
<span class="kd">set_option</span> <span class="n">trace.inductive_compiler.nested.simp.failure</span> <span class="n">true</span>
<span class="kd">inductive</span> <span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span>
<span class="c1">-- simplifier failed to prove goal; trace 'inductive_compiler.nested.simp.failure' for more information</span>

<span class="c1">-- [inductive_compiler.nested.simp.failure]</span>
<span class="c1">-- -------------------</span>

<span class="kd">def</span> <span class="n">foo2</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span>
<span class="kd">inductive</span> <span class="n">P2</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">foo2</span> <span class="n">P2</span> <span class="bp">→</span> <span class="n">P2</span>
<span class="c1">-- type mismatch at definition 'P2.mk.sizeof_spec', has type</span>
<span class="c1">--   ∀ (ᾰ : foo2 P2), P2.sizeof (P2.mk ᾰ) = P2.sizeof (P2.mk ᾰ)</span>
<span class="c1">-- but is expected to have type</span>
<span class="c1">--   ∀ (ᾰ : foo2 P2), P2.sizeof (P2.mk ᾰ) = 1</span>

<span class="kd">abbreviation</span> <span class="n">foo3</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">X</span>
<span class="kd">inductive</span> <span class="n">P3</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">foo3</span> <span class="n">P3</span> <span class="bp">→</span> <span class="n">P3</span> <span class="c1">-- ok</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">P3.mk</span> <span class="c1">-- P3.mk : foo3 P3 → P3</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">P3.rec</span> <span class="c1">-- P3.rec : Π (C : P3 → Sort u_1), (Π (ᾰ : P3 × P3), C (P3.mk ᾰ)) → Π (x : P3), C x</span>

<span class="kd">abbreviation</span> <span class="n">foo4</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span>
<span class="kd">inductive</span> <span class="n">P4</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">foo4</span> <span class="n">P4</span> <span class="bp">→</span> <span class="n">P4</span> <span class="c1">-- ok</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">P4.mk</span> <span class="c1">-- P4.mk : foo4 P4 → P4</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">P4.rec</span> <span class="c1">-- P4.rec : Π {motive : P4 → Sort u_1},</span>
               <span class="c1">--   (Π (ᾰ : foo4 P4), motive ᾰ → motive (P4.mk ᾰ)) → Π (n : P4), motive n</span>

<span class="kd">abbreviation</span> <span class="n">foo5</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span> <span class="bp">∧</span> <span class="n">X</span>
<span class="kd">inductive</span> <span class="n">P5</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">foo5</span> <span class="n">P5</span> <span class="bp">→</span> <span class="n">P5</span>
<span class="c1">-- invalid nested occurrence 'and P5 P5', either both must eliminate to Type or both must eliminate only to Prop</span>

<span class="kd">abbreviation</span> <span class="n">foo6</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span>
<span class="kd">inductive</span> <span class="n">P6</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">foo6</span> <span class="n">P6</span> <span class="bp">→</span> <span class="n">P6</span> <span class="c1">-- ok</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">P6.mk</span> <span class="c1">-- P6.mk : foo6 P6 → P6</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">P6.rec</span> <span class="c1">-- P6.rec : Π {motive : Sort u_1}, (foo6 P6 → motive → motive) → P6 → motive</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">P6.drec</span> <span class="c1">-- P6.drec : Π {motive : P6 → Sort u_1}, (Π (ᾰ : foo6 P6), motive ᾰ → motive _) → Π (n : P6), motive n</span>

<span class="kd">def</span> <span class="n">foo8</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span>
<span class="kd">inductive</span> <span class="n">P8</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">foo8</span> <span class="n">P8</span> <span class="bp">→</span> <span class="n">P8</span>
<span class="c1">-- LEAN ASSERTION VIOLATION</span>
<span class="c1">-- File: /home/mario/Documents/lean/lean/src/library/constructions/drec.cpp</span>
<span class="c1">-- Line: 132</span>
<span class="c1">-- Task: /home/mario/Documents/lean/lean/library/test.lean: parsing at line 41</span>
<span class="c1">-- j - num_fields &lt; recursive_params.size()</span>
</code></pre></div>



<a name="262546082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262546082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262546082">(Nov 24 2021 at 04:42)</a>:</h4>
<p>Part of the problem is that I'm not sure what the answer is even supposed to be. The error occurs during the construction of the type of the <code>T.drec</code> recursor for the inductive type, and you can see that different combinations here result in different types. Notice, for example, that the minor premise of <code>P3.rec</code> unfolds the definition in <code>(ᾰ : P3 × P3)</code>, while <code>P4.rec</code> and <code>P6.drec</code> don't: <code>(ᾰ : foo4 P4)</code></p>



<a name="262550429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262550429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262550429">(Nov 24 2021 at 06:24)</a>:</h4>
<p>Should I worry about the consistency of the kernel? The <code>'unreachable' code was reached</code> indicates that someone didn't expect such use case, which means that there may be something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Not</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">p</span><span class="o">,</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">→</span> <span class="n">Not</span> <span class="n">p</span>

<span class="kd">inductive</span> <span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">Not</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span>
</code></pre></div>
<p>that would allow us to prove <code>P ↔ ¬P</code> and then <code>0 = 1</code></p>



<a name="262556508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262556508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262556508">(Nov 24 2021 at 08:10)</a>:</h4>
<p>This code is not part of the kernel</p>



<a name="262556636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262556636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262556636">(Nov 24 2021 at 08:12)</a>:</h4>
<p>The issue is not with the kernel spec, but rather what the front end is allowed to desugar to the kernel spec. The kernel spec says nothing about definitions, and would reject all these examples, but the front end thinks it would be fine as long as the generated types are defeq to the kernel types</p>



<a name="262556705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%27unreachable%27%20code%20was%20reached/near/262556705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/'unreachable'.20code.20was.20reached.html#262556705">(Nov 24 2021 at 08:13)</a>:</h4>
<p>and then there is additional complication when it is a nested inductive, in which case even after unfolding definitions you get something that is not a valid kernel inductive and the front end does a more complicated simulation of the nested inductive (which is known to have bugs and be generally unreliable)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
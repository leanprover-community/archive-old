---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/.23check.20and.20.23check.40.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html">#check and #check@</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209642564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209642564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209642564">(Sep 10 2020 at 13:44)</a>:</h4>
<p>I though that the difference between <code>#check</code> and <code>#check@</code> was basically that the second is "more explicit" than the first. But then I don't understand what's happening: if I <code>#check is_fractional f J</code> I get <code>is_fractional f J : Prop</code> (which means, I gather, that <code>is_fractional f J</code> is the proposition saying that there exists <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">a\in R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>b</mi><mo>∈</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">\forall b \in J</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span>, the product <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\ast b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> is integral). ON the other hand, if I <code>#check@ is_fractional f J</code> I get the error <code>type mismatch at application
  is_fractional
term f
has type
  fraction_map R K : Type (max u_1 u_2)
but is expected to have type
  Type ? : Type (?+1)</code><br>
A part from the error itself, this leads me to think that there is a deeper difference between <code>#check</code> and <code>#check@</code></p>



<a name="209643771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209643771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209643771">(Sep 10 2020 at 13:52)</a>:</h4>
<p>There is only <code>#check</code>, which gives you the type of the term you provide. The term, if it has any arguments, has the arguments also displayed, but only if they are explicit. In any place where you can provide a term, doing <code>@term</code> will make all of the arguments it has, including the implicit ones (the ones indicated by <code>{ }</code> or <code>[ ]</code>), explicit.</p>



<a name="209643978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209643978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209643978">(Sep 10 2020 at 13:53)</a>:</h4>
<p>So in your case, you can't just do <code>#check @is_fractional f J</code> because <code>@is_fractional</code> requires you to provide</p>
<div class="codehilite"><pre><span></span><code><span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">P</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">localization_map</span> <span class="n">S</span> <span class="n">P</span><span class="o">)</span>
</code></pre></div>



<a name="209645484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209645484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209645484">(Sep 10 2020 at 14:00)</a>:</h4>
<p>Ah, I see. And is there a way to make the <code>Prop</code> term explicit? So that I can see (without going back to the definition) what proposition <code>is_fractional f J</code> is?</p>



<a name="209647047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209647047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209647047">(Sep 10 2020 at 14:03)</a>:</h4>
<p><code>#print is_fractional</code> will show the (expanded) definition of <code>is_fractional</code></p>



<a name="209647049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209647049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209647049">(Sep 10 2020 at 14:03)</a>:</h4>
<p>That's <code>#print</code> not <code>#check</code>. <code>#check</code> tells you the type of something, not the definition.</p>



<a name="209647348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209647348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209647348">(Sep 10 2020 at 14:05)</a>:</h4>
<p>and can I also use <code>#print</code> inside a proof? I guess not, but then is there an alternative way to see what <code>is_fractional J</code> does when <code>J</code> is a "concrete" submodule I have defined along a proof?</p>



<a name="209647508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209647508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209647508">(Sep 10 2020 at 14:06)</a>:</h4>
<p>Why does it matter what the exact definition is? What you want to know is the API, not the definition. The definition is an implementation issue.</p>



<a name="209647838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209647838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209647838">(Sep 10 2020 at 14:08)</a>:</h4>
<p>What do you actually want to do? Proofs are easy to work with. They have a name, and if you hover over them then you see their type, which is the statement of the theorem that they're a proof of. But definitions are harder. If you're spending any time working with a definition then before you start you should probably right-click on the definition and read the definition and the API which will be developed immediately after it. That is how you will use the object in question.</p>



<a name="209647855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209647855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209647855">(Sep 10 2020 at 14:08)</a>:</h4>
<p>(Answer to the first part of your comment)</p>
<p>Well, because I am lost and I am trying to figure out what Lean has in mind. Since  I undestood that<code>is fractional f J</code> should be a proof of the existence of an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">a\in R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\ast b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> is integral for every <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">b\in J</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span>, I wanted to <code>cases  is fractional f J with a ha</code> to produce an instance of such an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>.</p>



<a name="209647953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209647953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209647953">(Sep 10 2020 at 14:08)</a>:</h4>
<p>So you want to know how to get <code>a</code> and <code>ha</code> out of <code>is_fractional f J</code>, and there will be plenty of examples of this in the API.</p>



<a name="209649097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209649097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209649097">(Sep 10 2020 at 14:12)</a>:</h4>
<p>OK so I looked and it's just an existence statement, so you can use <code>cases</code> to get to <code>a</code> like you suggested. If it doesn't work for you then you'll have to post working code. Are you using tactics to define data? That might be why it's not working for you.</p>



<a name="209650502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209650502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209650502">(Sep 10 2020 at 14:14)</a>:</h4>
<p>My code is <code>cases is_fractional f M1 with a ha,</code> and the error I get is <code>cases tactic failed, it is not applicable to the given hypothesis</code>. I suspect that the problem is that my <code>M1</code> is a fractional idea, whereas in the definition of <code>is_fractional</code> it should be a submodule.</p>



<a name="209650536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209650536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209650536">(Sep 10 2020 at 14:14)</a>:</h4>
<p>So, I might have to replace <code>M1</code> with <code>M1.val</code> or something like this-no?</p>



<a name="209650697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209650697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209650697">(Sep 10 2020 at 14:15)</a>:</h4>
<p>I would be much happier communicating with you about explicit lean code than guessing what you're trying to do. It will save me having you ask you ten questions.</p>



<a name="209650785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209650785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209650785">(Sep 10 2020 at 14:16)</a>:</h4>
<p>That error usually means that the argument to <code>cases</code> did type check, but it wasn't something <code>cases</code> could apply to, most likely a function of some kind.</p>



<a name="209650879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209650879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209650879">(Sep 10 2020 at 14:16)</a>:</h4>
<p>Statements like "<code>M1</code> is a fractional ideal" are useless to me. I see <code>is_fractional</code> and <code>fractional_ideal</code> in the API and for all I know there are more.</p>



<a name="209650963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209650963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209650963">(Sep 10 2020 at 14:17)</a>:</h4>
<p>Ok, should I paste all my code here?</p>



<a name="209651038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209651038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209651038">(Sep 10 2020 at 14:17)</a>:</h4>
<p>Ideally you would make a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="209651314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209651314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209651314">(Sep 10 2020 at 14:18)</a>:</h4>
<p>OK, give me a sec, I' ll try to produce it</p>



<a name="209651991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209651991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209651991">(Sep 10 2020 at 14:20)</a>:</h4>
<p>I hope this helps:</p>
<p><code>
import linear_algebra.finite_dimensional
import order.zorn
import ring_theory.fractional_ideal
import ring_theory.polynomial.rational_root
import ring_theory.ideal.over
import set_theory.cardinal
import tactic
lemma trial (h : is_dedekind_domain f) {M : ideal R}
  (hM : ideal.is_maximal M) : is_unit (M : fractional_ideal f) :=
-- ⟨⟨M, M⁻¹, _, _⟩, rfl⟩
begin
let setM1 := {x : K | ∀ y ∈ M, f.is_integer (x * f.to_map y)},
let M1 : fractional_ideal f,sorry,
have h_nonfrac : ∃ (I : ideal R), ↑M*M1=↑I,
  cases is_fractional f M1.2 with a ha,
end</code></p>
<p>I have <code>sorried</code> the proof that <code>M1</code> is a fractional ideal, as it is very long</p>



<a name="209652013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209652013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209652013">(Sep 10 2020 at 14:20)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks">#backticks</a></p>



<a name="209652089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209652089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209652089">(Sep 10 2020 at 14:21)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="209652316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209652316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209652316">(Sep 10 2020 at 14:22)</a>:</h4>
<p>You have to learn how to write a good question, it's a really important skill.</p>



<a name="209652388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209652388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209652388">(Sep 10 2020 at 14:23)</a>:</h4>
<p>I know, and I apologize for this.</p>



<a name="209652406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209652406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209652406">(Sep 10 2020 at 14:23)</a>:</h4>
<p>You need to make it so that I can just paste what you post and see the same error. You can practice by posting what you post into a new file and seeing if you see the same error</p>



<a name="209652616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209652616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209652616">(Sep 10 2020 at 14:24)</a>:</h4>
<p>OK, I will do that. I apologize for wasting anyone's time. I might come back with the question if I manage to make it readable/answerable.</p>



<a name="209653214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209653214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209653214">(Sep 10 2020 at 14:30)</a>:</h4>
<p>Right now I have no definition of <code>f</code> but you're surely nearly there.</p>



<a name="209653745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209653745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209653745">(Sep 10 2020 at 14:33)</a>:</h4>
<p>Ok, this is what I could do. It compiles on an empty file. I have <code>sorried</code> the proof that <code>M1</code> is a fractional ideal, as it seemed irrelevant to me but I might be wrong. Also, the final statement of my lemma is not important, I am try to understand the error I get.</p>
<p>import linear_algebra.finite_dimensional<br>
import ring_theory.fractional_ideal<br>
import ring_theory.ideal.over<br>
import tactic</p>
<p>open ideal ring</p>
<p>variables {R K : Type*}</p>
<p>variables {S : Type*} [integral_domain R] [integral_domain S] [algebra R S]<br>
variables {L : Type*} [field K] [field L] {f : fraction_map R K}</p>
<p>variables {M : ideal R} [is_maximal M]</p>
<p>lemma trial : is_unit (M : fractional_ideal f) :=<br>
begin<br>
let setM1 := {x : K | ∀ y ∈ M, f.is_integer (x * f.to_map y)},<br>
let M1 : fractional_ideal f,sorry,<br>
have h_nonfrac : ∃ (I : ideal R), ↑M*M1=↑I,<br>
  cases is_fractional f M1 with a ha,<br>
end</p>



<a name="209654916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209654916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209654916">(Sep 10 2020 at 14:37)</a>:</h4>
<p>OK this is the first error I see with your code:</p>
<div class="codehilite"><pre><span></span><code>type mismatch at application
  is_fractional f _
term
  M1.property
has type
  is_fractional f M1.val : Prop
but is expected to have type
  submodule R (localization_map.codomain f) : Type u_2
</code></pre></div>


<p>Is that what you're talking about?</p>



<a name="209655114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209655114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209655114">(Sep 10 2020 at 14:38)</a>:</h4>
<p>Yes</p>



<a name="209655159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209655159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209655159">(Sep 10 2020 at 14:38)</a>:</h4>
<p>Some formatting cleanup:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finite_dimensional</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">fractional_ideal</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideal</span><span class="bp">.</span><span class="n">over</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">ideal</span> <span class="n">ring</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fraction_map</span> <span class="n">R</span> <span class="n">K</span><span class="o">}</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">is_maximal</span> <span class="n">M</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">trial</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">fractional_ideal</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">setM1</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">M</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="n">is_integer</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">f</span><span class="bp">.</span><span class="n">to_map</span> <span class="n">y</span><span class="o">)},</span>
  <span class="k">have</span> <span class="n">M1</span> <span class="o">:</span> <span class="n">fractional_ideal</span> <span class="n">f</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">h_nonfrac</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">),</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">fractional_ideal</span> <span class="n">f</span><span class="o">)</span> <span class="bp">*</span> <span class="n">M1</span> <span class="bp">=</span> <span class="n">I</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">is_fractional</span> <span class="n">f</span> <span class="n">M1</span><span class="bp">.</span><span class="mi">2</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span> <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="209655218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209655218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209655218">(Sep 10 2020 at 14:39)</a>:</h4>
<p>OK so the error is pretty clear: you have a "type mismatch" which means that you have some function <code>F : A -&gt; B</code> and after it you wrote something which didn't have type <code>A</code> so Lean didn't know what to do</p>



<a name="209655475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209655475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209655475">(Sep 10 2020 at 14:40)</a>:</h4>
<p>By the way, using <code>sorry</code> to skip proofs is fine, but using <code>sorry</code> to skip definitions (as you do here) is dangerous. Wouldn't you rather talk about filling in that dangerous sorry, which occurs before the error?</p>



<a name="209656006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209656006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209656006">(Sep 10 2020 at 14:43)</a>:</h4>
<p>As for that <code>sorry</code>, you might be right and I read your post about never leaving <code>sorry</code>'s around; I have almost finished the proof that <code>M1</code> is fractional and was willing to do something different.</p>
<p>What I am trying to do is to construct the ideal <code>I</code> whose existence is <code>h_nonfrac</code>. I thought about producing the <code>a</code> whose existence is granted by the definition of <code>is_fractional</code>, but I can't.</p>



<a name="209656240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209656240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209656240">(Sep 10 2020 at 14:44)</a>:</h4>
<p>OK great, let's leave the <code>sorry</code>, it sounds like it's under control. So let's just get clear what are the terms and what are the types.</p>



<a name="209656419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209656419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209656419">(Sep 10 2020 at 14:45)</a>:</h4>
<p>You do cases on the term, not the type, right?</p>



<a name="209656557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209656557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209656557">(Sep 10 2020 at 14:46)</a>:</h4>
<p>I would like to do the cases on the (existential) term of <code>Prop</code></p>



<a name="209656561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209656561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209656561">(Sep 10 2020 at 14:46)</a>:</h4>
<p>For example : I could just define a type <code>def X := P \or Q</code>, that's just a definition, and I can't do cases on <code>X</code>.</p>



<a name="209656576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209656576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209656576">(Sep 10 2020 at 14:46)</a>:</h4>
<p>Sure</p>



<a name="209656657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209656657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209656657">(Sep 10 2020 at 14:47)</a>:</h4>
<p>But if I got it right, <code>is_fractional f J</code> would be a term of <code>Prop</code> (hence, a proof); so I could do cases.</p>



<a name="209656749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209656749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209656749">(Sep 10 2020 at 14:47)</a>:</h4>
<p><code>is_fractional f J</code> has type <code>Prop</code> so you can't do cases on it. It's the statement of the theorem, not the proof.</p>



<a name="209656829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209656829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209656829">(Sep 10 2020 at 14:48)</a>:</h4>
<p>You need to do cases on the proof, not the statement.</p>



<a name="209656872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209656872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209656872">(Sep 10 2020 at 14:48)</a>:</h4>
<p>So you need to locate a term <code>h : is_fractional f J</code> for some appropriate <code>J</code> and then you can do cases on <code>h</code></p>



<a name="209657147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209657147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209657147">(Sep 10 2020 at 14:50)</a>:</h4>
<p>What is the type of <code>M1</code> in your proof? What does it mean for <code>M1</code> to be of that type, mathematically?</p>



<a name="209657167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209657167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209657167">(Sep 10 2020 at 14:50)</a>:</h4>
<p><code>Prop</code> is the universe, <code>is_fractional f _</code> is the Type (the theorem statement) and the thing you want to do cases on is the term.</p>



<a name="209657326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209657326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209657326">(Sep 10 2020 at 14:51)</a>:</h4>
<p>Well, <code>M1</code> in my proof has type <code>fractional_ideal R f</code>, I think. And I think this might be a problem as it should have type <code>submodule  R f.codomain</code></p>



<a name="209657369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209657369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209657369">(Sep 10 2020 at 14:51)</a>:</h4>
<p>You can't get to choose the type of your term</p>



<a name="209657524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209657524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209657524">(Sep 10 2020 at 14:52)</a>:</h4>
<p>I know</p>



<a name="209657539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209657539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209657539">(Sep 10 2020 at 14:52)</a>:</h4>
<p>So the next question is: do you understand the constructors and eliminators for <code>fractional_ideal f</code>? Do you understand how to make a term of type <code>fractional_ideal f</code> and do you understand what to do with terms of this type if you want to make other things (like extracting information from terms of this type)?</p>



<a name="209657580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209657580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209657580">(Sep 10 2020 at 14:52)</a>:</h4>
<p>Do you understand the <em>definition</em> of <code>fractional_ideal f</code>?</p>



<a name="209657899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209657899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209657899">(Sep 10 2020 at 14:54)</a>:</h4>
<p>(PS you wrote <code>fractional_ideal R f</code> but looking at the code it seems to be <code>fractional_ideal f</code>)</p>



<a name="209657954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209657954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209657954">(Sep 10 2020 at 14:54)</a>:</h4>
<p>Well, I think I understand the definition <code>is_fractional</code>: it takes a submodule <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> and produces a proof of the existence of an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">a\in R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\ast b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> is integer for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">b\in I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>.</p>



<a name="209657995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209657995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209657995">(Sep 10 2020 at 14:54)</a>:</h4>
<p>No. It cannot do this</p>



<a name="209658031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658031">(Sep 10 2020 at 14:55)</a>:</h4>
<p>Ah.</p>



<a name="209658105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658105">(Sep 10 2020 at 14:55)</a>:</h4>
<p>It cannot produce a proof of the existence of a because such an a might not exist, as you know</p>



<a name="209658163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658163">(Sep 10 2020 at 14:55)</a>:</h4>
<p>Ah, good point.</p>



<a name="209658173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658173">(Sep 10 2020 at 14:55)</a>:</h4>
<p>It produces the <em>statement</em> that there exists an a such that ab is an integer for all b in I</p>



<a name="209658249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658249">(Sep 10 2020 at 14:56)</a>:</h4>
<p>You need to be really clear about the difference between theorem statements and proofs</p>



<a name="209658280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658280">(Sep 10 2020 at 14:56)</a>:</h4>
<p>But anyway, this was not the question</p>



<a name="209658287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658287">(Sep 10 2020 at 14:56)</a>:</h4>
<p>Seems a very wise advice.</p>



<a name="209658349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658349">(Sep 10 2020 at 14:56)</a>:</h4>
<p>The question was: you are stuck with a term of type <code>fractional_ideal f</code> so do you understand the definition of <code>fractional_ideal</code>?</p>



<a name="209658442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658442">(Sep 10 2020 at 14:57)</a>:</h4>
<p>You can right click on it and peek the definition if you like</p>



<a name="209658677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658677">(Sep 10 2020 at 14:58)</a>:</h4>
<p>Well, I would have said a fractional ideal is a submodule of the codomain of f together with a proof that <code>is_fractional</code>?</p>



<a name="209658721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658721">(Sep 10 2020 at 14:59)</a>:</h4>
<p>But I try to right-click, first-one sec</p>



<a name="209658722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658722">(Sep 10 2020 at 14:59)</a>:</h4>
<p>Right. A term of type <code>fractional_ideal f</code> is a pair. It is a submodule and a proof.</p>



<a name="209658758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658758">(Sep 10 2020 at 14:59)</a>:</h4>
<p>Sure, right click and peek</p>



<a name="209658926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658926">(Sep 10 2020 at 15:00)</a>:</h4>
<p>You will see that it's a subtype: it's the type of all submodules <code>I</code> which satisfy the <code>is_fractional f I</code> statement.</p>



<a name="209658965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209658965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209658965">(Sep 10 2020 at 15:00)</a>:</h4>
<p>And to get to that pair, you can do cases.</p>



<a name="209659429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209659429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209659429">(Sep 10 2020 at 15:03)</a>:</h4>
<p>When you say that I can peek the definition , do you mean that I can read what's on the Infoview? Because that does not look like the pair we're speaking about.</p>



<a name="209659546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209659546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209659546">(Sep 10 2020 at 15:03)</a>:</h4>
<p>In VSCode, I press F12, which takes me to the source of the expression.</p>



<a name="209659668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209659668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209659668">(Sep 10 2020 at 15:04)</a>:</h4>
<p>Yes, Yes, got it: it simply opens the file containing the <code>def</code> at the right point.</p>



<a name="209659679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209659679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209659679">(Sep 10 2020 at 15:04)</a>:</h4>
<p>I mean "right click on <code>fractional_ideal</code> and select "peek definition", but if you are happy to jump to the definition you can do what Yakov suggests.</p>



<a name="209659698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209659698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209659698">(Sep 10 2020 at 15:04)</a>:</h4>
<p>OKOK, got it.</p>



<a name="209659762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209659762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209659762">(Sep 10 2020 at 15:05)</a>:</h4>
<p>So that definition <code>def X := {a : Y // P a}</code> is called a subtype, and to make a term of type <code>X</code> you have to give it a term <code>a</code> of type <code>Y</code> and a proof that <code>P a</code> is true. There's the proof.</p>



<a name="209659973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209659973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209659973">(Sep 10 2020 at 15:06)</a>:</h4>
<p>OK. But if I have a term <code>m</code> of type <code>X</code>,  can I extract the term of type <code>Y</code> and the proof from it?</p>



<a name="209660003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209660003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209660003">(Sep 10 2020 at 15:06)</a>:</h4>
<p>Sure, by <code>cases m with y hy</code></p>



<a name="209660053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209660053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209660053">(Sep 10 2020 at 15:06)</a>:</h4>
<p>Ah!</p>



<a name="209660080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209660080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209660080">(Sep 10 2020 at 15:07)</a>:</h4>
<p>But you are going to have problems with this approach, because you have sorried data in your definition of M1</p>



<a name="209660099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209660099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209660099">(Sep 10 2020 at 15:07)</a>:</h4>
<p>So, cases on <code>m</code> is like cases on "the second component of <code>m</code>"?</p>



<a name="209660105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209660105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209660105">(Sep 10 2020 at 15:07)</a>:</h4>
<p>So the moment Lean takes it apart it's going to get really confused.</p>



<a name="209660143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209660143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209660143">(Sep 10 2020 at 15:07)</a>:</h4>
<p>No, cases on m is like cases on m.</p>



<a name="209660183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209660183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209660183">(Sep 10 2020 at 15:08)</a>:</h4>
<p>Cases on the second component of <code>m</code> is <code>cases m.2</code> which is different</p>



<a name="209660262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209660262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209660262">(Sep 10 2020 at 15:08)</a>:</h4>
<p>I don't know what you mean</p>



<a name="209660352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209660352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209660352">(Sep 10 2020 at 15:09)</a>:</h4>
<p>But you said I can do cases on <code>m</code> to get the first/second element: is that the same thing as doing <code>m.1</code> or <code>m.2</code>?</p>



<a name="209660572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209660572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209660572">(Sep 10 2020 at 15:10)</a>:</h4>
<p>I want to do cases on a proof of the existence of something to get an instance of that something (in this case, I would like to get my hands on an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>, whose existence is granted by <code>m.2</code>)</p>



<a name="209660601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209660601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209660601">(Sep 10 2020 at 15:10)</a>:</h4>
<p>Is that correct?</p>



<a name="209661023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661023">(Sep 10 2020 at 15:12)</a>:</h4>
<p>Yes, you can <code>obtain</code> out of an existential, which is provided to you from the <code>property</code> of your <code>fractional_ideal f</code>.</p>



<a name="209661060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661060">(Sep 10 2020 at 15:13)</a>:</h4>
<p>but are you use you will be able to use those to prove what you want to prove? That's because of Kevin's statement that you've<code>sorry</code>ed the proof about the existence of <code>M1</code>.</p>



<a name="209661117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661117">(Sep 10 2020 at 15:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="300245">Filippo A. E. Nuccio</span> <a href="#narrow/stream/113489-new-members/topic/.23check.20and.20.23check.40/near/209660352">said</a>:</p>
<blockquote>
<p>But you said I can do cases on <code>m</code> to get the first/second element: is that the same thing as doing <code>m.1</code> or <code>m.2</code>?</p>
</blockquote>
<p><code>cases m with m1 m2</code> will destroy the term <code>m</code> and give you instead two news terms <code>m1</code> and <code>m2</code>, which you could have got to using <code>m.1</code> and <code>m.2</code> without destroying <code>m</code>. I don't understand what you mean by "doing" a term -- I don't think that makes any sense.</p>



<a name="209661189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661189">(Sep 10 2020 at 15:14)</a>:</h4>
<p>Let's fill in the sorry because you shouldn't sorry data.</p>



<a name="209661247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661247">(Sep 10 2020 at 15:14)</a>:</h4>
<p>What do you want M1 to be?</p>



<a name="209661261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661261">(Sep 10 2020 at 15:14)</a>:</h4>
<p>Sure-by "doing" I meant "appending a dot followed by a number 1 or 2"</p>



<a name="209661339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661339">(Sep 10 2020 at 15:14)</a>:</h4>
<p>OK</p>



<a name="209661464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661464">(Sep 10 2020 at 15:15)</a>:</h4>
<p>Oh yeah -- doing the cases just destroys <code>m</code> and keeps its pieces.</p>



<a name="209661524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661524">(Sep 10 2020 at 15:15)</a>:</h4>
<p>You can make <code>m</code> again from <code>m1</code> and <code>m2</code> using <code>\&lt;m1, m2\&gt;</code></p>



<a name="209661718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661718">(Sep 10 2020 at 15:16)</a>:</h4>
<p>Can I simply copy-paste my actual (almost complete) proof of <code>have M1 : fractional_ideal f,    { sorry },</code>?</p>



<a name="209661810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661810">(Sep 10 2020 at 15:16)</a>:</h4>
<p>Or do you want the entire code together with that piece of proof?</p>



<a name="209661825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661825">(Sep 10 2020 at 15:16)</a>:</h4>
<p>sure, I can try and plumb it in.</p>



<a name="209661848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661848">(Sep 10 2020 at 15:16)</a>:</h4>
<p>OK</p>



<a name="209661908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661908">(Sep 10 2020 at 15:16)</a>:</h4>
<p>have M1 : fractional_ideal f,<br>
{use setM1,<br>
  {intros y h,simp,use 0,simp,},<br>
  {intros a b ha hb,intros y h,rw add_mul a b (f.to_map y),<br>
  apply localization_map.is_integer_add,apply ha,exact h,apply hb,exact h,},<br>
  -- {intros c x h y h,<br>
  -- apply smul_mul c},<br>
   { intros c x h1 y h,<br>
    rw algebra.smul_mul_assoc,<br>
    apply localization_map.is_integer_smul,<br>
    exact h1 y h,},sorry,<br>
},</p>



<a name="209661973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661973">(Sep 10 2020 at 15:17)</a>:</h4>
<p>but my question was different -- it was "what do you want the definition of M1 to be mathematically"? I was then going to try and make it myself.</p>



<a name="209661980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661980">(Sep 10 2020 at 15:17)</a>:</h4>
<p>As you see, I still have a <code>sorry</code> at the end</p>



<a name="209661989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209661989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209661989">(Sep 10 2020 at 15:17)</a>:</h4>
<p>Ah, sorry</p>



<a name="209662140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662140">(Sep 10 2020 at 15:18)</a>:</h4>
<p>AH, ok: I am definining the inverse of the maximal ideal <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>; so I defined a set <code>setM1</code> and then I wanted to prove it is (the first component of) a fractional ideal <code>M1</code>.</p>



<a name="209662293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662293">(Sep 10 2020 at 15:19)</a>:</h4>
<p>I see. But it isn't, in general, right?</p>



<a name="209662332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662332">(Sep 10 2020 at 15:19)</a>:</h4>
<p>I haven't ever used this stuff before so I just spent 5 minutes reading the API for fractional_ideal</p>



<a name="209662512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662512">(Sep 10 2020 at 15:20)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks">#backticks</a></p>



<a name="209662534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662534">(Sep 10 2020 at 15:20)</a>:</h4>
<p>What do you mean by "it isn't in general"?</p>



<a name="209662570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662570">(Sep 10 2020 at 15:20)</a>:</h4>
<p>Did you read the API for <code>fractional_ideal</code>?</p>



<a name="209662622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662622">(Sep 10 2020 at 15:21)</a>:</h4>
<p>e.g.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">fractional_ideal</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mem_zero_iff</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">P</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">fractional_ideal</span> <span class="n">f</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="bp">⟨</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x&#39;</span><span class="o">,</span> <span class="n">x&#39;_mem_zero</span><span class="o">,</span> <span class="n">x&#39;_eq_x</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">x&#39;_eq_zero</span> <span class="o">:</span> <span class="n">x&#39;</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">x&#39;_mem_zero</span><span class="o">,</span>
    <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">x&#39;_eq_x</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">x&#39;_eq_zero</span><span class="o">]),</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">hx</span><span class="o">,</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="o">]</span><span class="bp">⟩</span><span class="o">)</span> <span class="bp">⟩</span>
</code></pre></div>



<a name="209662655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662655">(Sep 10 2020 at 15:21)</a>:</h4>
<p>I have never worked with fractional ideals at all in Lean, but I know the theory back to front mathematically.</p>



<a name="209662692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662692">(Sep 10 2020 at 15:21)</a>:</h4>
<p>So to learn how to use them in Lean, the first thing I do is jump to the definition and look through the file it's in</p>



<a name="209662763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662763">(Sep 10 2020 at 15:22)</a>:</h4>
<p>If you're saying that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> is the unique non-invertible prime in a Dedekind Domain, I certainly agree.</p>



<a name="209662824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662824">(Sep 10 2020 at 15:22)</a>:</h4>
<p>I'm sure you do, because I am sure you know the mathematics every bit as well as I do</p>



<a name="209662828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662828">(Sep 10 2020 at 15:22)</a>:</h4>
<p>But I am now proving that every maximal ideal in a (non-zero) DD is invertible, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> is not maximal</p>



<a name="209662930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209662930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209662930">(Sep 10 2020 at 15:23)</a>:</h4>
<p>Oh that's a relief! I hadn't spotted that you had a variable <code>[is_maximal M]</code></p>



<a name="209663032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663032">(Sep 10 2020 at 15:23)</a>:</h4>
<p>I am following Samuel's approach: first prove that maximal ones are invertible, then use this to prove every non-zero ideal is invertible.</p>



<a name="209663061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663061">(Sep 10 2020 at 15:24)</a>:</h4>
<p>Do you have that <code>R</code> is not a field?</p>



<a name="209663115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663115">(Sep 10 2020 at 15:24)</a>:</h4>
<p>You didn't have it in the MWE</p>



<a name="209663186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663186">(Sep 10 2020 at 15:24)</a>:</h4>
<p>Good point-let me check.</p>



<a name="209663251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663251">(Sep 10 2020 at 15:25)</a>:</h4>
<p>VERY good point; I have not.</p>



<a name="209663291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663291">(Sep 10 2020 at 15:25)</a>:</h4>
<p>I will certainly add this (or simply assume <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">M\neq 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>)</p>



<a name="209663325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663325">(Sep 10 2020 at 15:25)</a>:</h4>
<p>But you have that R is a Dedekind domain, right? Because this is a 1d phenomenon</p>



<a name="209663387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663387">(Sep 10 2020 at 15:26)</a>:</h4>
<p>Sure, this i have</p>



<a name="209663426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663426">(Sep 10 2020 at 15:26)</a>:</h4>
<p>in the mwe I did not add this, as it seemed irrelevant at that point of the discussion</p>



<a name="209663443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663443">(Sep 10 2020 at 15:26)</a>:</h4>
<p>and I tried to make it "minimal"</p>



<a name="209663487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663487">(Sep 10 2020 at 15:26)</a>:</h4>
<p>but got it wrong again... <span aria-label="unamused" class="emoji emoji-1f612" role="img" title="unamused">:unamused:</span></p>



<a name="209663563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663563">(Sep 10 2020 at 15:27)</a>:</h4>
<p>Have you read the API for fractional ideals? <code>inv</code> and <code>div</code> are already defined.</p>



<a name="209663694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663694">(Sep 10 2020 at 15:28)</a>:</h4>
<p>If you are proving theorems about fractional ideals, you should really read all of <code>ring_theory/fractional_ideal</code>, in a certain kind of way which won't take very long</p>



<a name="209663731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663731">(Sep 10 2020 at 15:28)</a>:</h4>
<p>You should read the docstring of every definition, and the statement of every theorem in the file</p>



<a name="209663755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663755">(Sep 10 2020 at 15:28)</a>:</h4>
<p>and skip all the proofs, most of them are obvious</p>



<a name="209663969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209663969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209663969">(Sep 10 2020 at 15:30)</a>:</h4>
<p>Well, I tried to do that and read all of it (although I might confess I have not understood the whole of it).</p>



<a name="209664072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209664072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209664072">(Sep 10 2020 at 15:30)</a>:</h4>
<p>The definitions are essentially all fundamental, and the theorems all very well-known (to you). What is an example of something you don't understand?</p>



<a name="209664179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209664179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209664179">(Sep 10 2020 at 15:31)</a>:</h4>
<p>Well, bits of codes I can't fully understand: for instance, <br>
<code>noncomputable instance fractional_ideal_has_div :
  has_div (fractional_ideal g) :=
⟨ λ I J, if h : J = 0 then 0 else ⟨I.1 / J.1, fractional_div_of_nonzero h⟩ ⟩</code></p>



<a name="209664429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209664429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209664429">(Sep 10 2020 at 15:32)</a>:</h4>
<p>That means "we define the symbol <code>/</code> on fractional ideals as follows. If <code>J = 0</code> then <code>I/J=0</code> and if <code>J</code> isn't <code>0</code> then it's the pair consisting of the submodule<code>I.1/J.1</code>, and a proof which we did earlier which shows that this is a fractional ideal"</p>



<a name="209664548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209664548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209664548">(Sep 10 2020 at 15:33)</a>:</h4>
<p>But you shouldn't be reading the definition, you should be reading the docstring which is missing, and which should say "<code>I/J</code> is the fractional ideal <code>I/J</code> if <code>J</code> is non-zero, and some junk value if <code>J=0</code>"</p>



<a name="209664579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209664579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209664579">(Sep 10 2020 at 15:34)</a>:</h4>
<p>That's all you need to know for now about that definition. Anything else?</p>



<a name="209664661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209664661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209664661">(Sep 10 2020 at 15:34)</a>:</h4>
<p>this was more or less ok, but the <code>noncomputable</code> bit is still obscure-yet I tried to go on. That' s what I mean when I say "I understood almost all of it, but not all".</p>



<a name="209664714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209664714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209664714">(Sep 10 2020 at 15:34)</a>:</h4>
<p><code>has_div</code> is a notational typeclass, so it's just saying what <code>/</code> means.</p>



<a name="209664822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209664822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209664822">(Sep 10 2020 at 15:35)</a>:</h4>
<p><code>noncomputable</code> means the following.</p>



<a name="209665053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665053">(Sep 10 2020 at 15:36)</a>:</h4>
<p>Let <code>R</code> be the integers, and let <code>J</code> be an ideal defined by an extremely obscure method. Then might not be able to <em>literally work out</em> what <code>1/J</code> is.</p>



<a name="209665331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665331">(Sep 10 2020 at 15:38)</a>:</h4>
<p>...are you saying that <code>noncomputable</code> asks Lean not to care?</p>



<a name="209665364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665364">(Sep 10 2020 at 15:38)</a>:</h4>
<p>If you ask Lean using <code>#eval</code> to compute the square of 4 it will say 16.</p>



<a name="209665445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665445">(Sep 10 2020 at 15:39)</a>:</h4>
<p>But if you used <code>#eval</code> to work out <code>1/J</code> then because it can't work out if <code>J</code> is 0 or not, it cannot evaluate the definition of <code>1/J</code> because it doesn't know which branch of the <code>if</code> to take.</p>



<a name="209665534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665534">(Sep 10 2020 at 15:40)</a>:</h4>
<p><code>if h : J = 0 then 0 else ⟨I.1 / J.1, fractional_div_of_nonzero h⟩</code></p>



<a name="209665599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665599">(Sep 10 2020 at 15:40)</a>:</h4>
<p>"If something happens, run one computer program, and if it doesn't, then run another one"</p>



<a name="209665627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665627">(Sep 10 2020 at 15:40)</a>:</h4>
<p>To actually run this program, the computer needs to know which thing happened.</p>



<a name="209665673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665673">(Sep 10 2020 at 15:40)</a>:</h4>
<p>Mathematicians <em>do not need to know</em>. This is why all of this sounds insanely weird to you.</p>



<a name="209665676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665676">(Sep 10 2020 at 15:40)</a>:</h4>
<p>And it might not be able to compute if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">J=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> or not?</p>



<a name="209665685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665685">(Sep 10 2020 at 15:40)</a>:</h4>
<p>Right.</p>



<a name="209665701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665701">(Sep 10 2020 at 15:40)</a>:</h4>
<p>But we as mathematicians don't care.</p>



<a name="209665730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665730">(Sep 10 2020 at 15:41)</a>:</h4>
<p>If J=0 the definition is one thing, if it isn't zero it's another thing</p>



<a name="209665825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665825">(Sep 10 2020 at 15:41)</a>:</h4>
<p>and if we came up with this in a proof, we could just do a case split: we could create a hypothesis <code>h : J = 0 \or not (J = 0)</code> and do <code>cases h</code></p>



<a name="209665949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209665949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209665949">(Sep 10 2020 at 15:42)</a>:</h4>
<p>but if you are actually trying to write a computer program then you need to be sure that your computer program knows how to figure out which way to go next</p>



<a name="209666025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666025">(Sep 10 2020 at 15:42)</a>:</h4>
<p>because <code>J = 0</code> is a statement involving an infinite set (R) and so you can't just check all the cases.</p>



<a name="209666042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666042">(Sep 10 2020 at 15:43)</a>:</h4>
<p>But this is of no relevance to us.</p>



<a name="209666084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666084">(Sep 10 2020 at 15:43)</a>:</h4>
<p>There were times in the perfectoid project where we just wrote <code>noncomputable theory</code> at the top of our files.</p>



<a name="209666124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666124">(Sep 10 2020 at 15:43)</a>:</h4>
<p>Files which are used to power certain tactics need to be computable, but this does not.</p>



<a name="209666343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666343">(Sep 10 2020 at 15:45)</a>:</h4>
<p>OK. But would Lean complain on the nose if the <code>noncomputable</code> bit was missing, or would it explose? Or would it complain only once it would be asked to invert an ideal?</p>



<a name="209666415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666415">(Sep 10 2020 at 15:45)</a>:</h4>
<p>Lean will only complain if you try to <code>#eval</code> something. It will <em>never</em> complain if you just want to prove theorems and build up the theory abstractly.</p>



<a name="209666436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666436">(Sep 10 2020 at 15:45)</a>:</h4>
<p>which is what I want to do</p>



<a name="209666438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666438">(Sep 10 2020 at 15:45)</a>:</h4>
<p>Ah ok.</p>



<a name="209666549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666549">(Sep 10 2020 at 15:46)</a>:</h4>
<p>so noncomputable doesn't matter at all. Maybe some constructivist will come along later on and complain, but in my opinion this is their problem not ours.</p>



<a name="209666593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666593">(Sep 10 2020 at 15:46)</a>:</h4>
<p>Thanks so much, at any rate. I am sorry again for the beginning with my m-nonw-e.</p>



<a name="209666665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666665">(Sep 10 2020 at 15:47)</a>:</h4>
<p>Now I think I can try to go back to my file trying to add <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">M\neq 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> and trying to see if I can finish the proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">M1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">1</span></span></span></span> is fractional.</p>



<a name="209666692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666692">(Sep 10 2020 at 15:47)</a>:</h4>
<p>I agree that part of this can already be in <code>fractional_ideal</code></p>



<a name="209666733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666733">(Sep 10 2020 at 15:48)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">trial</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">fractional_ideal</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">Minv</span> <span class="o">:=</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">fractional_ideal</span> <span class="n">f</span><span class="o">)</span><span class="bp">⁻¹</span><span class="o">,</span>
</code></pre></div>



<a name="209666786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666786">(Sep 10 2020 at 15:48)</a>:</h4>
<p>This is the way to start your proof.</p>



<a name="209666802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666802">(Sep 10 2020 at 15:48)</a>:</h4>
<p>Ah!</p>



<a name="209666818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666818">(Sep 10 2020 at 15:48)</a>:</h4>
<p>But I was looking through the API and I think that the following is missing:</p>



<a name="209666845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666845">(Sep 10 2020 at 15:48)</a>:</h4>
<p><code>(I/J)*J \le I</code></p>



<a name="209666924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209666924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209666924">(Sep 10 2020 at 15:49)</a>:</h4>
<p>Yes, this I haven't seen. I will try modifying the proof with your hint, I hope to get somewhere soon...</p>



<a name="209667473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209667473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209667473">(Sep 10 2020 at 15:52)</a>:</h4>
<p>After <code>lemma le_div_iff {I J K : submodule R A} : I ≤ J / K ↔ ∀ (x ∈ I) (z ∈ K), x * z ∈ J := iff.refl _
</code> in <code>algebra_operations</code> there should be the lemma that <code>I &lt;= J/K iff I*K &lt;= J</code></p>



<a name="209667782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209667782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209667782">(Sep 10 2020 at 15:54)</a>:</h4>
<p>You have <code>mul_le</code>. Do you understand what I'm saying?</p>



<a name="209668246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209668246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209668246">(Sep 10 2020 at 15:57)</a>:</h4>
<p>Yes, I think I do and I think I also see how you want me to use it to get a very quick proof of the invertibility of <code>M</code>.</p>



<a name="209668332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209668332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209668332">(Sep 10 2020 at 15:58)</a>:</h4>
<p>But I need to sit down and write everything properly on a sheet of paper.</p>



<a name="209668342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209668342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209668342">(Sep 10 2020 at 15:58)</a>:</h4>
<p>Presumably your proof wants to go like this. Say M is maximal and non-zero (why not just work in this generality, rather than saying "assume R is not a field"). mathlib already has inverses so let's set J=1/M. Now let's consider <code>J*M=(1/M)*M</code>. By some lemma which isn't in the library apparently, we have <code>(I/K)*K &lt;= I</code>. Hence <code>J*M</code> is an ideal of R. Now M &lt;= 1 so 1/1 &lt;= 1/M  and 1/1=1 so <code>J*M</code> contains <code>M</code>.</p>



<a name="209668428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209668428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209668428">(Sep 10 2020 at 15:58)</a>:</h4>
<p>Note that J/K &lt;= J/K and hence (J/K)*K &lt;= J</p>



<a name="209668587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209668587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209668587">(Sep 10 2020 at 15:59)</a>:</h4>
<p>etc etc.</p>



<a name="209668711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209668711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209668711">(Sep 10 2020 at 16:00)</a>:</h4>
<p>But you should not launch straight into a proof in a <code>begin end</code> block. You should plan your proof because ultimately you want it to be very short, and you want to factor out as many sublemmas as possible.</p>



<a name="209669173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209669173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209669173">(Sep 10 2020 at 16:03)</a>:</h4>
<p>Yes, this is basically the proof I have written down so far; a part from the fact that<br>
1) my definition of the inverse of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> was long and could probably be shortened, as you suggest<br>
2) Certainly need to add <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">M\neq 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br>
3) Still have some <code>sorry</code>'s here and there</p>



<a name="209669358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209669358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209669358">(Sep 10 2020 at 16:04)</a>:</h4>
<p>What I'm saying is that before you write any Lean code you should have a complete maths proof in front of you with all the details written down.</p>



<a name="209669380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209669380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209669380">(Sep 10 2020 at 16:04)</a>:</h4>
<p>And then you see you need (1/M)*M &lt;= R</p>



<a name="209669406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209669406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209669406">(Sep 10 2020 at 16:05)</a>:</h4>
<p>and then you see that this follows from <code>(I/J)*J &lt;= I</code></p>



<a name="209669498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209669498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209669498">(Sep 10 2020 at 16:05)</a>:</h4>
<p>and you then realise that this follows from <code>I &lt;= J/K iff I * K &lt;= J</code></p>



<a name="209669609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209669609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209669609">(Sep 10 2020 at 16:06)</a>:</h4>
<p>I agree; the problem is that as I started I was sure that having Samuel's proof under my eyes contained "all the details"; then I realised some "details" were missing; then other are missing, etc...</p>



<a name="209669721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209669721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209669721">(Sep 10 2020 at 16:07)</a>:</h4>
<p>It took me some time, for instance, to realise that injectivity of the localisation map was used (and hence useful)</p>



<a name="209669744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209669744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209669744">(Sep 10 2020 at 16:07)</a>:</h4>
<p>so the first thing you should do is prove <code>submodule.le_div_iff_mul_le</code></p>



<a name="209670277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209670277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209670277">(Sep 10 2020 at 16:11)</a>:</h4>
<p>Here's a proof; I've put it in <code>algebra_operations</code>. </p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">le_div_iff_mul_le</span> <span class="o">{</span><span class="n">I</span> <span class="n">J</span> <span class="n">K</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">≤</span> <span class="n">J</span> <span class="bp">/</span> <span class="n">K</span> <span class="bp">↔</span> <span class="n">I</span> <span class="bp">*</span> <span class="n">K</span> <span class="bp">≤</span> <span class="n">J</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">le_div_iff</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_le</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>You'll need it. I'll PR it.</p>



<a name="209670421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209670421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209670421">(Sep 10 2020 at 16:12)</a>:</h4>
<p>Thanks!</p>



<a name="209670666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209670666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209670666">(Sep 10 2020 at 16:14)</a>:</h4>
<p>The idea is that ultimately the proof between the <code>begin end</code> block of the theorem should look pretty much like what is written in Samuel. But to make this happen you need the infrastructure underneath to be good. Otherwise you keep finding yourself going off on wild tangents.</p>



<a name="209670709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209670709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209670709">(Sep 10 2020 at 16:14)</a>:</h4>
<p>Let me know what you think the maths proof should look like and let's see if we can make the Lean proof look as decent.</p>



<a name="209670914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209670914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209670914">(Sep 10 2020 at 16:16)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/4102">#4102</a></p>



<a name="209672583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209672583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209672583">(Sep 10 2020 at 16:28)</a>:</h4>
<p>Well, I am trying to first write down _one_ proof myself (lest I'll never learn anything about Lean, nor have any fun). I will then try to polish it and once this will look to me as similar as possible as Samuel's, I will either PR it or show it to you so that you can delete it and write it from scratch.</p>



<a name="209677526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209677526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209677526">(Sep 10 2020 at 17:02)</a>:</h4>
<p>OK! See if you can make it to the end and feel free to ask if you have any more questions. The answer to your original question is the following. You have several problems with your code. Firstly, you have sorried data (sorried proofs are fine but sorried data is not). Secondly, you are re-inventing the wheel with <code>setM1</code> and <code>M1</code> : they already defined inverses of fractional ideals and division of fractional ideals, and if it's in mathlib then it's a good idea to use it. Finally, you do cases on terms, not types. <code>is_fractional f _</code> is a type so you can never do cases on it. The term you're looking for (to do <code>cases</code> on) is <code>M1.2</code>, the second component of <code>M1</code>, but you might have problems doing <code>cases</code> on it because of the sorried data.</p>



<a name="209750256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%23check%20and%20%23check%40/near/209750256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.23check.20and.20.23check.40.html#209750256">(Sep 11 2020 at 07:50)</a>:</h4>
<p>Great, thanks. I'll work on it, hoping to (have fun, and) get somewhere. Thanks for your hints and comments.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Proving.20functions.20are.20equal.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20functions.20are.20equal.html">Proving functions are equal</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="222516378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20functions%20are%20equal/near/222516378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Devon Richards <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20functions.20are.20equal.html#222516378">(Jan 13 2021 at 00:36)</a>:</h4>
<p>I was playing around with lean trying to familiarize myself with it so I decided to try and define finite sequences and some operations on them. I defined <code>finite_sequence (n : nat) (\alpha : Type u)</code> as <code>fin n \to \alpha</code>. Then I defined <code>initial_segment s m</code> which is the sequence of the first m elements of s,  and <code>concat s t</code> which is the sequence made by the elements of s followed by the elements of t.<br>
Now I'm trying to prove that <code>\forall (s t : finite_sequence n \alpha), s = initial_segment (concat s t)</code> and I'm having trouble figuring out how to prove it in Lean. The outline of the proof in my head is to show that <code>\forall i, s i = (initial_segment (concat s t)) i</code>. Do I need to restate the theorem in that form or is there some good way to prove them equal otherwise without needing to simplify the definitions till they're definitionaly equal? I was wanting to treat the sequences as concrete objects not functions so the equality without the explicit parameter seemed much more aesthetically appealing.</p>



<a name="222517015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20functions%20are%20equal/near/222517015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20functions.20are.20equal.html#222517015">(Jan 13 2021 at 00:44)</a>:</h4>
<p>To "prove things are equal by proving their parts are equal," i.e. extensionality, you use the <code>ext</code> tactic (<a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#ext">tactic#ext</a>). Although this is general advice and I'm not completely sure it will work for your case.</p>



<a name="222517160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20functions%20are%20equal/near/222517160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20functions.20are.20equal.html#222517160">(Jan 13 2021 at 00:46)</a>:</h4>
<p><code>funext</code> is the theorem you need. The <code>ext</code> tactic is one way of automatically applying funext</p>



<a name="222517242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20functions%20are%20equal/near/222517242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Devon Richards <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20functions.20are.20equal.html#222517242">(Jan 13 2021 at 00:47)</a>:</h4>
<p>Thank you, that was exactly what I wanted.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Sebastian.20Zivota.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html">Sebastian Zivota</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="263148316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263148316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Zivota <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263148316">(Nov 30 2021 at 14:01)</a>:</h4>
<p>Hi, I'm interested in formalizing some (synthetic) projective geometry in Lean for my own enjoyment. To be honest I'm already struggling with how to formulate the definition of a projective plane, to wit: A projective plane comprises a set P of Points and a set L of Lines, with an incidence relation ε between them, satisfying the following axioms:</p>
<ol>
<li>For every p, q ∈ P with p ≠ q, there is a unique ℓ ∈ L such that p ε ℓ and q ε ℓ.</li>
<li>For every ℓ, m ∈ L with ℓ ≠ m, there is a p ∈ P such that p ε ℓ and p ε m.</li>
<li>There are four points such that no three among them lie on a line.</li>
</ol>
<p>My first approach was to model this as a structure:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">projective_plane</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">is_on</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">L</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">connecting_line</span> <span class="o">:</span> <span class="bp">…</span><span class="o">)</span>
  <span class="o">(</span><span class="n">intersection_point</span> <span class="o">:</span> <span class="bp">…</span><span class="o">)</span>
  <span class="o">(</span><span class="n">exists_quadrangle</span> <span class="o">:</span> <span class="bp">…</span><span class="o">)</span>
</code></pre></div>
<p>But if I do this, I don't see how I can e.g. define ε as notation for is_on (because it's relative to the plane). Is this the right approach or should I be doing something differently?</p>



<a name="263149134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263149134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263149134">(Nov 30 2021 at 14:07)</a>:</h4>
<p>Here is a rough estimate for what could be done...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">projective_plane</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">is_on</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">L</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">connecting_line</span> <span class="o">:</span> <span class="gr">sorry</span><span class="o">)</span>
  <span class="o">(</span><span class="n">intersection_point</span> <span class="o">:</span> <span class="gr">sorry</span><span class="o">)</span>
  <span class="o">(</span><span class="n">exists_quadrangle</span> <span class="o">:</span> <span class="gr">sorry</span><span class="o">)</span>

<span class="kd">notation</span> <span class="n">a</span> <span class="bp">`</span><span class="n">ε</span><span class="bp">`</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">projective_plane.is_on</span> <span class="n">a</span> <span class="n">b</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">P</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">projective_plane</span> <span class="n">P</span> <span class="n">L</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">p</span> <span class="n">ε</span> <span class="n">l</span>
</code></pre></div>



<a name="263149638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263149638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Zivota <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263149638">(Nov 30 2021 at 14:11)</a>:</h4>
<p>Excellent, thank you very much.</p>



<a name="263149671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263149671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263149671">(Nov 30 2021 at 14:11)</a>:</h4>
<p>yeah, creating a typeclass is a nice idea. alternatively, you can also use a <code>variables</code> declaration to introduce an instance of the plane structure, and then define notations to your heart's content!</p>



<a name="263149873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263149873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263149873">(Nov 30 2021 at 14:12)</a>:</h4>
<p>I prefer <code>variables</code> because that's what the IMO Grand Challenge does</p>



<a name="263150108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263150108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263150108">(Nov 30 2021 at 14:14)</a>:</h4>
<p>mathlib is a treasure trove of quality lean code. you should clone and read the code to learn lean <a href="https://github.com/leanprover-community/mathlib/tree/master/archive/imo">https://github.com/leanprover-community/mathlib/tree/master/archive/imo</a></p>



<a name="263154849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263154849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263154849">(Nov 30 2021 at 14:45)</a>:</h4>
<p>Making <code>projective_plane</code> a class sounds like the way to go, because then you can instantiate it for concrete projective planes instead of always having to pass around the same 3 hypotheses.</p>



<a name="263158252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263158252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263158252">(Nov 30 2021 at 15:09)</a>:</h4>
<p>Why not a <code>structure</code>?</p>



<a name="263163586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263163586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Zivota <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263163586">(Nov 30 2021 at 15:47)</a>:</h4>
<p>Does it make sense to create an auxiliary class <code>has_incidence</code> so that I can use the <code>ε</code> notation in the definition of a projective plane? And can I set this up so that I don't have to put both <code>[has_incidence]</code> and <code>[projective_plane]</code> bounds on functions?</p>



<a name="263166949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263166949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263166949">(Nov 30 2021 at 16:08)</a>:</h4>
<p>Do you really insist on not using the usual <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> symbol?</p>



<a name="263167887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263167887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Zivota <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263167887">(Nov 30 2021 at 16:15)</a>:</h4>
<p>No, not at all. I'd be fine with using <code>∈</code>.</p>



<a name="263172089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263172089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263172089">(Nov 30 2021 at 16:43)</a>:</h4>
<p>To use the standard symbol, you can extend the <code>has_mem</code> class:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">projective_plane</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mem</span> <span class="n">P</span> <span class="n">L</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">connecting_line</span> <span class="o">:</span> <span class="gr">sorry</span><span class="o">)</span>
  <span class="o">(</span><span class="n">intersection_point</span> <span class="o">:</span> <span class="gr">sorry</span><span class="o">)</span>
  <span class="o">(</span><span class="n">exists_quadrangle</span> <span class="o">:</span> <span class="gr">sorry</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">P</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">projective_plane</span> <span class="n">P</span> <span class="n">L</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">l</span>
</code></pre></div>



<a name="263210241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263210241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Zivota <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263210241">(Nov 30 2021 at 21:18)</a>:</h4>
<p>Is there an equivalent of has_mem in Lean 4?</p>



<a name="263214527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263214527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263214527">(Nov 30 2021 at 21:57)</a>:</h4>
<p>yes, in mathlib4: <a href="https://github.com/leanprover-community/mathlib4/blob/ceae8916f072cb3cb7fc67a88e01828d42bd924f/Mathlib/Init/SetNotation.lean#L1-L2">https://github.com/leanprover-community/mathlib4/blob/ceae8916f072cb3cb7fc67a88e01828d42bd924f/Mathlib/Init/SetNotation.lean#L1-L2</a></p>



<a name="263221256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263221256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263221256">(Nov 30 2021 at 23:00)</a>:</h4>
<p>There's also a little-used feature where you can define notation for use inside a definition.  I don't recommend it here because it conflicts with <code>has_mem</code>, but anyway here's how that works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">projective_plane</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_on</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">L</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kd">infix</span> <span class="bp">`</span> <span class="bp">∈</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">is_on</span><span class="o">)</span>
<span class="o">(</span><span class="n">connecting_line</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">P</span><span class="o">),</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">q</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">L</span><span class="o">),</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">intersection_point</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">ℓ</span> <span class="n">ℓ'</span> <span class="o">:</span> <span class="n">L</span><span class="o">),</span> <span class="n">ℓ</span> <span class="bp">≠</span> <span class="n">ℓ'</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">),</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">ℓ'</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_quadrangle</span> <span class="o">:</span> <span class="gr">sorry</span><span class="o">)</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">∈</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">projective_plane.is_on</span>
</code></pre></div>



<a name="263285258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263285258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Zivota <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263285258">(Dec 01 2021 at 12:59)</a>:</h4>
<p>How can I use/import <code>mathlib4</code>?</p>



<a name="263318666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263318666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263318666">(Dec 01 2021 at 16:39)</a>:</h4>
<p><code>mathlib4</code> right now is just some playground for experimenting with mathematics in Lean 4. Are you sure you want to use/import it? If so then just clone it and open it in VS Code, making sure you have the lean 4 extension enabled. Note however that all the code above was written in Lean 3, and there is no compatibility between the two versions.</p>



<a name="263420005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263420005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Zivota <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263420005">(Dec 02 2021 at 10:55)</a>:</h4>
<p>Right, I'm gonna switch to Lean 3 then :)</p>



<a name="263504704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263504704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Zivota <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263504704">(Dec 02 2021 at 21:47)</a>:</h4>
<p>Can I define a function for the connecting line of two distinct points? The problem is that it wouldn't be well-defined for all pairs of points.</p>



<a name="263504831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263504831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263504831">(Dec 02 2021 at 21:48)</a>:</h4>
<p>In the context of affine geometry?</p>



<a name="263505022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263505022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263505022">(Dec 02 2021 at 21:51)</a>:</h4>
<p>You can use <code>if ... then ... else ...</code> and just have it take a junk value if the two points are the same (you might need to assume <code>[nonempty L]</code>, then the junk value can be <code>default L</code>).  This is an approach taken fairly often in similar situations in mathlib.</p>
<p>Here's a discussion of the "junk value" technique from Kevin Buzzard's blog:<br>
<a href="https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/">https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/</a></p>



<a name="263505072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263505072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263505072">(Dec 02 2021 at 21:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="460941">Sebastian Zivota</span> <a href="#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263504704">said</a>:</p>
<blockquote>
<p>Can I define a function for the connecting line of two distinct points? The problem is that it wouldn't be well-defined for all pairs of points.</p>
</blockquote>
<p>How do you define "line"? In the context of affine geometry, you could take two points and return the affine span of the two points, so if the two points are the same you just get the point back.</p>



<a name="263505120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263505120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263505120">(Dec 02 2021 at 21:52)</a>:</h4>
<p>AH of course this is for your projective geometry above <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="263505152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263505152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263505152">(Dec 02 2021 at 21:52)</a>:</h4>
<p>Ah ok, so if you have already defined projective spaces, you could (first define, then.....) take the projective span ;)</p>



<a name="263505310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263505310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263505310">(Dec 02 2021 at 21:54)</a>:</h4>
<p>Ah I see, you want to use <code>projective_plane</code>from the code above. Yes, I would follow Heather's advice.</p>



<a name="263505327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263505327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263505327">(Dec 02 2021 at 21:54)</a>:</h4>
<p>(sorry, my connection seems to be lagging a bit today)</p>



<a name="263506071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263506071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263506071">(Dec 02 2021 at 22:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="460941">Sebastian Zivota</span> <a href="#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263504704">said</a>:</p>
<blockquote>
<p>Can I define a function for the connecting line of two distinct points? The problem is that it wouldn't be well-defined for all pairs of points.</p>
</blockquote>
<p>If your axiom is <code>connecting_line : ∀ (p q : P), p ≠ q → ∃! (ℓ : L), p ∈ ℓ</code>, then you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/exists.some">docs#exists.some</a></p>
<p>For example if <code>h</code> is a proof that <code>p</code> and <code>q</code> are not equal, you can do <code>(connecting_line p q h).some</code> (though you might need to specify the intended type <code>L</code> for the typeclass resolution to work).</p>



<a name="263508559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263508559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Zivota <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263508559">(Dec 02 2021 at 22:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263506071">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="460941">Sebastian Zivota</span> <a href="#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263504704">said</a>:</p>
<blockquote>
<p>Can I define a function for the connecting line of two distinct points? The problem is that it wouldn't be well-defined for all pairs of points.</p>
</blockquote>
<p>If your axiom is <code>connecting_line : ∀ (p q : P), p ≠ q → ∃! (ℓ : L), p ∈ ℓ</code>, then you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/exists.some">docs#exists.some</a></p>
<p>For example if <code>h</code> is a proof that <code>p</code> and <code>q</code> are not equal, you can do <code>(connecting_line p q h).some</code> (though you might need to specify the intended type <code>L</code> for the typeclass resolution to work).</p>
</blockquote>
<p>Assuming you mean <a href="https://leanprover-community.github.io/mathlib_docs/logic/basic.html#Exists.some">Exists.some</a>: this doesn't appear to use the uniqueness at all. <br>
Should I define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">connecting_line</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">P</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">L</span><span class="o">,</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">∈</span> <span class="n">ℓ</span>
<span class="n">line</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">Exists.some</span> <span class="o">(</span><span class="n">connecting_line</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span>
<span class="n">line_connects₁</span> <span class="o">:=</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">line</span> <span class="n">p</span> <span class="n">q</span>
<span class="n">line_connects₂</span> <span class="o">:=</span> <span class="n">q</span> <span class="bp">∈</span> <span class="n">line</span> <span class="n">p</span> <span class="n">q</span>
<span class="n">line_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">L</span><span class="o">),</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">line</span> <span class="n">p</span> <span class="n">q</span>
</code></pre></div>
<p>i.e. have <code>line p q</code> defined even for <code>p = q</code> and prove the interesting property (uniqueness) only for distinct points? Or is there another way to do it?</p>



<a name="263509235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263509235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263509235">(Dec 02 2021 at 22:32)</a>:</h4>
<p><span class="user-mention" data-user-id="460941">@Sebastian Zivota</span> do you have a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> with your <code>projective_plane</code> class?</p>



<a name="263509466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263509466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263509466">(Dec 02 2021 at 22:35)</a>:</h4>
<p>That's true that <a href="https://leanprover-community.github.io/mathlib_docs/find/Exists.some">docs#Exists.some</a> doesn't need uniqueness.  You can make use of the uniqueness property (to characterize this function) using <a href="https://leanprover-community.github.io/mathlib_docs/find/Exists.some_spec">docs#Exists.some_spec</a></p>
<p>Splitting the axiom like that seems like a reasonable idea, though, since we do know that there's a line running through every point.</p>



<a name="263509544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263509544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263509544">(Dec 02 2021 at 22:36)</a>:</h4>
<p>That then makes <a href="https://leanprover-community.github.io/mathlib_docs/find/Exists.some">docs#Exists.some</a> responsible for choosing the "junk data" for <code>line p p</code></p>



<a name="263562392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263562392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Zivota <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263562392">(Dec 03 2021 at 10:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263509235">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="460941">Sebastian Zivota</span> do you have a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> with your <code>projective_plane</code> class?</p>
</blockquote>
<p>Working, if not exactly pretty.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">P</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">is_triangle</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">P</span> <span class="n">L</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="n">p</span> <span class="bp">≠</span> <span class="n">q</span>
  <span class="bp">∧</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">r</span>
  <span class="bp">∧</span> <span class="n">q</span> <span class="bp">≠</span> <span class="n">r</span>
  <span class="bp">∧</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">l</span> <span class="o">:</span> <span class="n">L</span><span class="o">,</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">r</span> <span class="bp">∈</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">is_quadrangle</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">P</span> <span class="n">L</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="bp">@</span><span class="n">is_triangle</span> <span class="n">_</span> <span class="n">L</span> <span class="n">_</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span>
  <span class="bp">∧</span> <span class="bp">@</span><span class="n">is_triangle</span> <span class="n">_</span> <span class="n">L</span> <span class="n">_</span> <span class="n">p</span> <span class="n">q</span> <span class="n">s</span>
  <span class="bp">∧</span> <span class="bp">@</span><span class="n">is_triangle</span> <span class="n">_</span> <span class="n">L</span> <span class="n">_</span> <span class="n">p</span> <span class="n">r</span> <span class="n">s</span>
  <span class="bp">∧</span> <span class="bp">@</span><span class="n">is_triangle</span> <span class="n">_</span> <span class="n">L</span> <span class="n">_</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span>

<span class="kd">class</span> <span class="n">projective_plane</span> <span class="o">(</span><span class="n">P</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mem</span> <span class="n">P</span> <span class="n">L</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">exists_connecting_line</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">P</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">l</span> <span class="o">:</span> <span class="n">L</span><span class="o">,</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">)</span>
  <span class="o">(</span><span class="n">exists_intersection_point</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="n">m</span> <span class="o">:</span> <span class="n">L</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">,</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">point_line_uniq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">P</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="n">m</span> <span class="o">:</span> <span class="n">L</span><span class="o">},</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∈</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="bp">∨</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">exists_quadrangle</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">P</span><span class="o">),</span> <span class="bp">@</span><span class="n">is_quadrangle</span> <span class="n">_</span> <span class="n">L</span> <span class="n">_</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">projective_plane</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">P</span><span class="o">}</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">connecting_line</span> <span class="o">[</span><span class="n">projective_plane</span> <span class="n">P</span> <span class="n">L</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">Exists.some</span> <span class="o">(</span><span class="n">exists_connecting_line</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span>

<span class="kd">notation</span> <span class="n">p</span> <span class="bp">`</span> <span class="bp">⊔</span> <span class="bp">`</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">connecting_line</span> <span class="n">p</span> <span class="n">q</span>

<span class="kd">theorem</span> <span class="n">connecting_line_left</span> <span class="o">[</span><span class="n">projective_plane</span> <span class="n">P</span> <span class="n">L</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">P</span><span class="o">,</span>  <span class="n">p</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">@</span><span class="n">connecting_line</span> <span class="n">P</span> <span class="n">L</span> <span class="n">_</span> <span class="n">p</span> <span class="n">q</span> <span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">Exists.some_spec</span> <span class="o">(</span><span class="n">exists_connecting_line</span> <span class="n">p</span> <span class="n">q</span><span class="o">))</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">connecting_line_right</span> <span class="o">[</span><span class="n">projective_plane</span> <span class="n">P</span> <span class="n">L</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">P</span><span class="o">,</span>  <span class="n">q</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">@</span><span class="n">connecting_line</span> <span class="n">P</span> <span class="n">L</span> <span class="n">_</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">Exists.some_spec</span> <span class="o">(</span><span class="n">exists_connecting_line</span> <span class="n">p</span> <span class="n">q</span><span class="o">))</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">connecting_line_uniq</span> <span class="o">[</span><span class="n">projective_plane</span> <span class="n">P</span> <span class="n">L</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">L</span><span class="o">),</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">p</span> <span class="bp">⊔</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">p</span> <span class="n">q</span> <span class="n">l</span> <span class="n">hpq</span> <span class="n">hpl</span> <span class="n">hql</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hpm</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">p</span> <span class="bp">⊔</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">connecting_line_left</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hqm</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">∈</span> <span class="n">p</span> <span class="bp">⊔</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">connecting_line_right</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="bp">∨</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">p</span> <span class="bp">⊔</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">(</span><span class="n">point_line_uniq</span> <span class="n">hpl</span> <span class="n">hql</span> <span class="n">hpm</span> <span class="n">hqm</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">or_iff_not_imp_left.mp</span> <span class="n">h</span> <span class="n">hpq</span>
<span class="kd">end</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">intersection_point</span> <span class="o">(</span><span class="n">l</span> <span class="n">m</span> <span class="o">:</span> <span class="n">L</span><span class="o">)</span> <span class="o">[</span><span class="n">projective_plane</span> <span class="n">P</span> <span class="n">L</span><span class="o">]</span> <span class="o">:</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">Exists.some</span> <span class="bp">$</span> <span class="n">exists_intersection_point</span> <span class="n">l</span> <span class="n">m</span>

<span class="kd">notation</span> <span class="n">l</span> <span class="bp">`</span> <span class="bp">⊓</span> <span class="bp">`</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">intersection_point</span> <span class="n">l</span> <span class="n">m</span>

<span class="kd">end</span> <span class="n">projective_plane</span>
<span class="c1">-- insert dual theorems here</span>
</code></pre></div>
<p>I find myself having to fully spell out an uncomfortable number of types that I would rather keep implicit, like <code>@is_triangle _ L _ p q r</code> in the definition of <code>is_quadrangle</code>. I'm also not happy with the end of the proof of <code>connecting_line_uniq</code>; I wonder if there is a more elegant way to derive <code>B</code> from <code>A ∨ B</code> and <code>¬A</code> than using <code>or_iff_not_imp_left.mp</code>.</p>



<a name="263588820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263588820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263588820">(Dec 03 2021 at 14:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="460941">Sebastian Zivota</span> <a href="#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263562392">said</a>:</p>
<blockquote>
<p>I'm also not happy with the end of the proof of <code>connecting_line_uniq</code>; I wonder if there is a more elegant way to derive <code>B</code> from <code>A ∨ B</code> and <code>¬A</code> than using <code>or_iff_not_imp_left.mp</code>.</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/or.resolve_left">docs#or.resolve_left</a></p>



<a name="263594727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263594727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263594727">(Dec 03 2021 at 15:24)</a>:</h4>
<p>ah, and <code>tauto</code> is also pretty useful for closing simple 1st order logic goals!</p>



<a name="263595119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sebastian%20Zivota/near/263595119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sebastian.20Zivota.html#263595119">(Dec 03 2021 at 15:27)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#tautology">https://leanprover-community.github.io/mathlib_docs/tactics.html#tautology</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
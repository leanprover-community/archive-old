---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Invalid.20Constructor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html">Invalid Constructor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="184546082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546082">(Dec 31 2019 at 14:16)</a>:</h4>
<p>I'm having a bit of trouble with inductive type constructors. My code is as follows:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>
<span class="kn">import</span> <span class="n">field_theory</span><span class="bp">.</span><span class="n">subfield</span>

<span class="kn">set_option</span> <span class="n">class</span><span class="bp">.</span><span class="n">instance_max_depth</span> <span class="mi">40</span>

<span class="c1">-- define fixes K k f for any f ∈ ring_aut K</span>
<span class="n">def</span> <span class="n">fixes</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ring_aut</span> <span class="n">K</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">))</span>

<span class="c1">-- define gal K k</span>
<span class="n">def</span> <span class="n">gal</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">α</span> <span class="o">:</span> <span class="o">(</span><span class="n">K</span> <span class="err">≃</span><span class="bp">+*</span> <span class="n">K</span><span class="o">)</span> <span class="bp">//</span> <span class="o">(</span><span class="n">fixes</span> <span class="n">k</span> <span class="n">α</span><span class="o">)</span> <span class="o">}</span>
<span class="kn">instance</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">}</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span><span class="n">has_coe</span> <span class="o">(</span><span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="n">val</span><span class="bp">⟩</span>

<span class="kn">section</span> <span class="n">gal</span>

<span class="c1">-- Let K/k be an extension of fields</span>
<span class="kn">variable</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kn">variable</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>
<span class="kn">variable</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">}</span>
<span class="kn">variable</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span>

<span class="c1">-- Show that id is in gal</span>
<span class="n">def</span> <span class="n">aut_one</span> <span class="o">:</span> <span class="n">ring_aut</span> <span class="n">K</span> <span class="o">:=</span>  <span class="n">group</span><span class="bp">.</span><span class="n">one</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span>
<span class="kn">theorem</span> <span class="n">aut_one_fixes_k</span> <span class="o">:</span> <span class="n">fixes</span> <span class="n">k</span> <span class="n">aut_one</span> <span class="o">:=</span> <span class="k">begin</span> <span class="n">rw</span> <span class="o">[</span><span class="n">fixes</span><span class="o">],</span> <span class="n">intro</span><span class="o">,</span> <span class="n">refl</span> <span class="kn">end</span>
<span class="n">def</span> <span class="n">gal_one</span> <span class="o">:</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span> <span class="o">:=</span> <span class="bp">⟨</span> <span class="n">aut_one</span><span class="o">,</span> <span class="n">aut_one_fixes_k</span> <span class="bp">⟩</span>

<span class="c1">-- define multiplication in the galois group</span>
<span class="n">def</span> <span class="n">aut_mul</span> <span class="o">:</span> <span class="n">ring_aut</span> <span class="n">K</span> <span class="bp">→</span> <span class="n">ring_aut</span> <span class="n">K</span> <span class="bp">→</span> <span class="n">ring_aut</span> <span class="n">K</span> <span class="o">:=</span> <span class="n">group</span><span class="bp">.</span><span class="n">mul</span>
<span class="kn">theorem</span> <span class="n">gal_closed_under_aut_mul</span> <span class="o">(</span><span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">fixes</span> <span class="n">k</span> <span class="o">(</span><span class="n">aut_mul</span> <span class="n">g</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">g</span><span class="bp">.</span><span class="n">val</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">val</span><span class="bp">.</span><span class="n">to_fun</span> <span class="err">↑</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">x</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="bp">.</span><span class="n">property</span><span class="o">,</span> <span class="n">g</span><span class="bp">.</span><span class="n">property</span><span class="o">]</span>
<span class="kn">end</span>
<span class="n">def</span> <span class="n">gal_mul</span> <span class="o">:</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span> <span class="o">:=</span>
    <span class="bp">λ</span> <span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">),</span> <span class="bp">⟨</span> <span class="n">aut_mul</span> <span class="n">g</span> <span class="n">h</span><span class="o">,</span> <span class="n">gal_closed_under_aut_mul</span> <span class="n">g</span> <span class="n">h</span><span class="bp">⟩</span>

<span class="c1">-- show that the galois group is closed under inversion</span>
<span class="n">def</span> <span class="n">aut_inv</span> <span class="o">:</span> <span class="n">ring_aut</span> <span class="n">K</span> <span class="bp">→</span> <span class="n">ring_aut</span> <span class="n">K</span> <span class="o">:=</span> <span class="n">group</span><span class="bp">.</span><span class="n">inv</span>
<span class="kn">theorem</span> <span class="n">gal_closed_under_inversion</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">fixes</span> <span class="n">k</span> <span class="o">(</span><span class="n">aut_inv</span> <span class="n">g</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">g</span><span class="bp">.</span><span class="n">val</span><span class="bp">.</span><span class="n">to_equiv</span><span class="bp">.</span><span class="n">injective</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">g</span><span class="bp">.</span><span class="n">val</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">g</span><span class="bp">.</span><span class="n">val</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="err">↑</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span><span class="bp">.</span><span class="n">val</span><span class="bp">.</span><span class="n">to_fun</span> <span class="err">↑</span><span class="n">x</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">g</span><span class="bp">.</span><span class="n">val</span><span class="bp">.</span><span class="n">right_inv</span><span class="o">,</span> <span class="n">g</span><span class="bp">.</span><span class="n">property</span><span class="o">],</span>
<span class="kn">end</span>
<span class="n">def</span> <span class="n">gal_inv</span> <span class="o">:</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="o">:</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">aut_inv</span> <span class="n">g</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">gal_closed_under_inversion</span> <span class="n">g</span><span class="bp">⟩</span>

<span class="c1">-- show is assoc</span>
<span class="kn">theorem</span> <span class="n">gal_mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">),</span> <span class="n">gal_mul</span> <span class="o">(</span><span class="n">gal_mul</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">gal_mul</span> <span class="n">a</span> <span class="o">(</span><span class="n">gal_mul</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
<span class="kn">end</span>

<span class="c1">-- show gal_one is the left and right identity</span>
<span class="kn">theorem</span> <span class="n">gal_one_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">),</span> <span class="n">gal_mul</span> <span class="n">gal_one</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">change</span> <span class="bp">⟨</span> <span class="n">aut_mul</span> <span class="n">aut_one</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">gal_closed_under_aut_mul</span> <span class="n">gal_one</span> <span class="n">a</span> <span class="bp">⟩</span> <span class="bp">=</span> <span class="n">a</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>The last line produces an error, specifically it tells me:</p>
<div class="codehilite"><pre><span></span>invalid constructor ⟨...⟩, expected type is not an inductive type
  ?m_1
</pre></div>


<p>which isn't making much sense to me. As far as I can see the type <code>gal K k</code> really ought to be deducible, so it should be using the constructor for that type, which as a subtype is of the form <code>⟨a : ring_aut K, p : fixes k a⟩</code>.</p>



<a name="184546091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546091">(Dec 31 2019 at 14:16)</a>:</h4>
<p>use ```lean to enable syntax highlighting</p>



<a name="184546100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546100">(Dec 31 2019 at 14:17)</a>:</h4>
<div class="codehilite"><pre><span></span>```lean
lorem ipsum
```
</pre></div>



<a name="184546159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546159">(Dec 31 2019 at 14:18)</a>:</h4>
<p>change that line to:</p>
<div class="codehilite"><pre><span></span><span class="n">change</span> <span class="o">(</span><span class="bp">⟨</span> <span class="n">aut_mul</span> <span class="n">aut_one</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">gal_closed_under_aut_mul</span> <span class="n">gal_one</span> <span class="n">a</span> <span class="bp">⟩</span> <span class="o">:</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="o">,</span>
</pre></div>



<a name="184546161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546161">(Dec 31 2019 at 14:19)</a>:</h4>
<p>Lean elaborates from left to right</p>



<a name="184546166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546166">(Dec 31 2019 at 14:19)</a>:</h4>
<p>so Lean sees the anonymous constructor before it sees <code>a</code></p>



<a name="184546171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546171">(Dec 31 2019 at 14:19)</a>:</h4>
<p>and it tries to match the type of <code>a</code> <strong>to</strong> the type of the anonymous constructor (i.e. coerce RHS to LHS)</p>



<a name="184546175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546175">(Dec 31 2019 at 14:19)</a>:</h4>
<p>but Lean cannot figure out the type of the anonymous constructor</p>



<a name="184546355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546355">(Dec 31 2019 at 14:23)</a>:</h4>
<p>Thanks, that really helps!</p>



<a name="184546753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546753">(Dec 31 2019 at 14:33)</a>:</h4>
<p>One issue with doing Galois theory like this (with subfields) is that in practice you might end up with two fields E and F and an injective field map from E to F, and you'll have to dance around between E and the image of the map. This is not really an issue when doing mathematics, but when formalising it in type theory you might find that it becomes a pain and you'd be better off setting things up with E a field and F an E-algebra.</p>



<a name="184546816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546816">(Dec 31 2019 at 14:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>
<span class="kn">import</span> <span class="n">field_theory</span><span class="bp">.</span><span class="n">subfield</span>

<span class="n">universes</span> <span class="n">u</span>

<span class="c1">-- Define fixes k f for any f : ring_aut K.</span>
<span class="n">def</span> <span class="n">fixes</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">k</span><span class="o">,</span> <span class="bp">@</span><span class="n">coe_fn</span> <span class="bp">_</span> <span class="n">ring_equiv</span><span class="bp">.</span><span class="n">has_coe_to_fun</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span>

<span class="c1">-- Define gal K k.</span>
<span class="n">def</span> <span class="n">gal</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">α</span> <span class="o">:</span> <span class="n">K</span> <span class="err">≃</span><span class="bp">+*</span> <span class="n">K</span> <span class="bp">//</span> <span class="n">fixes</span> <span class="n">k</span> <span class="n">α</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">}</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_coe</span> <span class="o">(</span><span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="n">val</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">}</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">group</span> <span class="o">(</span><span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">subtype</span><span class="bp">.</span><span class="n">group</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="bp">_</span> <span class="o">{</span> <span class="n">f</span> <span class="bp">|</span> <span class="n">fixes</span> <span class="n">k</span> <span class="n">f</span> <span class="o">}</span>
<span class="o">{</span> <span class="n">mul_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span> <span class="n">hf</span> <span class="n">hg</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="k">show</span> <span class="n">f</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">g</span><span class="bp">.</span><span class="mi">1</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="k">show</span> <span class="n">g</span><span class="bp">.</span><span class="mi">1</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">hg</span> <span class="n">x</span> <span class="n">hx</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">hf</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">one_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">inv_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">hf</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">symm_apply_eq</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="err">$</span> <span class="n">hf</span> <span class="n">x</span> <span class="n">hx</span> <span class="o">}</span>
</pre></div>



<a name="184546818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546818">(Dec 31 2019 at 14:34)</a>:</h4>
<p><code>theorem aut_one_fixes_k : fixes k aut_one := begin intro, refl end</code> You don't need the rewrite, because it's true by definition ;-)</p>



<a name="184546832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546832">(Dec 31 2019 at 14:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> try as I might, I cannot fix the line with <code>@coe_fn _ ring_equiv.has_coe_to_fun f x = x</code> (L9)</p>



<a name="184546834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546834">(Dec 31 2019 at 14:35)</a>:</h4>
<p>you might be familiar with priority tricks</p>



<a name="184546841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546841">(Dec 31 2019 at 14:35)</a>:</h4>
<p><code>theorem aut_one_fixes_k : fixes k aut_one := λ _, rfl</code> is the term mode version</p>



<a name="184546965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546965">(Dec 31 2019 at 14:38)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> try as I might, I cannot fix the line with <code>@coe_fn _ ring_equiv.has_coe_to_fun f x = x</code> (L9)</p>
</blockquote>
<div class="codehilite"><pre><span></span><span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="n">to_equiv</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span>
</pre></div>


<p>? I remember talking about this with Mario. I think there's no coercion from all these higher equivs to regular equiv, and perhaps this is for a reason.</p>



<a name="184546973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546973">(Dec 31 2019 at 14:38)</a>:</h4>
<p>but why isn't the <code>ring_equiv.has_coe_to_fun</code> instance triggering</p>



<a name="184546978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546978">(Dec 31 2019 at 14:38)</a>:</h4>
<p>You do seem to have to manually cast them using to_equiv</p>



<a name="184546980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546980">(Dec 31 2019 at 14:38)</a>:</h4>
<p><span class="user-mention" data-user-id="253752">@James Weaver</span> btw this is how I would construct the group structure</p>



<a name="184546996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184546996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184546996">(Dec 31 2019 at 14:39)</a>:</h4>
<p>then what is <code>ring_equiv.has_coe_to_fun</code> for</p>



<a name="184547062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547062">(Dec 31 2019 at 14:41)</a>:</h4>
<p><code>@subtype.group</code> is a new one to me</p>



<a name="184547115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547115">(Dec 31 2019 at 14:42)</a>:</h4>
<p>In type theory a set is a term, not a type.</p>



<a name="184547120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547120">(Dec 31 2019 at 14:42)</a>:</h4>
<p>So <code>group X</code> doesn't make sense if X is a subset of Y.</p>



<a name="184547130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547130">(Dec 31 2019 at 14:42)</a>:</h4>
<p>It doesn't typecheck.</p>



<a name="184547157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547157">(Dec 31 2019 at 14:43)</a>:</h4>
<p>If X is a subgroup of G, then <code>subtype.group</code> is the function you need to create the <code>group  ↥X</code> term</p>



<a name="184547201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547201">(Dec 31 2019 at 14:44)</a>:</h4>
<p>right, I see</p>



<a name="184547202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547202">(Dec 31 2019 at 14:44)</a>:</h4>
<p>where that weird little up-arrow means "change the subset X into a subtype"</p>



<a name="184547244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547244">(Dec 31 2019 at 14:45)</a>:</h4>
<p>You can figure out what Kenny is doing by just writing <code>#check @subtype.group</code>. The <code>@</code> sign means "let me fill in all of the inputs to the function myself, even the ones you usually guess for me in the <code>{}</code> and <code>[]</code> brackets"</p>



<a name="184547326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547326">(Dec 31 2019 at 14:47)</a>:</h4>
<blockquote>
<p>but why isn't the <code>ring_equiv.has_coe_to_fun</code> instance triggering</p>
</blockquote>
<p>Is it because <code>ring_aut</code> isn't syntactically equivalent to <code>ring_equiv</code>?</p>



<a name="184547351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547351">(Dec 31 2019 at 14:47)</a>:</h4>
<p>/me nods</p>



<a name="184547397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547397">(Dec 31 2019 at 14:48)</a>:</h4>
<p>Right, and the $ is function application with a different binding weight so as to avoid excessive parentheses?</p>



<a name="184547402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547402">(Dec 31 2019 at 14:48)</a>:</h4>
<p>I tried <code>∀ x ∈ k, (f : K ≃+* K) x = x</code> <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span></p>



<a name="184547403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547403">(Dec 31 2019 at 14:48)</a>:</h4>
<p>(Like in Haskel)</p>



<a name="184547443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547443">(Dec 31 2019 at 14:49)</a>:</h4>
<blockquote>
<p>I tried <code>∀ x ∈ k, (f : K ≃+* K) x = x</code> <span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span></p>
</blockquote>
<p>Maybe that's one of those "check that <code>f</code> can be considered as having type <code>ring_equiv</code> but don't actually change what Lean thinks the type of <code>f</code> is?" issues?</p>



<a name="184547455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547455">(Dec 31 2019 at 14:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">ring_equiv</span><span class="bp">.</span><span class="n">to_fun</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">fixes</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span>
</pre></div>



<a name="184547501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547501">(Dec 31 2019 at 14:50)</a>:</h4>
<p>ok <code>∀ x ∈ k, (show K ≃+* K, from f) x = x</code> worked but that is only zeta equivalent</p>



<a name="184547506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547506">(Dec 31 2019 at 14:50)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">ring_equiv</span><span class="bp">.</span><span class="n">to_fun</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">fixes</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span>
</pre></div>


</blockquote>
<p>nice</p>



<a name="184547512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547512">(Dec 31 2019 at 14:50)</a>:</h4>
<p>So arguably there's a missing instance here.</p>



<a name="184547522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547522">(Dec 31 2019 at 14:51)</a>:</h4>
<p>(and I don't care if I made a loop in the instance graph because eveything is defeq)</p>



<a name="184547529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547529">(Dec 31 2019 at 14:51)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>
<span class="kn">import</span> <span class="n">field_theory</span><span class="bp">.</span><span class="n">subfield</span>

<span class="n">universes</span> <span class="n">u</span>

<span class="c1">-- credit Kevin Buzzard</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">ring_equiv</span><span class="bp">.</span><span class="n">to_fun</span><span class="bp">⟩</span>

<span class="c1">-- Define fixes k f for any f : ring_aut K.</span>
<span class="n">def</span> <span class="n">fixes</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span>

<span class="c1">-- Define gal K k.</span>
<span class="n">def</span> <span class="n">gal</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">α</span> <span class="o">:</span> <span class="n">K</span> <span class="err">≃</span><span class="bp">+*</span> <span class="n">K</span> <span class="bp">//</span> <span class="n">fixes</span> <span class="n">k</span> <span class="n">α</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">}</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_coe</span> <span class="o">(</span><span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="n">val</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">}</span> <span class="o">[</span><span class="n">is_subfield</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">group</span> <span class="o">(</span><span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">subtype</span><span class="bp">.</span><span class="n">group</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="bp">_</span> <span class="o">{</span> <span class="n">f</span> <span class="bp">|</span> <span class="n">fixes</span> <span class="n">k</span> <span class="n">f</span> <span class="o">}</span>
<span class="o">{</span> <span class="n">mul_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span> <span class="n">hf</span> <span class="n">hg</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="k">show</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">hg</span> <span class="n">x</span> <span class="n">hx</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">hf</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">one_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">inv_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">hf</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">symm_apply_eq</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="err">$</span> <span class="n">hf</span> <span class="n">x</span> <span class="n">hx</span> <span class="o">}</span>
</pre></div>



<a name="184547538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547538">(Dec 31 2019 at 14:51)</a>:</h4>
<p>now the code is cleaner</p>



<a name="184547799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547799">(Dec 31 2019 at 14:56)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">gal_one_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">gal</span> <span class="n">K</span> <span class="n">k</span><span class="o">),</span> <span class="n">gal_mul</span> <span class="n">gal_one</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">gal_mul</span> <span class="n">gal_one</span><span class="o">,</span>
  <span class="n">unfold_coes</span><span class="o">,</span>
  <span class="n">dsimp</span><span class="o">,</span>
<span class="bp">...</span>
</pre></div>


<p>is another way of getting around the <code>change</code> issue. But actually the correct thing to do is to play around like I'm doing above, and then see what you want to change the goal to, and then use <code>change</code> the way Kenny said.</p>



<a name="184547874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547874">(Dec 31 2019 at 14:58)</a>:</h4>
<p>I did find the operation of the function <code>set</code> a little surprising<br>
I would have expected <code>set K</code> to be an assertion that <code>K</code> is a set or a way of accessing the underlying set of <code>K</code>, but it seems that <code>set K</code> is the type of subsets of the underlying set of <code>K</code>.</p>



<a name="184547887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547887">(Dec 31 2019 at 14:58)</a>:</h4>
<p>There's no "underlying set" -- it's type theory.</p>



<a name="184547902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547902">(Dec 31 2019 at 14:59)</a>:</h4>
<p>I spent a long time mentally changing <code>set K</code> to <code>subset_of K</code> before I got the hang of it.</p>



<a name="184547993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184547993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184547993">(Dec 31 2019 at 15:00)</a>:</h4>
<p>This kerfuffle is one reason why I would consider setting it up with k and K both types and an injective field map k -&gt; K. This is a delicate type theory foundational issue which has burned me in the past (I wrote a bunch of MSc level algebraic and arithmetic geometry up in Lean and it taught me loads about what to avoid -- the hard way).</p>



<a name="184548024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548024">(Dec 31 2019 at 15:01)</a>:</h4>
<p>That's always the way when learning a language I find. You learn by doing wrongly.</p>



<a name="184548086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548086">(Dec 31 2019 at 15:02)</a>:</h4>
<p>The way to think about it is to imagine what might come your way in the future which you might want to apply your theory to, and if your theory only applies after a lot of pain then you might have set up your theory incorrectly. The p-adic valuation of 0 is +infinity and as you can imagine, this is a pain. But here's a summary of how it caused me far more pain than it should have done.</p>



<a name="184548146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548146">(Dec 31 2019 at 15:03)</a>:</h4>
<p>We were setting up a theory of adic spaces so we needed a theory of norms on general rings. A general norm takes values (in the mathematical literature) in the set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∪</mo><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">{0}\cup\Gamma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">0</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span> is a totally ordered group under multiplication (for example the positive reals). We dutifully defined a new function which ate Gamma and spat out {0} union Gamma.</p>



<a name="184548224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548224">(Dec 31 2019 at 15:05)</a>:</h4>
<p>and then let our norms take values in this. And then we tried to unify our work with the p-adic norm, but the p-adic norm was taking values in the non-negative real numbers :-/ and although this might be canonically isomorphic to {0} union (positive reals), it wasn't _equal_ to it, so there was a lot of faffing around which culminated in our changing our definition of a general norm.</p>



<a name="184548256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548256">(Dec 31 2019 at 15:05)</a>:</h4>
<p>This issue doesn't exist mathematically, because of course <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub><mo>=</mo><msub><mi mathvariant="double-struck">R</mi><mrow><mo>&gt;</mo><mn>0</mn></mrow></msub><mo>∪</mo><mo stretchy="false">{</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\mathbb{R}_{\geq0}=\mathbb{R}_{&gt;0}\cup\{0\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.934069em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.86626em;vertical-align:-0.17737em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">&gt;</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mclose">}</span></span></span></span>, but this is a set-theoretic equals not a type-theoretic one.</p>



<a name="184548302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548302">(Dec 31 2019 at 15:06)</a>:</h4>
<p>in type theory, there are maps in both directions and you can get sick of them very quickly.</p>



<a name="184548390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548390">(Dec 31 2019 at 15:08)</a>:</h4>
<p>so if you want to do Gal(C/R) with your Galois theory, but for some reason you want to use Lean's real numbers, which are of course not <em>defined</em> as a subfield of the complex numbers, then you'll be forever passing between Lean's real numbers and the subfield of C.</p>



<a name="184548397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548397">(Dec 31 2019 at 15:08)</a>:</h4>
<p>something which is completely transparent to a mathematician but which is an issue when formalising.</p>



<a name="184548405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548405">(Dec 31 2019 at 15:08)</a>:</h4>
<p>ugh, yes</p>



<a name="184548422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548422">(Dec 31 2019 at 15:09)</a>:</h4>
<p>To be honest mathematicians can get very sloppy with equality and isomorphism</p>



<a name="184548531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548531">(Dec 31 2019 at 15:11)</a>:</h4>
<p>Mathematicians know that nothing changes if you move from the reals as Cauchy sequences to the reals as Dedekind cuts to the reals as a subfield of C, but really these are all ("canonical") isomorphisms, and they are sufficiently canonical that any sensible mathematical statement about "the reals" will be true for one iff it's true for all of them. However there are stupid statements which are only true for some and not for others (e.g. in set theory one could ask "is the real number 37 a countable or an uncountable set?") and in type theory there are analogous pathological (i.e. non-mathematical) questions which one could ask about "the reals" which might be true for one model and false for others.</p>



<a name="184548614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548614">(Dec 31 2019 at 15:12)</a>:</h4>
<p>This means that working with isomorphisms is harder than it should be (e.g. you can't <code>rw h</code> if <code>h</code> is a proof that the rings A and B are <strong>isomorphic</strong>, and you have a proof that A is Noetherian, and your goal is to prove that B is Noetherian).</p>



<a name="184548657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548657">(Dec 31 2019 at 15:13)</a>:</h4>
<p>one day a computer scientist will come and write some kind of <code>rw</code> on steroids which will let us rewrite here, because <code>Noetherian</code> will be tagged with a special tag saying "this predicate on rings is constant on isomorphism classes"</p>



<a name="184548697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184548697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184548697">(Dec 31 2019 at 15:14)</a>:</h4>
<p>but that hasn't happened yet.</p>



<a name="184596607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184596607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184596607">(Jan 01 2020 at 12:42)</a>:</h4>
<p>Right, after some changes based on what you both said yesterday this is what I have now:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>
<span class="kn">import</span> <span class="n">field_theory</span><span class="bp">.</span><span class="n">subfield</span>

<span class="n">universes</span> <span class="n">u</span>

<span class="c1">-- Causes ring automorphisms K ≃+* K to be coercible to functions K → K</span>
<span class="c1">-- credit Kevin Buzzard</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">ring_equiv</span><span class="bp">.</span><span class="n">to_fun</span><span class="bp">⟩</span>

<span class="c1">-- Define a field extension as a chosen monomorphism k → K</span>
<span class="kn">structure</span> <span class="n">field_extension</span>
    <span class="o">(</span><span class="n">K</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>
        <span class="o">:=</span> <span class="n">mk</span> <span class="bp">::</span> <span class="o">(</span><span class="n">inc</span><span class="o">:</span> <span class="n">ring_hom</span> <span class="n">k</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">inj</span><span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">inc</span><span class="bp">.</span><span class="n">to_fun</span><span class="o">)</span>

<span class="c1">-- Define a coercion from a field extension to a ring_homomorphism, this in turn provides coercions to</span>
<span class="c1">-- other types including k → K</span>
<span class="kn">instance</span>
    <span class="o">(</span><span class="n">K</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span>
        <span class="n">has_coe</span> <span class="o">(</span><span class="n">field_extension</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_hom</span> <span class="n">k</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">ext</span><span class="o">,</span> <span class="n">ext</span><span class="bp">.</span><span class="n">inc</span><span class="bp">⟩</span>


<span class="c1">-- Define fixes k f for any f : ring_aut K.</span>
<span class="n">def</span> <span class="n">fixes</span>
    <span class="o">{</span><span class="n">K</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>
    <span class="o">(</span><span class="n">ext</span><span class="o">:</span> <span class="n">field_extension</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span>
        <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">ext</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ext</span> <span class="n">x</span>

<span class="c1">-- Define gal for an extension</span>
<span class="n">def</span> <span class="n">gal</span>
    <span class="o">{</span><span class="n">K</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>
    <span class="o">(</span><span class="n">K_k</span><span class="o">:</span> <span class="n">field_extension</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span>
        <span class="o">:=</span> <span class="o">{</span> <span class="n">α</span> <span class="o">:</span> <span class="n">ring_aut</span> <span class="n">K</span> <span class="bp">//</span> <span class="n">fixes</span> <span class="n">K_k</span> <span class="n">α</span> <span class="o">}</span>

<span class="c1">-- Define a coercion from gal K_k to ring_aut K</span>
<span class="c1">-- This in turn will allow coercions further including to K → K</span>
<span class="kn">instance</span>
    <span class="o">{</span><span class="n">K</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>
    <span class="o">(</span><span class="n">K_k</span><span class="o">:</span> <span class="n">field_extension</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
        <span class="n">has_coe</span> <span class="o">(</span><span class="n">gal</span> <span class="n">K_k</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
            <span class="bp">⟨λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="n">val</span><span class="bp">⟩</span>

<span class="c1">-- Prove that gal K_k is a group under composition</span>
<span class="kn">instance</span>
    <span class="o">{</span><span class="n">K</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>
    <span class="o">(</span><span class="n">K_k</span><span class="o">:</span> <span class="n">field_extension</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
        <span class="n">group</span> <span class="o">(</span><span class="n">gal</span> <span class="n">K_k</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">subtype</span><span class="bp">.</span><span class="n">group</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="bp">_</span> <span class="o">{</span> <span class="n">f</span> <span class="bp">|</span> <span class="n">fixes</span> <span class="n">K_k</span> <span class="n">f</span> <span class="o">}</span>
<span class="o">{</span> <span class="n">mul_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span> <span class="n">hf</span> <span class="n">hg</span> <span class="n">x</span><span class="o">,</span> <span class="k">show</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="err">$</span> <span class="n">K_k</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">K_k</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">hg</span> <span class="n">x</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">hf</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">one_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">inv_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">hf</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">symm_apply_eq</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="err">$</span> <span class="n">hf</span> <span class="n">x</span> <span class="o">}</span>
</pre></div>


<p>which seems fine in of itself, but when I try adding this below:</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">(</span><span class="n">K</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">K_k</span> <span class="o">:</span> <span class="n">field_extension</span> <span class="n">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">k</span> <span class="n">K</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">K_k</span><span class="bp">⟩</span>


<span class="kn">variable</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kn">variable</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kn">variable</span> <span class="n">f</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">→</span> <span class="n">K</span>
<span class="kn">variable</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span>
<span class="kn">variable</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">f</span> <span class="o">(</span><span class="n">discrete_field</span><span class="bp">.</span><span class="n">one</span> <span class="n">k</span><span class="o">)</span>
</pre></div>


<p>I get a peculiar (to me) error where it complains that it can't automatically synthesise a name for the <code>has_coe</code> instance, which is odd since no other has_coe instance I've seen has needed an explicit name. Adding an explicit name fixes that error, but the check in the last line doesn't seem to find the coercion from k to K and complains that <code>discrete_field one k</code> isn't a <code>K</code>.</p>
<p>Any thoughts? Have I made another obvious mistake somewhere?</p>



<a name="184596624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184596624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184596624">(Jan 01 2020 at 12:43)</a>:</h4>
<p>every ring hom between two fields is injective</p>



<a name="184596667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184596667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184596667">(Jan 01 2020 at 12:44)</a>:</h4>
<p>Of course it is. Shows how long it's been since I was doing maths regularly.</p>



<a name="184596981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184596981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184596981">(Jan 01 2020 at 12:53)</a>:</h4>
<p>Ok, right, so that being the case, this seems sufficient:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>
<span class="kn">import</span> <span class="n">field_theory</span><span class="bp">.</span><span class="n">subfield</span>

<span class="n">universes</span> <span class="n">u</span>

<span class="c1">-- Causes ring automorphisms K ≃+* K to be coercible to functions K → K</span>
<span class="c1">-- credit Kevin Buzzard</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">ring_equiv</span><span class="bp">.</span><span class="n">to_fun</span><span class="bp">⟩</span>


<span class="c1">-- Define fixes k f for any f : ring_aut K.</span>
<span class="n">def</span> <span class="n">fixes</span>
    <span class="o">{</span><span class="n">K</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>
    <span class="o">(</span><span class="n">ext</span><span class="o">:</span> <span class="n">k</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span>
        <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">ext</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ext</span> <span class="n">x</span>

<span class="c1">-- Define gal for an extension</span>
<span class="n">def</span> <span class="n">gal</span>
    <span class="o">{</span><span class="n">K</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>
    <span class="o">(</span><span class="n">K_k</span><span class="o">:</span> <span class="n">k</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">)</span>
        <span class="o">:=</span> <span class="o">{</span> <span class="n">α</span> <span class="o">:</span> <span class="n">ring_aut</span> <span class="n">K</span> <span class="bp">//</span> <span class="n">fixes</span> <span class="n">K_k</span> <span class="n">α</span> <span class="o">}</span>

<span class="c1">-- Define a coercion from gal K_k to ring_aut K</span>
<span class="c1">-- This in turn will allow coercions further including to K → K</span>
<span class="kn">instance</span>
    <span class="o">{</span><span class="n">K</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>
    <span class="o">(</span><span class="n">K_k</span><span class="o">:</span> <span class="n">k</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span>
        <span class="n">has_coe</span> <span class="o">(</span><span class="n">gal</span> <span class="n">K_k</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
            <span class="bp">⟨λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="n">val</span><span class="bp">⟩</span>

<span class="c1">-- Prove that gal K_k is a group under composition</span>
<span class="kn">instance</span>
    <span class="o">{</span><span class="n">K</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>
    <span class="o">(</span><span class="n">K_k</span><span class="o">:</span> <span class="n">k</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span>
        <span class="n">group</span> <span class="o">(</span><span class="n">gal</span> <span class="n">K_k</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">subtype</span><span class="bp">.</span><span class="n">group</span> <span class="o">(</span><span class="n">ring_aut</span> <span class="n">K</span><span class="o">)</span> <span class="bp">_</span> <span class="o">{</span> <span class="n">f</span> <span class="bp">|</span> <span class="n">fixes</span> <span class="n">K_k</span> <span class="n">f</span> <span class="o">}</span>
<span class="o">{</span> <span class="n">mul_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span> <span class="n">hf</span> <span class="n">hg</span> <span class="n">x</span><span class="o">,</span> <span class="k">show</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="err">$</span> <span class="n">K_k</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">K_k</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">hg</span> <span class="n">x</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">hf</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">one_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">inv_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">hf</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">symm_apply_eq</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="err">$</span> <span class="n">hf</span> <span class="n">x</span> <span class="o">}</span>
</pre></div>



<a name="184597213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184597213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Weaver <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184597213">(Jan 01 2020 at 13:01)</a>:</h4>
<p>Still running into a problem with</p>
<div class="codehilite"><pre><span></span><span class="c1">-- introduce an example</span>
<span class="kn">variable</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kn">variable</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kn">variable</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span>
<span class="kn">variable</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>
<span class="kn">variable</span> <span class="n">i</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">→+*</span> <span class="n">K</span>

<span class="kn">instance</span> <span class="n">n</span><span class="o">:</span><span class="n">has_coe</span> <span class="n">k</span> <span class="n">K</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">i</span><span class="bp">⟩</span>

<span class="kn">variable</span> <span class="n">f</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">→</span> <span class="n">K</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">f</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">k</span><span class="o">)</span>
</pre></div>


<p>though.  The has_coe instance demands an explicit name and isn't found by the #check command.</p>



<a name="184597515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184597515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184597515">(Jan 01 2020 at 13:10)</a>:</h4>
<p>I think your problem is that i is a variable, the following works</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>


<span class="kn">variable</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span>
<span class="kn">variable</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span>
<span class="kn">variable</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">k</span><span class="o">]</span>
<span class="kn">variable</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span>
<span class="n">def</span> <span class="n">i</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">→+*</span> <span class="n">K</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">instance</span> <span class="n">n</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">k</span> <span class="n">K</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">i</span> <span class="n">K</span> <span class="n">k</span><span class="bp">⟩</span>
<span class="kn">variable</span> <span class="n">f</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">→</span> <span class="n">K</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">f</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">k</span><span class="o">)</span>
</pre></div>



<a name="184597640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Invalid%20Constructor/near/184597640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Invalid.20Constructor.html#184597640">(Jan 01 2020 at 13:14)</a>:</h4>
<p>I don't know exactly what your use case is so maybe this isnt that useful? But before you had <code>n</code> depending on <code>i</code> so the coercion couldn't just pick one <code>i</code>to make the coercion from?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
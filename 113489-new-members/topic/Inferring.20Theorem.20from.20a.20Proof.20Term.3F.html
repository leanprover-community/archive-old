---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html">Inferring Theorem from a Proof Term?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="230272634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230272634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230272634">(Mar 14 2021 at 22:07)</a>:</h4>
<p>I've noticed that in Lean, theorems are always stated and then proved, i.e. backwards reasoning is the norm. In The Hitchhiker's Guide to Logical Verification I read about structured proofs (i.e. forward proofs), but even in that case the theorem is always stated before the proof begins.</p>
<p>I understand why this is the case, but I'm interested in computational methods for randomly generating theorems, and for this purpose it would be helpful to have a method of pulling theorems statements directly from (randomly generated) proofs. In other words, given a randomly generated proof (generated without knowing what theorem it will be a proof of), it would be helpful to have a way of extracting the theorem statement it is a proof of.</p>
<p>In Lean can you infer a theorem (i.e. type) directly from a proof term that proves that theorem? If so, how?</p>
<p>I understand that #check can provide the type of any well-formed term, but sometimes Lean won't allow me to "#check" a proof term for instance if it is constructed with iff.dcases_on as in this <a href="https://leanprover-community.github.io/lean-web-editor/#code=lemma%20iff_of_true2%20%7BP%20%3A%20Prop%7D%3A%0A%28P%20%E2%86%94%20true%29%20%E2%86%92%20P%20%3A%3D%0A%CE%BB%20H%2C%20iff.dcases_on%20H%20%28%CE%BB%20H%E2%82%81%20H%E2%82%82%2C%20H%E2%82%82%20trivial%29%0A%0A%23check%20%28%CE%BB%20H%2C%20iff.dcases_on%20H%20%28%CE%BB%20H%E2%82%81%20H%E2%82%82%2C%20H%E2%82%82%20trivial%29%29%0A%0A">example</a></p>
<p>Perhaps to fix this example I need a fully elaborated version of the proof term?</p>



<a name="230275304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230275304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230275304">(Mar 14 2021 at 22:28)</a>:</h4>
<p>If you use <code>def</code> rather than <code>lemma</code>, lean will try to deduce the type (in this case, the statement) for you</p>



<a name="230276488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230276488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230276488">(Mar 14 2021 at 22:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="kd">lemma</span> <span class="n">iff_of_true2</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}:</span>
<span class="o">(</span><span class="n">P</span> <span class="bp">↔</span> <span class="n">true</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">iff.dcases_on</span> <span class="n">H</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">H₁</span> <span class="n">H₂</span><span class="o">,</span> <span class="n">H₂</span> <span class="n">trivial</span><span class="o">)</span>

<span class="k">#print</span> <span class="n">iff_of_true2</span>

<span class="k">#check</span> <span class="bp">λ</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">iff</span> <span class="n">P</span> <span class="n">true</span><span class="o">),</span> <span class="bp">@</span><span class="n">iff.dcases_on.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">P</span> <span class="n">true</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">iff</span> <span class="n">P</span> <span class="n">true</span><span class="o">),</span> <span class="n">P</span><span class="o">)</span> <span class="n">H</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">H₁</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">true</span><span class="o">)</span> <span class="o">(</span><span class="n">H₂</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">P</span><span class="o">),</span> <span class="n">H₂</span> <span class="n">trivial</span><span class="o">)</span>
</code></pre></div>
<p>It works if you give it the fully elaborated term.</p>



<a name="230281677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230281677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230281677">(Mar 15 2021 at 00:33)</a>:</h4>
<p>Thanks! I didn't realize <code>#print</code> would do that</p>



<a name="230289189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230289189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230289189">(Mar 15 2021 at 03:02)</a>:</h4>
<p>Are you going to use Lean to randomly generate the proof or some external tool?  In either case, I think you might quickly run into difficulties with dependent parameters but I suppose that will depend a lot on what terms you are using to generate your proofs.  For example, consider randomly generating an induction proof using <code>nat.rec</code> (or similar theorem).  Also, be considerate of <code>rfl</code> proofs, since you can prove <code>0 = 0+0</code> with <code>rfl</code>, but if you copy and paste the fully elaborated proof, you it will type check as<code>0=0</code>.  (I don’t mean to discourage, just pointing out some considerations that I thought about when think through a similar project.)</p>



<a name="230289313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230289313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230289313">(Mar 15 2021 at 03:04)</a>:</h4>
<p>You can also use <code>infer_type</code> to get the type of an <code>expr</code>, this lets you get the theorem statement from the proof term. I'm not on my Lean machine right now, but I think you can do something like,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">infer_type</span> <span class="bp">`</span><span class="o">(</span><span class="bp">\</span><span class="n">lambda</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span>
</code></pre></div>
<p>to get <code>\forall x, x = x</code>. I hope that's right.</p>



<a name="230290826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230290826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230290826">(Mar 15 2021 at 03:34)</a>:</h4>
<p>The reason for my question about what you are using to generate terms is that <span class="user-mention" data-user-id="209436">@Lucas Allen</span> is correct that if you are looking to do this programmatically, then <code>infer_type</code> is one good way to go.  Technically, there are two ways to programmatically work with Lean.  You can use the language server.  It is slow, but you can do anything you can do in VS Code (like <code>#check</code>).  Or you can use the monadic tactic framework, including <code>infer_type</code>.  If you do everything in the Lean programming language, this latter one is the way to go.  If you are integrating with external tools, then it requires some finesse, but we did recently add to Lean a way to parse Lean text inside the tactic monad which should make some things easier.  I'm happy to explain more, but I don't want to get ahead of myself here.</p>



<a name="230408836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230408836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230408836">(Mar 15 2021 at 20:01)</a>:</h4>
<p><span class="user-mention" data-user-id="209436">@Lucas Allen</span> Thanks for the tip!</p>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> I really appreciate for your words of advice and interest. My intention is use neural nets to generate the proof terms. I'm interested in the question of how to create a feedback loop between a model that generates theorems/proofs and a model that tries to reconstruct proofs given the  theorem statement. Essentially the question is how to get asymmetric self-play to work in mathematics. I'm not entirely sure it makes sense to try doing this by simply generating proof terms, and then <code>#check </code>ing them to get theorems, but I'm not sure how else it could be done in Lean today. My understanding is that many tactics only work in a backwards proof style where the goal is known. If one is generating new theorems then the "goal" is not known. Hence why I'm thinking to work directly with proof terms instead of tactics.</p>
<p>Any idea how much slower the language server is? It seems like it might be a simpler interface to use. </p>
<p>Btw I read your recent PACT paper (really cool paper btw)  and I see that the theorem proving environment is written entirely in Lean. Having read through some of the code, I'm curious to know how you feel about it. What are the limitations of working in Lean? I don't have much background in functional programming (by profession I'm a deep learning engineer) and I'm finding it hard to understand the code and to assess the pros/cons.</p>



<a name="230419651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230419651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230419651">(Mar 15 2021 at 21:14)</a>:</h4>
<p>You can just make a metavariable goal, and work backwards even without knowing what the goal is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.factorial</span>

<span class="kd">def</span> <span class="n">wrapper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>

<span class="kd">def</span> <span class="n">ex</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:</span> <span class="n">_</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">apply</span> <span class="n">nat.factorial_pos</span><span class="o">,</span>
    <span class="n">exact</span> <span class="mi">7</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">wrapper</span> <span class="n">x</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#print</span> <span class="n">ex</span>
</code></pre></div>



<a name="230435682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230435682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230435682">(Mar 15 2021 at 23:09)</a>:</h4>
<p>Neat trick!  <code>intro n</code> doesn't seem to work in such a proof (since it doesn't know the type of <code>n</code>), but you can use <code>refine</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.factorial</span>

<span class="kd">def</span> <span class="n">wrapper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>

<span class="kd">def</span> <span class="n">ex</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:</span> <span class="n">_</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">refine</span> <span class="bp">λ</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span>       <span class="c1">-- basically `intro n`</span>
    <span class="n">tactic.trace_result</span><span class="o">,</span>     <span class="c1">-- show proof so far</span>
    <span class="n">apply</span> <span class="n">nat.factorial_pos</span><span class="o">,</span> <span class="c1">-- apply theorem nat.factorial_pos</span>
    <span class="n">tactic.trace_result</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">tactic.trace_result</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="n">exact</span> <span class="n">wrapper</span> <span class="n">x</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#print</span> <span class="n">ex</span>
</code></pre></div>



<a name="230436983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230436983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230436983">(Mar 15 2021 at 23:24)</a>:</h4>
<p>You also might need to reorder the goals using <code>tactic.rotate</code> since some goals depend on others.</p>



<a name="230441296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230441296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230441296">(Mar 16 2021 at 00:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="337523">Joe Palermo (S2'17)</span> <a href="#narrow/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F/near/230408836">said</a>:</p>
<blockquote>
<p>My intention is use neural nets to generate the proof terms.</p>
</blockquote>
<p>Neural nets would make a lot of sense.  Our gptf/pact paper indeed shows that transformers can generate whole term proofs (in the form of <code>exact ...</code> directly, and I'm sure there are lots of other ways to apply neural nets into generators besides direct text generation.  They would also probably be good at making sure that the various types match.  If you are looking to do "math zero", you might have a bit of trouble getting the loop started, since for induction proofs (which are pretty common before you build up facts) you have to know what your induction hypothesis is at the beginning.  This is true in dependent type theory (using <code>nat.rec</code> say) as well as first order logic (using say the Peano axioms or ZFC).</p>



<a name="230441303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230441303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230441303">(Mar 16 2021 at 00:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="337523">Joe Palermo (S2'17)</span> <a href="#narrow/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F/near/230408836">said</a>:</p>
<blockquote>
<p>I'm not entirely sure it makes sense to try doing this by simply generating proof terms, and then #check ing them to get theorems, but I'm not sure how else it could be done in Lean today.</p>
</blockquote>
<p>I think there are a few considerations.  You have a lot of options to generate terms.  If you generate them as plain text you can use (1) pretty-printed human-style Lean, (2) fully elaborated lean, or (3) Lean expressions (more on this in a bit).  For gptf, we used option 1 for the proof steps, but that was because we were using human written code.  However, much of the time, the pretty printed output of a lean proof will not actually parse as you have already seen.  The fully elaborated proofs (option 2) are more likely to parse, but also much longer and you have to fill in type information that Lean could do automatically.  Human proofs of course use a mix.  When it is possible to use the less verbose syntax, they use that, but then switch to the elaborated versions when needed.  Note, however that at least in Lean 3 (everything I say is for Lean 3) what Lean shows as a fully elaborated proof might still not parse (there are cycle-consistency problems in Lean 3).  For more security, you could build the proof as a Lean expression internally in Lean.  You could build it externally as say an s-expression, or internally using Lean's metaprogramming framework to build a proof term possibly programming in something like Scott's example above to build a proof in stages instead of all at once.  The advantage here is that Lean would stop you part way through a proof to say that one part of the proof can't unify with another.</p>



<a name="230441310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230441310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230441310">(Mar 16 2021 at 00:12)</a>:</h4>
<p>Then there is the question of how to check the terms.  You can use the lean server, writing a file and <code>#check</code>ing the proof.  You asked how long that takes.  It has a hard-coded speed limit of 200ms to process a file.  (You can get around it a bit by putting in multiple <code>#check</code>s in on file, but this becomes a pain.)  If you are interested in the Lean server, I'd recommend looking at my example <a href="https://github.com/jasonrute/communicating-with-lean">here</a> of using it in Python.  Another, better way to use it in Python is via the <a href="https://github.com/leanprover-community/lean-client-python">lean-python client</a>.  That client really needs some love (my fault, hopefully this is motivation for me to put in some effort to fix it up).</p>



<a name="230441318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230441318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230441318">(Mar 16 2021 at 00:12)</a>:</h4>
<p>The other option is to learn to metaprogram in Lean.  Then you can either (1) use Lean's metaprogramming framework to build proofs in stages (building on Scott's example), or (2) have Lean read a string, parse it, and check it.  For the latter approach, I'd recommend looking at this thread as looking through my annotated examples in <a class="stream-topic" data-stream-id="113489" href="/#narrow/stream/113489-new-members/topic/basic.20tactic.20writing.20.26.20IO">#new members &gt; basic tactic writing &amp; IO</a>.  Both approaches would involve learning to metaprogram in Lean.  For that I recommend:</p>
<ul>
<li><a href="https://leanprover-community.github.io/extras/tactic_writing.html">https://leanprover-community.github.io/extras/tactic_writing.html</a></li>
<li><a href="https://agentultra.github.io/lean-for-hackers/">https://agentultra.github.io/lean-for-hackers/</a></li>
</ul>



<a name="230441322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230441322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230441322">(Mar 16 2021 at 00:12)</a>:</h4>
<p>When I said before that you should use the <code>tactic</code> framework, I really meant in general the metaprogramming framework.  That is made up mostly of three monads: <code>tactic</code>, <code>parser</code>, <code>io</code>.  All three have access to Lean's Environment, so they could be used to loop over, say, all Lean proofs.  The <code>io</code> monad also supports IO, the <code>parser</code> monad is needed to read Lean code and parse it (which may be important to what you are doing), and the <code>tactic</code> monad, while often used for generating proofs, also just has a bunch of tools for interacting with the environment and type checker.  One of these is the function <code>infer_type</code> which will let you take an expression (of say a proof term already parsed with the parser) and infer its type (i.e. the theorem it proves).  Note, now all the monads can access all the other ones.  That wasn't the case in the thread <a class="stream-topic" data-stream-id="113489" href="/#narrow/stream/113489-new-members/topic/basic.20tactic.20writing.20.26.20IO">#new members &gt; basic tactic writing &amp; IO</a>, so much of that thread was elaborate tricks to access the <code>parser</code> monad inside the <code>io</code> or <code>tactic</code> monads.</p>



<a name="230441356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230441356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230441356">(Mar 16 2021 at 00:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="337523">Joe Palermo (S2'17)</span> <a href="#narrow/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F/near/230408836">said</a>:</p>
<blockquote>
<p>Btw I read your recent PACT paper (really cool paper btw) and I see that the theorem proving environment is written entirely in Lean. Having read through some of the code, I'm curious to know how you feel about it. What are the limitations of working in Lean? I don't have much background in functional programming (by profession I'm a deep learning engineer) and I'm finding it hard to understand the code and to assess the pros/cons.</p>
</blockquote>
<p>The advantage of working in Lean directly is that you can work with Lean objects directly, including Lean proofs.  Also, Lean has a lot of tools for stuff like what you are doing.  The disadvantage is that Lean 3 is hard to learn, and the notation is confusing.  If you are new to functional programming (and even if you are not), it will honestly take some time.  (Lean 4 is a better programming language, but I don't think it has as many tools right now.)</p>



<a name="230441360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230441360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230441360">(Mar 16 2021 at 00:13)</a>:</h4>
<p>Last, I want to again emphasize that <code>rfl</code> proofs are weird.  Here is an example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="n">nat.zero</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span>   <span class="c1">-- rfl : 0 = 0</span>
<span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="n">nat.zero</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span>   <span class="c1">-- @rfl.{1} nat nat.zero : @eq.{1} nat nat.zero nat.zero</span>
</code></pre></div>
<p>You would think this would type check as <code>nat.zero = 0 + 0</code> or something like that, but <code>rfl</code> as a <em>theorem</em> can only prove <code>a = a</code> and that is what it type checks as.  (Notice there is nothing in the proof, even the fully elaborated proof, about 0+0.) However, <code>rfl</code> is more than just a theorem.  It is like a built in script in the proof term language that tells the type checker to identify things which are judgmentally equal.  I think the idea is that this reduces the size of proof terms, since lean or an external proof checker can just check the <code>rfl</code> part on the fly by normalizing the expressions instead of saving the very long proof term that <code>rfl</code> would generate.  Anyway, that means you might have to put in some extra work generating <code>rfl</code> proofs which are not just trivial identities.</p>



<a name="230441575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230441575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230441575">(Mar 16 2021 at 00:16)</a>:</h4>
<p>(deleted)</p>



<a name="230506194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230506194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230506194">(Mar 16 2021 at 12:53)</a>:</h4>
<p>I realize this morning that my description of <code>rfl</code> is wrong.  I no longer think the <code>rfl</code> (which is basically just the constructor <code>eq.refl</code>) is special in the way I said.  Consider:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">ex</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">h</span>
<span class="k">#print</span> <span class="n">ex</span>
<span class="c1">-- The proof type checks to λ (h : 1 * 1 &lt; 0), h : 1 * 1 &lt; 0 → 1 * 1 &lt; 0</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">),</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>
<p>There is no <code>rfl</code> but the same thing is going on.  Instead, now I think that judgmentally equal things are just treated as the same in Lean, and this is verified by the type checker.  Anyway, the consequence is still the same.  The same proof can be a proof for a number of theorems which all judgmentally equal.  If you ask Lean to typecheck a proof without it being associated with a declaration (theorem/def) then it will pick one type of many equivalent possibilities.</p>



<a name="230519623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/230519623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#230519623">(Mar 16 2021 at 14:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="115715">Jason Rute</span> <a href="#narrow/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F/near/230441318">said</a>:</p>
<blockquote>
<p>The other option is to learn to metaprogram in Lean.  Then you can either (1) use Lean's metaprogramming framework to build proofs in stages (building on Scott's example), or (2) have Lean read a string, parse it, and check it.  For the latter approach, I'd recommend looking through my annotated examples in <a class="stream-topic" data-stream-id="113489" href="/#narrow/stream/113489-new-members/topic/basic.20tactic.20writing.20.26.20IO">#new members &gt; basic tactic writing &amp; IO</a>.  Both approaches would involve learning to metaprogram in Lean.  For that I recommend:</p>
<ul>
<li><a href="https://leanprover-community.github.io/extras/tactic_writing.html">https://leanprover-community.github.io/extras/tactic_writing.html</a></li>
<li><a href="https://agentultra.github.io/lean-for-hackers/">https://agentultra.github.io/lean-for-hackers/</a></li>
</ul>
</blockquote>
<p>These resources look super useful! Thanks very much for the abundance of information. I'm going to dive into these materials and re-assess those design choices once I have some more comfort with Lean.</p>



<a name="233378538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233378538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233378538">(Apr 06 2021 at 19:54)</a>:</h4>
<p>#print command above in the meta variable goal example from <span class="user-mention" data-user-id="115715">@Jason Rute</span>  produces this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">ex</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n.factorial</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">n.factorial_pos</span> <span class="k">in</span> <span class="n">wrapper</span> <span class="n">x</span>
</code></pre></div>
<p>I guess the whole thing <code>let x : ∀ (n : ℕ), 0 &lt; n.factorial := λ (n : ℕ), n.factorial_pos in wrapper x</code> is a proof term. I didn't know proof terms could contain ":=". How would you get the theorem statement for this proof? If I run #check on the whole proof term. I just comes back as "true" which makes sense since that's the type that was declared for ex, but ideally I'd like to extract some more descriptive type. Not sure if it's possible.</p>



<a name="233398524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233398524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233398524">(Apr 06 2021 at 22:08)</a>:</h4>
<p>The theorem that whole term is a proof of is the theorem whose statement is just <code>true</code>. It has some much shorter proofs, like <code>trivial</code> which is what appears in the implementation of <code>wrapper</code>.</p>



<a name="233398777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233398777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233398777">(Apr 06 2021 at 22:10)</a>:</h4>
<p>There's a theorem embedded inside there, which is the part between <code>let x :</code> and <code>:=</code>. In other words, it's the type that's being ascribed to <code>x</code>.</p>
<p>That theorem isn't part of the type of the whole term, so you'd want to extract it from the term's syntax.</p>



<a name="233400551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233400551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233400551">(Apr 06 2021 at 22:27)</a>:</h4>
<p><span class="user-mention" data-user-id="337523">@Joe Palermo (S2'17)</span> I think there are two questions here.  The first question is about this exact proof term.  As Greg said, it is using <code>let</code> notation.  For example, <code>let x := 2 in x + x</code> evaluates to <code>4</code>, and you can also add in a type so <code>let x : nat := 2 in 2 + 2</code> is the same thing but explicitly giving the type of <code>x</code>.  The proof you showed should be read as "Let <code>x</code> be the element of type <code>∀ (n : ℕ), 0 &lt; n.factorial</code> whose value is <code>λ (n : ℕ), n.factorial_pos</code> (so <code>λ (n : ℕ), n.factorial_pos</code> is a proof of <code>∀ (n : ℕ), 0 &lt; n.factorial</code>) and put this in <code>wrapper x</code> (which remember is just a proof of <code>true</code> ignoring the input).  Your second question is if you use that trick above, how do you get the inner proof being constructed (ignoring all the wrapping stuff).  The inner theorem being proved is between <code>x :</code> and <code>:=</code> and the proof is between <code>:=</code> and <code>in</code>.  (Of course, writing a parser for this that will be guaranteed to work in all situations could be complicated if the inner proof also uses <code>let</code>notation.)</p>



<a name="233401254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233401254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233401254">(Apr 06 2021 at 22:34)</a>:</h4>
<p>I think a very simple parser will work even if the proof uses let-notation -- as long as the theorem statement itself doesn't. It just has to look for the first <code>:=</code>.</p>



<a name="233401507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233401507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233401507">(Apr 06 2021 at 22:36)</a>:</h4>
<p>If the (inner) theorem statement may use let-notation, then the easiest solution is probably to work out how to do the metaprogramming to ask Lean about the pieces of the expression object directly.</p>



<a name="233403296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233403296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233403296">(Apr 06 2021 at 22:54)</a>:</h4>
<p>Ahh I see, it's a meaningful theorem wrapped in a dummy theorem. That clarifies things a lot.</p>



<a name="233530150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233530150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233530150">(Apr 07 2021 at 17:30)</a>:</h4>
<p>Here's a followup question. Could you take any proof in mathlib and stick it into a wrapper like this? I picked a random theorem in data.nat.factorial (factorial_lt for example), and tried wrapping it up in the same way, but it fails. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.factorial</span>

<span class="kd">def</span> <span class="n">wrapper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>

<span class="kd">def</span> <span class="n">ex</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:</span> <span class="n">_</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">split</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">not_le</span><span class="o">],</span> <span class="n">intro</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">apply</span> <span class="n">not_le_of_lt</span> <span class="n">h</span> <span class="o">(</span><span class="n">factorial_le</span> <span class="n">hmn</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">n</span><span class="bp">!</span> <span class="bp">&lt;</span> <span class="n">n.succ</span><span class="bp">!</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">k</span> <span class="n">hk</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">factorial_succ</span><span class="o">,</span> <span class="n">succ_mul</span><span class="o">,</span> <span class="n">lt_add_iff_pos_left</span><span class="o">],</span>
      <span class="n">apply</span> <span class="n">mul_pos</span> <span class="n">hk</span> <span class="o">(</span><span class="n">factorial_pos</span> <span class="n">k</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">induction</span> <span class="n">h</span> <span class="k">with</span> <span class="n">k</span> <span class="n">hnk</span> <span class="n">generalizing</span> <span class="n">h0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="n">_</span> <span class="n">h0</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">lt_trans</span> <span class="o">(</span><span class="n">h_ih</span> <span class="n">h0</span><span class="o">)</span> <span class="o">(</span><span class="n">this</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span> <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">h0</span> <span class="o">(</span><span class="n">lt_of_succ_le</span> <span class="n">hnk</span><span class="o">)</span> <span class="o">}}</span>
    <span class="o">},</span>
  <span class="n">exact</span> <span class="n">wrapper</span> <span class="n">x</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#print</span> <span class="n">ex</span>
</code></pre></div>
<p>It fails immediately on split because "constructor tactic failed, target is not an inductive datatype". So you can't just naively wrap a proof, but is there a simple procedure one could implement to do it? i.e. an algorithm to automatically put a wrapper around the proof, in such a way that everything checks out and one could #print and parse out the resulting theorem.</p>
<p>The context here is that I'm interested in ways of generating proofs with machine learning methods, but it's really critical that proofs in mathlib can be put into the same structure to serve as data for bootstrapping, otherwise there's no way to get off the ground.</p>



<a name="233532598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233532598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233532598">(Apr 07 2021 at 17:47)</a>:</h4>
<blockquote>
<p>an algorithm to automatically put a wrapper around the proof</p>
</blockquote>
<p>Most tactics work by inspecting the current goal, and doing something based upon it - but your example fails, because the goal is just <code>_</code>, a wildcard with no information.</p>
<p>Perhaps more damningly to this idea, there is not a unique lemma statement corresponding to a tactic; <code>by {ext, simp}</code> is a proof of probably 100s of lemmas in mathlib.</p>



<a name="233535056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233535056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233535056">(Apr 07 2021 at 18:01)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Thanks for the input. </p>
<p>That's an important point. There isn't a unique lemma statement corresponding to the proofs of form <code>by {ext, simp}</code>, but I assume each such proof would have a unique proof term corresponding to it. That suggests to me that the only way to do something like this in Lean would be to use raw proof terms. But that's such a verbose representation, I wonder if it defeats the utility of it.</p>



<a name="233535320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233535320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233535320">(Apr 07 2021 at 18:03)</a>:</h4>
<p>Tactic proofs nicely summarize proof terms which could be massive if fully elaborated</p>



<a name="233535587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233535587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233535587">(Apr 07 2021 at 18:04)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">theorem</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="n">y</span><span class="o">)</span><span class="bp">^</span><span class="mi">3</span><span class="bp">=</span><span class="n">x</span><span class="bp">^</span><span class="mi">3</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">x</span><span class="bp">^</span><span class="mi">2</span><span class="bp">*</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="bp">^</span><span class="mi">2</span><span class="bp">+</span><span class="n">y</span><span class="bp">^</span><span class="mi">3</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">ring</span>

<span class="k">#print</span> <span class="n">foo</span> <span class="c1">-- oof</span>
</code></pre></div>



<a name="233537532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233537532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233537532">(Apr 07 2021 at 18:18)</a>:</h4>
<p>~Note that~ As far as I'm aware, "raw" proof terms already contain the theorem statement. What you care about are "pretty printed" proof terms, which may or may not round-trip to the original proof term depending on how nasty the term is and whether you have <code>set_option pp.implicit true</code> (or worse) enabled.</p>



<a name="233572057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233572057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233572057">(Apr 07 2021 at 22:18)</a>:</h4>
<p><span class="user-mention" data-user-id="337523">@Joe Palermo (S2'17)</span> Again, I think it is helpful to step back and think through what you want to accomplish here.  If your goal is to generate proofs, you have two options: Generate the whole proof in one go (maybe as a tree or as a Lean fully elaborated text), or generate the proofs in steps.  For example, to generate <code>λ (n : ℕ), n.factorial_pos</code> you would do it in stages:</p>
<ul>
<li><code>λ (n : ℕ), _</code></li>
<li><code>λ (n : ℕ), nat.factorial_pos _</code></li>
<li><code>λ (n : ℕ), nat.factorial_pos n</code><br>
If you did it in stages that is when that trick would help you.  But, no you can't use the typical tactics, you would have to work with a very small DSL of low-level tactics like <code>apply</code> and <code>refine</code>.</li>
</ul>
<p>My personal thought is that if you are doing this as a supervised learning project and have access to a large language model, then try to generate whole proof terms.   If you are doing this as a "math zero"reinforcement learning project where you are building up proofs from scratch or you don't have access to large language models, then breaking up the construction into steps would help your model.  For example, one wrong character could cause a proof to not type check (and fully elaborated proofs can get really long).  Doing this as a tree search over this tactic DSL gives your model the ability to backtrack.  </p>
<p>However if you do the latter approach where you generate a proof in stages, then that is a lot of engineering to both create the DSL, convert your proofs to this DSL, and make your model work with this DSL, whereas large language models are easy (if you have the resources).</p>



<a name="233661430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inferring%20Theorem%20from%20a%20Proof%20Term%3F/near/233661430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F.html#233661430">(Apr 08 2021 at 14:27)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> Thanks again for your detailed advice. I have the skill set and resources to train reasonably large language models so I'm definitely inclined to that direction. I'm going to followup in my other thread (<a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python">https://leanprover.zulipchat.com/#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python</a>), regarding some more specific questions about how one might do that.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
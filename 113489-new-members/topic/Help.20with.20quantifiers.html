---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Help.20with.20quantifiers.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html">Help with quantifiers</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="257293282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257293282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257293282">(Oct 13 2021 at 00:41)</a>:</h4>
<p>I got stuck trying to prove these two, please can anyone help me with the solutions:</p>
<p>theorem DG2 (α : Type*) (A : α → Prop) : (¬ ∃ x, ¬ A x) → ∀ x, A x := sorry<br>
theorem NG1 (α : Type*) (A : α → Prop) : (¬ ∀ x, A x) → ∃ x, ¬ A x := sorry</p>
<p>Thanks,<br>
Jose</p>



<a name="257295216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257295216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257295216">(Oct 13 2021 at 01:08)</a>:</h4>
<p>What have you tried? (See also <a href="https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks">#backticks</a>)</p>



<a name="257316445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257316445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257316445">(Oct 13 2021 at 06:14)</a>:</h4>
<p>Is this homework? And what Scott said.</p>



<a name="257436524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257436524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257436524">(Oct 13 2021 at 20:57)</a>:</h4>
<p>Hi Scott, and Kevin, thanks a lot for your message.</p>
<p>It is not homework, I am just trying to learn Lean on my own, and I doing the exercises that I found in a Logic text book using Lean, but the book is not related at all with Lean.<br>
In the book the relations between quantifiers are given for granted and used without demonstration. That is why I thought it to be a good idea to use theorem and then use it directly in other demonstrations.<br>
All the exercises in the book have solutions, so for me it is more like translating them to Lean, to help me to learn how to translate natural deduction proofs into Lean. Hopefully that will help me to understand better natural deduction too.</p>
<p>I had to try to solve the problem again as I had deleted all that I tried. I usually just keep the solutions that work.</p>
<p>This what I tried but it is clearly wrong. Any hint?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">DG2</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">A</span> <span class="n">x</span><span class="o">,</span>
<span class="k">show</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span>
<span class="n">classical.by_contradiction</span>
<span class="o">(</span><span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span>
     <span class="n">classical.by_contradiction</span><span class="o">(</span>
     <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
     <span class="k">assume</span> <span class="n">h3</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">A</span> <span class="n">x</span><span class="o">,</span>
     <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">A</span> <span class="n">x</span><span class="o">),</span> <span class="k">from</span> <span class="o">⟨</span><span class="n">x</span> <span class="o">,</span> <span class="n">h3</span><span class="o">⟩,</span>
     <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span> <span class="n">h4</span><span class="o">),</span>
  <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)</span>
</code></pre></div>



<a name="257438109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257438109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257438109">(Oct 13 2021 at 21:07)</a>:</h4>
<p>Do you insist on writing a proof term or would you be happy using tactics?</p>



<a name="257438545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257438545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257438545">(Oct 13 2021 at 21:10)</a>:</h4>
<p>Hi Patrick, thanks for your message.<br>
I tried to learn tactics, but found it very confusing, also, proof theorem looks to me more similar to natural deduction. Maybe I am wrong?<br>
But yes, I plan to learn tactics.</p>



<a name="257439063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257439063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257439063">(Oct 13 2021 at 21:14)</a>:</h4>
<p>Ok, I'll give you a better term mode start then:</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">DG2</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h1</span> <span class="n">x</span><span class="o">,</span>
<span class="n">classical.by_contradiction</span> <span class="n">_</span>
</code></pre></div>
</div></div>



<a name="257439084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257439084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257439084">(Oct 13 2021 at 21:14)</a>:</h4>
<p>You could first try showing <code>(¬ ∃ x, A x) → ∀ x, ¬ A x</code>. I'll let you appreciate how this is basically the definition of <code>∃</code>.</p>



<a name="257439112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257439112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257439112">(Oct 13 2021 at 21:14)</a>:</h4>
<p>I assume he is already past that stage</p>



<a name="257439199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257439199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257439199">(Oct 13 2021 at 21:15)</a>:</h4>
<p>Anyway, I do recommend learning tactic mode. The tutorials project is hopeful good enough, and it features proving all this (in tactic mode).</p>



<a name="257439255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257439255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257439255">(Oct 13 2021 at 21:15)</a>:</h4>
<p>Yes, that one was easy, thanks Yael</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">NP1</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">A</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">,</span>
<span class="k">show</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">A</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span>
    <span class="o">(</span>
      <span class="k">assume</span> <span class="n">y</span><span class="o">,</span>
      <span class="k">assume</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">A</span> <span class="n">y</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">A</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists.intro</span> <span class="n">y</span> <span class="n">h2</span><span class="o">,</span>
      <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1</span> <span class="n">h3</span>
    <span class="o">)</span>
</code></pre></div>



<a name="257439509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257439509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257439509">(Oct 13 2021 at 21:17)</a>:</h4>
<p>Now, swapping the <code>¬</code> around is a matter of simplifying <code>¬ (¬ something)</code> to <code>something</code> and hopefully you should have a clearer view by now <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="257441643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257441643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257441643">(Oct 13 2021 at 21:31)</a>:</h4>
<p>oh, I said that was easy, but not, in fact I don't understand it completely. Any hit about logical principles that I can look at, to understand it better Yaël? <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span><br>
Thanks Patrick, will try that, I guess this is one of the things where Type Theory is different from Set theory. The need to assume that x to be able to do the demonstration. I think it is mentioned somewhere in Logic and Proof.</p>



<a name="257445658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257445658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257445658">(Oct 13 2021 at 22:00)</a>:</h4>
<p>Thanks Patrick and Yaël.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">DG2</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
<span class="n">classical.by_contradiction</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">h1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h1</span><span class="o">⟩,</span>
  <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span> <span class="n">h2</span>
<span class="o">)</span>
</code></pre></div>
<p>Anyway, this is weird, need to think about it. <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>



<a name="257445676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257445676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257445676">(Oct 13 2021 at 22:00)</a>:</h4>
<p>No, the keyword <code>assume</code> is a bit confusing but there is no difference with first order logic foundations here. In order to prove a statement starting with <code>∀ x, ...</code>, the direct proof starts with "Let's fix an arbitrary x". This is what <code>assume x</code> is doing</p>



<a name="257445725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257445725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257445725">(Oct 13 2021 at 22:01)</a>:</h4>
<p>I was answering your previous message, but we wrote at the same time</p>



<a name="257445798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257445798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257445798">(Oct 13 2021 at 22:01)</a>:</h4>
<p>Great. Now you're ready to rewrite it as <code>λ h1 x, classical.by_contradiction (λ h2, h1 ⟨x, h2⟩)</code></p>



<a name="257445874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257445874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257445874">(Oct 13 2021 at 22:02)</a>:</h4>
<p>And this is the signal you should be learning tactic mode instead of obfuscated mode.</p>



<a name="257446215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257446215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257446215">(Oct 13 2021 at 22:04)</a>:</h4>
<p><span class="user-mention" data-user-id="219844">@Jose Balado</span> I've just been writing lean files and YouTube tutorials for this sort of thing for my UGs -- maybe <a href="https://github.com/ImperialCollegeLondon/M40001_lean/blob/master/src/2021/logic/README.md">https://github.com/ImperialCollegeLondon/M40001_lean/blob/master/src/2021/logic/README.md</a> and <a href="https://youtube.com/playlist?list=PLVZep5wTamMmeF968ovIjd-uc1I6kdirJ">https://youtube.com/playlist?list=PLVZep5wTamMmeF968ovIjd-uc1I6kdirJ</a> might help?</p>



<a name="257446538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257446538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257446538">(Oct 13 2021 at 22:07)</a>:</h4>
<p>yes Patrick, I see, I got it wrong, the case I was referring being different for Type theory was this:<br>
In contrast, the statement (∀ x : U, P x) → ∃ x : U, P x is not provable in Lean.</p>
<p>Yes, using Lambda notation is not a problem.</p>
<p>Ok, I will give a try to tactics, but even this short code  looks weird, I can not see how I can related this to natural deduction.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">h1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h2</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="257446858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257446858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257446858">(Oct 13 2021 at 22:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219844">Jose Balado</span> <a href="#narrow/stream/113489-new-members/topic/Help.20with.20quantifiers/near/257446538">said</a>:</p>
<blockquote>
<p>yes Patrick, I see, I got it wrong, the case I was referring being different for Type theory was this:<br>
In contrast, the statement (∀ x : U, P x) → ∃ x : U, P x is not provable in Lean.</p>
</blockquote>
<p>I still don't see a difference. That statement wouldn't be provable in any (sound) foundation.</p>



<a name="257446973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257446973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257446973">(Oct 13 2021 at 22:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <br>
Everything helps, looks interesting, thanks for the link.</p>



<a name="257446991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257446991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257446991">(Oct 13 2021 at 22:11)</a>:</h4>
<p>I don't understand what's wrong with your short code involving two rewrites. But I'm a mathematician so I don't know what is "natural deduction".</p>



<a name="257447132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257447132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257447132">(Oct 13 2021 at 22:12)</a>:</h4>
<p>It's those crazy fractions I think</p>



<a name="257447237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257447237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257447237">(Oct 13 2021 at 22:13)</a>:</h4>
<p>Kevin is also a mathematician <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="257447249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257447249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257447249">(Oct 13 2021 at 22:13)</a>:</h4>
<p>On the Discord the other day I was telling someone that in the maths department we specialise in unnatural deduction</p>



<a name="257447359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257447359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257447359">(Oct 13 2021 at 22:14)</a>:</h4>
<p>He tries to pretend but he knows there are all sorts of crazy fractions (including typing rules)</p>



<a name="257447495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257447495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257447495">(Oct 13 2021 at 22:15)</a>:</h4>
<p>Usually the way of presenting First Order demonstrations in first year Mathematical logic books. Like this, for example:<br>
<a href="https://leanprover.github.io/logic_and_proof/natural_deduction_for_first_order_logic.html">https://leanprover.github.io/logic_and_proof/natural_deduction_for_first_order_logic.html</a></p>
<p><span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>



<a name="257447865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257447865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257447865">(Oct 13 2021 at 22:18)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> <br>
To give more context about (∀ x : U, P x) → ∃ x : U, P x is not provable in Lean.</p>
<p>-- This is subtle: the proof does not go through if we do not declare a variable u of type U, even though u does not appear in the statement of the theorem.<br>
-- This highlights a difference between first-order logic and the logic implemented in Lean. <br>
-- In natural deduction, we can prove ∀x P(x) → ∃x P(x), which shows that our proof system implicitly assumes that the universe has at least one object. <br>
-- In contrast, the statement (∀ x : U, P x) → ∃ x : U, P x is not provable in Lean. <br>
-- In other words, in Lean, it is possible for a type to be empty, and so the proof above requires an explicit assumption that there is an element u in U.</p>
<p>And I think I saw that in several logic books, but, can be completely mistaken, of course. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
<p><a href="https://leanprover.github.io/logic_and_proof/first_order_logic_in_lean.html">https://leanprover.github.io/logic_and_proof/first_order_logic_in_lean.html</a></p>



<a name="257448556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257448556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257448556">(Oct 13 2021 at 22:24)</a>:</h4>
<p>I understand this very well. But the analogue statement in set theory would not be <code>∀x P(x) → ∃x P(x)</code>, it would be <code>(∀ x ∈ A, P(x)) → ∃ x ∈ A, P(x)</code><br>
for some unspecified set <code>A</code>, and this isn't provable either.</p>



<a name="257449042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257449042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257449042">(Oct 13 2021 at 22:28)</a>:</h4>
<p>I remember telling one of the Isabelle crowd that we'd defined a perfectoid space and they asked if we'd proved any theorems about it and I said no, and they said "oh so all you did was proved the type was inhabited?" and I said "oh no we didn't do that either"</p>



<a name="257449106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257449106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257449106">(Oct 13 2021 at 22:29)</a>:</h4>
<p>I've never quite understood this. I have a memory from model theory lectures that they assume all models are nonempty</p>



<a name="257450765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257450765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257450765">(Oct 13 2021 at 22:46)</a>:</h4>
<p>Ok, I thought Set Theory and First Order Logic to be based in exactly the same foundations, aside from the Axiom of Choice. It seems they are not. Also, Type Theory feels different than Set Theory and probably better to represent other domains aside from Maths.<br>
But my knowledge of Set Theory and Mathematical Logic is really basic, so it is just a gut feeling.</p>



<a name="257450854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257450854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257450854">(Oct 13 2021 at 22:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/Help.20with.20quantifiers/near/257446858">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="219844">Jose Balado</span> <a href="#narrow/stream/113489-new-members/topic/Help.20with.20quantifiers/near/257446538">said</a>:</p>
<blockquote>
<p>yes Patrick, I see, I got it wrong, the case I was referring being different for Type theory was this:<br>
In contrast, the statement (∀ x : U, P x) → ∃ x : U, P x is not provable in Lean.</p>
</blockquote>
<p>I still don't see a difference. That statement wouldn't be provable in any (sound) foundation.</p>
</blockquote>
<p>Actually, this is an axiom or provable in FOL and HOL foundations</p>



<a name="257450888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257450888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257450888">(Oct 13 2021 at 22:47)</a>:</h4>
<p>the catch is that all types are nonempty in these foundations</p>



<a name="257450952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257450952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257450952">(Oct 13 2021 at 22:48)</a>:</h4>
<p><code>false</code> is not a type in those foundations?</p>



<a name="257450957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257450957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257450957">(Oct 13 2021 at 22:48)</a>:</h4>
<p>no</p>



<a name="257450976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257450976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257450976">(Oct 13 2021 at 22:48)</a>:</h4>
<p>in FOL, propositions are not types</p>



<a name="257450997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257450997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257450997">(Oct 13 2021 at 22:48)</a>:</h4>
<p>and this is one reason why they can't be</p>



<a name="257451062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257451062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257451062">(Oct 13 2021 at 22:49)</a>:</h4>
<p>in HOL whenever you construct a new type you have to prove it is nonempty before the construction is admitted</p>



<a name="257451358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257451358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257451358">(Oct 13 2021 at 22:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Thanks, that is really interesting.</p>



<a name="257451436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257451436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257451436">(Oct 13 2021 at 22:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="219844">Jose Balado</span> <a href="#narrow/stream/113489-new-members/topic/Help.20with.20quantifiers/near/257450765">said</a>:</p>
<blockquote>
<p>Also, Type Theory feels different than Set Theory and probably better to represent other domains aside from Maths.</p>
</blockquote>
<p>I claim type theory is much closer to how mathematicians actually think than FOL+set theory.</p>



<a name="257451527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257451527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257451527">(Oct 13 2021 at 22:54)</a>:</h4>
<p>It takes a bit of time to realize this because our polite lie that maths relies on set theory is an old habit. Of course the truth is math is completely foundation-agnostic.</p>



<a name="257451658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257451658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257451658">(Oct 13 2021 at 22:54)</a>:</h4>
<p>It's a soft type theory though, and defeq is definitely not a thing</p>



<a name="257451712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257451712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257451712">(Oct 13 2021 at 22:55)</a>:</h4>
<p>Anyway, I should go to sleep now that my teaching is ready for tomorrow.</p>



<a name="257610353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257610353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257610353">(Oct 14 2021 at 21:39)</a>:</h4>
<p>Hi, is there a way to simplify this theorem? Don't like too much the idea of using two by_contradicition.<br>
Thanks.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">NG1</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">A</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">,</span>
<span class="k">show</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">A</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span>
<span class="n">classical.by_contradiction</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">A</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span>
  <span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">classical.by_contradiction</span><span class="o">(</span>
    <span class="k">assume</span> <span class="n">h3</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h3</span><span class="o">⟩,</span>
    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1</span> <span class="n">h4</span>
  <span class="o">),</span>
  <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span> <span class="n">h2</span>
<span class="o">)</span>
</code></pre></div>



<a name="257611903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257611903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257611903">(Oct 14 2021 at 21:53)</a>:</h4>
<p>I mean, you can golf it to one line as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">classical.by_contradiction</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h2</span><span class="o">,</span> <span class="n">h</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">classical.by_contradiction</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">hA</span><span class="o">,</span> <span class="n">h2</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hA</span><span class="o">⟩</span>
</code></pre></div>
<p>It turns out this is pretty much how mathlib proves <a href="https://leanprover-community.github.io/mathlib_docs/find/not_forall">docs#not_forall</a> (the forward direction of which is your statement):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">not.decidable_imp_symm</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">nx</span> <span class="n">x</span><span class="o">,</span> <span class="n">nx.decidable_imp_symm</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>
</code></pre></div>
<p>where <code>decidable.not_imp_symm</code> is basically just <code>by_contradiction</code>.</p>



<a name="257612258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257612258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257612258">(Oct 14 2021 at 21:56)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Thanks Eric, will take a look at it.</p>



<a name="257612844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Help%20with%20quantifiers/near/257612844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jose Balado <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Help.20with.20quantifiers.html#257612844">(Oct 14 2021 at 22:00)</a>:</h4>
<p>A little bit difficult for me to follow mathlib, but looks really interesting. Thanks for the link Eric</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
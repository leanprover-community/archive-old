---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Group.20theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html">Group theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="243880793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/243880793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sai Gopal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#243880793">(Jun 25 2021 at 06:44)</a>:</h4>
<p>If I want to use pre defined definitions and theorems in groip theory, how shld I import them? <br>
For instance, to import topology it is import topology.basic</p>



<a name="243880856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/243880856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#243880856">(Jun 25 2021 at 06:45)</a>:</h4>
<p><code>import topology.basic</code> means: grab everything that's in <code>src/topology/basic.lean</code> and import it into the environment.</p>



<a name="243880924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/243880924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#243880924">(Jun 25 2021 at 06:46)</a>:</h4>
<p>So now <code>import group_theory.&lt;some_nice_file&gt;</code> that you find by browsing mathlib</p>



<a name="243881053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/243881053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sai Gopal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#243881053">(Jun 25 2021 at 06:48)</a>:</h4>
<p>instead of .&lt;&gt; <br>
Can you tell me which file has all basics of GT ?</p>



<a name="243881114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/243881114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#243881114">(Jun 25 2021 at 06:49)</a>:</h4>
<p>You should rather be precise about what you want to do.</p>



<a name="243881167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/243881167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#243881167">(Jun 25 2021 at 06:50)</a>:</h4>
<p>What is the exact maths statement that you want to formalize in Lean?</p>



<a name="243881206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/243881206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#243881206">(Jun 25 2021 at 06:50)</a>:</h4>
<p>There is also the directory <code>src/algebra/group/</code> which contains a lot of low-level stuff: <a href="https://github.com/leanprover-community/mathlib/tree/master/src/algebra/group">https://github.com/leanprover-community/mathlib/tree/master/src/algebra/group</a></p>



<a name="243881326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/243881326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sai Gopal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#243881326">(Jun 25 2021 at 06:53)</a>:</h4>
<p>So How do I include this ?</p>



<a name="244008299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244008299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244008299">(Jun 26 2021 at 10:37)</a>:</h4>
<p>Import the name of the file</p>



<a name="244207162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244207162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244207162">(Jun 28 2021 at 21:29)</a>:</h4>
<p>if i were to construct a specific kind of free group, would i do something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">some_specific_free_group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">free_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:=</span>
<span class="c1">--proofs of its properties here</span>
</code></pre></div>
<p>which came from modifying this code slightly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">one_mem'</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_mem'</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_mem'</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">∈</span> <span class="n">carrier</span><span class="o">)</span>
</code></pre></div>
<p>or should i use something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">G</span><span class="o">,</span> <span class="n">has_one</span> <span class="n">G</span><span class="o">,</span> <span class="n">has_inv</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">))</span>
<span class="o">(</span><span class="n">one_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_left_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>(i found these in the tutorial project linked in previous messages)</p>



<a name="244208079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244208079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244208079">(Jun 28 2021 at 21:39)</a>:</h4>
<p>What would you like to do specifically? Would you like to declare that a specific group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> is a free group, or, given a type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>, consider "the" free group on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>?</p>



<a name="244208511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244208511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244208511">(Jun 28 2021 at 21:44)</a>:</h4>
<p>I would like to create a new structure/class (i'm not sure what the difference is yet) that is a free group plus some other properties. I think this is like declaring a free group, or declaring that it has free group properties.</p>



<a name="244208633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244208633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244208633">(Jun 28 2021 at 21:45)</a>:</h4>
<p>It's maybe not what you want, but we have <a href="https://leanprover-community.github.io/mathlib_docs/find/is_free_group">docs#is_free_group</a></p>



<a name="244208736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244208736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244208736">(Jun 28 2021 at 21:46)</a>:</h4>
<p>As well as <a href="https://leanprover-community.github.io/mathlib_docs/find/free_group">docs#free_group</a></p>



<a name="244213003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244213003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244213003">(Jun 28 2021 at 22:33)</a>:</h4>
<p>could someone briefly walk me through what these are doing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable theory</span>
<span class="kd">universes</span> <span class="n">u</span> <span class="n">w</span>

<span class="sd">/-- `is_free_group G` means that `G` has the universal property of a free group,</span>
<span class="sd">That is, it has a family `generators G` of elements, such that a group homomorphism</span>
<span class="sd">`G →* X` is uniquely determined by a function `generators G → X`. -/</span>
<span class="kd">class</span> <span class="n">is_free_group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">generators</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">of</span> <span class="o">:</span> <span class="n">generators</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">unique_lift'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">generators</span> <span class="bp">→</span> <span class="n">X</span><span class="o">),</span>
                <span class="bp">∃!</span> <span class="n">F</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">F</span> <span class="o">(</span><span class="n">of</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">free_group_is_free_group</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_free_group</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">generators</span> <span class="o">:=</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">of</span> <span class="o">:=</span> <span class="n">free_group.of</span><span class="o">,</span>
  <span class="n">unique_lift'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">introsI</span> <span class="n">X</span> <span class="n">_</span> <span class="n">f</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">free_group.lift.symm.bijective.exists_unique</span> <span class="n">f</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="n">function.funext_iff</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">group</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">*</span><span class="o">),</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">inv</span> <span class="o">:=</span> <span class="n">has_inv.inv</span><span class="o">,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">L₁</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">L₂</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">L₃</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">L</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">L</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">one_eq_mk</span><span class="o">],</span>
  <span class="n">mul_left_inv</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">L</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">exact</span> <span class="o">(</span><span class="n">list.rec_on</span> <span class="n">L</span> <span class="n">rfl</span> <span class="bp">$</span>
    <span class="bp">λ</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">b</span><span class="o">⟩</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span> <span class="n">eq.trans</span> <span class="o">(</span><span class="n">quot.sound</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">one_eq_mk</span><span class="o">])</span> <span class="n">ih</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>
<p>to me, these look like they are both declaring free groups?</p>



<a name="244213200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244213200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244213200">(Jun 28 2021 at 22:35)</a>:</h4>
<p>To give a term of the first type <code>is_free_group G</code> is to give a proof that <code>G</code> is abstractly isomorphic to a free group (more precisely, it is to give an isomorphism between <code>G</code> and a free group).</p>
<p>The <code>instance</code> is a term of type <code>is_free_group (free_group A)</code> so it's a proof that the free group on a type <code>A</code> is a free group.</p>
<p>The final <code>instance</code> is the proof that the free group on a type alpha is a group.</p>



<a name="244213484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244213484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244213484">(Jun 28 2021 at 22:39)</a>:</h4>
<p>For example, you could fill in the following sorry:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.is_free_group</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">is_free_group</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">generators</span> <span class="o">:=</span> <span class="n">punit</span><span class="o">,</span>
  <span class="n">of</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">multiplicative.of_add</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">unique_lift'</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>



<a name="244213506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244213506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244213506">(Jun 28 2021 at 22:39)</a>:</h4>
<p>Which says that the group of integers is a free group on a single element.</p>



<a name="244214322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244214322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244214322">(Jun 28 2021 at 22:48)</a>:</h4>
<p>And then you could PR it to mathlib :)</p>



<a name="244875836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244875836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244875836">(Jul 04 2021 at 20:22)</a>:</h4>
<p>hi! i was wondering if you could explain what the following code is doing? i understand that <code>1</code> is the identity here. how is it being declared in order to be used in the axioms <code>one_mul</code> and <code>mul_one</code> later on? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The canonical map from `list (α × bool)` to the free group on `α`. -/</span>
<span class="kd">def</span> <span class="n">mk</span> <span class="o">(</span><span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">quot.mk</span> <span class="n">red.step</span> <span class="n">L</span>

<span class="bp">...</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">mk</span> <span class="o">[]⟩</span>
<span class="kd">lemma</span> <span class="n">one_eq_mk</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mk</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">⟩</span>
</code></pre></div>
<p>from <a href="https://github.com/leanprover-community/mathlib/blob/4ace3b73b4a3cdafe51f3c1a01fe2b583ae0c499/src/group_theory/free_group.lean#L76">https://github.com/leanprover-community/mathlib/blob/4ace3b73b4a3cdafe51f3c1a01fe2b583ae0c499/src/group_theory/free_group.lean#L76</a></p>



<a name="244876061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244876061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244876061">(Jul 04 2021 at 20:29)</a>:</h4>
<p><code>instance : has_one _</code> is specifying what <code>1</code> means in that example. Is that your question?</p>



<a name="244982116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244982116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244982116">(Jul 05 2021 at 23:43)</a>:</h4>
<p>sorry for the late reply. yes, i'm confused on what the notation <code>mk []</code> means? i think this also leads to my question of what <code>quot.mk red.step L</code> is?</p>



<a name="244982124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244982124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244982124">(Jul 05 2021 at 23:43)</a>:</h4>
<p>thanks again.</p>



<a name="244987114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/244987114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#244987114">(Jul 06 2021 at 01:39)</a>:</h4>
<p><span class="user-mention" data-user-id="418958">@Holly Liu</span>  Recall that a free group can be presented as words of generators and inverses of generators, modulo the relation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><msup><mi>x</mi><mrow><mo>±</mo><mn>1</mn></mrow></msup><msup><mi>x</mi><mrow><mo>∓</mo><mn>1</mn></mrow></msup><mi>v</mi><mo>=</mo><mi>u</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">u x^{\pm 1} x^{\mp 1}v=uv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">±</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∓</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">uv</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> is a generator and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> are words.  A nice fact about this relation is that you can apply this relation repeatedly until it doesn't apply anymore (in the left-to-right direction), and it will always eventually reduce the word to its normal form.</p>
<p>In mathlib, words are represented by the type <code>list (α × bool)</code>, lists of pairs of a generator and a boolean.  The boolean is true or false depending on whether it is the generator or its inverse.  For example <code>[(x, tt), (y, tt), (x, ff)]</code> represents <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi><msup><mi>x</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">xyx^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>A single application of the reduction relation is represented by the following inductive type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Reduction step: `w * x * x⁻¹ * v ~&gt; w * v` -/</span>
<span class="kd">inductive</span> <span class="n">red.step</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">bnot</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">x</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">red.step</span> <span class="o">(</span><span class="n">L₁</span> <span class="bp">++</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">bnot</span> <span class="n">b</span><span class="o">)</span> <span class="o">::</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">L₁</span> <span class="bp">++</span> <span class="n">L₂</span><span class="o">)</span>
</code></pre></div>
<p>If you squint hard enough, you might see the resemblance.</p>
<p>Then, the free group with generators from the type <code>α</code> is given by the type <code>quot red.step α</code> (this is the definition of <code>free_group</code>).  This creates a quotient type, where terms of  <code>quot red.step α</code> correspond to equivalence classes under the equivalence relation generated by <code>red.step</code>.</p>
<p>The way you take a word <code>w</code> and put it into the quotient type is <code>quot.mk red.step w</code>.  In math speak, this is like writing brackets around an element that represents an element of a quotient (it's like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>w</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[w]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span></span></span></span>).</p>
<p>In Lean, <code>[]</code> is the empty list, so <code>quot.mk red.step []</code> is "the empty word as an element of the free group."</p>



<a name="245064783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245064783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245064783">(Jul 06 2021 at 16:33)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>  thanks for the very thorough explanation.</p>



<a name="245095490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245095490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245095490">(Jul 06 2021 at 20:38)</a>:</h4>
<p>in this snippet, what are the notations <code>$</code> and <code>@</code> doing? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The free group over a type, i.e. the words formed by the elements of the type and their formal</span>
<span class="sd">inverses, quotient by one step reduction. -/</span>
<span class="kd">def</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">quot</span> <span class="bp">$</span> <span class="bp">@</span><span class="n">free_group.red.step</span> <span class="n">α</span>
</code></pre></div>



<a name="245095964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245095964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245095964">(Jul 06 2021 at 20:42)</a>:</h4>
<p>I like to think of <code>$</code> as a pair of parentheses stacked on top of each other, nailed together.  It's a notation that basically means "open parenthesis, then insert the close parenthesis at the end of the expression."  So, it's the same as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The free group over a type, i.e. the words formed by the elements of the type and their formal</span>
<span class="sd">inverses, quotient by one step reduction. -/</span>
<span class="kd">def</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">quot</span> <span class="o">(</span><span class="bp">@</span><span class="n">free_group.red.step</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>
<p>What <code>@</code> does is make all implicit arguments explicit.  <a href="https://leanprover.github.io/reference/expressions.html#implicit-arguments">https://leanprover.github.io/reference/expressions.html#implicit-arguments</a></p>



<a name="245096078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245096078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245096078">(Jul 06 2021 at 20:43)</a>:</h4>
<p>ah i see.</p>



<a name="245096336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245096336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Malvin Gattinger <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245096336">(Jul 06 2021 at 20:45)</a>:</h4>
<p>Ah, so $ does the same as in Haskell, nice to know.</p>



<a name="245096463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245096463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245096463">(Jul 06 2021 at 20:46)</a>:</h4>
<p>This is the type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">free_group.red.step</span> <span class="o">:</span> <span class="n">free_group.red.step</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">},</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
</code></pre></div>
<p>So if you want to pass the <code>α</code> in, you can use <code>@</code>.  The issue is that there's nothing else in the expression that can help Lean infer what <code>α</code> should be.</p>



<a name="245097167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245097167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245097167">(Jul 06 2021 at 20:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="422703">Malvin Gattinger</span> <a href="#narrow/stream/113489-new-members/topic/Group.20theory/near/245096336">said</a>:</p>
<blockquote>
<p>Ah, so $ does the same as in Haskell, nice to know.</p>
</blockquote>
<p>Yep, though it's implemented a bit differently.  Rather than being an operator in its own right, it's defined as notation in <code>init/core.lean</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">f</span> <span class="bp">`</span> <span class="bp">$</span> <span class="bp">`</span><span class="o">:</span><span class="mi">1</span> <span class="n">a</span><span class="o">:</span><span class="mi">0</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div>
<p>You can still do <code>($)</code> as a Haskeller would expect.</p>



<a name="245097519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245097519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Malvin Gattinger <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245097519">(Jul 06 2021 at 20:55)</a>:</h4>
<p>Ah, thanks. The ( ) notation to turn infix into prefix works just for $ or in general with all infix notations?</p>



<a name="245102527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245102527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245102527">(Jul 06 2021 at 21:42)</a>:</h4>
<p>It works on all infix notation</p>



<a name="245102594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245102594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245102594">(Jul 06 2021 at 21:43)</a>:</h4>
<p>We also have <code>(+ 1)</code> which expands to <code> λ x, x + 1</code> for all infix operators</p>



<a name="245102652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245102652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245102652">(Jul 06 2021 at 21:44)</a>:</h4>
<p>So I guess <code>($ x)</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/function.eval">docs#function.eval</a> x</p>



<a name="245105936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245105936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245105936">(Jul 06 2021 at 22:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Group.20theory/near/245096463">said</a>:</p>
<blockquote>
<p>This is the type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">free_group.red.step</span> <span class="o">:</span> <span class="n">free_group.red.step</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">},</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
</code></pre></div>
<p>So if you want to pass the <code>α</code> in, you can use <code>@</code>.  The issue is that there's nothing else in the expression that can help Lean infer what <code>α</code> should be.</p>
</blockquote>
<p><del>so if we were to leave out the <code>@</code>, say we have <code>quot free_group.red.step α</code>, then what is <code>α</code>? is it still <code>Type u</code>? i think i'm confused about when we would want Lean to infer the type, and why we want it to infer it here when we're already giving it the type by writing <code>(α : Type u)</code>.</del> read the doc and i think i understand.</p>



<a name="245106436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245106436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245106436">(Jul 06 2021 at 22:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Group.20theory/near/245102527">said</a>:</p>
<blockquote>
<p>It works on all infix notation</p>
</blockquote>
<p>if by infix you mean <code>infix</code>, then <code>$</code> isn't defined in that way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">f</span> <span class="bp">`</span> <span class="bp">$</span> <span class="bp">`</span><span class="o">:</span><span class="mi">1</span> <span class="n">a</span><span class="o">:</span><span class="mi">0</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div>



<a name="245106850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245106850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245106850">(Jul 06 2021 at 22:33)</a>:</h4>
<p>oh I see this was mentioned above</p>



<a name="245106982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245106982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245106982">(Jul 06 2021 at 22:34)</a>:</h4>
<p>I think by <code>infix</code> I mean "anything that unfolds to the same type of notation command as <code>infix</code>"</p>



<a name="245107035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245107035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245107035">(Jul 06 2021 at 22:35)</a>:</h4>
<p><code>#print notation</code> doesn't show anything but <code>notation</code>; the other keywords seem to just be shorthands</p>



<a name="245109582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245109582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245109582">(Jul 06 2021 at 23:07)</a>:</h4>
<p><span class="user-mention" data-user-id="418958">@Holly Liu</span> <code>quot free_group.red.step α</code> would be an error, because <code>quot</code> only takes a single explicit argument. This is the type for <code>quot</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">quot</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span>
</code></pre></div>
<p>It takes (implicitly) a type and (explicitly) a relation on that type, producing a new type.</p>
<p>The following are equivalent:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">free_group_1</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">quot</span> <span class="o">(</span><span class="bp">@</span><span class="n">free_group.red.step</span> <span class="n">α</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">free_group_2</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">quot</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">))</span> <span class="n">free_group.red.step</span>
<span class="kd">def</span> <span class="n">free_group_3</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">quot</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">))</span> <span class="o">(</span><span class="bp">@</span><span class="n">free_group.red.step</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>
<p>In this last one, we explicitly give all the implicit arguments.</p>
<p>The issue I was talking about is this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">free_group_4</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">quot</span> <span class="n">free_group.red.step</span>
</code></pre></div>
<p>Notice that it doesn't ever <em>use</em> <code>α</code>.  Lean will figure out it's a quotient on <code>list (_ x bool)</code>, but it can't figure out what to put for the underscore.  This is the "don't know how to synthesize placeholder" error message.</p>



<a name="245111134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245111134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245111134">(Jul 06 2021 at 23:30)</a>:</h4>
<p>ok i think that makes sense. thanks a lot! that was really clear and easy to understand.</p>



<a name="245521553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245521553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245521553">(Jul 10 2021 at 01:01)</a>:</h4>
<p>i was wondering if there is an expression equivalent to <code>fin n</code> for <code>{n : nat}</code> that uses an abstract variable instead of <code>n</code> but still defines a group with a certain number of elements?</p>



<a name="245529525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245529525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245529525">(Jul 10 2021 at 04:40)</a>:</h4>
<p><code>{G : Type*} [group G] [fintype G]</code>?</p>



<a name="245529528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245529528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245529528">(Jul 10 2021 at 04:41)</a>:</h4>
<p><code>fintype.card G</code> is then the number of elements</p>



<a name="245531720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245531720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245531720">(Jul 10 2021 at 05:49)</a>:</h4>
<p>and if you want the cardinality to be a variable, it could be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">hcard</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>
<p>If you have an application in mind, it would be helpful if you explained what you were trying to do -- I'm not sure exactly what you're asking for.</p>



<a name="245565503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245565503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245565503">(Jul 10 2021 at 18:51)</a>:</h4>
<p>sure: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">braid</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="n">n</span><span class="o">,</span> <span class="n">list</span><span class="o">((</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">braid3</span> <span class="o">:=</span> <span class="n">braid</span> <span class="mi">3</span>
<span class="k">#eval</span> <span class="n">braid3.length</span>
</code></pre></div>
<p>i'm trying to define a braid on a finite number of strands, though I wonder if <code>list((fin n) x bool)</code> is appending the bool to the set rather than its elements? also, <code>braid</code> is of type <code>Type</code> which i think is keeping me from using list operations like <code>length</code> on it? i'm not sure how to go about this.</p>



<a name="245565558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245565558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245565558">(Jul 10 2021 at 18:52)</a>:</h4>
<p>Can you post a link to the maths definition you're trying to formalise?</p>



<a name="245565602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245565602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245565602">(Jul 10 2021 at 18:53)</a>:</h4>
<p>i'm not sure if braid groups are formalized yet? i think i'm mostly using free groups: <a href="https://github.com/leanprover-community/mathlib/blob/49bf1fdecf56ce9ae3e6d15953896996af596c07/src/group_theory/free_group.lean#L385">https://github.com/leanprover-community/mathlib/blob/49bf1fdecf56ce9ae3e6d15953896996af596c07/src/group_theory/free_group.lean#L385</a></p>



<a name="245565827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245565827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245565827">(Jul 10 2021 at 18:59)</a>:</h4>
<p>oh wait was this what you meant? <a href="https://en.wikipedia.org/wiki/Braid_group">https://en.wikipedia.org/wiki/Braid_group</a></p>



<a name="245565833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245565833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245565833">(Jul 10 2021 at 18:59)</a>:</h4>
<p>Oh we're talking about braid groups? Why not just formalise them as the presentation on that Wikipedia page?</p>



<a name="245566158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245566158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245566158">(Jul 10 2021 at 19:06)</a>:</h4>
<p>do you mean like when its saying 'the group whose elements are equivalence classes of n-braids (e.g. under ambient isotopy), and whose group operation is composition of braids'? or is there code somewhere i'm not seeing?</p>



<a name="245566369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245566369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245566369">(Jul 10 2021 at 19:12)</a>:</h4>
<p>Oh, I just mean that there's an explicit description of the braid group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">B_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as the quotient of the free group on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>σ</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>σ</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_1,\sigma_2,\ldots,\sigma_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> by (the normal subgroup generated by) the relations <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub><msub><mi>σ</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>σ</mi><mi>i</mi></msub><mo>=</mo><msub><mi>σ</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>σ</mi><mi>i</mi></msub><msub><mi>σ</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_i\sigma_{i+1}\sigma_i=\sigma_{i+1}\sigma_i\sigma_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1\leq i\leq n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub><msub><mi>σ</mi><mi>j</mi></msub><mo>=</mo><msub><mi>σ</mi><mi>j</mi></msub><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_i\sigma_j=\sigma_j\sigma_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo>≤</mo><mi>n</mi><mo>−</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1\leq i\leq j-2\leq n-3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>. That wouldn't be too hard to put into Lean.</p>



<a name="245566406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245566406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245566406">(Jul 10 2021 at 19:13)</a>:</h4>
<p>There is <a href="https://leanprover-community.github.io/mathlib_docs/find/presented_group">docs#presented_group</a></p>



<a name="245566713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245566713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245566713">(Jul 10 2021 at 19:21)</a>:</h4>
<p>ah ok, i'll try that. i don't fully understand what all those words mean together yet...</p>



<a name="245566862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245566862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245566862">(Jul 10 2021 at 19:25)</a>:</h4>
<p>oh so would we just construct a specific quotient of the free group that contains only those two equivalence classes?</p>



<a name="245568561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245568561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245568561">(Jul 10 2021 at 20:09)</a>:</h4>
<p>Do you understand what a presentation of a group is (in maths, nothing to do with Lean)? If not then you should maybe read up on that first. I'm suggesting that using group presentations is a painless way to define braid groups in Lean.</p>



<a name="245570517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245570517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245570517">(Jul 10 2021 at 20:55)</a>:</h4>
<p>hm alright, i'll read up on that.</p>



<a name="245573552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/245573552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#245573552">(Jul 10 2021 at 21:47)</a>:</h4>
<p>The Wikipedia page you linked to contains a presentation of the braid group which can be turned into a lean definition once you know something about presentations.</p>



<a name="246785145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246785145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246785145">(Jul 21 2021 at 21:58)</a>:</h4>
<p>i'm still a bit confused on how to define braids using presentation groups. i'm trying to understand the presentation groups file and have a bunch of miscellaneous questions:</p>
<ol>
<li>
<p>why do <code>set</code> and equivalence relations map to a <code>Prop</code> in their definitions: <code>def set (α : Type u) := α → Prop</code> and <code>
constant quot : Π {α : Sort u}, (α → α → Prop) → Sort u</code> where <code>r : (α → α → Prop)</code>?</p>
</li>
<li>
<p>for universe <code>u</code>, <code>#check Sort u</code> evaluates <code>Sort u</code> as having type <code>Type u</code>, however the documentation says types are really just <code>Sort</code>s, i.e. <code>Prop</code> abbreviates <code>Sort 0</code>, <code>Type</code> abbreviates <code>Sort 1</code>, and <code>Type u</code> abbreviates <code>Sort (u+1)</code>. is the point of <code>Sort</code> just to have an umbrella set that includes both <code>Prop</code> and <code>Type</code>? </p>
</li>
<li>i see this <code>of</code> term often and i'm having trouble understanding it. for example:</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- `of` is the canonical map from `α` to a presented group with generators `x : α`. The term `x` is</span>
<span class="sd">mapped to the equivalence class of the image of `x` in `free_group α`. -/</span>
<span class="kd">def</span> <span class="n">of</span> <span class="o">{</span><span class="n">rels</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">α</span><span class="o">)}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">presented_group</span> <span class="n">rels</span> <span class="o">:=</span>
<span class="n">quotient_group.mk</span> <span class="o">(</span><span class="n">free_group.of</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>why do we want to map the terms <code>x : α</code> to the equivalence classes? i feel like there's some math here i'm not understanding. also, what is the 'image of <code>x</code> in <code>free_group α</code>'? is this referring to another function?</p>



<a name="246785871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246785871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246785871">(Jul 21 2021 at 22:04)</a>:</h4>
<p>You seem to have at least three unrelated questions here... The following is an explanation about item 3</p>
<p>Suppose <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> is a set, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is a set of elements in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span> denotes the free group on a set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>. Write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> for the smallest normal subgroup of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> which contains <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>. A presentation of a group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> is, mathematically speaking, an isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F(S)/N(R) \cong G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>. </p>
<p>In mathlib, <code>free_group α</code> is simply <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(\alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span>, and the map <code>free_group.of</code> is the canonical function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha \to F(\alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span>. The set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> above corresponds to <code>rels</code> in your code, and <code>quotient_group.mk</code> in this case is the quotient map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>l</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(\alpha) \to F(\alpha)/N(rels)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>. So if you start with <code>a</code> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>, you first map to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(\alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span> using <code>free_group.of</code>, then to the quotient by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>l</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(rels)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> using <code>quotient_group.mk</code>.</p>



<a name="246786026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246786026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246786026">(Jul 21 2021 at 22:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Group.20theory/near/246785871">said</a>:</p>
<blockquote>
<p>have at least three unrelated questions here... </p>
</blockquote>
<p>yeah i keep going down these rabbit holes...</p>



<a name="246786361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246786361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246786361">(Jul 21 2021 at 22:08)</a>:</h4>
<p>I think Adam's point is that you might do better to ask each question as a separate thread if you suspect they are unrelated</p>



<a name="246786417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246786417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246786417">(Jul 21 2021 at 22:09)</a>:</h4>
<p>oh, i will do that</p>



<a name="246786956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246786956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246786956">(Jul 21 2021 at 22:14)</a>:</h4>
<p>Before going on to working with braid groups via their presentation, it might be worthwhile to try to fill in some of the following sorry's (or at least try to understand mathematically why they should be true):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.zmod.basic</span>
<span class="kn">import</span> <span class="n">group_theory.presented_group</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">punit</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">Z2_rels</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">free_group.of</span> <span class="n">tt</span> <span class="bp">*</span> <span class="n">free_group.of</span> <span class="n">ff</span> <span class="bp">*</span> <span class="o">(</span><span class="n">free_group.of</span> <span class="n">tt</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">free_group.of</span> <span class="n">ff</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">presented_group</span> <span class="n">Z2_rels</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="o">(</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span> <span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">Zn_rels</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">punit</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="o">(</span><span class="n">free_group.of</span> <span class="n">punit.star</span><span class="o">)</span><span class="bp">^</span><span class="n">n</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">presented_group</span> <span class="o">(</span><span class="n">Zn_rels</span> <span class="n">n</span><span class="o">)</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="o">(</span> <span class="n">zmod</span> <span class="n">n</span> <span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="246787811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246787811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246787811">(Jul 21 2021 at 22:22)</a>:</h4>
<p>thanks, that makes more sense</p>



<a name="246787926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246787926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246787926">(Jul 21 2021 at 22:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Group.20theory/near/246786956">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">punit</span> <span class="bp">≃*</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">punit</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>?</p>



<a name="246788151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246788151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246788151">(Jul 21 2021 at 22:25)</a>:</h4>
<p>Oops!</p>



<a name="246788158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246788158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246788158">(Jul 21 2021 at 22:25)</a>:</h4>
<p>Yes</p>



<a name="246788187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246788187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246788187">(Jul 21 2021 at 22:25)</a>:</h4>
<p>Same for the other sorry's as well</p>



<a name="246788327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246788327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246788327">(Jul 21 2021 at 22:27)</a>:</h4>
<p>Fixed! Thanks <span class="user-mention" data-user-id="260507">@Heather Macbeth</span> !</p>



<a name="246895667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246895667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246895667">(Jul 22 2021 at 19:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Group.20theory/near/246786956">said</a>:</p>
<blockquote>
<p>it might be worthwhile to try to fill in some of the following sorry's</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">punit</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>what is the <code>≃*</code> notation and what is <code>multiplicative ℤ</code> ?</p>



<a name="246896096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246896096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246896096">(Jul 22 2021 at 19:47)</a>:</h4>
<p>vscode will tell you what notation means if you hover over it</p>



<a name="246896236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246896236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246896236">(Jul 22 2021 at 19:48)</a>:</h4>
<p><del>is it <code>\approx *</code> ?</del> nvm let me copy paste first</p>



<a name="246896299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/246896299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#246896299">(Jul 22 2021 at 19:49)</a>:</h4>
<p>it will also tell you how to write it</p>



<a name="247044676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247044676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247044676">(Jul 23 2021 at 23:43)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.zmod.basic</span>
<span class="kn">import</span> <span class="n">group_theory.presented_group</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">punit</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>if we are proving this isomorphism between the free group and the multiplicative <code>ℤ</code>, wouldn't the second set need an inverse property? i don't think it has one as we aren't able to use reciprocals in <code>ℤ</code>.</p>



<a name="247045489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247045489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247045489">(Jul 23 2021 at 23:58)</a>:</h4>
<p>"multiplicative int" means consider the additive group on int, but labeling the unit as 1, the group operation as *, and the inverse as ^-1</p>



<a name="247046138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247046138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247046138">(Jul 24 2021 at 00:10)</a>:</h4>
<p>ohh ok</p>



<a name="247046306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247046306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247046306">(Jul 24 2021 at 00:15)</a>:</h4>
<p>where is <code>punit</code> defined btw? i found punit.lean but it calls punit from somewhere else.</p>



<a name="247046317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247046317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247046317">(Jul 24 2021 at 00:15)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/punit/src">src#punit</a></p>



<a name="247046799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247046799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247046799">(Jul 24 2021 at 00:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">punit</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">punit</span>

<span class="sd">/-- An abbreviation for `punit.{0}`, its most common instantiation.</span>
<span class="sd">    This type should be preferred over `punit` where possible to avoid</span>
<span class="sd">    unnecessary universe parameters. -/</span>
<span class="kd">abbreviation</span> <span class="n">unit</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">punit</span>

<span class="kd">@[pattern]</span> <span class="kd">abbreviation</span> <span class="n">unit.star</span> <span class="o">:</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">punit.star</span>
</code></pre></div>
<p>i'm not really understanding what this type is for or why it only has the element <code>star</code>. does this have something to do with category theory</p>



<a name="247046984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247046984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247046984">(Jul 24 2021 at 00:30)</a>:</h4>
<p><code>punit</code> is a type with a single term called <code>punit.star</code></p>



<a name="247047063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247047063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247047063">(Jul 24 2021 at 00:32)</a>:</h4>
<p>So the mathematical meaning of the isomorphism you're trying to construct is that the integers (as an additive group) is isomorphic to the free group generated by a set with a single element.</p>



<a name="247047073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247047073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247047073">(Jul 24 2021 at 00:32)</a>:</h4>
<p>If you don't understand yhe definition of <code>punit</code> then before you go much further you should probably read the chapters on inductive types in <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> , it provides a good introduction to basic dependent type theory notions such as inductive types.</p>



<a name="247049922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247049922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247049922">(Jul 24 2021 at 01:51)</a>:</h4>
<p>could i get a hint on how to unpack the <code>mul_equiv</code> (<code>≃*</code>)? i don't think i encountered this in the natural numbers game though i got through about 70% of it.</p>



<a name="247053239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247053239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247053239">(Jul 24 2021 at 03:26)</a>:</h4>
<p>A mul_equiv consists of a function that satisfies some properties. If you want to construct it manually, then you can write something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">my_def</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">punit</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>
<p>and then vscode should tell you what axioms you need to prove.</p>



<a name="247053255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247053255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247053255">(Jul 24 2021 at 03:27)</a>:</h4>
<p>In practice, you're probably better off using some lemma about how a bijective monoid_hom is a mul_equiv</p>



<a name="247053300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247053300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247053300">(Jul 24 2021 at 03:28)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/mul_equiv.of_bijective">docs#mul_equiv.of_bijective</a></p>



<a name="247234762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247234762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247234762">(Jul 26 2021 at 17:31)</a>:</h4>
<p>i am still trying to understand how to use the lemmas in that file to show that a bijective monoid homomorphism is a mul_equiv in order to prove <code>example : free_group punit ≃* multiplicative ℤ := </code>. i'm confused about the notation here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The identity map is a multiplicative isomorphism. -/</span>
<span class="kd">@[refl, to_additive "The identity map is an additive isomorphism."]</span>
<span class="kd">def</span> <span class="n">refl</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">≃*</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
<span class="bp">..</span><span class="n">equiv.refl</span> <span class="n">_</span><span class="o">}</span>
</code></pre></div>
<p>what is the <code>'</code> and the <code>..equiv.refl</code>?</p>



<a name="247235110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247235110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247235110">(Jul 26 2021 at 17:34)</a>:</h4>
<p>The <code>'</code> is just part of the name of the field, so its not so important, why its there is a good question though but I think it can be safely ignored <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>.<br>
For the <code>..</code> see <a href="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#objects">https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#objects</a> where it talks about "record update".</p>



<a name="247235795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247235795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247235795">(Jul 26 2021 at 17:39)</a>:</h4>
<p><span class="user-mention" data-user-id="418958">@Holly Liu</span> If you want to know more about the <code>'</code>, compare the output of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">mul_equiv.map_mul'</span>
<span class="c1">-- vs</span>
<span class="k">#print</span> <span class="n">mul_equiv.map_mul</span>
</code></pre></div>



<a name="247235809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247235809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247235809">(Jul 26 2021 at 17:39)</a>:</h4>
<p>In this example we can see what happens if we delete it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.equiv.mul_add</span>
<span class="sd">/-- The identity map is a multiplicative isomorphism. -/</span>
<span class="kd">def</span> <span class="n">refl</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">≃*</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">}</span>
</code></pre></div>
<p>we get the errors:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span>
<span class="n">invalid</span> <span class="kd">structure</span> <span class="n">value</span> <span class="o">{</span> <span class="bp">...</span> <span class="o">},</span> <span class="n">field</span> <span class="bp">'</span><span class="n">to_fun'</span> <span class="n">was</span> <span class="n">not</span> <span class="n">provided</span>
<span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span>
<span class="n">invalid</span> <span class="kd">structure</span> <span class="n">value</span> <span class="o">{</span> <span class="bp">...</span> <span class="o">},</span> <span class="n">field</span> <span class="bp">'</span><span class="n">inv_fun'</span> <span class="n">was</span> <span class="n">not</span> <span class="n">provided</span>
<span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span>
<span class="n">invalid</span> <span class="kd">structure</span> <span class="n">value</span> <span class="o">{</span> <span class="bp">...</span> <span class="o">},</span> <span class="n">field</span> <span class="bp">'</span><span class="n">left_inv'</span> <span class="n">was</span> <span class="n">not</span> <span class="n">provided</span>
<span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span>
<span class="n">invalid</span> <span class="kd">structure</span> <span class="n">value</span> <span class="o">{</span> <span class="bp">...</span> <span class="o">},</span> <span class="n">field</span> <span class="bp">'</span><span class="n">right_inv'</span> <span class="n">was</span> <span class="n">not</span> <span class="n">provided</span>
</code></pre></div>
<p>so the <code>..</code> is filling in the values of all these fields using the values from <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.refl">docs#equiv.refl</a>.</p>



<a name="247249458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247249458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247249458">(Jul 26 2021 at 19:24)</a>:</h4>
<p>ok, thanks!</p>



<a name="247284319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247284319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247284319">(Jul 27 2021 at 01:41)</a>:</h4>
<p><del>where is <code>map_mul</code> defined?</del></p>



<a name="247284385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247284385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247284385">(Jul 27 2021 at 01:42)</a>:</h4>
<p>tried searching mathlib but couldn't find it</p>



<a name="247284527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247284527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247284527">(Jul 27 2021 at 01:44)</a>:</h4>
<p>nvm, i found it oops</p>



<a name="247424663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247424663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247424663">(Jul 28 2021 at 05:57)</a>:</h4>
<p>in the exercises that were given to me (which are very neat btw), could you explain the </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Z2_rels</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">free_group.of</span> <span class="n">tt</span> <span class="bp">*</span> <span class="n">free_group.of</span> <span class="n">ff</span> <span class="bp">*</span> <span class="o">(</span><span class="n">free_group.of</span> <span class="n">tt</span><span class="o">)</span><span class="bp">⁻¹</span>
<span class="bp">*</span> <span class="o">(</span><span class="n">free_group.of</span> <span class="n">ff</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="o">}</span>
</code></pre></div>
<p>? i think i understand that these are supposed to be relations but i'm confused on what part of it is the relation, e.g. is it saying something like <code>free_group.of tt</code>, <code>free_group.of ff</code>, <code>(free_group.of tt)⁻¹</code>, and <code>(free_group.of ff)⁻¹</code> are elements of the same equivalence class?</p>



<a name="247425557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247425557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247425557">(Jul 28 2021 at 06:15)</a>:</h4>
<p><code>free_group.of</code> is the natural map from a type S to the free group on S</p>



<a name="247446002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247446002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247446002">(Jul 28 2021 at 11:15)</a>:</h4>
<p>Nothing specifically marks this as a relation (there is no specific type for relations in groups that is). Relations are some elements of a (free) group, that are meant to equal one in the group being presented (in the sense of <a href="https://en.wikipedia.org/wiki/Presentation_of_a_group">https://en.wikipedia.org/wiki/Presentation_of_a_group</a>). So this is a set of distinct elements all of which we will want to quotient the free group by. So this is saying we want the product `free_group.of tt * free_group.of ff * (free_group.of tt)⁻¹</p>
<ul>
<li>(free_group.of ff)⁻¹<code> to equal one when we make the quotient, though that happens at a later step. This will be a group where </code>free_group.of tt<code> and </code>free_group.of ff` commute.</li>
</ul>



<a name="247526171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247526171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247526171">(Jul 28 2021 at 22:41)</a>:</h4>
<p>oh i see. so we are saying that <code>free_group.of tt * free_group.of ff * (free_group.of tt)⁻¹ * (free_group.of ff)⁻¹ = free_group.of ff * free_group.of tt * (free_group.of tt)⁻¹ * (free_group.of ff)⁻¹ = 1</code> ?</p>



<a name="247526312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247526312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247526312">(Jul 28 2021 at 22:43)</a>:</h4>
<p>so if we quotient the free group by this set, we are saying it is the smallest normal subgroup of the free group which contains the relation? so the subgroup only contains one element which is the relation itself?</p>



<a name="247526473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247526473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247526473">(Jul 28 2021 at 22:45)</a>:</h4>
<p>or wait, do you mean we are quotienting the free group by each <code>free_group.of</code>term?</p>



<a name="247529449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247529449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247529449">(Jul 28 2021 at 23:24)</a>:</h4>
<p>Yeah you want to quotient by the smallest normal subgroup containing the relation indeed. But i guess that happens at a later step in the code?</p>



<a name="247538985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247538985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247538985">(Jul 29 2021 at 02:39)</a>:</h4>
<p>hm the next part of the code is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">presented_group</span> <span class="n">Z2_rels</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="o">(</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span> <span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>and <code>Z2_rels</code> is not used again. i guess the <code>presented_group Z2_rels</code> part is quotienting the set?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Given a set of relations, rels, over a type `α`, presented_group constructs the group with</span>
<span class="sd">generators `x : α` and relations `rels` as a quotient of free_group `α`.-/</span>
<span class="kd">def</span> <span class="n">presented_group</span> <span class="o">(</span><span class="n">rels</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="n">quotient_group.quotient</span> <span class="bp">$</span> <span class="n">subgroup.normal_closure</span> <span class="n">rels</span>
</code></pre></div>



<a name="247539702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/247539702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#247539702">(Jul 29 2021 at 02:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Group.20theory/near/244987114">said</a>:</p>
<blockquote>
<p>A single application of the reduction relation is represented by the following inductive type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Reduction step: `w * x * x⁻¹ * v ~&gt; w * v` -/</span>
<span class="kd">inductive</span> <span class="n">red.step</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">bnot</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">x</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">red.step</span> <span class="o">(</span><span class="n">L₁</span> <span class="bp">++</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">bnot</span> <span class="n">b</span><span class="o">)</span> <span class="o">::</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">L₁</span> <span class="bp">++</span> <span class="n">L₂</span><span class="o">)</span>
</code></pre></div>
<p>If you squint hard enough, you might see the resemblance.</p>
<p>Then, the free group with generators from the type <code>α</code> is given by the type <code>quot red.step α</code> (this is the definition of <code>free_group</code>).  This creates a quotient type, where terms of  <code>quot red.step α</code> correspond to equivalence classes under the equivalence relation generated by <code>red.step</code>.</p>
</blockquote>
<p>this was from a while ago, but i was wondering if <code>quot red.step α</code> is both a quotient and a free group?</p>



<a name="256063868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/256063868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ayush Agrawal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#256063868">(Oct 04 2021 at 14:02)</a>:</h4>
<p>Hi Guys! I have recently started exploring Lean and group theory at the same time. Can anyone recommend some resource where I can find some simple example proofs related to Group theory. Any advice would be helpful!</p>



<a name="256064027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/256064027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#256064027">(Oct 04 2021 at 14:03)</a>:</h4>
<p>If you scroll up you'll see several other people asking the same question :-)</p>
<p>I ran a workshop on groups and subgroups -- notes are here. <a href="https://xenaproject.wordpress.com/2021/01/28/formalising-mathematics-workshop-2/">https://xenaproject.wordpress.com/2021/01/28/formalising-mathematics-workshop-2/</a> It might make sense to do workshop 1 first though...</p>



<a name="256064324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Group%20theory/near/256064324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ayush Agrawal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Group.20theory.html#256064324">(Oct 04 2021 at 14:05)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I'll go through this thread and thanks for sharing the resource!!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
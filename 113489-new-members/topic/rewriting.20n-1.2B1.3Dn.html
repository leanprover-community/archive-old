---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html">rewriting n-1+1=n</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="287955082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287955082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ritwick Bhargava <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287955082">(Jun 29 2022 at 23:30)</a>:</h4>
<p>Hi everyone, I'm working on some results related to Tits' theorem in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, dealing with reduced words of permutations. If a permutation has type equiv.perm (fin n), then I find it natural for reduced words to have type list (fin (n-1)), but this back and forth from n to n-1 can sometimes get messy. <br>
I've included below an MWE for some problems I've been having chaining results together: for some reason, I just can't use the fact that n-1+1 = n in the proof of mylemma. I've put a sorry on things where only the type is relevant.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">equiv</span>

<span class="kd">def</span> <span class="n">red_wrd</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span><span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">perm_of_list</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="bp">→</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>  <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">l_inv</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">π</span><span class="o">,</span> <span class="n">perm_of_list</span> <span class="n">n</span> <span class="o">(</span><span class="n">red_wrd</span> <span class="n">n</span> <span class="n">π</span><span class="o">)</span> <span class="bp">=</span> <span class="n">π</span><span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">comparing_lists</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)):</span>
 <span class="n">perm_of_list</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">u</span> <span class="bp">=</span><span class="n">perm_of_list</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">u.length</span> <span class="bp">=</span><span class="n">v.length</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">mylemma</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">π</span><span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">h1</span><span class="o">:</span> <span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span><span class="o">:</span> <span class="n">perm_of_list</span> <span class="n">n</span> <span class="n">l</span> <span class="bp">=</span><span class="n">π</span><span class="o">):</span>
  <span class="n">l.length</span> <span class="bp">=</span> <span class="o">(</span><span class="n">red_wrd</span> <span class="n">n</span> <span class="n">π</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">comparing_lists</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">l</span>  <span class="o">(</span><span class="n">red_wrd</span> <span class="n">n</span> <span class="n">π</span><span class="o">),</span>
<span class="c1">--WTS perm_list (n - 1 + 1) l = perm_list (n - 1 + 1) (red_wrd n π), but can't use l_inv or even h2</span>
<span class="c1">--rw h, gives "rewrite tactic failed, motive is not type correct"</span>
<span class="c1">--simp_rw h, gives "simplify tactic failed to simplify"</span>
<span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
<span class="c1">--lemma helper  (n:ℕ)  (h:n-1+1=n) : perm_list n = perm_list (n-1+1) := sorry</span>
<span class="c1">-- lean complains if I try to factor this out as a sublemma</span>
</code></pre></div>
<p>Do you have any comments or suggestions on how to deal with this?</p>



<a name="287955680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287955680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287955680">(Jun 29 2022 at 23:37)</a>:</h4>
<p>Does setting it up like this to avoid the problem work for you?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">equiv</span>

<span class="kd">def</span> <span class="n">red_wrd</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span><span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">perm_of_list</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="bp">→</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>  <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">l_inv</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">π</span><span class="o">,</span> <span class="n">perm_of_list</span> <span class="n">n</span> <span class="o">(</span><span class="n">red_wrd</span> <span class="n">n</span> <span class="n">π</span><span class="o">)</span> <span class="bp">=</span> <span class="n">π</span><span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">comparing_lists</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">))):</span>
 <span class="n">perm_of_list</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="n">u</span> <span class="bp">=</span><span class="n">perm_of_list</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">u.length</span> <span class="bp">=</span><span class="n">v.length</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">mylemma</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">π</span><span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">h1</span><span class="o">:</span> <span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span><span class="o">:</span> <span class="n">perm_of_list</span> <span class="n">n</span> <span class="n">l</span> <span class="bp">=</span><span class="n">π</span><span class="o">):</span>
  <span class="n">l.length</span> <span class="bp">=</span> <span class="o">(</span><span class="n">red_wrd</span> <span class="n">n</span> <span class="n">π</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">comparing_lists</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="n">l</span>  <span class="o">(</span><span class="n">red_wrd</span> <span class="n">n</span> <span class="n">π</span><span class="o">),</span>
<span class="n">rw</span> <span class="n">h2</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">l_inv</span><span class="o">,</span>
<span class="kd">end</span>
<span class="c1">--lemma helper  (n:ℕ)  (h:n-1+1=n) : perm_list n = perm_list (n-1+1) := sorry</span>
<span class="c1">-- lean complains if I try to factor this out as a sublemma</span>
</code></pre></div>



<a name="287955735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287955735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287955735">(Jun 29 2022 at 23:37)</a>:</h4>
<p>Here I just changed the type of <code>comparing_lists</code>, but seeing as I didnt think about the mathematics maybe you need to add a side condition to that</p>



<a name="287956103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287956103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ritwick Bhargava <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287956103">(Jun 29 2022 at 23:41)</a>:</h4>
<p>Yeah, that does work in the MWE, and I have tried just changing the type of the lemmas, but this kind of just shifts the problem around (i.e. if I change the type of one lemma, then something else breaks/ becomes incompatible). I think at some point in the document there needs to be a full circuit n -&gt; n-1 -&gt; n-1+1 =n which is why I was kinda hoping for a solution with the types unchanged (part of the hypothesis in all this is that n&gt;0 so n-1+1 =n is actually true)</p>



<a name="287956352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287956352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287956352">(Jun 29 2022 at 23:44)</a>:</h4>
<p>If you have <code>hn : 0 &lt; n</code> then <code>nat.sub_add_cancel hn : n - 1 + 1 = n</code></p>



<a name="287956428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287956428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287956428">(Jun 29 2022 at 23:45)</a>:</h4>
<p>If you use n+1 and n instead of n and n-1 the problem probably disappear, since n+1-1=n (and obviously n+1=n+1) is defeq.</p>



<a name="287956481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287956481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ritwick Bhargava <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287956481">(Jun 29 2022 at 23:46)</a>:</h4>
<p>Yep, I'm just including (h:n-1+1=n) as the hypothesis to simplify the MWE<br>
<span class="user-mention silent" data-user-id="422543">Stuart Presnell</span> <a href="#narrow/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn/near/287956352">said</a>:</p>
<blockquote>
<p>If you have <code>hn : 0 &lt; n</code> then <code>nat.sub_add_cancel hn : n - 1 + 1 = n</code></p>
</blockquote>



<a name="287956668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287956668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287956668">(Jun 29 2022 at 23:48)</a>:</h4>
<p>One of the reasons you're having trouble is that n-1+1 != n for all n &lt; 1</p>



<a name="287956680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287956680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287956680">(Jun 29 2022 at 23:48)</a>:</h4>
<p>In the way that nat subtraction is defined</p>



<a name="287957368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287957368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ritwick Bhargava <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287957368">(Jun 29 2022 at 23:57)</a>:</h4>
<p>I guess I was just hoping that having the n-1+1=n in the environment would mean that the identification of fin (n-1+1) with fin n would be relatively easy</p>



<a name="287957461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287957461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ritwick Bhargava <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287957461">(Jun 29 2022 at 23:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn/near/287956428">said</a>:</p>
<blockquote>
<p>If you use n+1 and n instead of n and n-1 the problem probably disappear, since n+1-1=n (and obviously n+1=n+1) is defeq.</p>
</blockquote>
<p>This makes sense, I think I'll give this a try - thanks!</p>



<a name="287959644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287959644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287959644">(Jun 30 2022 at 00:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="478603">Ritwick Bhargava</span> <a href="#narrow/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn/near/287957368">said</a>:</p>
<blockquote>
<p>I guess I was just hoping that having the n-1+1=n in the environment would mean that the identification of fin (n-1+1) with fin n would be relatively easy</p>
</blockquote>
<p>In theory, you should be able to just <code>rw h1</code> and it should work, but the <code>rw</code> tactic is not smart enough to handle this situation. Alternatively, you can construct the <code>eq.rec</code> motive manually, but it may be painful.</p>



<a name="287963354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287963354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287963354">(Jun 30 2022 at 01:29)</a>:</h4>
<p>The problem here is that for <code>l : perm (n - 1)</code>, Lean can't deduce that <code>perm_of_list n l</code> is well-typed, since it doesn't know that <code>(n - 1) + 1 = n</code> just by looking at the expression</p>



<a name="287963641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287963641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287963641">(Jun 30 2022 at 01:33)</a>:</h4>
<p>The easiest way out of this is to use types <code>n + 1</code> and <code>n</code> instead of <code>n</code> and <code>n - 1</code>. Since <code>(n + 1) - 1 = n</code> is a definitional equality, you won't have these sorts of type problems</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">equiv</span>

<span class="kd">def</span> <span class="n">red_wrd</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">perm_of_list</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">l_inv</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">π</span><span class="o">,</span> <span class="n">perm_of_list</span> <span class="n">n</span> <span class="o">(</span><span class="n">red_wrd</span> <span class="n">n</span> <span class="n">π</span><span class="o">)</span> <span class="bp">=</span> <span class="n">π</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">comparing_lists</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">perm_of_list</span> <span class="n">n</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">perm_of_list</span> <span class="n">n</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">u.length</span> <span class="bp">=</span> <span class="n">v.length</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">mylemma</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">perm_of_list</span> <span class="n">n</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l.length</span> <span class="bp">=</span> <span class="o">(</span><span class="n">red_wrd</span> <span class="n">n</span> <span class="n">π</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">comparing_lists</span> <span class="n">n</span> <span class="n">l</span> <span class="o">(</span><span class="n">red_wrd</span> <span class="n">n</span> <span class="n">π</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">l_inv</span><span class="o">,</span> <span class="n">h2</span><span class="o">]</span>
<span class="kd">end</span>
</code></pre></div>



<a name="287963862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287963862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287963862">(Jun 30 2022 at 01:37)</a>:</h4>
<p>If you insist on your current approach, you'll have to get comfortable with heterogeneous equality.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">equiv</span>

<span class="kd">def</span> <span class="n">red_wrd</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">perm_of_list</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">→</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">l_inv</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">π</span><span class="o">,</span> <span class="n">perm_of_list</span> <span class="n">n</span> <span class="o">(</span><span class="n">red_wrd</span> <span class="n">n</span> <span class="n">π</span><span class="o">)</span> <span class="bp">=</span> <span class="n">π</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">comparing_lists</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)):</span>
  <span class="n">perm_of_list</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">perm_of_list</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">u.length</span> <span class="bp">=</span> <span class="n">v.length</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">mylemma</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">perm_of_list</span> <span class="n">n</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">:</span> <span class="n">l.length</span> <span class="bp">=</span> <span class="o">(</span><span class="n">red_wrd</span> <span class="n">n</span> <span class="n">π</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">comparing_lists</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">l</span> <span class="o">(</span><span class="n">red_wrd</span> <span class="n">n</span> <span class="n">π</span><span class="o">),</span>
  <span class="n">convert</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">heq_of_eq</span> <span class="o">(</span><span class="n">l_inv</span> <span class="n">n</span> <span class="n">π</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="287964040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287964040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287964040">(Jun 30 2022 at 01:40)</a>:</h4>
<p>The <code>convert</code> tactic makes its best effort to convert one proof into another by matching what it thinks are corresponding terms. It's able to use proofs from the context, which is why you don't have to explicitly call <code>h1</code></p>



<a name="287965239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287965239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ritwick Bhargava <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287965239">(Jun 30 2022 at 02:03)</a>:</h4>
<p>Thanks a lot for the detailed answer! I guess using <code>n+1</code> instead of  <code>n</code> is the simplest solution even though I prefer the latter for aesthetic reasons.</p>



<a name="287965299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287965299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ritwick Bhargava <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287965299">(Jun 30 2022 at 02:04)</a>:</h4>
<p>What exactly is heterogeneous equality, and is there a reason to avoid it?</p>



<a name="287966712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287966712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287966712">(Jun 30 2022 at 02:31)</a>:</h4>
<p><code>n - 1</code> just isn't nearly as well behaved as <code>n + 1</code>. In fact, <code>succ n = n + 1</code> is a constructor for the naturals, you can't get much better behaved than that.</p>



<a name="287966765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287966765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ma, Jia-Jun <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287966765">(Jun 30 2022 at 02:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="478603">Ritwick Bhargava</span> <a href="#narrow/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn/near/287965239">said</a>:</p>
<blockquote>
<p>Thanks a lot for the detailed answer! I guess using <code>n+1</code> instead of  <code>n</code> is the simplest solution even though I prefer the latter for aesthetic reasons.</p>
</blockquote>
<p>I encounter a similar problem when dealing with <code>S_n</code>.</p>



<a name="287966770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287966770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287966770">(Jun 30 2022 at 02:32)</a>:</h4>
<p>Heterogeneous equality is equality between terms of types Lean can't necessarily prove equal definitionally. If you're using it, as a rule of thumb, something is going wrong.</p>



<a name="287967021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287967021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287967021">(Jun 30 2022 at 02:38)</a>:</h4>
<p>Another way would be to use <a href="https://leanprover-community.github.io/mathlib_docs/find/fin_congr">docs#fin_congr</a> to turn equality into bijection.</p>



<a name="287994195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rewriting%20n-1%2B1%3Dn/near/287994195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewriting.20n-1.2B1.3Dn.html#287994195">(Jun 30 2022 at 08:47)</a>:</h4>
<p>I had no idea <code>fin_congr h</code> existed, I've been using <code>(fin.cast h).to_equiv</code> everywhere</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
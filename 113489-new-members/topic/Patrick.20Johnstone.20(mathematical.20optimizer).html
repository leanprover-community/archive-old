---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html">Patrick Johnstone (mathematical optimizer)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="253962527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253962527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253962527">(Sep 19 2021 at 18:26)</a>:</h4>
<p>Greetings! I am brand new to Lean, I just completed the natural number game, great fun. I am totally on-board with this general project though, I think it's great.</p>
<p>I am a researcher in the general field of mathematical optimization. I prove theorems about algorithms like gradient descent. As far as I know, <em>almost no one</em> in the math programming community is using Lean. Am I wrong? Does anyone know of formalizations of, for example, the proof that gradient descent converges to a minimizer of a smooth convex function? Or that the convergence rate is 1/k... </p>
<p>I feel this is completely open territory... The proofs in math optimization are very algebra heavy and ripe for automation. Yet I don't see anyone doing it. Perhaps there are reasons. Perhaps no one could be bothered yet. Or there were no tools like Lean...</p>
<p>Anyway, if anyone knows of work in Lean related to proving convergence properties of optimization algorithms like gradient descent, Newton's method etc. let me know.</p>
<p>Thanks,</p>



<a name="253962656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253962656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253962656">(Sep 19 2021 at 18:28)</a>:</h4>
<p>To put your "as far as I know" into some kind of context, almost no-one in any mathematical community is using any theorem prover at all.</p>



<a name="253962680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253962680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253962680">(Sep 19 2021 at 18:29)</a>:</h4>
<p>One thing I discovered very early on is that you can just do stuff which is regarded as totally basic in your field, but do it in a theorem prover, and then get a publication :D (because nobody did anything like it before)</p>



<a name="253962793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253962793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253962793">(Sep 19 2021 at 18:31)</a>:</h4>
<p>Hey! <span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span>, <span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span>, <span class="user-mention silent" data-user-id="240862">Oliver Nash</span>, <span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span>  and myself (at least! hope I didn't forget anyone) are working on and around convex analysis. I don't know about convex optimization specifically.</p>



<a name="253963158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253963158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253963158">(Sep 19 2021 at 18:37)</a>:</h4>
<p><span class="user-mention" data-user-id="441939">@Patrick Johnstone</span> There is <a href="https://github.com/dselsam/certigrad">https://github.com/dselsam/certigrad</a> by <span class="user-mention" data-user-id="230999">@Daniel Selsam</span> .</p>



<a name="253963192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253963192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253963192">(Sep 19 2021 at 18:38)</a>:</h4>
<p>There is a youtube talk about this as well, by Daniel</p>



<a name="253963618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253963618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253963618">(Sep 19 2021 at 18:44)</a>:</h4>
<p>Thank you! This is definitely along the lines of what I'm interested in. Although I don't think they proved convergence of the optimization algorithm, but they do prove the method produces the right stochastic gradients, which is neat.</p>



<a name="253966038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253966038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253966038">(Sep 19 2021 at 19:26)</a>:</h4>
<p>That's good to know. Would these be publications in journals related to formal verification? Or in the field of the work itself. Because I don't know how optimization people would react to theorem provers, they might not be welcoming.</p>



<a name="253966102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253966102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253966102">(Sep 19 2021 at 19:26)</a>:</h4>
<p>Right, journals related to formal verification (if you are pushing these systems to do things they've never done before)</p>



<a name="253966133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253966133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253966133">(Sep 19 2021 at 19:27)</a>:</h4>
<p>Journals and conference proceedings (which is a standard venue for publication in computer science).</p>



<a name="253975648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253975648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253975648">(Sep 19 2021 at 22:16)</a>:</h4>
<p><span class="user-mention" data-user-id="129120">@Alexander Bentkamp</span> and I have begun to explore another way of using proof assistants to solve optimization problems: <a href="http://www.andrew.cmu.edu/user/avigad/Papers/verified_optimization_wip_paper.pdf">http://www.andrew.cmu.edu/user/avigad/Papers/verified_optimization_wip_paper.pdf</a>. We argue that applied mathematics is a natural market for formal methods. They allow you to specify complex models more precisely and use symbolic and numeric software more rigorously.</p>



<a name="253987313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253987313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253987313">(Sep 20 2021 at 01:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110865">Jeremy Avigad</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/253975648">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="129120">Alexander Bentkamp</span> and I have begun to explore another way of using proof assistants to solve optimization problems: <a href="http://www.andrew.cmu.edu/user/avigad/Papers/verified_optimization_wip_paper.pdf">http://www.andrew.cmu.edu/user/avigad/Papers/verified_optimization_wip_paper.pdf</a>. We argue that applied mathematics is a natural market for formal methods. They allow you to specify complex models more precisely and use symbolic and numeric software more rigorously.</p>
</blockquote>
<p>Great, thanks. Do you have a github for this project yet? </p>
<p>My interest is more in convergence proofs for optimization algorithms -  since that's what my research focuses on. But it's definitely related to what you are working on.</p>



<a name="253987383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/253987383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#253987383">(Sep 20 2021 at 01:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/253962793">said</a>:</p>
<blockquote>
<p>Hey! <span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span>, <span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span>, <span class="user-mention silent" data-user-id="240862">Oliver Nash</span>, <span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span>  and myself (at least! hope I didn't forget anyone) are working on and around convex analysis. I don't know about convex optimization specifically.</p>
</blockquote>
<p>Great, I don't think you can do much convex optimization without at least some basic convex analysis.</p>



<a name="254008991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/254008991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#254008991">(Sep 20 2021 at 07:37)</a>:</h4>
<p>I think it's a great time for this sort of stuff to be formalised. When we transition to Lean 4 ("soon"), it will be possible to write algorithms that run fast, and prove theorems about them, in the same language.</p>
<p>(That said, algorithms that involve manipulating real numbers are hard to formalise naively, because floats are horrible.)</p>



<a name="254142154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/254142154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#254142154">(Sep 21 2021 at 01:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/254008991">said</a>:</p>
<blockquote>
<p>I think it's a great time for this sort of stuff to be formalised. When we transition to Lean 4 ("soon"), it will be possible to write algorithms that run fast, and prove theorems about them, in the same language.</p>
<p>(That said, algorithms that involve manipulating real numbers are hard to formalise naively, because floats are horrible.)</p>
</blockquote>
<p>I hadn't thought about the floating point issue before. In optimization we simply prove theorems about infinite precision algorithms. Normally not a care in the world goes into the fact that we actually implement them with floats. </p>
<p>When you say floats are horrible, has anyone tried to formalize floats in lean? Like have a float datatype and prove stuff about them?</p>



<a name="254145944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/254145944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#254145944">(Sep 21 2021 at 02:10)</a>:</h4>
<p>mathlib is fine for proving theorems about infinite precision algorithms --- of course they can't be run, so my point about Lean4 being fast is irrelevant.</p>
<p>I'm not an expert on the float datatype. My understanding is that there are astonishingly few true theorems about it. :-)</p>



<a name="254147207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/254147207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#254147207">(Sep 21 2021 at 02:29)</a>:</h4>
<p>There is <a href="https://leanprover-community.github.io/mathlib_docs/data/fp/basic.html">docs#data.fp.basic</a></p>



<a name="254147300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/254147300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#254147300">(Sep 21 2021 at 02:30)</a>:</h4>
<p>which hasn't been touched in years</p>



<a name="254147381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/254147381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#254147381">(Sep 21 2021 at 02:31)</a>:</h4>
<p>there are even a few low hanging fruits in that file requiring a proof (they were postponed because the proofs weren't the focus); all the <code>meta def</code>s are only <code>meta</code> because they use <code>undefined</code> instead of <code>sorry</code></p>



<a name="254160548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/254160548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#254160548">(Sep 21 2021 at 06:19)</a>:</h4>
<p>So basically we can prove that your algorithms work in theory, but not in practice :-)</p>



<a name="254299127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/254299127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#254299127">(Sep 22 2021 at 00:38)</a>:</h4>
<p>I don't think the finite precision issue is a deal-breaker. I had a look today and there are a few optimization papers on the effects of finite precision, but mostly this is not studied. Probably there is just a lot of accumulated wisdom and empirical experience that round off errors tend to be benign for optimization algorithms, so it's not attractive to study theoretically.</p>



<a name="254615472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/254615472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#254615472">(Sep 23 2021 at 22:26)</a>:</h4>
<p>And when you do have true theorems about floats, there's still lots of room for bugs to creep in in the gap between what the true theorems actually say and what you need for the real algorithm implementation in some programming language.</p>
<p>There are lots of new floating-point functions in the next (2023) version of the C standard, many of which I've been implementing for glibc. For some of those functions, it's convenient to use a standard floating-point technique (round-to-odd), the correctness of which is the subject of a true theorem (formalized in Coq some years ago). Despite the functions being simple and the implementation technique being formally verified, I've found quite a few bugs in the implementations that  come in some way from that gap between the theorem and the implementation (sometimes in parts of the gap that might be a lot harder to formalize than floating point itself) - including bugs that survived in some functions for a few years between when I originally implemented them and when I recently discovered them accidentally while implementing more such functions.</p>



<a name="266478407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266478407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266478407">(Dec 31 2021 at 03:32)</a>:</h4>
<p>Hi all,<br>
I have been tinkering with Lean in my spare time for the last few months. </p>
<p>I wanted to clarify some things I've gathered in my reading: if I define a function from \R\to\R, Lean cannot #eval it, correct? </p>
<p>Like, even for "computable" functions like f(x)=2*x or f(x)=x+5 or f(x)=sin(x). These are "computable" according to certain definitions of Turing machines over the reals. I understand that a real number has potentially infinitely many digits, so computable here means informally "can compute an arbitrary number of digits".</p>
<p>So if I write <br>
#eval (λ x:ℝ,x) 14</p>
<p>then I am doomed to get gibberish. </p>
<p>And further, there is no way to "force" lean to just use floating point representations? I see that there is a native.float type, so one could potentially just define a flag and switch everything over to native.float if one wants to do any computation...</p>
<p>I assume the certigrad code has a way around this, because they prove stuff about their code assuming infinite precision reals but then allow computation using an external linear algebra package. I had a brief look through the code but couldn't fully understand it. I think they somehow defines their own "real numbers" and lists a bunch of axioms it must satisfy.  </p>
<p>Thanks for your help in advance...</p>



<a name="266485443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266485443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266485443">(Dec 31 2021 at 06:37)</a>:</h4>
<p>Yup, currently in Lean 3 you can not compute with <code>ℝ</code> directly. If you want to compute, you need to use tactics that do the computation for you.</p>



<a name="266506454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266506454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266506454">(Dec 31 2021 at 14:31)</a>:</h4>
<p>In fact, you can do a bit of computations with reals if you're lucky and the functions happen to be computable according to Lean, but mathlib has not been designed to keep computable real functions computable.</p>



<a name="266506513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266506513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266506513">(Dec 31 2021 at 14:33)</a>:</h4>
<p>The gibberish that you're getting is because <a href="https://leanprover-community.github.io/mathlib_docs/find/real">docs#real</a> is defined as some quotient of cauchy sequences, so you're seeing the <code>λ</code> term defining the sequence</p>



<a name="266506688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266506688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266506688">(Dec 31 2021 at 14:37)</a>:</h4>
<p>You can define a custom <a href="https://leanprover-community.github.io/mathlib_docs/find/has_repr">docs#has_repr</a> instance to convert it to a readable string:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_repr</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">repr</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x.cauchy.lift</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">cau_seq</span> <span class="n">ℚ</span> <span class="n">abs</span><span class="o">),</span> <span class="n">repr</span> <span class="o">(</span><span class="n">xs.1</span> <span class="mi">100</span><span class="o">))</span>
  <span class="gr">sorry</span> <span class="c">/-</span><span class="cm"> this is actually not true (since `0.9999...` and `1.000...` should have the same `repr` but don't if we don't round the value above -/</span> <span class="o">}</span>

<span class="k">#eval</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="c1">-- 2</span>
</code></pre></div>



<a name="266507417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266507417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266507417">(Dec 31 2021 at 14:52)</a>:</h4>
<p>Just don't try <code>#eval (1/2 + 1/2 : ℝ) </code>.</p>
<p>Think about it in general: in Lean we defined pi to be twice the smallest positive real root of the cosine function. Then pi is an uncomputable but well-defined real number (we proved cos(0)=1, cos(2)&lt;0 and that cos was continuous). What can <code>#eval</code> do with this? We proved a lot of theorems about pi such as sin(n*pi)=0 etc but it was quite a long time before we proved pi&gt;3; this was not necessary for any trig computations. We did happen to know that cos(1)&gt;0 and that cos was decreasing on [0,2] so it wasn't too hard to deduce from this that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>&lt;</mo><mi>π</mi><mo>&lt;</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2&lt;\pi&lt;4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> but that was all we had for quite some time (even though we had a bunch of theorems about trig functions and pi)</p>



<a name="266508309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266508309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266508309">(Dec 31 2021 at 15:09)</a>:</h4>
<p>Is Lean 4 different?</p>



<a name="266508828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266508828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266508828">(Dec 31 2021 at 15:18)</a>:</h4>
<p>Not in this regard!</p>



<a name="266508958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266508958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266508958">(Dec 31 2021 at 15:21)</a>:</h4>
<p>Real numbers are not floats. You have to think about them in a totally different way. They are the uncountable type which mathematicians use. Mathematicians can prove theorems about real numbers without ever having some kind of algorithm which can be used to write down an expression which attempts to represent, or approximate, the real number. I'm assuming you're expecting an answer in base 10. But this is a purely human construct. Real numbers are abstract objects in Lean. Floats are totally different. There are only finitely many and they do not satisfy the axioms of e.g. an abelian group; they are a highly imperfect representation of the reals. Mathematicians do not need that representation to prove theorems about or involving real numbers.</p>



<a name="266511181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266511181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266511181">(Dec 31 2021 at 16:05)</a>:</h4>
<p>A (maybe simpler) example are the natural numbers, which usually have an inductive definition in formal systems (being zero or the successor of a natural number). This definition is sufficient to prove results about natural numbers, but it's not the best representation for actually performing operations on the natural numbers.</p>
<p>For the later purpose, a low level byte array would be more suitable for the CPU. Hence the difference between, say, <code>UInt32</code> and <code>Nat</code> in Lean 4. And again, a mathematical limitation that's similar to the one that Kevin pointed out arises. <code>UInt32</code> can't represent infinite numbers and may overflow. You can think of <code>Float</code> and <code>UInt32</code> as computational tricks for mimicking mathematical objects like the real and natural numbers respectively.</p>



<a name="266511634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266511634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266511634">(Dec 31 2021 at 16:15)</a>:</h4>
<p>Thanks. Makes sense. So I suppose there is little support for "floating point extraction"? I.e: define an algorithm/function in Lean for the Reals, prove stuff about it, then extract a floating point approximation in another language or in Lean itself.</p>



<a name="266511724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266511724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266511724">(Dec 31 2021 at 16:17)</a>:</h4>
<p>There's nothing like that in Lean 3 or 4 but I'm sure other people would be interested. For computational real numbers I should think you'd be much better off with Coq right now.</p>



<a name="266512071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266512071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266512071">(Dec 31 2021 at 16:24)</a>:</h4>
<p>On that direction, Lean 4 supports accessing low level (C) implementations via FFI. For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[extern "c_sqrt_sqrt"]</span> <span class="kd">def</span> <span class="n">sqrtSqrt</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="o">:</span> <span class="n">Float</span> <span class="o">:=</span>
  <span class="n">Float.sqrt</span> <span class="o">(</span><span class="n">Float.sqrt</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>You would be able to reason and prove results about <code>sqrtSqrt</code> in Lean, but executing <code>sqrtSqrt</code> would trigger a computation on a function called <code>c_sqrt_sqrt</code> that you would need to provide C code for (and call it that way). The responsibility for the consistency of the result, however, would be totally on the author of the C implementation.</p>



<a name="266512412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266512412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266512412">(Dec 31 2021 at 16:30)</a>:</h4>
<p>Then if you wanted to write functions on <code>ℝ^n → Float</code>, you would need to unwrap (the term adopted by the FFI is actually "unbox") the real number representation in C, extract a <code>double</code> from it, perform the computations and return the result</p>



<a name="266563202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266563202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266563202">(Jan 01 2022 at 15:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="441939">Patrick Johnstone</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266511634">said</a>:</p>
<blockquote>
<p>Thanks. Makes sense. So I suppose there is little support for "floating point extraction"? I.e: define an algorithm/function in Lean for the Reals, prove stuff about it, then extract a floating point approximation in another language or in Lean itself.</p>
</blockquote>
<p>What I'm currently doing is to define reals as <code>def Real := Float</code> and just postulate that <code>Real</code> form a field. This way you keep the computability(executing with floats) and still be able to do proofs about <code>Real</code>. </p>
<p>Doing this can maybe(I do not know) introduce inconsistency i.e. ability to prove <code>False</code>. However, I was unable to do so as everything about <code>Float</code> is hidden behind <code>constant</code>.</p>



<a name="266563526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266563526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266563526">(Jan 01 2022 at 16:04)</a>:</h4>
<p>I'd guess that rounding and loss of significance/cancellation make this approach inconsistent somehow</p>



<a name="266563786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266563786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266563786">(Jan 01 2022 at 16:11)</a>:</h4>
<p>But are you actually able to prove <code>False</code>? I don't think so. Of course, the program might not be doing what you have proven it is supposed to be doing because of the rounding errors.</p>



<a name="266563901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266563901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266563901">(Jan 01 2022 at 16:14)</a>:</h4>
<p>You are proving only computations on some hypothetical machine capable of computing with reals. If you can prove, in addition, that your program is a continuous function, then you have a proof that the program is doing the correct thing in the limit of infinite precision.</p>



<a name="266564069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266564069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266564069">(Jan 01 2022 at 16:19)</a>:</h4>
<p>I would guess that due to cancellation one might be able to proof that two things that are not actually equally are equal due to the field axioms? But I'm unsure whether the framework around floats allows for that.</p>



<a name="266564137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266564137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266564137">(Jan 01 2022 at 16:21)</a>:</h4>
<p>Can you prove that <code>1.0 + 0.1 = 1.1</code>? I do not know how.</p>
<p>What about this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Float</span> <span class="o">:=</span> <span class="mi">1</span><span class="bp">.</span><span class="mi">0000000000000000000000</span>
<span class="kd">def</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Float</span> <span class="o">:=</span> <span class="mi">0</span><span class="bp">.</span><span class="mi">00000000000000000000001</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="bp">.</span><span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span>   <span class="c1">-- If you can prove this then using `Real := Float` is bad</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>   <span class="o">:=</span> <span class="gr">sorry</span>   <span class="c1">-- You can prove this using `Real := Float`</span>
</code></pre></div>



<a name="266564142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266564142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266564142">(Jan 01 2022 at 16:21)</a>:</h4>
<p>Yeah that's exactly what I don't know either :/</p>



<a name="266564290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266564290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266564290">(Jan 01 2022 at 16:25)</a>:</h4>
<p>What about trying to prove that <code>y^2=0</code>?  Is that any easier?</p>



<a name="266564398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266564398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266564398">(Jan 01 2022 at 16:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266564290">said</a>:</p>
<blockquote>
<p>What about trying to prove that <code>y^2=0</code>?  Is that any easier?</p>
</blockquote>
<p>I do not think so, exponentiation on floats is defined as: (in Lean 4, probably similarly in Lean 3 too)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[extern "pow"]</span> <span class="kd">constant</span> <span class="n">Float.pow</span> <span class="o">:</span> <span class="n">Float</span> <span class="bp">→</span> <span class="n">Float</span> <span class="bp">→</span> <span class="n">Float</span>
</code></pre></div>
<p>i.e. with constant so you are not able to prove anything about it. You just know some kind of function like that exists.</p>



<a name="266564561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266564561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266564561">(Jan 01 2022 at 16:33)</a>:</h4>
<p>I suspect that operations involving floats are ultimately hidden behind the FFI. It's not like you can get to the bottom of things in terms of Lean declarations</p>



<a name="266564732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266564732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266564732">(Jan 01 2022 at 16:38)</a>:</h4>
<p>Yes exactly, so the interesting question is: If you postulate that <code>Float</code> form a field, can you prove <code>False</code>?</p>



<a name="266564856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266564856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266564856">(Jan 01 2022 at 16:41)</a>:</h4>
<p>I don't think so. The problem is that you wouldn't account for floating point errors, which would most certainly break your consistency in practice</p>



<a name="266564924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266564924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266564924">(Jan 01 2022 at 16:43)</a>:</h4>
<p>If you can't, then I would argue that postulating <code>Float</code> as a field(maybe additionally Archimedean property and completenes to really get reals) is a viable option how to approach computations with reals.</p>
<p>To actually prove that your program is doing what you have proven in the limit of infinite precision. You would have to, for example, show that your program is continuous. Even better, if you prove your program to be Lipshitz, then you can have some meaningful bound on the error.</p>



<a name="266564925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266564925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266564925">(Jan 01 2022 at 16:43)</a>:</h4>
<p>Not a serious trouble if you're satisfied with C's <code>double</code> precision</p>



<a name="266564990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266564990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266564990">(Jan 01 2022 at 16:45)</a>:</h4>
<p>Yeah, the approach I see as most complete is offering some guarantee of error boundary</p>



<a name="266565058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565058">(Jan 01 2022 at 16:47)</a>:</h4>
<p>So you'd formally account for imprecisions</p>



<a name="266565164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565164">(Jan 01 2022 at 16:50)</a>:</h4>
<p>But not having this guarantee wouldn't stop me from using your package if needed :D</p>



<a name="266565198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565198">(Jan 01 2022 at 16:51)</a>:</h4>
<p>I would assume you cannot prove everything about reals just because you postulate that <code>Float</code> is a field and treating it like reals though right?</p>



<a name="266565275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565275">(Jan 01 2022 at 16:53)</a>:</h4>
<p>So the interesting question to me would be, what additional things would you need to actually treat <code>Float</code> like a real.</p>



<a name="266565337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565337">(Jan 01 2022 at 16:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266565198">said</a>:</p>
<blockquote>
<p>I would assume you cannot prove everything about reals just because you postulate that <code>Float</code> is a field and treating it like reals though right?</p>
</blockquote>
<p>Well you need these <a href="https://en.wikipedia.org/wiki/Construction_of_the_real_numbers#Axioms">axioms</a>, i.e. field + total order + compatibility of order and arithmetic + completeness.</p>



<a name="266565474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565474">(Jan 01 2022 at 16:58)</a>:</h4>
<p>Floats satisfy very few of these axioms though, or am I misunderstanding this conversation?</p>



<a name="266565476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565476">(Jan 01 2022 at 16:58)</a>:</h4>
<p>This requires one additional data: <code>sup</code> of a bounded sets. Everything else should be in <code>Prop</code>.</p>



<a name="266565592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565592">(Jan 01 2022 at 17:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="221921">Marc Huisinga</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266565474">said</a>:</p>
<blockquote>
<p>Floats satisfy very few of these axioms though, or am I misunderstanding this conversation?</p>
</blockquote>
<p>Floats don't even qualify as a field if you view at the actual values they produce, however (at least in Lean 4) float operations are (this is an hypothesis of us) exposed in a way that doesn't allow you to actually reason about them to the point where you could show that the assumption that float is a field is inconsistent. This would in theory allow value extraction from computation on reals by just treating Float like reals.</p>



<a name="266565634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565634">(Jan 01 2022 at 17:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="221921">Marc Huisinga</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266565474">said</a>:</p>
<blockquote>
<p>Floats satisfy very few of these axioms though, or am I misunderstanding this conversation?</p>
</blockquote>
<p>Yes they don't, but the question is: can you prove <code>False</code> if you postulate these axioms about floats? If not, you can treat <code>Float</code> as reals and keep your programs runnable.</p>



<a name="266565718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565718">(Jan 01 2022 at 17:03)</a>:</h4>
<p>So basically instead of the current mathlib approach to reals we would have a typeclass <code>Real</code> that is a combination of these 4 structures and then just <code>instance : Real Float := sorry</code>(well not exactly sorry, we would have to put the operations there and sorry the laws out), which should allow real functions to just be used with float input right?</p>



<a name="266565808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565808">(Jan 01 2022 at 17:05)</a>:</h4>
<p>Addition on float is provably not associative so if you assume it is then surely you can prove false</p>



<a name="266565855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565855">(Jan 01 2022 at 17:06)</a>:</h4>
<p>We are aware of that, but the way that it is exposed in Lean 4 is as a <code>constant</code> so you cannot actually prove anything about addition on floats.</p>



<a name="266565870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565870">(Jan 01 2022 at 17:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266565718">said</a>:</p>
<blockquote>
<p>So basically instead of the current mathlib approach to reals we would have a typeclass <code>Real</code> that is a combination of these 4 structures and then just <code>instance : Real Float := sorry</code>(well not exactly sorry, we would have to put the operations there and sorry the laws out), which should allow real functions to just be used with float input right?</p>
</blockquote>
<p>Hmm, in my current code I just do <code>def Real := Float</code> and then provide <code>instance : Add Real := Float.add</code> etc. and postulate <code>instance : Field Real := { ... := sorry }</code>(I make sure that I sorry only Prop)</p>



<a name="266565924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565924">(Jan 01 2022 at 17:08)</a>:</h4>
<p>Are you saying you can't prove e.g. <code>0 ≠ 1</code> in <code>float</code>?</p>



<a name="266565938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565938">(Jan 01 2022 at 17:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266565924">said</a>:</p>
<blockquote>
<p>Are you saying you can't prove e.g. <code>0 ≠ 1</code> in <code>float</code>?</p>
</blockquote>
<p>At least, I do not know how.</p>



<a name="266565946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565946">(Jan 01 2022 at 17:09)</a>:</h4>
<p>That I don't know, but I'm saying you cannot prove: <code>1 + 0 = 1</code> or <code>1 * 1 = 1</code> in float due to the way the API is built.</p>



<a name="266565953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266565953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266565953">(Jan 01 2022 at 17:09)</a>:</h4>
<p>It seems a lot easier to me to just make your algorithms polymorphic on the underlying type, assuming <code>HasAdd</code> <code>HasMul</code> etc on that type, show that they are correct for a mathematical definition of the reals, and then run them for Float? Am I missing something?</p>



<a name="266566005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266566005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266566005">(Jan 01 2022 at 17:10)</a>:</h4>
<p>Does <code>float</code> not have decidable equality?</p>



<a name="266566012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266566012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266566012">(Jan 01 2022 at 17:10)</a>:</h4>
<p>Lean 4 says it doesn't, I'd have to check for lean 3</p>



<a name="266566089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266566089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266566089">(Jan 01 2022 at 17:12)</a>:</h4>
<p>I just tried <code>example : (0.0 : Float) ≠ (1.0 : Float) := by simp [OfScientific.ofScientific, Float.ofBinaryScientific]</code> in Lean 4 and it broke my server <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="266566106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266566106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266566106">(Jan 01 2022 at 17:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266565808">said</a>:</p>
<blockquote>
<p>Addition on float is provably not associative so if you assume it is then surely you can prove false</p>
</blockquote>
<p>The thing is that all Float operations in Lean 4 are constants, so you know nothing about them except that the type is inhabited. You can use them to evaluate stuff, but for the purpose of proof, they're just as good as arbitrary types. So postulating that they have certain structure should be fine (as long as what you postulated isn't inconsistent itself).<br>
That said, I'm not sure if this approach is super practical. My intuition is that things with floats can go wrong badly, even if your proof over reals says that things are fine.<br>
If I wanted to build a model of floats that's practical for proofs, I'd probably go for something like <a href="http://smtlib.cs.uiowa.edu/papers/BTRW15.pdf">http://smtlib.cs.uiowa.edu/papers/BTRW15.pdf</a>, and not try to model them as bit vectors.</p>



<a name="266566109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266566109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266566109">(Jan 01 2022 at 17:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266565953">said</a>:</p>
<blockquote>
<p>It seems a lot easier to me to just make your algorithms polymorphic on the underlying type, assuming <code>HasAdd</code> <code>HasMul</code> etc on that type, show that they are correct for a mathematical definition of the reals, and then run them for Float? Am I missing something?</p>
</blockquote>
<p>Yes but what if I wanted to e.g. reason about the derivative of my function? Surely one would want to use the mathlib tools that are available for this right? But this is not possible with these type class constraints. If we instead made <code>Real</code> itself a typeclass and provide an instance for <code>Float</code> where the axioms are sorried out (which is hopefully valid, we don't know this for sure) and mathlib would switch to this approach on reals one should be able to reason about the derivative of a function of the form: <code>(R : Type) [Real R] : R -&gt; R</code> using mathlib tools AND compute it using floats.</p>



<a name="266566174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266566174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266566174">(Jan 01 2022 at 17:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266565953">said</a>:</p>
<blockquote>
<p>It seems a lot easier to me to just make your algorithms polymorphic on the underlying type, assuming <code>HasAdd</code> <code>HasMul</code> etc on that type, show that they are correct for a mathematical definition of the reals, and then run them for Float? Am I missing something?</p>
</blockquote>
<p>If you really want to run the algorithm, you might not trust the specializer enough or you might want to do things that don't generalize (e.g. using unboxed arrays of <code>Float</code>).</p>



<a name="266566386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266566386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266566386">(Jan 01 2022 at 17:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266566012">said</a>:</p>
<blockquote>
<p>Lean 4 says it doesn't, I'd have to check for lean 3</p>
</blockquote>
<p>In lean 4 there is <code>floatDecLe</code> for decidable le though, so you could give a decidable equality check assuming the le relation was irreflexive</p>



<a name="266566557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266566557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266566557">(Jan 01 2022 at 17:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266566089">said</a>:</p>
<blockquote>
<p>I just tried <code>example : (0.0 : Float) ≠ (1.0 : Float) := by simp [OfScientific.ofScientific, Float.ofBinaryScientific]</code> in Lean 4 and it broke my server <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>
</blockquote>
<p>I don't know why it broke the server, but <code>ofScientific</code> and the like also use constants, such as <code>scaleB</code>. The same should be true for equality; see <a href="https://github.com/leanprover/lean4/blob/b65da42b7ec7cf25e97a111a48f0a662a27fe02a/src/Init/Data/Float.lean#L30">this</a> (the type used for Floats, here Unit, is hidden behind a constant), so I think you can do nothing with Float equality at the proof level either.</p>



<a name="266566688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266566688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266566688">(Jan 01 2022 at 17:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="221921">Marc Huisinga</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266566106">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266565808">said</a>:</p>
<blockquote>
<p>Addition on float is provably not associative so if you assume it is then surely you can prove false</p>
</blockquote>
<p>The thing is that all Float operations in Lean 4 are constants, so you know nothing about them except that the type is inhabited. You can use them to evaluate stuff, but for the purpose of proof, they're just as good as arbitrary types. So postulating that they have certain structure should be fine (as long as what you postulated isn't inconsistent itself).<br>
That said, I'm not sure if this approach is super practical. My intuition is that things with floats can go wrong badly, even if your proof over reals says that things are fine.<br>
If I wanted to build a model of floats that's practical for proofs, I'd probably go for something like <a href="http://smtlib.cs.uiowa.edu/papers/BTRW15.pdf">http://smtlib.cs.uiowa.edu/papers/BTRW15.pdf</a>, and not try to model them as bit vectors.</p>
</blockquote>
<p>Let me be a bit adversarial here :) All these approaches(those I have seen) to model errors of floating point arithmetic in my opinion/for what I want to do  are really unsatisfactory. They usually deal with simple arithmetic expression involving handful of variables. I want do to numerical linear algebra and have some proper bounds on the error.</p>
<p>I want to see some framework that can give me some proper bounds on floating point arithmetic in Conjugate Gradient(CG) method or GMRES. (I took a full semester course on studying floating point errors in Conjugate Gradient method. It was super tough and we didn't even dare to analyze GMRES)</p>
<p>Until someone provides me such a framework, I will just not bother proving anything about floating point arithmetic and just follow best practices to hopefully dodge any/most problems with it.</p>



<a name="266566763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266566763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266566763">(Jan 01 2022 at 17:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266566174">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266565953">said</a>:</p>
<blockquote>
<p>It seems a lot easier to me to just make your algorithms polymorphic on the underlying type, assuming <code>HasAdd</code> <code>HasMul</code> etc on that type, show that they are correct for a mathematical definition of the reals, and then run them for Float? Am I missing something?</p>
</blockquote>
<p>If you really want to run the algorithm, you might not trust the specializer enough or you might want to do things that don't generalize (e.g. using unboxed arrays of <code>Float</code>).</p>
</blockquote>
<p>What does trusting the specializer mean in this context?<br>
The second reason definitely makes sense though, but I would in that situation definitely trust a proof that an implementation with unboxed array of floats agrees with a reference implementation that is correct for reals.</p>



<a name="266566986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266566986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266566986">(Jan 01 2022 at 17:36)</a>:</h4>
<p>Trust in the sense that it will deliver good performance, of course correctness is not in question.<br>
The generic implementation (look up the <code>add</code> method in the class dictionary and call it via a function pointer, while passing boxed <code>Float</code>s) might be ~1000 times as expensive as the specialized/inlined implementation (a single instruction).</p>



<a name="266567017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266567017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266567017">(Jan 01 2022 at 17:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266566109">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266565953">said</a>:</p>
<blockquote>
<p>It seems a lot easier to me to just make your algorithms polymorphic on the underlying type, assuming <code>HasAdd</code> <code>HasMul</code> etc on that type, show that they are correct for a mathematical definition of the reals, and then run them for Float? Am I missing something?</p>
</blockquote>
<p>Yes but what if I wanted to e.g. reason about the derivative of my function? Surely one would want to use the mathlib tools that are available for this right? But this is not possible with these type class constraints. If we instead made <code>Real</code> itself a typeclass and provide an instance for <code>Float</code> where the axioms are sorried out (which is hopefully valid, we don't know this for sure) and mathlib would switch to this approach on reals one should be able to reason about the derivative of a function of the form: <code>(R : Type) [Real R] : R -&gt; R</code> using mathlib tools AND compute it using floats.</p>
</blockquote>
<p>I certainly agree that having a typeclass that is equivalent to <code>real</code> is a good thing (I even wrote one for lean 3), I just don't still understand why Float needs to have an instance <code>Real Float</code> to do what you are saying, looking at the definition of <code>has_deriv_at</code> in lean 3 <a href="https://leanprover-community.github.io/mathlib_docs/find/has_deriv_at">docs#has_deriv_at</a> the type of the function <code>f</code> is <code>f : 𝕜 → F</code>, so if you define polymorphic functions <code>def f {T :Type} [Add T] [Mul T] .. </code> which only use the data fields of the <code>Real</code> typeclass you can reason about their derivatives over fields satisfying the axioms, but still evaluate them on floats.</p>



<a name="266567711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266567711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266567711">(Jan 01 2022 at 17:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266567017">said</a>:</p>
<blockquote>
<p>I certainly agree that having a typeclass that is equivalent to <code>real</code> is a good thing (I even wrote one for lean 3), I just don't still understand why Float needs to have an instance <code>Real Float</code> to do what you are saying, looking at the definition of <code>has_deriv_at</code> in lean 3 <a href="https://leanprover-community.github.io/mathlib_docs/find/has_deriv_at">docs#has_deriv_at</a> the type of the function <code>f</code> is <code>f : 𝕜 → F</code>, so if you define polymorphic functions <code>def f {T :Type} [Add T] [Mul T] .. </code> which only use the data fields of the <code>Real</code> typeclass you can reason about their derivatives over fields satisfying the axioms, but still evaluate them on floats.</p>
</blockquote>
<p>I do not have a solid reason for it, but I would certainly get tired of typing <code>[Add T] [Mul T] [Sub T] [Neg T] [Inv T] [HPow T Nat T] ...</code>, of course I can define  <code>class RealData (T : Type) extends Add T, Mul T ...</code>. Still I would get tired of writing <code>foo {X} [RealData X] (x : X)</code> instead of <code>foo (x : Real)</code></p>
<p>I'm playing around with differentiable programming and some of my function definitions look like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℝ</span> <span class="bp">⟿</span> <span class="n">ℝ</span><span class="o">))</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℝ</span> <span class="bp">⟿</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>where <code>(ℝ ⟿ ℝ)</code> is a set of all smooth function from reals to reals. Of course, I could have definition like <code>def foo (f : (X -&gt; X)) (t : X) : (X -&gt; X)</code> and then provide a theorem that if <code>f : X -&gt; X</code> is smooth then <code>foo f t</code> is smooth. Again, this is too much additional typing that I do not want to do, plus it is making things look more complicated then they truly are.</p>



<a name="266568035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266568035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266568035">(Jan 01 2022 at 18:02)</a>:</h4>
<p>You could have a <code>variable {ℝ: Type} [RealData ℝ]</code> at the top of your file / section....or agree on some default representation of reals that is actually exported as <code>Real</code>.</p>



<a name="266568617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266568617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266568617">(Jan 01 2022 at 18:19)</a>:</h4>
<p>But you can't have <code>(ℝ ⟿ ℝ)</code> because that requires notion of differentiability that you can't define if you only have <code>RealData</code>.</p>



<a name="266568667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266568667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266568667">(Jan 01 2022 at 18:20)</a>:</h4>
<p>You certainly can't define differentiability on <code>float</code> though ;-)</p>



<a name="266568760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266568760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266568760">(Jan 01 2022 at 18:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266568667">said</a>:</p>
<blockquote>
<p>You certainly can't define differentiability on <code>float</code> though ;-)</p>
</blockquote>
<p><span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span> That is the whole point of the discussion. With the definition of <code>Float</code> as it is in Lean 4 you can hopefully postulate all axioms of real numbers without getting into inconsistency and thus you can define differentiability on <code>Float</code>.</p>



<a name="266568767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266568767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266568767">(Jan 01 2022 at 18:23)</a>:</h4>
<p>And what would it say?</p>



<a name="266569079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266569079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266569079">(Jan 01 2022 at 18:31)</a>:</h4>
<p>What would be the point, though? Aren't you just proving things about \R at that point, rather than about floats?</p>



<a name="266569220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266569220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266569220">(Jan 01 2022 at 18:35)</a>:</h4>
<p>The usual stuff, definition through a limit. Probably using somewhere non-computable function <code>sup</code> defined on bounded sets that would just be postulated to exist. <code>Float</code> would effectively turn into reals for any sake formal reasoning. <br>
The way I see it now:</p>
<ol>
<li><code>Float</code> is type representing floating point numbers, it is defined though constants therefore you can't do any form of reasoning.  Like proving <code>1.0 + 0.1 = 1.1</code> but you can do computations <code>#eval (1.1 : Float) + (0.1 : Float)</code></li>
<li><code>real</code> in mathlib is completely non-computational(not 100% sure about this). You can't do <code>#eval (1 : real) + (0.1 : real)</code> but can prove <code>1.0 + 0.1 = 1.1</code> in <code>real</code></li>
</ol>
<p>Why not to merge these two types together? Define <code>def Real := Float</code> and postulate axioms of real numbers on <code>Real</code>. Now you can prove stuff about <code>Real</code> and do computations with <code>#eval</code>. What you prove will not 100% correspond to what you compute with <code>#eval</code> but I still find it useful.</p>



<a name="266575909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266575909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266575909">(Jan 01 2022 at 21:22)</a>:</h4>
<p>The reason not to merge the types together is presumably because, as you've just shown, they're completely different objects :-) Attempting to identify them is probably dangerous in terms of consistency?</p>



<a name="266576912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266576912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266576912">(Jan 01 2022 at 21:44)</a>:</h4>
<p>I feel like we are arguing in a circle :) sure I'm worried about consistency too. If you can prove <code>False</code> from assuming axioms of reals on <code>Float</code> then I will agree it is a bad idea. However, many people want extract runable code by replacing reals with floats. This can be easily done by merging these two types together as I propose.</p>



<a name="266576943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266576943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266576943">(Jan 01 2022 at 21:45)</a>:</h4>
<p>Can you make a MWE of what you propose?</p>



<a name="266577003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266577003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266577003">(Jan 01 2022 at 21:46)</a>:</h4>
<p>And perhaps put it in another thread? We're talking about Lean 4, right? How about you start in the lean 4 stream with a mwe of what you propose to do and then perhaps other people can have some fun trying to prove <code>false</code> from it. This conversation has drifted and the current thread/stream are no longer appropriate.</p>



<a name="266579398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266579398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266579398">(Jan 01 2022 at 22:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266576943">said</a>:</p>
<blockquote>
<p>Can you make a MWE of what you propose?</p>
</blockquote>
<p><a href="#narrow/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F">Here it is</a> and in a new thread as you suggested.</p>



<a name="266583768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266583768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266583768">(Jan 02 2022 at 00:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266565953">said</a>:</p>
<blockquote>
<p>It seems a lot easier to me to just make your algorithms polymorphic on the underlying type, assuming <code>HasAdd</code> <code>HasMul</code> etc on that type, show that they are correct for a mathematical definition of the reals, and then run them for Float? Am I missing something?</p>
</blockquote>
<p>I really like this idea. Here is my beginner attempt at making gradient descent polymorphic</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">gd_poly</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
            <span class="o">(</span><span class="n">hsub</span> <span class="o">:</span> <span class="n">has_sub</span> <span class="n">α</span><span class="o">)</span>
            <span class="o">(</span><span class="n">hmul</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">)</span>
            <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">gradf</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">):</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span>      <span class="o">:=</span> <span class="n">x0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">gd_poly</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">-</span> <span class="n">η</span><span class="bp">*</span><span class="n">gradf</span><span class="o">(</span><span class="n">gd_poly</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
</code></pre></div>



<a name="266583842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266583842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266583842">(Jan 02 2022 at 00:08)</a>:</h4>
<p>Then </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">gd_poly</span> <span class="n">ℝ</span> <span class="n">real.has_sub</span> <span class="n">real.has_mul</span> <span class="o">(</span><span class="mi">0</span><span class="bp">.</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">:</span><span class="n">ℝ</span><span class="o">,</span><span class="n">x</span><span class="o">)</span> <span class="mi">10</span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">gd_poly</span> <span class="n">native.float</span> <span class="n">native.float.has_sub</span> <span class="n">native.float.has_mul</span> <span class="o">(</span><span class="mi">0</span><span class="bp">.</span><span class="mi">1</span> <span class="o">:</span> <span class="n">native.float</span><span class="o">)</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">native.float</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">:</span><span class="n">native.float</span><span class="o">,</span><span class="n">x</span><span class="o">)</span> <span class="mi">10</span>
</code></pre></div>
<p>seem to work, although verbose.</p>



<a name="266586768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266586768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266586768">(Jan 02 2022 at 01:25)</a>:</h4>
<p>You can omit the type class instances (has_sub and has_mul) by passing them in <code>[]</code> instead of <code>()</code> which will let the type class system figure them out for you.ALso since the arguments already contain the type <code>α</code> you can make it implicit by putting in in <code>{}</code> instead of <code>()</code> which will let lean figure the type argument out based on the arguments, that way it should become  a lot less verbose already <span class="user-mention" data-user-id="441939">@Patrick Johnstone</span></p>



<a name="266624430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266624430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnstone <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266624430">(Jan 02 2022 at 17:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266586768">said</a>:</p>
<blockquote>
<p>You can omit the type class instances (has_sub and has_mul) by passing them in <code>[]</code> instead of <code>()</code> which will let the type class system figure them out for you.ALso since the arguments already contain the type <code>α</code> you can make it implicit by putting in in <code>{}</code> instead of <code>()</code> which will let lean figure the type argument out based on the arguments, that way it should become  a lot less verbose already <span class="user-mention silent" data-user-id="441939">Patrick Johnstone</span></p>
</blockquote>
<p>Much better, see below, thanks.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">gd_poly</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
            <span class="o">[</span><span class="n">has_sub</span> <span class="n">α</span><span class="o">]</span>
            <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span>
            <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">gradf</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">):</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span>      <span class="o">:=</span> <span class="n">x0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">gd_poly</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">-</span> <span class="n">η</span><span class="bp">*</span><span class="n">gradf</span><span class="o">(</span><span class="n">gd_poly</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>

<span class="k">#eval</span> <span class="n">gd_poly</span> <span class="o">(</span><span class="mi">0</span><span class="bp">.</span><span class="mi">1</span> <span class="o">:</span> <span class="n">native.float</span><span class="o">)</span> <span class="mi">2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">)</span> <span class="mi">15</span>
<span class="k">#check</span> <span class="n">gd_poly</span> <span class="o">(</span><span class="mi">0</span><span class="bp">.</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="mi">2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">)</span> <span class="mi">10</span>
</code></pre></div>



<a name="266625484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266625484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fadil Ahmed <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266625484">(Jan 02 2022 at 18:00)</a>:</h4>
<p>I am newbie to lean and i just set it up in vs code, but when i open it it says 'waiting for lean server to start'. Could anyone among you please tell what the problem is and how to solve it</p>



<a name="266625999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Patrick%20Johnstone%20%28mathematical%20optimizer%29/near/266625999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Patrick.20Johnstone.20(mathematical.20optimizer).html#266625999">(Jan 02 2022 at 18:10)</a>:</h4>
<p>Can you please ask this question in a new thread? This is about something else. My guess is that you've not used VS Code's "open folder" functionality to open a lean project. You can't just open a random lean file and expect it to work.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
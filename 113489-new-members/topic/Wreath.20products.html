---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Wreath.20products.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Wreath.20products.html">Wreath products</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="320273166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Wreath%20products/near/320273166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernhard Reinke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Wreath.20products.html#320273166">(Jan 09 2023 at 16:43)</a>:</h4>
<p>Hi, I am interested in implementing <a href="https://en.wikipedia.org/wiki/Wreath_product">wreath products</a> in lean (currently lean 3). I have a small working definition for unrestricted wreath products reducing it to a semidirect product such as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">A</span> <span class="n">L</span><span class="o">]</span>

<span class="o">[</span><span class="bp">...</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">wreath_product_1</span> <span class="o">:=</span> <span class="n">semidirect_product</span> <span class="o">(</span><span class="n">L</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="n">A</span> <span class="n">wreath_product.φ</span>

<span class="kd">notation</span> <span class="n">B</span><span class="bp">`</span> <span class="bp">≀</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="mi">35</span> <span class="n">L</span><span class="o">:</span><span class="mi">35</span><span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">A</span> <span class="o">:</span><span class="mi">35</span> <span class="o">:=</span> <span class="n">wreath_product_1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">L</span>
</code></pre></div>
<p>where <code>ẁreath_product.φ : A →* mul_aut (L → B)</code> given by the reindexing action <code>λ (a : A) (f : L → B) (l: L), f (has_smul.smul a⁻¹ l)</code>. Most of the file is currently showing that this definition lifts to <code>A →* mul_aut (L → B)</code>.</p>
<p>I also want to consider restricted wreath products.  But here I am not sure how to deal with the type classes: semidirect products are defined for (multiplicative) groups, but finsupp is defined for <code>has_zero B</code>.  I also want to consider groups B that are noncommutative, so I am reluctant to use additive notation for B. I saw that <span class="user-mention" data-user-id="492774">@Sky Wilshaw</span> was thinking of <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Finsupp.20generalisations/near/306301812">generalizing finsupp</a>. Has there been any progress there? Any good suggestions on how to proceed? I don't really want to reinvent the wheel but I also don't know how to glue the current definitions together.</p>



<a name="320284042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Wreath%20products/near/320284042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sky Wilshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Wreath.20products.html#320284042">(Jan 09 2023 at 17:32)</a>:</h4>
<p>I stopped working on that PR to give more effort to porting mathlib3 to mathlib4. I don't intend to continue with that PR, I might submit something similar for mathlib4 after the port.</p>



<a name="320286116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Wreath%20products/near/320286116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Wreath.20products.html#320286116">(Jan 09 2023 at 17:42)</a>:</h4>
<p><del>Could you use <a href="https://leanprover-community.github.io/mathlib_docs/find/free_monoid">docs#free_monoid</a> instead of finsupp?</del></p>



<a name="321854821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Wreath%20products/near/321854821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernhard Reinke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Wreath.20products.html#321854821">(Jan 17 2023 at 15:16)</a>:</h4>
<p>I decided to side step restricted wreath products for now, one thing I want to work towards to is the description of the p-Sylow group of Sym(p^k) as an k-times iterated wreath product of the cyclic group of order p. See the <a href="https://github.com/leanprover-community/mathlib/commit/b5cf4961caf1d6e305bc4d6e8afe8cde067fc381">stub</a>.</p>
<p>At the moment I am still struggling to define iterated wreath products correctly, again because of type class issues. Is it possible to define types inductively together with their instance of a certain type class?</p>
<p>For wreath products, I define a structure</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">section</span> <span class="n">bare_def</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">wreath_product</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">left</span><span class="o">:</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">bare_def</span>
</code></pre></div>
<p>and show a group instance</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">section</span> <span class="n">group</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">A</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">instance</span> <span class="n">wreath_product_group</span> <span class="o">:</span> <span class="n">group</span> <span class="o">(</span><span class="n">wreath_product</span> <span class="n">A</span> <span class="n">B</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="bp">...</span><span class="o">]</span>

<span class="kd">end</span> <span class="n">group</span>

<span class="kd">notation</span> <span class="n">B</span><span class="bp">`</span> <span class="bp">≀</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="mi">35</span> <span class="n">L</span><span class="o">:</span><span class="mi">35</span><span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">A</span> <span class="o">:</span><span class="mi">35</span> <span class="o">:=</span> <span class="n">wreath_product</span> <span class="n">A</span> <span class="n">B</span> <span class="n">L</span>
</code></pre></div>
<p>I want to define iterated wreath products the following way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">iterated_wreath_product</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">triv_group</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">iterated_wreath_product</span> <span class="n">n</span> <span class="bp">≀</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">G</span>

<span class="kd">lemma</span> <span class="n">iterated_wreath_product_zero</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">iterated_wreath_product</span> <span class="n">G</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">triv_group</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">iterated_wreath_product_succ</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">iterated_wreath_product</span> <span class="n">G</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">iterated_wreath_product</span> <span class="n">G</span> <span class="n">n</span> <span class="bp">≀</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>


<span class="kd">instance</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">group</span> <span class="o">(</span><span class="n">iterated_wreath_product</span> <span class="n">G</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">rw</span> <span class="n">iterated_wreath_product_zero</span><span class="o">,</span>
    <span class="n">apply_instance</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">rw</span> <span class="n">iterated_wreath_product_succ</span><span class="o">,</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>here triv_group is a unit type with the trivial group structure. I would like to construct the group structure inductively. But in the inductive step,<br>
if I try instead of the <code>sorry</code>the tactic <code>apply wreath_product_group</code>I get the error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">apply</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
  <span class="n">group</span> <span class="o">(</span><span class="n">iterated_wreath_product</span> <span class="n">G</span> <span class="n">n</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">case</span> <span class="n">nat.succ</span>
<span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span><span class="o">,</span>
<span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">ih</span> <span class="o">:</span> <span class="n">group</span> <span class="o">(</span><span class="n">iterated_wreath_product</span> <span class="n">G</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="n">group</span> <span class="o">(</span><span class="n">iterated_wreath_product</span> <span class="n">G</span> <span class="n">n</span> <span class="bp">≀</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">G</span><span class="o">)</span>
</code></pre></div>
<p>So it seems I cannot use the type class instance for the induction hypothesis. Is there some nice way around this?</p>



<a name="321869076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Wreath%20products/near/321869076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernhard Reinke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Wreath.20products.html#321869076">(Jan 17 2023 at 16:17)</a>:</h4>
<p>I think I found an OK solution, by the defining the group structure on wreath products  like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">A</span> <span class="n">L</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">wreath_product_group_explicit</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">group</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">group</span> <span class="o">(</span><span class="n">wreath_product</span> <span class="n">A</span> <span class="n">B</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="bp">...</span><span class="o">]</span>
</code></pre></div>
<p>and then add an instance as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">A</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">group</span> <span class="o">(</span><span class="n">wreath_product</span> <span class="n">A</span> <span class="n">B</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="n">wreath_product_group_explicit</span> <span class="n">A</span> <span class="n">B</span> <span class="n">L</span> <span class="n">infer_instance</span>
</code></pre></div>
<p>then it is possible to use the inductively constructed group structure</p>



<a name="321887394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Wreath%20products/near/321887394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Wreath.20products.html#321887394">(Jan 17 2023 at 17:38)</a>:</h4>
<p>Maybe you can just do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="n">rw</span> <span class="n">iterated_wreath_product_succ</span><span class="o">,</span>
    <span class="n">resetI</span><span class="o">,</span> <span class="n">apply_instance</span><span class="o">,</span>
</code></pre></div>
<p>or if you make <code>iterated_wreath_product</code> a <code>@[reducible] def</code> then maybe you don't even need the rewrite.</p>
<p>I think something like this comes up in <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.splitting_field">docs#polynomial.splitting_field</a> (where we iteratively adjoin roots), but IIRC there situation is more complicated because we want an <code>algebra</code> instance over the base field.</p>



<a name="321960162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Wreath%20products/near/321960162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Wreath.20products.html#321960162">(Jan 18 2023 at 01:40)</a>:</h4>
<p>I think I asked something similar a long time ago about iteratively defining tensor powers</p>



<a name="321960380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Wreath%20products/near/321960380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Wreath.20products.html#321960380">(Jan 18 2023 at 01:43)</a>:</h4>
<p>It's perhaps worth noting that you can get the trivial group more easily with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- could use `unit` directly if you're fine with `0 : unit` existing</span>
<span class="kd">@[derive [comm_group, unique, fintype, decidable_eq]</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">trivial_group</span> <span class="o">:=</span> <span class="n">unit</span>
</code></pre></div>



<a name="322975767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Wreath%20products/near/322975767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernhard Reinke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Wreath.20products.html#322975767">(Jan 23 2023 at 09:47)</a>:</h4>
<p>I didn't know about resetI, thanks! What does <code>@[reducible] def</code>do exactly?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
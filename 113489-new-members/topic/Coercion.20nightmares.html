---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Coercion.20nightmares.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html">Coercion nightmares</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="277873721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277873721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277873721">(Apr 05 2022 at 12:57)</a>:</h4>
<p>A subgroup of a subgroup is a subgroup, but this proof looks ridiculous. Am I that much ignorant ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">import</span> <span class="n">group_theory.subgroup.basic</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">s</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">u</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="o">(⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">hs</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">s</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">j</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">s</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">↑</span><span class="n">x</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">j</span> <span class="bp">''</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_image</span><span class="o">,</span> <span class="n">set_coe.exists</span><span class="o">]</span> <span class="n">at</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">hb'</span><span class="o">,</span> <span class="n">hb''</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ha</span><span class="o">,</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">this</span><span class="o">,</span> <span class="n">use</span> <span class="n">hb</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hb'</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">hb''</span><span class="o">,</span>
    <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">hs'</span><span class="o">,</span> <span class="n">hs''</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_image</span><span class="o">,</span> <span class="n">set_coe.exists</span><span class="o">],</span>
    <span class="n">use</span> <span class="n">a</span><span class="o">,</span> <span class="n">use</span> <span class="n">hs'</span><span class="o">,</span> <span class="n">apply</span> <span class="n">and.intro</span> <span class="n">hs''</span><span class="o">,</span>
    <span class="n">refl</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">variable</span> <span class="o">[</span><span class="n">hα</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="bp">@</span><span class="n">subgroup</span> <span class="n">α</span> <span class="n">hα</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">),</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">H'</span> <span class="bp">↔</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G</span><span class="o">),</span> <span class="o">(⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">G</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">H</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">G</span> <span class="n">H</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">j</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">subgroup.subtype</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">H.map</span> <span class="o">(</span><span class="n">G.subtype</span><span class="o">),</span>
  <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subgroup.mem_map</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">]</span> <span class="n">at</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">hb'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ha</span><span class="o">,</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="k">have</span> <span class="n">this'</span><span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="n">this</span><span class="o">,</span> <span class="n">exact</span> <span class="n">set_like.coe_mem</span> <span class="n">b</span><span class="o">,</span> <span class="o">},</span>
      <span class="n">use</span> <span class="n">this'</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">this'</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">this'</span><span class="o">⟩,</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">subtype.eq</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">this</span><span class="o">),</span> <span class="o">},</span>
      <span class="n">rw</span> <span class="n">this'</span> <span class="n">at</span> <span class="n">hb</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hb</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">hb'</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">congr</span> <span class="n">_</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">subgroup.coe_subtype</span> <span class="n">G</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">ha</span><span class="o">,</span> <span class="n">ha'</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subgroup.mem_map</span><span class="o">,</span> <span class="n">subgroup.coe_subtype</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">],</span>
    <span class="n">use</span> <span class="o">(⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩),</span>
    <span class="n">apply</span> <span class="n">and.intro</span> <span class="n">ha'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">subtype.coe_mk</span> <span class="n">a</span> <span class="n">ha</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="277874354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277874354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277874354">(Apr 05 2022 at 13:01)</a>:</h4>
<p>The trick is to use map and comap to push sets forwards and backwards along the map from <code>\u s</code> to <code>alpha</code></p>



<a name="277874672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277874672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277874672">(Apr 05 2022 at 13:04)</a>:</h4>
<p>And sometimes it turns out to be better to work with injective group homs.</p>



<a name="277874750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277874750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277874750">(Apr 05 2022 at 13:04)</a>:</h4>
<p>The map is <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.subtype">docs#subgroup.subtype</a></p>



<a name="277876786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277876786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277876786">(Apr 05 2022 at 13:18)</a>:</h4>
<p>The whole role of this is to be able teach Lean that <code>fixing_subgroup (fixing_subgroup M s) t = fixing_subgroup M (s \cup t)</code>, but Lean resists…</p>



<a name="277876881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277876881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277876881">(Apr 05 2022 at 13:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">u</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="o">(⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">hs</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">s</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- move s, t before the colon to save `intro`</span>
  <span class="n">use</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">''</span> <span class="n">t</span><span class="o">,</span> <span class="c1">-- the map is already there and this is the simp normal form</span>
  <span class="n">finish</span><span class="o">,</span> <span class="c1">-- this is now just logic nonsense, unpacking and repacking</span>
<span class="kd">end</span>
</code></pre></div>
<p>some tips <span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span></p>



<a name="277878051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277878051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277878051">(Apr 05 2022 at 13:27)</a>:</h4>
<p>I learn about <code>finish</code>!</p>



<a name="277878439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277878439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277878439">(Apr 05 2022 at 13:30)</a>:</h4>
<p>By the way, do you understand why I needed to specify <code>@subgroup hM M</code> (where <code>hM : group M</code>) in the second proof above ? — <code>subgroup M</code> didn't suffice to find an instance of <code>group M</code>.</p>



<a name="277878543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277878543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277878543">(Apr 05 2022 at 13:30)</a>:</h4>
<p>This is weird</p>



<a name="277878787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277878787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277878787">(Apr 05 2022 at 13:32)</a>:</h4>
<p>ah, wait, this is because you named the instance</p>



<a name="277878813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277878813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277878813">(Apr 05 2022 at 13:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">),</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">H'</span> <span class="bp">↔</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G</span><span class="o">),</span> <span class="o">(⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">G</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">H</span> <span class="o">:=</span>
</code></pre></div>
<p>should be OK</p>



<a name="277879015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277879015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277879015">(Apr 05 2022 at 13:34)</a>:</h4>
<p>If you give a name to a variable between square brackets, then Lean will not include it unless you mention it. So with <code>variable [hα :  group α]</code> it doesn't know that <code>α </code> is a group</p>



<a name="277879184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277879184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277879184">(Apr 05 2022 at 13:35)</a>:</h4>
<p>In any case, now I can at least state what I wish to prove :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">certainly_easy_to_prove_nightmare_to_state</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">fixing_subgroup</span> <span class="n">M</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span>
  <span class="o">(</span><span class="n">fixing_subgroup</span> <span class="o">(</span><span class="n">fixing_subgroup</span> <span class="n">M</span> <span class="n">s</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">fixing_subgroup</span> <span class="n">M</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">subtype</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="277879185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277879185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277879185">(Apr 05 2022 at 13:35)</a>:</h4>
<p>If you need to give it a name and use it several time you can write <code>include hα</code>.</p>



<a name="277881051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277881051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277881051">(Apr 05 2022 at 13:49)</a>:</h4>
<p>It seems we are missing a reasonable API for <code>fixing_subgroup</code>. For example the first sorry here</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">M</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">certainly_easy_to_prove_nightmare_to_state</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">fixing_subgroup</span> <span class="n">M</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span>
  <span class="o">(</span><span class="n">fixing_subgroup</span> <span class="o">(</span><span class="n">fixing_subgroup</span> <span class="n">M</span> <span class="n">s</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">fixing_subgroup</span> <span class="n">M</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">subtype</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩⟩,</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">hx</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy₁</span> <span class="bp">|</span> <span class="n">hy₂</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>should follow from some monotonicity of <code>fixing_subgroup</code>, that I don't find.</p>



<a name="277881179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277881179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277881179">(Apr 05 2022 at 13:50)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">import</span> <span class="n">group_theory.subgroup.basic</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">u</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="o">(⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">hs</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">s</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">use</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">''</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- We begin by abusing definitional equality and use the `rfl` trick.</span>
    <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hbs</span><span class="o">⟩,</span> <span class="n">hbt</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="c1">-- The `rfl` trick *defines* `a` to be `b`, substitutes in and then just rerases `a`.</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">hbs</span><span class="o">,</span> <span class="n">hbt</span><span class="o">⟩</span> <span class="o">},</span> <span class="c1">-- Can now just make the term</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">has</span><span class="o">,</span> <span class="n">hat</span><span class="o">⟩,</span>
    <span class="c1">-- the proof should now be one line, of the form `exact ⟨⟨t₁, t₂⟩, ⟨t₃, t₄, t₅⟩⟩`.</span>
    <span class="c1">-- Let's *experiment* now in tactic mode, and then use the `refine` tactic to make the</span>
    <span class="c1">-- term we need.</span>
    <span class="c1">-- `use a`, Oh this made progress. I now randomly have two goals but they</span>
    <span class="c1">-- both look pretty simple. I'll take that.</span>
    <span class="c1">-- But actually `use` just ran the `refine` tactic on something else.</span>
    <span class="c1">-- Let's see what `use a` actually did:</span>
    <span class="n">refine</span> <span class="o">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩,</span>  <span class="c1">-- The two underscores are the new goals.</span>
    <span class="o">{</span> <span class="c1">-- two goals so make a new bracket</span>
      <span class="c1">-- `use has` closes this goal! Now let's think about how to write it using `refine`</span>
      <span class="n">exact</span> <span class="n">has</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- the first `_` was just the term `has`.</span>
    <span class="o">{</span> <span class="c1">-- second goal</span>
      <span class="c1">-- `apply and.intro hat,` looks like a good first move. But `apply` just used `refine`:</span>
      <span class="n">refine</span> <span class="n">and.intro</span> <span class="n">hat</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">refl</span> <span class="c1">-- now solves the goal!</span>
       <span class="c1">-- but if the proof was refl we can just use `rfl` on the previous line</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="c1">-- Therefore, the one line proof is `exact ⟨⟨a, has⟩, and.intro hat rfl⟩`,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="277881729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277881729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277881729">(Apr 05 2022 at 13:53)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> , Yes, <a href="https://leanprover-community.github.io/mathlib_docs/find/fixing_subgroup">docs#fixing_subgroup</a> `is defined « par la bande » in the files devoted to Galois theory. I believe one needs to transfer them somewhere in the files related to <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action">docs#mul_action</a>, as well as adding much stuff. For example, I found useful to have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mem_fixing_subgroup_iff</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g</span> <span class="bp">∈</span> <span class="n">fixing_subgroup</span> <span class="n">M</span> <span class="n">s</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">g</span> <span class="bp">•</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">hg</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hg</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">h</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩,</span> <span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">⟩</span>
</code></pre></div>



<a name="277881869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277881869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277881869">(Apr 05 2022 at 13:54)</a>:</h4>
<p>I totally agree that lemma should be immediately after the definition, that should be elsewhere</p>



<a name="277882056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277882056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277882056">(Apr 05 2022 at 13:55)</a>:</h4>
<p>There is <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action.stabilizer">docs#mul_action.stabilizer</a></p>



<a name="277882171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277882171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277882171">(Apr 05 2022 at 13:56)</a>:</h4>
<p>With an API, but it is for a singleton (I didn't check the whole file).</p>



<a name="277882624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277882624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277882624">(Apr 05 2022 at 13:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">u</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="o">(⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">hs</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">s</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">t</span> <span class="o">:=</span>
<span class="o">⟨(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">''</span> <span class="n">t</span><span class="o">,</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">⟨</span><span class="kd">by</span> <span class="o">{</span><span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hbs</span><span class="o">⟩,</span> <span class="n">hbt</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span><span class="n">exact</span> <span class="o">⟨</span><span class="n">hbs</span><span class="o">,</span> <span class="n">hbt</span><span class="o">⟩},</span>
  <span class="c1">-- no rfl trick here so can do it all in term mode</span>
  <span class="bp">λ</span> <span class="n">ha</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha.some</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">ha.some_spec</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩⟩⟩</span>
</code></pre></div>



<a name="277883044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277883044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277883044">(Apr 05 2022 at 14:01)</a>:</h4>
<p>The <code>rfl</code> trick in <code>rintro</code> involves a "deep <code>eq.rec</code>" so you don't want to translate it into term mode, my guess is that the term generated by the <code>rintro rfl</code> tactic is really nasty.</p>



<a name="277883143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277883143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277883143">(Apr 05 2022 at 14:01)</a>:</h4>
<p>Oh by the way I used the axiom of choice with <code>exists.some</code> and <code>exists.some_spec</code></p>



<a name="277892224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277892224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277892224">(Apr 05 2022 at 15:02)</a>:</h4>
<p>quite unnecessarily though: <code>λ ⟨ha₁, ha₂⟩, ⟨⟨a, ha₁⟩, ⟨ha₂, rfl⟩⟩</code></p>



<a name="277908994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277908994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277908994">(Apr 05 2022 at 16:48)</a>:</h4>
<p>I thought that term mode lambda pointies were discouraged!</p>



<a name="277909070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277909070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277909070">(Apr 05 2022 at 16:48)</a>:</h4>
<p>Only for defining data</p>



<a name="277909383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277909383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277909383">(Apr 05 2022 at 16:51)</a>:</h4>
<p>It will produce a term with a <code>whatever.rec</code> in a place that usually isn't the best place for it</p>



<a name="277909398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20nightmares/near/277909398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20nightmares.html#277909398">(Apr 05 2022 at 16:51)</a>:</h4>
<p>but for a proof we don't care</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html">Defining a (non-full) subcategory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="231546871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231546871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob Scholbach <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231546871">(Mar 23 2021 at 21:29)</a>:</h4>
<p>Another category theoretic question: I am trying to construct a (non-full) subcategory whose morphisms have the lifting property with respect to some other subcategory (see around here <a href="https://ncatlab.org/nlab/show/lift">https://ncatlab.org/nlab/show/lift</a>). What is a convenient syntax to phrase such things? A not-quite-minimal example is posted below, but the question makes sense for any property of morphisms in a category that is stable under composition and holds for the identity morphisms.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.category</span>
<span class="kn">import</span> <span class="n">category_theory.arrow</span>
<span class="kn">import</span> <span class="n">category_theory.functor</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kd">universes</span> <span class="n">v‚ÇÅ</span> <span class="n">u‚ÇÅ</span> <span class="n">u‚ÇÇ</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u‚ÇÅ</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v‚ÇÅ</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u‚ÇÅ</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v‚ÇÅ</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span>
<span class="kd">variable</span> <span class="n">X</span> <span class="o">:</span> <span class="n">C</span>

<span class="c">/-</span><span class="cm"> The left lifting property of a morphism i vs. a morphism p. -/</span>
<span class="kd">def</span> <span class="n">llp</span> <span class="o">(</span><span class="n">i</span> <span class="n">p</span> <span class="o">:</span> <span class="n">arrow</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">sq</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">‚ü∂</span> <span class="n">p</span><span class="o">),</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">arrow.lift_struct</span> <span class="n">sq</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> The subcategory of C consisting of those morphisms having the right lifting property with respect to any</span>
<span class="cm">morphism in the range of a functor. -/</span>

<span class="c">/-</span><span class="cm"> Any identity has the right lifting property with respect to any map. -/</span>
<span class="kd">lemma</span> <span class="n">id_has_rlp</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">arrow</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">llp</span> <span class="n">i</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="o">(</span><span class="mi">ùüô</span> <span class="n">X</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">rlp_of_range</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">‚•§</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">category.</span><span class="o">{</span><span class="n">v‚ÇÅ</span><span class="o">}</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">hom</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">X</span> <span class="n">Y</span><span class="o">,</span> <span class="o">{</span> <span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">‚ü∂</span> <span class="n">Y</span> <span class="bp">//</span> <span class="bp">‚àÄ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">arrow</span> <span class="n">D</span><span class="o">,</span> <span class="n">llp</span> <span class="o">((</span><span class="n">functor.map_arrow</span> <span class="n">I</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="n">p</span><span class="o">)},</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">X</span><span class="o">,</span> <span class="o">{</span>
    <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- want to use id_has_rlp here</span>
  <span class="o">},</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- will use a similar stability of the lifting</span>
  <span class="n">id_comp'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">comp_id'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">assoc'</span> <span class="o">:=</span> <span class="n">_</span>
<span class="o">}</span>
 <span class="bp">```</span>
</code></pre></div>



<a name="231547369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231547369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231547369">(Mar 23 2021 at 21:32)</a>:</h4>
<p><span class="user-mention" data-user-id="247154">@Jakob Scholbach</span> you might be interested in <a href="https://github.com/rwbarton/lean-homotopy-theory">https://github.com/rwbarton/lean-homotopy-theory</a> where <span class="user-mention" data-user-id="110032">@Reid Barton</span> develops a whole lot of homotopy theory. However that repo is quite old, and not compatible with current mathlib.</p>



<a name="231547791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231547791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231547791">(Mar 23 2021 at 21:35)</a>:</h4>
<p>Note that because <code>C</code> already has a category structure in your code, you would want to introduce an alias for <code>C</code>.</p>



<a name="231547847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231547847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231547847">(Mar 23 2021 at 21:36)</a>:</h4>
<p>To answer question, I would break <code>rlp_of_range</code> into pieces. So</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">rlp_of_range</span>

<span class="kd">def</span> <span class="n">hom</span> <span class="bp">...</span>

<span class="kd">def</span> <span class="n">id</span> <span class="bp">...</span>

<span class="kd">def</span> <span class="n">comp</span> <span class="bp">...</span>

<span class="kd">end</span> <span class="n">rlp_of_range</span>

<span class="kd">def</span> <span class="n">rlp_of_range</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">‚•§</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">category.</span><span class="o">{</span><span class="n">v‚ÇÅ</span><span class="o">}</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="n">rlp_of_range.hom</span><span class="o">,</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="n">rlp_of_range.id</span><span class="o">,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="n">rlp_of_range.comp</span><span class="o">,</span>
  <span class="n">id_comp'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">comp_id'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">assoc'</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>



<a name="231547901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231547901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231547901">(Mar 23 2021 at 21:36)</a>:</h4>
<p>At first, this seems very tedious. But in practice it is a lot faster to work this way, because you can take more advantage of the previous steps</p>



<a name="231548458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231548458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob Scholbach <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231548458">(Mar 23 2021 at 21:41)</a>:</h4>
<p>OK, good - is there some example somewhere in mathlib that has applied this skeleton in this way?</p>



<a name="231548544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231548544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob Scholbach <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231548544">(Mar 23 2021 at 21:42)</a>:</h4>
<p>It always takes me lots of time to hunt down the syntax to the place where it is actually defined.</p>



<a name="231548832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231548832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231548832">(Mar 23 2021 at 21:44)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.isomorphism</span>
<span class="kn">import</span> <span class="n">category_theory.functor</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">liftable</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">‚•§</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="n">C</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">‚•§</span> <span class="n">C</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">liftable.X</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">liftable</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">x</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="o">(</span><span class="n">liftable</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">X</span> <span class="n">Y</span><span class="o">,</span> <span class="o">{</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X.X</span> <span class="bp">‚ü∂</span> <span class="n">Y.X</span> <span class="bp">//</span> <span class="bp">‚àÄ</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">D</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">‚ü∂</span> <span class="n">b</span><span class="o">}</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">b</span> <span class="bp">‚âÖ</span> <span class="n">Y.X</span><span class="o">},</span>
    <span class="bp">‚àÉ</span> <span class="n">h</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">a</span> <span class="bp">‚ü∂</span> <span class="n">X.X</span><span class="o">,</span> <span class="n">h</span> <span class="bp">‚â´</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">F.map</span> <span class="n">g</span> <span class="bp">‚â´</span> <span class="n">i.hom</span><span class="o">},</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">id_comp'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">comp_id'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">assoc'</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="231548857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231548857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231548857">(Mar 23 2021 at 21:44)</a>:</h4>
<p>I haven't thought about whether the definition is actually correct, but it typechecks</p>



<a name="231548931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231548931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231548931">(Mar 23 2021 at 21:45)</a>:</h4>
<p>Note that one should not talk about equality of objects in the category, hence the isomorphism <code>i</code> in the condition</p>



<a name="231548975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231548975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231548975">(Mar 23 2021 at 21:45)</a>:</h4>
<p>And I agree with Johan's comments that it's probably better to split off the hom, id, comp, etc.</p>



<a name="231630346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231630346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob Scholbach <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231630346">(Mar 24 2021 at 13:10)</a>:</h4>
<p>A follow up question:  given the definition of the hom-sets, identity and composition as below, how do I unwind the definition of the composition that I just made in order to show <code>id_comp'</code> (near the end of the post)?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.category</span>
<span class="kn">import</span> <span class="n">category_theory.arrow</span>
<span class="kn">import</span> <span class="n">category_theory.functor</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kd">universes</span> <span class="n">v‚ÇÅ</span> <span class="n">u‚ÇÅ</span> <span class="n">u‚ÇÇ</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u‚ÇÅ</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v‚ÇÅ</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u‚ÇÅ</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v‚ÇÅ</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span>


<span class="c">/-</span><span class="cm"> The left lifting property of a morphism i vs. a morphism p. -/</span>
<span class="kd">def</span> <span class="n">has_lifting_property</span> <span class="o">(</span><span class="n">i</span> <span class="n">p</span> <span class="o">:</span> <span class="n">arrow</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">sq</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">‚ü∂</span> <span class="n">p</span><span class="o">),</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">arrow.lift_struct</span> <span class="n">sq</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">liftable</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">‚•§</span> <span class="n">arrow</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="n">C</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">‚•§</span> <span class="n">arrow</span> <span class="n">C</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">liftable.X</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">liftable</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">has_lifting_property_id'</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span>  <span class="bp">‚àÄ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">D</span><span class="o">,</span> <span class="n">has_lifting_property</span> <span class="o">((</span><span class="n">F.obj</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="o">(</span><span class="mi">ùüô</span> <span class="n">X</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">has_lifting_property_comp'</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">‚ü∂</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">D</span><span class="o">,</span> <span class="n">has_lifting_property</span> <span class="o">((</span><span class="n">F.obj</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="n">f</span><span class="o">))</span>
 <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">‚ü∂</span> <span class="n">Z</span><span class="o">}</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">D</span><span class="o">,</span> <span class="n">has_lifting_property</span> <span class="o">((</span><span class="n">F.obj</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="n">g</span><span class="o">))</span> <span class="o">:</span>
<span class="bp">‚àÄ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">D</span><span class="o">,</span>  <span class="n">has_lifting_property</span> <span class="o">((</span><span class="n">F.obj</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="o">(</span><span class="n">f</span> <span class="bp">‚â´</span> <span class="n">g</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"> Given a functor F : D ‚•§ arrow C, we construct the (non-full) subcategory of C</span>
<span class="cm">spanned by those morphisms that have the right lifting property relative to all maps</span>
<span class="cm">of the form F(i), where i is any object in D. -/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="o">(</span><span class="n">liftable</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">X</span> <span class="n">Y</span><span class="o">,</span> <span class="o">{</span> <span class="n">p</span> <span class="o">:</span> <span class="n">X.X</span> <span class="bp">‚ü∂</span> <span class="n">Y.X</span> <span class="bp">//</span> <span class="bp">‚àÄ</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">D</span><span class="o">},</span>
    <span class="n">has_lifting_property</span> <span class="o">((</span><span class="n">F.obj</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="n">p</span><span class="o">)},</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">X</span><span class="o">,</span> <span class="o">‚ü®</span> <span class="mi">ùüô</span> <span class="n">X</span><span class="o">,</span> <span class="n">has_lifting_property_id'</span> <span class="n">X</span><span class="o">,</span> <span class="o">‚ü©,</span> <span class="c1">--Œª X, llp_to_id' X,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="o">‚ü®</span><span class="n">f.val</span> <span class="bp">‚â´</span> <span class="n">g.val</span><span class="o">,</span> <span class="n">has_lifting_property_comp'</span> <span class="n">f.property</span> <span class="n">g.property</span> <span class="o">‚ü©,</span>
  <span class="n">id_comp'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="c1">-- how do I unwind the definition of comp with f.val ‚â´ g.val that I previously made?</span>
  <span class="n">comp_id'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">assoc'</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="231630489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231630489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231630489">(Mar 24 2021 at 13:11)</a>:</h4>
<p>I guess I would start with <code>intros, ext, dsimp</code></p>



<a name="231631014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231631014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob Scholbach <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231631014">(Mar 24 2021 at 13:14)</a>:</h4>
<p>Thanks! -- Can I get a copy of your lean brain, please?! :)</p>



<a name="231633658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231633658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231633658">(Mar 24 2021 at 13:32)</a>:</h4>
<p>Tidy should be able to handle that goal, I hope?!</p>



<a name="231637034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231637034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231637034">(Mar 24 2021 at 13:54)</a>:</h4>
<p>Here's tidy doing all the work :)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.category</span>
<span class="kn">import</span> <span class="n">category_theory.arrow</span>
<span class="kn">import</span> <span class="n">category_theory.functor</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kd">universes</span> <span class="n">v‚ÇÅ</span> <span class="n">u‚ÇÅ</span> <span class="n">u‚ÇÇ</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u‚ÇÅ</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v‚ÇÅ</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u‚ÇÅ</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v‚ÇÅ</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span>


<span class="c">/-</span><span class="cm"> The left lifting property of a morphism i vs. a morphism p. -/</span>
<span class="kd">def</span> <span class="n">has_lifting_property</span> <span class="o">(</span><span class="n">i</span> <span class="n">p</span> <span class="o">:</span> <span class="n">arrow</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">sq</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">‚ü∂</span> <span class="n">p</span><span class="o">),</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">arrow.lift_struct</span> <span class="n">sq</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">liftable</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">‚•§</span> <span class="n">arrow</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="c1">-- :-)</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">‚•§</span> <span class="n">arrow</span> <span class="n">C</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">has_lifting_property_id'</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span>  <span class="bp">‚àÄ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">D</span><span class="o">,</span> <span class="n">has_lifting_property</span> <span class="o">((</span><span class="n">F.obj</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="o">(</span><span class="mi">ùüô</span> <span class="n">X</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">has_lifting_property_comp'</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">‚ü∂</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">D</span><span class="o">,</span> <span class="n">has_lifting_property</span> <span class="o">((</span><span class="n">F.obj</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="n">f</span><span class="o">))</span>
 <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">‚ü∂</span> <span class="n">Z</span><span class="o">}</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">D</span><span class="o">,</span> <span class="n">has_lifting_property</span> <span class="o">((</span><span class="n">F.obj</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="n">g</span><span class="o">))</span> <span class="o">:</span>
<span class="bp">‚àÄ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">D</span><span class="o">,</span>  <span class="n">has_lifting_property</span> <span class="o">((</span><span class="n">F.obj</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="o">(</span><span class="n">f</span> <span class="bp">‚â´</span> <span class="n">g</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"> Given a functor F : D ‚•§ arrow C, we construct the (non-full) subcategory of C</span>
<span class="cm">spanned by those morphisms that have the right lifting property relative to all maps</span>
<span class="cm">of the form F(i), where i is any object in D. -/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="o">(</span><span class="n">liftable</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">X</span> <span class="n">Y</span><span class="o">,</span> <span class="o">{</span> <span class="n">p</span> <span class="o">:</span> <span class="n">X.X</span> <span class="bp">‚ü∂</span> <span class="n">Y.X</span> <span class="bp">//</span> <span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">D</span><span class="o">),</span>
    <span class="n">has_lifting_property</span> <span class="o">((</span><span class="n">F.obj</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="n">p</span><span class="o">)},</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">X</span><span class="o">,</span> <span class="o">‚ü®</span><span class="mi">ùüô</span> <span class="n">_</span><span class="o">,</span> <span class="n">has_lifting_property_id'</span> <span class="n">_</span><span class="o">‚ü©,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="o">‚ü®</span><span class="n">f.1</span> <span class="bp">‚â´</span> <span class="n">g.1</span><span class="o">,</span> <span class="n">has_lifting_property_comp'</span> <span class="n">f.2</span> <span class="n">g.2</span><span class="o">‚ü©</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="231637392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231637392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231637392">(Mar 24 2021 at 13:56)</a>:</h4>
<p>When you omit the fields like I did in this code, lean uses what's called the <code>auto_param</code> which is essentially a tactic that it tries in order to close the goal automatically. In this case, it applies <code>tidy</code>, which is able to close the three omitted goals all by itself.</p>



<a name="231638003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231638003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231638003">(Mar 24 2021 at 14:00)</a>:</h4>
<p>The key trick was to replace the definition of liftable with a structure, so that tidy is able to use <code>cases X</code></p>



<a name="231705633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20%28non-full%29%20subcategory/near/231705633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob Scholbach <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20(non-full).20subcategory.html#231705633">(Mar 24 2021 at 20:46)</a>:</h4>
<p>Thanks again <span class="user-mention" data-user-id="243562">@Adam Topaz</span>  and <span class="user-mention" data-user-id="112680">@Johan Commelin</span> . I somehow did not see this last message and used a slightly more verbose way (but also including<code>tidy</code>). I will integrate your simplification there soon. If you are interested, have a look here <a href="https://github.com/leanprover-community/mathlib/issues/6852">#6852</a>. I'm sure there will again be many stylistic shortcomings...<br>
My mid-term goal is to define the notion of a model category.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
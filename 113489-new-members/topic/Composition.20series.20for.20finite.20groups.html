---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html">Composition series for finite groups</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="221565377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221565377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221565377">(Jan 04 2021 at 19:00)</a>:</h4>
<p>What would be the best way to define composition series on finite groups? I'm thinking of this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">composition_series</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">subgroup</span> <span class="n">G</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">⊤</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">maximal_normal_subgroup</span> <span class="o">(</span><span class="n">composition_series</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>
<p>It should be possible to define <code>maximal_normal_subgroup</code> by creating a maximal element of <code>{ N : subgroup G // N.normal }</code>, but I'm not sure how to do that. Presumably there's something in the order theory files, but I haven't been able to find anything. (I don't really know what I'm looking for.  <span aria-label="grimacing" class="emoji emoji-1f62c" role="img" title="grimacing">:grimacing:</span> )</p>



<a name="221565498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221565498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221565498">(Jan 04 2021 at 19:01)</a>:</h4>
<p>At least two other people have been thinking about this recently. <span class="user-mention" data-user-id="253861">@Thomas Browning</span> <span class="user-mention" data-user-id="243312">@Jason KY.</span> ?</p>



<a name="221565574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221565574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221565574">(Jan 04 2021 at 19:01)</a>:</h4>
<p>You probably want to use <code>is_coatom</code> somewhere. I'm not sure how much API we have on the lattice of normal subgroups, though.</p>



<a name="221565661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221565661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221565661">(Jan 04 2021 at 19:02)</a>:</h4>
<p><span class="user-mention" data-user-id="298851">@Patrick Lutz</span> and I haven't done composition series specifically. However, <span class="user-mention" data-user-id="110401">@Brendan Seamas Murphy</span> did composition series a long time ago: <a href="https://github.com/Shamrock-Frost/jordan-holder/blob/master/src/composition_series.lean">https://github.com/Shamrock-Frost/jordan-holder/blob/master/src/composition_series.lean</a></p>



<a name="221565863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221565863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221565863">(Jan 04 2021 at 19:04)</a>:</h4>
<p>In my mind this is not a completely straightforward problem. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>⊂</mo><msub><mi>G</mi><mn>1</mn></msub><mo>⊂</mo><msub><mi>G</mi><mn>2</mn></msub><mo>⊂</mo><msub><mi>G</mi><mn>3</mn></msub><mo>⊂</mo><mo>⋯</mo><mo>⊂</mo><msub><mi>G</mi><mi>n</mi></msub><mo>=</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">1\subset G_1\subset G_2\subset G_3\subset\cdots\subset G_n=G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> then it's very natural for the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> to be subgroups of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> but you also want <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> to be a subgroup of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">G_j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> too.</p>



<a name="221566082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221566082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221566082">(Jan 04 2021 at 19:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Maybe just specify embeddings rather than require the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> to be subgroups?</p>



<a name="221566134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221566134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221566134">(Jan 04 2021 at 19:06)</a>:</h4>
<p>So you can go "full type" and have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> all being types and there being maps between them</p>



<a name="221566168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221566168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221566168">(Jan 04 2021 at 19:07)</a>:</h4>
<p>yeah</p>



<a name="221566654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221566654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221566654">(Jan 04 2021 at 19:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="253861">Thomas Browning</span> <a href="#narrow/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups/near/221565661">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="298851">Patrick Lutz</span> and I haven't done composition series specifically. However, <span class="user-mention silent" data-user-id="110401">Brendan Seamas Murphy</span> did composition series a long time ago: <a href="https://github.com/Shamrock-Frost/jordan-holder/blob/master/src/composition_series.lean">https://github.com/Shamrock-Frost/jordan-holder/blob/master/src/composition_series.lean</a></p>
</blockquote>
<p>To give a little more detail: we've proved some stuff about solvable groups (along with Jordan Brown), but it seemed easier to us to define solvable in terms of the derived series of a group rather than in terms of composition series. The definition of derived series should be merged into mathlib soon though</p>



<a name="221567673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221567673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221567673">(Jan 04 2021 at 19:19)</a>:</h4>
<p><span class="user-mention" data-user-id="355764">@Hanting Zhang</span> Your definition of <code>composition_series</code> seems to be trying to define a unique sequence associated to a finite group. But can't a group have multiple different composition series (because there is not always a unique maximal normal subgroup)?</p>



<a name="221567743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221567743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221567743">(Jan 04 2021 at 19:19)</a>:</h4>
<p>So maybe instead you should define a <em>type</em> of composition series and prove that it's nonempty (it looks like the repository that Thomas linked to takes a similar approach)</p>



<a name="221567933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221567933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221567933">(Jan 04 2021 at 19:21)</a>:</h4>
<p>I can't really understand what <span class="user-mention" data-user-id="110401">@Brendan Seamas Murphy</span> has done at first glance. The category theory is getting lost on me. Would the type be <code>list subgroup G</code>? I don't really understand what "full type" means either.</p>



<a name="221568023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221568023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221568023">(Jan 04 2021 at 19:21)</a>:</h4>
<p>Also, not sure if this is the type of lemma you are asking about, but mathlib does have <code>finset.exists_maximal</code> which shows that any finite subset of a preorder has a maximal element</p>



<a name="221568030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221568030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221568030">(Jan 04 2021 at 19:21)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/data/fintype/basic.html#finset.exists_maximal">https://leanprover-community.github.io/mathlib_docs/data/fintype/basic.html#finset.exists_maximal</a></p>



<a name="221568693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221568693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221568693">(Jan 04 2021 at 19:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="355764">Hanting Zhang</span> <a href="#narrow/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups/near/221567933">said</a>:</p>
<blockquote>
<p>I can't really understand what <span class="user-mention silent" data-user-id="110401">Brendan Seamas Murphy</span> has done at first glance. The category theory is getting lost on me. Would the type be <code>list subgroup G</code>? I don't really understand what "full type" means either.</p>
</blockquote>
<p>Here's what's going on I think. First, he defines a type consisting of all "normal series" of a group</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">normal_series</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">Group.</span><span class="o">{</span><span class="n">u</span><span class="o">}):</span> <span class="n">Group.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">initial</span> <span class="o">{}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">T'</span><span class="o">},</span> <span class="o">(</span><span class="n">T'</span> <span class="bp">≅</span> <span class="n">T</span><span class="o">)</span> <span class="bp">→</span> <span class="n">normal_series</span> <span class="n">T'</span>
<span class="bp">|</span> <span class="n">step</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">H</span> <span class="n">G</span> <span class="n">K</span> <span class="o">:</span> <span class="n">Group.</span><span class="o">{</span><span class="n">u</span><span class="o">}},</span>
       <span class="n">SES</span> <span class="n">H</span> <span class="n">G</span> <span class="n">K</span>
       <span class="bp">→</span> <span class="n">normal_series</span> <span class="n">H</span>
       <span class="bp">→</span> <span class="n">normal_series</span> <span class="n">G</span>
</code></pre></div>
<p>Basically this is saying that if <code>G</code> is a group then </p>
<ol>
<li>Any group isomorphic to <code>G</code> can count as a normal series for <code>G</code> (think of it as the trivial normal series of length 1)</li>
<li>If <code>H</code> embeds into <code>G</code> and its image is a normal subgroup then if you have a normal series on <code>H</code> you also have a normal series on <code>G</code> which you get by appending <code>H</code> to the beginning</li>
</ol>
<p>One slightly tricky thing here is that the elements of this type are not sequences in the usual sense (i.e. they are not functions from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span> to some set), instead they are elements of some inductive type. But you could extract a sequence from them if you wanted.</p>



<a name="221568796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221568796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221568796">(Jan 04 2021 at 19:28)</a>:</h4>
<p>Next, he defines a predicate on the <code>normal_series</code> type that says if the given normal series is a composition series</p>



<a name="221569022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221569022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221569022">(Jan 04 2021 at 19:30)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">is_composition_series</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">normal_series</span> <span class="mi">1</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">:=</span> <span class="n">list.foldr</span> <span class="o">(</span><span class="bp">∧</span><span class="o">)</span> <span class="n">true</span>
     <span class="bp">$</span> <span class="n">list.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">K</span> <span class="o">:</span> <span class="n">Group</span><span class="o">,</span> <span class="n">simple_group</span> <span class="n">K</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">subsingleton</span> <span class="n">K</span><span class="o">)</span>
     <span class="bp">$</span> <span class="n">factors</span> <span class="n">σ</span>
</code></pre></div>
<p>Basically this is just saying that if <code>σ</code> is a normal series for <code>G</code> it is a composition series if at every step in the formation of <code>σ</code>, if you quotient by the subgroup that was used, you get a simple group</p>



<a name="221569087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221569087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221569087">(Jan 04 2021 at 19:30)</a>:</h4>
<p>What is the analog of <code>Group.{u}</code> in Lean currently? I'm guessing it means the Type of all groups in <code>u</code>.</p>



<a name="221569170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221569170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221569170">(Jan 04 2021 at 19:31)</a>:</h4>
<p>Also, thanks for all the explanations, they're very helpful.</p>



<a name="221569171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221569171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221569171">(Jan 04 2021 at 19:31)</a>:</h4>
<p>I would normally write <code>(G : Type u) [group G]</code></p>



<a name="221569219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221569219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221569219">(Jan 04 2021 at 19:31)</a>:</h4>
<p>or <code>(G : Type*) [group G]</code></p>



<a name="221571504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221571504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221571504">(Jan 04 2021 at 19:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups/near/221565498">said</a>:</p>
<blockquote>
<p>At least two other people have been thinking about this recently. <span class="user-mention silent" data-user-id="253861">Thomas Browning</span> <span class="user-mention silent" data-user-id="243312">Jason KY.</span> ?</p>
</blockquote>
<p>I messed around with derived series a while back and I defined it in a way similar to what Zhang has</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">derived_subgroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">subgroup</span> <span class="n">G</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="o">:=</span> <span class="bp">⊤</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">commutator</span> <span class="bp">$</span> <span class="n">derived_subgroup</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">derived_subgroup</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">inclusion</span>
</code></pre></div>
<p>where <code>inclusion</code>is the following homomorphism</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">subgroup.inclusion</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">→*</span> <span class="n">G</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.1</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
</code></pre></div>
<p>I couldn't find a nice way of extending this to composition series however.</p>



<a name="221572277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221572277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221572277">(Jan 04 2021 at 19:54)</a>:</h4>
<p>I think I'm getting somewhere, although the definition isn't done:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">normal_series</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">T</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">init</span> <span class="o">{}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">T'</span> <span class="o">[</span><span class="n">group</span> <span class="n">T'</span><span class="o">],</span> <span class="n">T'</span> <span class="bp">≃*</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">normal_series</span> <span class="n">T'</span>
<span class="bp">|</span> <span class="n">step</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">H</span> <span class="n">G</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">K</span><span class="o">],</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">→*</span> <span class="n">G</span><span class="o">,</span> <span class="n">function.injective</span> <span class="n">f</span> <span class="bp">∧</span> <span class="c">/-</span><span class="cm"> H identifies as a normal subgroup of G -/</span> <span class="o">)</span>
  <span class="n">normal_series</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">normal_series</span> <span class="n">G</span>
</code></pre></div>



<a name="221572337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221572337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221572337">(Jan 04 2021 at 19:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="355764">Hanting Zhang</span> <a href="#narrow/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups/near/221569087">said</a>:</p>
<blockquote>
<p>What is the analog of <code>Group.{u}</code> in Lean currently? I'm guessing it means the Type of all groups in <code>u</code>.</p>
</blockquote>
<p>In Lean, <code>Group</code> would be the category of all groups (in universe u) (assuming they made this category by now :-) )</p>



<a name="221572396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221572396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221572396">(Jan 04 2021 at 19:55)</a>:</h4>
<p><span class="user-mention" data-user-id="243312">@Jason KY.</span> FYI, there is currently a PR underway to mathlib to add derived series (<a href="https://github.com/leanprover-community/mathlib/issues/5565">#5565</a>). Also there will probably soon be a PR coming to add something like your <code>inclusion</code></p>



<a name="221572747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221572747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221572747">(Jan 04 2021 at 19:58)</a>:</h4>
<p>Oh no, is it better to work with <code>Group</code> then?  This is getting much harder than I thought it would be.</p>



<a name="221572757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221572757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221572757">(Jan 04 2021 at 19:58)</a>:</h4>
<p><span class="user-mention" data-user-id="243312">@Jason KY.</span> Actually I got a little confused. Your <code>inclusion</code> is just <code>subgroup.subtype</code> which is already in mathlib</p>



<a name="221572813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221572813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221572813">(Jan 04 2021 at 19:59)</a>:</h4>
<p>but soon there will be a map from <code>subgroup H</code> to <code>subgroup G</code> (see <a href="https://github.com/leanprover-community/mathlib/blob/697692be6219bdcd15d17883b632441c0b7ab930/src/group_theory/subgroup.lean#L774">here</a>)</p>



<a name="221572899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221572899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221572899">(Jan 04 2021 at 19:59)</a>:</h4>
<p>I was just messing around in lean since I was learning the material myself so its not surprising that I missed that definition :p</p>



<a name="221573164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221573164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Lutz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221573164">(Jan 04 2021 at 20:01)</a>:</h4>
<p>Yeah, I think I only discovered it by accident (using <code>library_search</code> or something)</p>



<a name="221573845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Composition%20series%20for%20finite%20groups/near/221573845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Composition.20series.20for.20finite.20groups.html#221573845">(Jan 04 2021 at 20:07)</a>:</h4>
<p>I am not sure that using category theory will help here</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
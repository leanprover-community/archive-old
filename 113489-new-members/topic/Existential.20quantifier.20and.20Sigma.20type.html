---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html">Existential quantifier and Sigma type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="264328034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264328034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264328034">(Dec 09 2021 at 16:37)</a>:</h4>
<p>I am confused about existential quantifiers and Sigma types.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span>
<span class="k">#check</span> <span class="bp">Π</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span>
<span class="k">#check</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span>
<span class="k">#check</span> <span class="bp">Σ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span>
<span class="k">#check</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span>
</code></pre></div>
<p>Why is <code>Σ x</code> syntactically incorrect whereäs both <code>Π x</code> and <code>∀ x</code> are syntactically correct (and mean the same thing)? Isn't <code>∀</code> just a syntactic sugar for <code>Π</code> in the same way that <code>∃</code> is, at least I supposed, a syntactic sugar for <code>Σ</code> under the assumption that <code>p x : Prop</code> ?</p>



<a name="264328721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264328721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264328721">(Dec 09 2021 at 16:42)</a>:</h4>
<p>(First, all of these are <em>syntactically</em> correct.)<br>
<code>∀</code> and <code>Π</code> are indeed the same, but <code>∃</code> and <code>Σ</code> are completely separate: the first is <a href="https://leanprover-community.github.io/mathlib_docs/find/Exists">docs#Exists</a> and the second is <a href="https://leanprover-community.github.io/mathlib_docs/find/sigma">docs#sigma</a>.</p>



<a name="264328868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264328868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264328868">(Dec 09 2021 at 16:43)</a>:</h4>
<p>Oh, sorry, I considered type mismatch to be a kind of syntactic error.</p>



<a name="264329958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264329958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264329958">(Dec 09 2021 at 16:50)</a>:</h4>
<p>How can I find a similar documentation for Pi instead of Sigma?</p>



<a name="264330353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264330353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264330353">(Dec 09 2021 at 16:53)</a>:</h4>
<p>Pi is a primitive. There's some info on it in <a href="https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html#the-universal-quantifier">section 4.1 of TPIL</a>.</p>



<a name="264331067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264331067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264331067">(Dec 09 2021 at 16:58)</a>:</h4>
<p>What is the difference between Pi being primitive and Sigma not being primitive? Does Pi have a constructor (as a structure) as well?</p>



<a name="264332195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264332195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264332195">(Dec 09 2021 at 17:05)</a>:</h4>
<p>No, it doesn't have a constructor. Pi/forall is a kind of expression that the kernel handles directly because it's  'part of the system'. Sigma is an inductive type that gets declared by users.</p>



<a name="264332407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264332407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264332407">(Dec 09 2021 at 17:06)</a>:</h4>
<p>Oh, thank you!</p>



<a name="264332818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264332818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264332818">(Dec 09 2021 at 17:09)</a>:</h4>
<p>This leaves me with the last question: Why cannot <code>∃</code> be translated to <code>Σ</code> in the similar way how <code>∀</code> is translated to <code>Π</code> (or maybe not translated to the other symbol but both being translated to the same kernel expression)?</p>



<a name="264332977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264332977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264332977">(Dec 09 2021 at 17:10)</a>:</h4>
<p><code>∀</code> only exists in the pretty printer and as notation (for <code>Π a, p a</code> when <code>p a : Prop</code>), there's no real translation happening. <a href="https://leanprover-community.github.io/mathlib_docs/find/sigma">docs#sigma</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/Exists">docs#Exists</a> are different types.</p>



<a name="264333102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264333102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264333102">(Dec 09 2021 at 17:11)</a>:</h4>
<p>Yes, thanks, but why do they need to be different types?</p>



<a name="264333147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264333147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264333147">(Dec 09 2021 at 17:11)</a>:</h4>
<p>Because they reside in different universes</p>



<a name="264333348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264333348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264333348">(Dec 09 2021 at 17:12)</a>:</h4>
<p>Respectively, <code>sigma p : Type (max u v)</code>, <code>psigma p : Sort (max 1 u v)</code>, <code>Exists p : Prop</code></p>



<a name="264333494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264333494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264333494">(Dec 09 2021 at 17:13)</a>:</h4>
<p>arguably we don't need both <code>sigma</code> and <code>psigma</code>, beyond the fact that <code>Sort (max 1 u v)</code> isannoying vs <code>Type (max u v)</code></p>



<a name="264333563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264333563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264333563">(Dec 09 2021 at 17:14)</a>:</h4>
<p>I can now see that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="mi">3</span>
<span class="k">#check</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span>
</code></pre></div>
<p>is also correct.</p>



<a name="264334144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264334144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264334144">(Dec 09 2021 at 17:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264333147">said</a>:</p>
<blockquote>
<p>Because they reside in different universes</p>
</blockquote>
<p>But why can <code>Π x : α</code> eat <code>p : α -&gt; Sort 0</code> which <code>Σ x : α</code> rejects?</p>



<a name="264334301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264334301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264334301">(Dec 09 2021 at 17:18)</a>:</h4>
<p><code>sigma</code> rejects that because it's defined to reject that</p>



<a name="264334311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264334311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264334311">(Dec 09 2021 at 17:18)</a>:</h4>
<p><code>psigma</code>, <code>Σ' x, p x</code> doesn't, but is more annoying to work with</p>



<a name="264334364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264334364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264334364">(Dec 09 2021 at 17:18)</a>:</h4>
<p>Yes, I see, but why is <code>Π</code> ok with that?</p>



<a name="264334422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264334422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264334422">(Dec 09 2021 at 17:19)</a>:</h4>
<p>Because it's not defined like sigma?</p>



<a name="264334468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264334468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264334468">(Dec 09 2021 at 17:19)</a>:</h4>
<p>The similarities end with the syntax being similar</p>



<a name="264334582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264334582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264334582">(Dec 09 2021 at 17:20)</a>:</h4>
<p>Is there a fundamental reason why <code>Π</code> can be more versatile than <code>Σ</code> is?</p>



<a name="264334879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264334879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264334879">(Dec 09 2021 at 17:22)</a>:</h4>
<p>maybe this helps compare the exact differences:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="c1">-- the most general form of pi, just so that we can #check</span>
<span class="kd">def</span> <span class="k">Pi</span><span class="bp">'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">x</span> <span class="n">i</span>

<span class="k">#check</span> <span class="bp">@</span><span class="k">Pi</span><span class="bp">'.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span>    <span class="c1">-- Π {α : Sort u}, (α → Sort v) → Sort (imax u v)</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">psigma.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="c1">-- Π {α : Sort u}, (α → Sort v) → Sort (max 1 u v)</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">sigma.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span>  <span class="c1">-- Π {α : Type u}, (α → Type v) → Type (max u v)</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">Exists.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span>   <span class="c1">-- Π {α : Sort u}, (α → Prop)   → Prop</span>
</code></pre></div>



<a name="264335845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264335845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264335845">(Dec 09 2021 at 17:28)</a>:</h4>
<p>Oh, it seems to be the magic inside <code>imax</code>.</p>



<a name="264335925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264335925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264335925">(Dec 09 2021 at 17:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264334582">said</a>:</p>
<blockquote>
<p>Is there a fundamental reason why <code>Π</code> can be more versatile than <code>Σ</code> is?</p>
</blockquote>
<p>That's just how the type theory works. Inductive types have to abide by certain rules to keep things from being inconsistent.</p>



<a name="264336948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264336948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264336948">(Dec 09 2021 at 17:36)</a>:</h4>
<p>A variation on <code>psigma</code> with the type <code>Π {α : Sort u}, (α → Sort v) → Sort (imax u v)</code> would not be desirable, because it would not have a first projection (like exists) and would also not have proof irrelevance, so it is sort of the worst of both worlds</p>



<a name="264337426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264337426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264337426">(Dec 09 2021 at 17:39)</a>:</h4>
<p><code>(p)sigma</code> and <code>exists</code> have fundamentally different ways of getting information out of them: <code>sigma</code> has first and second projections, while <code>Exists</code> uses <code>Exists.rec</code> which only works for proving propositions, but on the other hand satisfies equations like <code>\&lt;0, trivial\&gt; = \&lt;1, trivial\&gt;</code> (as elements of, say, <code>\exists n : nat, true</code>)</p>



<a name="264337443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264337443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264337443">(Dec 09 2021 at 17:39)</a>:</h4>
<p><del>(I assume you meant "like (p)sigma" and not "like exists")</del> words are hard, "would not (have X like Y)" vs "(would not have X) like Y"</p>



<a name="264337599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264337599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264337599">(Dec 09 2021 at 17:40)</a>:</h4>
<p>the parenthetical refers to the previous 6 words, not just the last 2</p>



<a name="264338638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264338638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264338638">(Dec 09 2021 at 17:47)</a>:</h4>
<p>Can you please check for me that I extracted the main informations correctly?<br>
<a href="/user_uploads/3121/YiVyy1H7BjkVRBGb5l4_fuLL/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/YiVyy1H7BjkVRBGb5l4_fuLL/image.png" title="image.png"><img src="/user_uploads/3121/YiVyy1H7BjkVRBGb5l4_fuLL/image.png"></a></div>



<a name="264339261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264339261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264339261">(Dec 09 2021 at 17:51)</a>:</h4>
<p>"they don't have a constructor; they live kind of beyond the system" is inaccurate. <code>Pi</code> has a constructor, it is <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.pi">docs#expr.pi</a> . It is a builtin term constructor, unlike all other constructors which use <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.const">docs#expr.const</a> for various choices of constant</p>



<a name="264339284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264339284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264339284">(Dec 09 2021 at 17:51)</a>:</h4>
<p>Maybe it would also help to get rid of the type theory language. Let's just define a "proposition" to be a set with at most one element. If we form the product of a bunch of propositions, the result is again a proposition. However if we form the sum of a bunch of propositions, there's no reason why the result should have at most one element. Then I can decide to either truncate it to make a proposition again, or not. That's the difference between <code>Exists</code> and <code>sigma</code>.</p>



<a name="264339489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264339489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264339489">(Dec 09 2021 at 17:53)</a>:</h4>
<p><code>α × β</code> is not shorthand syntax for <code>Σ _ : α, β</code>. The former uses <code>prod</code> and the latter uses <code>sigma</code>. (Yes, this is not consistent with the behavior for <code>→</code> / <code>∀</code>.)</p>



<a name="264340357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264340357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264340357">(Dec 09 2021 at 17:58)</a>:</h4>
<p>But it could have been, right? It just would have been annoying to use had it been defined that way.</p>



<a name="264340434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264340434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264340434">(Dec 09 2021 at 17:59)</a>:</h4>
<p>Yes, you could conceivably define it that way. You would probably want more builtin sugar for it</p>



<a name="264340519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264340519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264340519">(Dec 09 2021 at 17:59)</a>:</h4>
<p>I'm sure there are examples where the type inference is not as good</p>



<a name="264342036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264342036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264342036">(Dec 09 2021 at 18:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264339261">said</a>:</p>
<blockquote>
<p><code>Pi</code> has a constructor, it is <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.pi">docs#expr.pi</a> .</p>
</blockquote>
<p>I think introducing <code>meta inductive expr</code> sort of overloads the statement "Pi has a constructor" in a way that might not be helpful to someone learning the type theory.</p>



<a name="264343186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264343186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264343186">(Dec 09 2021 at 18:15)</a>:</h4>
<p>E.g. TPIL introduces Pi as something that's explicitly not an inductive: <code>in Lean’s library, every concrete type other than the universes and every type constructor other than Pi is an instance of a general family of type constructions known as inductive types</code>.</p>



<a name="264343223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264343223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264343223">(Dec 09 2021 at 18:15)</a>:</h4>
<p>True. But "beyond the system" was the main thing I wanted to address. It is more primitive than usual, but still something in the system</p>



<a name="264343739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264343739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264343739">(Dec 09 2021 at 18:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264339261">said</a>:</p>
<blockquote>
<p>"they don't have a constructor; they live kind of beyond the system" is inaccurate. <code>Pi</code> has a constructor, it is <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.pi">docs#expr.pi</a> . It is a builtin term constructor, unlike all other constructors which use <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.const">docs#expr.const</a> for various choices of constant</p>
</blockquote>
<p>What does <code>(elaborated : bool := tt)</code> mean, please?</p>



<a name="264344045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264344045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264344045">(Dec 09 2021 at 18:20)</a>:</h4>
<p>To simplify representation, lean uses the same inductive type for both <code>expr := expr tt</code> and <code>pexpr := expr ff</code>, but <code>pexpr</code> (pre-expression) is only used during parsing and you can ignore it for the purpose of learning the theory</p>



<a name="264344428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264344428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264344428">(Dec 09 2021 at 18:23)</a>:</h4>
<p>Thank you all for your replies! It will take me a longer while to understand it and summarize it. Until then, my study notes will contain those mistakes that were pointed out above.</p>



<a name="264461198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264461198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264461198">(Dec 10 2021 at 15:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="228466">Chris B</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264343186">said</a>:</p>
<blockquote>
<p>E.g. TPIL introduces Pi as something that's explicitly not an inductive: <code>in Lean’s library, every concrete type other than the universes and every type constructor other than Pi is an instance of a general family of type constructions known as inductive types</code>.</p>
</blockquote>
<p>This sentence doesn't refer to the meaning of the word instance that is connected to typeclasses, does it?</p>



<a name="264465640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264465640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264465640">(Dec 10 2021 at 15:49)</a>:</h4>
<p>Current version of my notes contains:<br>
<a href="/user_uploads/3121/PdBSOHHdE6O4kqq7oNyWL5fF/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/PdBSOHHdE6O4kqq7oNyWL5fF/image.png" title="image.png"><img src="/user_uploads/3121/PdBSOHHdE6O4kqq7oNyWL5fF/image.png"></a></div>



<a name="264466071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264466071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264466071">(Dec 10 2021 at 15:51)</a>:</h4>
<p>It's hard to rell from the pixels, but you seem to be using <code>(a, b)</code> as notation for <code>sigma.mk</code>, whereas it's actually notation for <code>prod.mk</code>. Maybe those are angle brackets and the image is too small to tell though.</p>



<a name="264466234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264466234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264466234">(Dec 10 2021 at 15:52)</a>:</h4>
<p>Is <code>z = (a, b)</code> incorrect?</p>



<a name="264467091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264467091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264467091">(Dec 10 2021 at 15:58)</a>:</h4>
<p>Eh. The tuple notation in parenthesis is for <code>prod</code>, right? For <code>sigma</code>, I should have used chevrons (langle and rangle), right?</p>



<a name="264471704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264471704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264471704">(Dec 10 2021 at 16:28)</a>:</h4>
<p>"chevrons" work for all inductive types with one constructor, so both prod and sigma. <code>(_, _, ...)</code> is only for <code>prod</code></p>



<a name="264472132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264472132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264472132">(Dec 10 2021 at 16:31)</a>:</h4>
<p>Can I do a product of three types without nesting them? Or is it a property of the ˙( )˙ that it gets flattened?</p>



<a name="264473155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264473155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264473155">(Dec 10 2021 at 16:39)</a>:</h4>
<p>The chevrons associate to the right, so <code>\&lt;_,\&lt;_,_\&gt;\&gt;</code> is the same as <code>\&lt;_,_,_\&gt;</code>.</p>



<a name="264473273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264473273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264473273">(Dec 10 2021 at 16:40)</a>:</h4>
<p>Does the same apply for parentheses?</p>



<a name="264473294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264473294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264473294">(Dec 10 2021 at 16:40)</a>:</h4>
<p>I would imagine so...</p>



<a name="264473373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264473373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264473373">(Dec 10 2021 at 16:40)</a>:</h4>
<p>As long as you don't define your triple product at <code>(A \x B) \x C</code>, but rather use <code>A \x B \x C</code>, you should be able to write <code>(a,b,c)</code> (or with <code>\&lt;...\&gt;</code>)</p>



<a name="264473676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264473676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264473676">(Dec 10 2021 at 16:43)</a>:</h4>
<p>Oh yes. And \times associates in the same way. For example <code>int × Type × nat</code> is a short for <code>int × (Type × nat)</code>.</p>



<a name="264477435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264477435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264477435">(Dec 10 2021 at 17:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264461198">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="228466">Chris B</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264343186">said</a>:</p>
<blockquote>
<p>E.g. TPIL introduces Pi as something that's explicitly not an inductive: <code>in Lean’s library, every concrete type other than the universes and every type constructor other than Pi is an instance of a general family of type constructions known as inductive types</code>.</p>
</blockquote>
<p>This sentence doesn't refer to the meaning of the word instance that is connected to typeclasses, does it?</p>
</blockquote>
<p>It does not.</p>



<a name="264482490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264482490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264482490">(Dec 10 2021 at 17:49)</a>:</h4>
<p>Did I get it right, please?<br>
<a href="/user_uploads/3121/wC_6-9QTQ_TQGk6tjClPb3oi/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/wC_6-9QTQ_TQGk6tjClPb3oi/image.png" title="image.png"><img src="/user_uploads/3121/wC_6-9QTQ_TQGk6tjClPb3oi/image.png"></a></div>



<a name="264485709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264485709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264485709">(Dec 10 2021 at 18:11)</a>:</h4>
<p>The parentheses don't stand for <code>g.mk</code>, but for <code>prod.mk</code>. In your notations <code>g</code> is a term of a product type, the prefix is the name of the type, not the term</p>



<a name="264486762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264486762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264486762">(Dec 10 2021 at 18:15)</a>:</h4>
<p>Oh, thank you!<br>
Is it all right now?<br>
<a href="/user_uploads/3121/Aeh923TmsG0URUtp4_zcvN8N/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/Aeh923TmsG0URUtp4_zcvN8N/image.png" title="image.png"><img src="/user_uploads/3121/Aeh923TmsG0URUtp4_zcvN8N/image.png"></a></div>



<a name="264487366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264487366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264487366">(Dec 10 2021 at 18:19)</a>:</h4>
<p>Well, conceptually at least yes, if you just want to use <code>g</code> to simplify the notation in your notes.</p>



<a name="264487542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264487542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264487542">(Dec 10 2021 at 18:21)</a>:</h4>
<p>But keep in mind that won't work as actual Lean code. If you were to define <code>g := prod</code>, then <code>g.mk</code> still wouldn't exist, only <code>prod.mk</code></p>



<a name="264488060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264488060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264488060">(Dec 10 2021 at 18:24)</a>:</h4>
<p>I am not sure whether I understand you. In my snippet,  I have <code>g = τ × δ</code> which is <code>g = prod τ δ</code> and not just <code>g = prod</code>.</p>



<a name="264488210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264488210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264488210">(Dec 10 2021 at 18:25)</a>:</h4>
<p>Does <code>g.mk</code> exists then? Or how can I write a term of the type <code>g</code> without the syntactic sugar?</p>



<a name="264488353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264488353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264488353">(Dec 10 2021 at 18:26)</a>:</h4>
<p>No, only <code>prod.mk</code> exists. You'd write <code>prod.mk bar baz</code></p>



<a name="264488441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264488441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264488441">(Dec 10 2021 at 18:27)</a>:</h4>
<p>:-o</p>



<a name="264488515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264488515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264488515">(Dec 10 2021 at 18:27)</a>:</h4>
<p>Does <code>h.mk</code> exist?</p>



<a name="264488618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264488618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264488618">(Dec 10 2021 at 18:28)</a>:</h4>
<p>Also note that there is only one <code>prod.mk</code> for all <code>\tau</code> and <code>\delta</code>, it's not that for each two types you get some other <code>(prod \tau \delta).mk</code> (that's what your notation would suggest to me)</p>



<a name="264488759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264488759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264488759">(Dec 10 2021 at 18:29)</a>:</h4>
<p>No, for Sigma it's the same thing, and probably for any such type definition</p>



<a name="264488983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264488983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264488983">(Dec 10 2021 at 18:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="329243">Horatiu Cheval</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264488759">said</a>:</p>
<blockquote>
<p>No, for Sigma it's the same thing, and probably for any such type definition</p>
</blockquote>
<p>Are you replying to <code>h.mk</code> here?</p>



<a name="264489224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264489224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264489224">(Dec 10 2021 at 18:32)</a>:</h4>
<p>Yes</p>



<a name="264489257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264489257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264489257">(Dec 10 2021 at 18:33)</a>:</h4>
<p>Ah. Thanks a lot!</p>



<a name="264490755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264490755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264490755">(Dec 10 2021 at 18:44)</a>:</h4>
<p>When I write <code>prod.mk</code> it works but when I write <code>Σ.mk</code> it doesn't work. How can I invoke the constructor explicitly (without chevrons)?</p>



<a name="264490800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264490800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264490800">(Dec 10 2021 at 18:44)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/sigma.mk">docs#sigma.mk</a></p>



<a name="264492598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264492598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264492598">(Dec 10 2021 at 18:58)</a>:</h4>
<p>I wrote:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">constant</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="n">a</span>
<span class="k">#check</span> <span class="n">sigma.mk</span> <span class="n">a</span> <span class="n">b</span>
<span class="k">#check</span> <span class="bp">Σ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="o">,</span> <span class="n">β</span> <span class="n">x</span>
</code></pre></div>
<p>The output is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">sigma</span> <span class="n">β</span>
<span class="bp">Σ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">Type</span>
</code></pre></div>
<p>By looking at it, I don't know what the relationship between them is. So I added:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mytype</span> <span class="o">:=</span> <span class="bp">Σ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="o">,</span> <span class="n">β</span> <span class="n">x</span>
<span class="k">#check</span> <span class="n">sigma.mk</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>
<p>Unfortunately, the output is again:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">sigma</span> <span class="n">β</span>
</code></pre></div>
<p>How can I obtain <code>(sigma.mk a b) : mytype</code> please?</p>



<a name="264493073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264493073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264493073">(Dec 10 2021 at 19:01)</a>:</h4>
<p>Does <code>#check (sigma.mk a b : mytype)</code> work? In any case, the thing is that you have to explicitly type-annotate it</p>



<a name="264493287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264493287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264493287">(Dec 10 2021 at 19:02)</a>:</h4>
<p>By <code>#check (sigma.mk a b : mytype)</code> I obtain <code>⟨a, b⟩ : Σ (x : α), β x</code> which makes me more happy than the previous thing.</p>



<a name="264494099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264494099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264494099">(Dec 10 2021 at 19:09)</a>:</h4>
<p>What would happen if, for concrete types, I would end up with <code>β a</code> being <code>int</code> for example? Would it still know that a term constructed by <code>sigma.mk a 5</code> is of the type <code>mytype</code>?</p>



<a name="264494496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264494496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264494496">(Dec 10 2021 at 19:12)</a>:</h4>
<p>The way it's written here no, I don't think you will be able to do <code>def x : mtytype := sigma.mk a 5</code>, because <code>mytype</code> is just <code>Type</code>, it's not parametrized. In your definition <code>\alpha</code> and <code>\beta</code> are fixed constants, so they argument for the type <code>mytype</code></p>



<a name="264494531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264494531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264494531">(Dec 10 2021 at 19:12)</a>:</h4>
<p>You would be able to do that if used <code>variable</code> instead of <code>constant</code> for example</p>



<a name="264495087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264495087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264495087">(Dec 10 2021 at 19:17)</a>:</h4>
<p>Is it now correct?<br>
<a href="/user_uploads/3121/6xvEjccEtaL16m3zADV3SzHV/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/6xvEjccEtaL16m3zADV3SzHV/image.png" title="image.png"><img src="/user_uploads/3121/6xvEjccEtaL16m3zADV3SzHV/image.png"></a></div>



<a name="264495648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264495648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264495648">(Dec 10 2021 at 19:21)</a>:</h4>
<p>I originally (wrongly) assumed that I could use <code>mytype.mk</code> and I would get (when provided correct arguments) a term of the type <code>mytype</code>. Now I can see that I cannot do it.</p>
<p>As a result, it makes me uncomfortable that I must write e.g. <code>sigma.mk 5 9</code> but there are many possible sigma types which my term could be an instance of.</p>



<a name="264495849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264495849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264495849">(Dec 10 2021 at 19:23)</a>:</h4>
<p>It seems correct</p>



<a name="264495868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264495868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264495868">(Dec 10 2021 at 19:23)</a>:</h4>
<p>But I don't really understand your last statement</p>



<a name="264495993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264495993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264495993">(Dec 10 2021 at 19:24)</a>:</h4>
<p>The reason is that there are many possibly functions  that send <code>5</code> to <code>nat</code></p>



<a name="264496203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264496203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264496203">(Dec 10 2021 at 19:26)</a>:</h4>
<p>Let's say I have <code>f : int -&gt; Type</code> and <code>g : int -&gt; Type</code>. Let's say they agree on the value of <code>f 5 = nat = g 5</code>. Now I call <code>sigma.mk 5 9</code>. Do I have an instance of <code>sigma f</code> or of <code>signa g</code>?</p>



<a name="264496231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264496231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264496231">(Dec 10 2021 at 19:26)</a>:</h4>
<p>Does that even typecheck? It shouldn't</p>



<a name="264496243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264496243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264496243">(Dec 10 2021 at 19:26)</a>:</h4>
<p>I'm talking about <code>sigma.mk 5 9</code></p>



<a name="264496254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264496254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264496254">(Dec 10 2021 at 19:26)</a>:</h4>
<p>Because <code>9</code> is not a function</p>



<a name="264496374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264496374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264496374">(Dec 10 2021 at 19:27)</a>:</h4>
<p>Why should I put function on the position of <code>9</code> in my expression? I have <code>f 5 = nat</code> and not something like <code>f 5 = (nat -&gt; nat)</code>.</p>



<a name="264496462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264496462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264496462">(Dec 10 2021 at 19:28)</a>:</h4>
<p>In general you need to use type annotations to tell lean what the type family is when defining a term of a sigma type.</p>



<a name="264496559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264496559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264496559">(Dec 10 2021 at 19:29)</a>:</h4>
<p>Should I write something like <code>let myvalue := (sigma.mk 5 9 : mytype)</code> ?</p>



<a name="264496567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264496567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264496567">(Dec 10 2021 at 19:29)</a>:</h4>
<p>Oh right, sorry. I thought you meant <code>sigma 5 9</code></p>



<a name="264496601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264496601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264496601">(Dec 10 2021 at 19:29)</a>:</h4>
<p>What's <code>mytype</code>?</p>



<a name="264496840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264496840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264496840">(Dec 10 2021 at 19:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264496601">said</a>:</p>
<blockquote>
<p>What's <code>mytype</code>?</p>
</blockquote>
<p>Say <code>Σ x : int, f x</code>.</p>



<a name="264496857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264496857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264496857">(Dec 10 2021 at 19:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">⟩</span>
<span class="kd">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">does_not_typecheck</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">=</span> <span class="n">bar</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="264496982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264496982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264496982">(Dec 10 2021 at 19:32)</a>:</h4>
<p>I would write <code>let myvalue : mytype := ...</code></p>



<a name="264497012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264497012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264497012">(Dec 10 2021 at 19:32)</a>:</h4>
<p>If you want to define something inline, then you can do <code>(... : mytype)</code></p>



<a name="264497469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264497469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264497469">(Dec 10 2021 at 19:36)</a>:</h4>
<p>Maybe a better example: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">ℤ</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">ℕ</span>

<span class="kd">def</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">ℤ</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">sigma</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)⟩</span>
<span class="kd">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">sigma</span> <span class="n">g</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)⟩</span>

<span class="kd">lemma</span> <span class="n">also_does_not_typecheck</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">=</span> <span class="n">bar</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="264497550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264497550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264497550">(Dec 10 2021 at 19:37)</a>:</h4>
<p>Thank you! Your last example explains a lot!</p>



<a name="264499061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264499061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264499061">(Dec 10 2021 at 19:51)</a>:</h4>
<p>I still wasn't technically correct, was I?<br>
<a href="/user_uploads/3121/brenY4pdggN3GD1MAgd23HMc/image.png">image.png</a> <br>
Here <code>(prod.mk bar baz)</code> automatically becomes a term of the type <code>τ × δ</code> hence it can be used as an argument of the type <code>g</code>. This isn't true for <code>(sigma.mk bar baz)</code> because I would have to explicitly say that I want a term of the type <code>h</code> (or something definitionally equal to <code>h</code>).</p>
<div class="message_inline_image"><a href="/user_uploads/3121/brenY4pdggN3GD1MAgd23HMc/image.png" title="image.png"><img src="/user_uploads/3121/brenY4pdggN3GD1MAgd23HMc/image.png"></a></div>



<a name="264499195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264499195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264499195">(Dec 10 2021 at 19:52)</a>:</h4>
<p>The type will generally not be inferred from context if you only write <code>sigma.mk a b</code> or <code>\&lt;a,b\&gt;</code>.</p>



<a name="264499268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264499268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264499268">(Dec 10 2021 at 19:52)</a>:</h4>
<p>But it will be inferred for <code>(a,b)</code>, right?</p>



<a name="264499274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264499274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264499274">(Dec 10 2021 at 19:52)</a>:</h4>
<p>Even if you write <code>sigma.mk a b</code>, there will be a metavariable because lean wouldn't know what the type family is without further hints</p>



<a name="264499327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264499327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264499327">(Dec 10 2021 at 19:53)</a>:</h4>
<p>For <code>(a,b)</code> you will get a term of the product, and since lean knows the type of <code>a</code> and <code>b</code>, the type of <code>(a,b)</code> is inferred correctly.</p>



<a name="264499363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264499363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264499363">(Dec 10 2021 at 19:53)</a>:</h4>
<p>For <code>prod.mk a b</code> I will automatically get inferred the right type.</p>



<a name="264499870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264499870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264499870">(Dec 10 2021 at 19:57)</a>:</h4>
<p>Try this out in a vscode and see what happens:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="n">sigma.mk</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">ℕ</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">bar</span> <span class="o">:=</span> <span class="n">sigma.mk</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
</code></pre></div>



<a name="264500079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264500079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264500079">(Dec 10 2021 at 19:59)</a>:</h4>
<p>Only the first one passes the typecheck!</p>



<a name="264500808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264500808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264500808">(Dec 10 2021 at 20:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264340519">said</a>:</p>
<blockquote>
<p>I'm sure there are examples where the type inference is not as good</p>
</blockquote>
<p>Is [the thing we discussed today (above)] an example of what you were talking about?</p>



<a name="264500948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264500948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264500948">(Dec 10 2021 at 20:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264499195">said</a>:</p>
<blockquote>
<p>The type will generally not be inferred from context if you only write <code>sigma.mk a b</code> or <code>\&lt;a,b\&gt;</code>.</p>
</blockquote>
<p>highlight 1</p>



<a name="264500958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264500958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264500958">(Dec 10 2021 at 20:06)</a>:</h4>
<p>(deleted)</p>



<a name="264501026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264501026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264501026">(Dec 10 2021 at 20:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264499327">said</a>:</p>
<blockquote>
<p>For <code>(a,b)</code> you will get a term of the product, and since lean knows the type of <code>a</code> and <code>b</code>, the type of <code>(a,b)</code> is inferred correctly.</p>
</blockquote>
<p>highlight 2</p>



<a name="264501243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264501243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264501243">(Dec 10 2021 at 20:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> To save you some scrolling and reading, just have a look at the two comments (highlight 1 &amp; 2) above. Is it the motivation you were talking about — sigma could be used for prod but the type inference would be worse.</p>



<a name="264530086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264530086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264530086">(Dec 11 2021 at 00:45)</a>:</h4>
<p>Apologies to derail slightly with a tangential question -- <span class="user-mention" data-user-id="417654">@Martin Dvořák</span> are you using some mind/concept mapping software in the screenshots? If so, which?</p>



<a name="264539901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264539901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264539901">(Dec 11 2021 at 04:10)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span> Sure, yes that's an example. I haven't seen the trick with using a beta redex for the second pair element before, but it makes sense that it would work</p>



<a name="264689268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Existential%20quantifier%20and%20Sigma%20type/near/264689268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type.html#264689268">(Dec 13 2021 at 10:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="128280">Wojciech Nawrocki</span> <a href="#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264530086">said</a>:</p>
<blockquote>
<p>Apologies to derail slightly with a tangential question -- <span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> are you using some mind/concept mapping software in the screenshots? If so, which?</p>
</blockquote>
<p>Yes, it is OrgPad.<br>
<a href="https://orgpad.com/">https://orgpad.com/</a></p>
<p>I will be glad if you give me any comments on my (current version of) study notes about Lean.<br>
<a href="https://orgpad.com/s/ZBGjrzoGIBb">https://orgpad.com/s/ZBGjrzoGIBb</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
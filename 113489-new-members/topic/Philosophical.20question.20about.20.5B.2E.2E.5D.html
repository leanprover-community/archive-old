---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html">Philosophical question about [..]</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="252068940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252068940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252068940">(Sep 05 2021 at 11:05)</a>:</h4>
<p>I have a philosophical question regarding Lean. Do you consider <code>[..]</code> to be a syntax for dependency injection?</p>



<a name="252073569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252073569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252073569">(Sep 05 2021 at 12:30)</a>:</h4>
<p>what syntax are you talking about? <code>[..]</code> isn't an operator, are you talking about instance arguments?</p>



<a name="252073773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252073773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252073773">(Sep 05 2021 at 12:34)</a>:</h4>
<p>Yes, instance arguments; sorry for not making it clear.</p>



<a name="252073887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252073887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252073887">(Sep 05 2021 at 12:35)</a>:</h4>
<p>I forgot that <code>[..]</code> has more meanings in Lean.</p>



<a name="252073891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252073891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252073891">(Sep 05 2021 at 12:35)</a>:</h4>
<p>also dependency injection sounds like a vague buzzword and reading the article on it didn't help</p>



<a name="252073970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252073970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252073970">(Sep 05 2021 at 12:36)</a>:</h4>
<p>I'm sure there is a way to interpret the term to make the answer 'yes'</p>



<a name="252074590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252074590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252074590">(Sep 05 2021 at 12:47)</a>:</h4>
<p>I'd argue <code>[some_typeclass]</code> is no more "dependency injection" than <code>(h : some_typeclass)</code> is</p>



<a name="252074683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252074683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252074683">(Sep 05 2021 at 12:49)</a>:</h4>
<p>It was meant as a philosophical question; the absence of clear definition of "dependency injection" is not a bug.</p>
<p>I was talking about stuff like this.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">T</span><span class="o">]</span> <span class="o">:</span> <span class="bp">&lt;</span><span class="n">something</span><span class="bp">&gt;</span>
</code></pre></div>
<p>Here, we just assume that we get a guarantee that <code>T</code> is inhabited; we get it from somewhere. And if there are more instances that match the pattern, it is not a problem. We don't care what term <code>default T</code> is. We only need to know that <code>default T</code> exists and that, if we call <code>default T</code> twice in our proof, the returned terms will be equal to each other.</p>



<a name="252074761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252074761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252074761">(Sep 05 2021 at 12:50)</a>:</h4>
<p>We may or may not care what <code>default T</code> is. For instance you can have another argument that bounds its value</p>



<a name="252074789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252074789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252074789">(Sep 05 2021 at 12:51)</a>:</h4>
<p>but like Eric said the situation is exactly the same for regular arguments to a function</p>



<a name="252074864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252074864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252074864">(Sep 05 2021 at 12:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D/near/252074590">said</a>:</p>
<blockquote>
<p>I'd argue <code>[some_typeclass]</code> is no more "dependency injection" than <code>(h : some_typeclass)</code> is</p>
</blockquote>
<p>In the latter case, we have to say explicitly what instance of <code>some_typeclass</code> we are using, don't we?</p>



<a name="252075018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252075018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252075018">(Sep 05 2021 at 12:55)</a>:</h4>
<p>we say it either way, but one comes with some automation to fill the argument. You can use automation to fill a regular argument too, or conversely specify a typeclass argument; and you are still not absolved of the responsibility to care what argument was inferred <em>in fact</em> when you let the automation take over, because it can directly influence the result or the side goals</p>



<a name="252075323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252075323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252075323">(Sep 05 2021 at 13:00)</a>:</h4>
<p>Would you say that the automatic filling of <code>{T : Type}</code> has the same level of vagueness as the automatic filling of <code>[inhabited T]</code> per se? Do they both give you an urge to check "what the automation inferred here" if the call to <code>foo</code> ends up being in your production code?</p>



<a name="252075462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252075462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252075462">(Sep 05 2021 at 13:03)</a>:</h4>
<p>the automatic filling of <code>{T}</code> doesn't require cross checking, because I know that if it was able to fill the argument, then it put "what it had to" there, there is no possibility of me being able to put anything else and still get a type-correct term</p>



<a name="252075525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252075525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252075525">(Sep 05 2021 at 13:04)</a>:</h4>
<p>unless I care to put something else that is definitionally equal in that slot for some reason</p>



<a name="252075620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252075620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252075620">(Sep 05 2021 at 13:06)</a>:</h4>
<p>Thank you for your explanation!</p>



<a name="252075630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252075630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252075630">(Sep 05 2021 at 13:06)</a>:</h4>
<p>with instance arguments, the degree to which typeclass inference can get the "wrong" result compared to what the user was hoping for depends on the class (whether it is a Prop or subsingleton, and whether there are different kinds of instances that are meaningfully different in the system)</p>



<a name="252075758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252075758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252075758">(Sep 05 2021 at 13:09)</a>:</h4>
<p>And now, less philosophically, more practically...</p>
<p>On the left side of <code>:</code>, there is a distinction between <code>{}</code> vs <code>[]</code> but on the right side, it is always <code>()</code> isn't it?</p>



<a name="252075960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252075960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252075960">(Sep 05 2021 at 13:13)</a>:</h4>
<p>you can use any binder type using something like <code>: \forall {T : Type}, ...</code></p>



<a name="252076254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252076254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252076254">(Sep 05 2021 at 13:18)</a>:</h4>
<p>what is the point of instance binders after a ∀ if you need to <code>exactI</code> all the time? e.g.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}:</span> <span class="bp">∀</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">],</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="n">finset.card_univ</span>
</code></pre></div>



<a name="252076467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252076467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252076467">(Sep 05 2021 at 13:22)</a>:</h4>
<p>instance binders have no effect inside a theorem, they only affect users of the theorem</p>



<a name="252076561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252076561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252076561">(Sep 05 2021 at 13:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D/near/252075960">said</a>:</p>
<blockquote>
<p>you can use any binder type using something like <code>: \forall {T : Type}, ...</code></p>
</blockquote>
<p>Is there a chapter in TPIL or any other source about this?</p>



<a name="252076600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252076600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252076600">(Sep 05 2021 at 13:24)</a>:</h4>
<p><span class="user-mention" data-user-id="284160">@Eric Rodriguez</span> For the reason you mention, it is generally preferable to keep instance arguments left of the colon, but sometimes you don't have any choice, for instance if your statement has more quantifier complexity (e.g. <code>\exists k, \forall f [Ck_map f k], ...</code></p>



<a name="252076647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252076647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252076647">(Sep 05 2021 at 13:26)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span> what more would you like to know? <code>\forall</code> takes a list of binders with just the same syntax as binders left of the colon</p>



<a name="252076701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252076701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252076701">(Sep 05 2021 at 13:26)</a>:</h4>
<p>I don't have any particular recommendations, assuming this isn't already covered in <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a></p>



<a name="252087435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252087435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252087435">(Sep 05 2021 at 16:43)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span> If you imagine that to evaluate a function, you have to instantiate a class and set all its arguments before calling a <code>run()</code> method, then you could think of Lean instance arguments as being <code>@Inject</code>-annotated setters/members.  Lean's typeclass system, from this point of view, is injecting dependencies from its database of instances, with the added fun that almost all of it is polymorphic (akin to dependency injection in Java with generics).</p>
<p>A difference is that Lean's system is to provide standard implementations of things that we wouldn't want to explicitly name each time, but as I'd understood it, dependency injection is more for wiring together systems through configuration.  No one will later reconfigure the "default T" instance for a given "T" in this second sense.</p>



<a name="252134358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252134358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252134358">(Sep 06 2021 at 06:59)</a>:</h4>
<p>Does Lean sometimes provide <code>default T</code> automatically even when <code>T</code> is a custom type?</p>



<a name="252156808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252156808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252156808">(Sep 06 2021 at 10:35)</a>:</h4>
<p>No, the language itself knows nothing about <code>inhabited</code>. It's just a typeclass defined as we go along. Mathlib certainly provides many <code>inhabited T</code> instances for particular <code>T</code>. (But perhaps I'm misunderstanding your question.)</p>



<a name="252157070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252157070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252157070">(Sep 06 2021 at 10:38)</a>:</h4>
<p>Thank you. I just wanted to make sure that, if I declare my own type, it will never become inhabited on its own.</p>



<a name="252159410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Philosophical%20question%20about%20%5B..%5D/near/252159410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Philosophical.20question.20about.20.5B.2E.2E.5D.html#252159410">(Sep 06 2021 at 11:02)</a>:</h4>
<p>On the wishlist for a while has been a "derive handler" for <code>inhabited</code>, so that you could just write <code>@[derive inhabited]</code> before a definition and hope automation can take care of it.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
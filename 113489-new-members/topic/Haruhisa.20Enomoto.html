---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Haruhisa.20Enomoto.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html">Haruhisa Enomoto</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="280290481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280290481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Haruhisa Enomoto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280290481">(Apr 27 2022 at 00:36)</a>:</h4>
<p>Hello everyone, my name is <a href="https://haruhisa-enomoto.github.io/">Haruhisa Enomoto</a>. I'm a postdoc majoring in the representation of algebras (= studying modules over non-commutative rings).<br>
I became interested in Lean from Natural number game, and I recentely proved some basic facts in ring theory in Lean which are not in mathlib now (characterizing Jacobson radical ideal and local ring in non-commutative ring).<br>
I have some questions.</p>
<ol>
<li>
<p>What level and kinds of maths is mathlib aiming at? I noticed e.g. some theorems in <a href="https://leanprover-community.github.io/100.html">100 theorems</a>  (and clearly "Liquid Tensor Experiment"!) are not in mathlib, so are there any criteria?<br>
Maybe undergrad level will be welcomed, but should graduate level math or too specialized maths be done independently from mathlib?</p>
</li>
<li>
<p>If so, how about basic non-commutative ring theory, such as Jacobson radial, non-commutative Nakayama, Artin-Wedderburn, and Hopkins-Levitzki (left artinian ring is left noetherian)?</p>
</li>
<li>Probably at least the notion of two-sided ideal and quotient ring by two-sided ideal is worth being formalized in mathlib. Are there anyone working on it?</li>
</ol>



<a name="280295962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280295962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280295962">(Apr 27 2022 at 02:13)</a>:</h4>
<p>Here's an overview of things that are in mathlib, to give you an idea: <a href="https://leanprover-community.github.io/mathlib-overview.html">https://leanprover-community.github.io/mathlib-overview.html</a></p>
<p>The criteria for mathlib inclusion is roughly (1) has anyone heard of it? (2) has it been refined enough to be library code? (for example, has everything been generalized and modularized enough? is the "API" well-designed? does it seem like it will support formalizations of related theorems?)</p>
<p>Refinement takes a good amount of work, and there is a lot of Lean code out there that's just not in mathlib <em>yet</em>. Usually people work on projects and contribute little pieces as they become ready.</p>
<p>Noncommutative algebra is definitely in scope. I've wanted to see Jacobson radicals, Jacobson-semisimple rings, and the Artin-Wedderburn theorem.</p>



<a name="280296005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280296005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280296005">(Apr 27 2022 at 02:13)</a>:</h4>
<p>There has been some discussion here on the Zulip about noncommutative algebra and how to deal with two-sided ideals. Even questions as basic as "what is the right way to talk about group representations" are still somewhat unanswered (but I think I saw a tentative(?) solution in the last week).  One popular solution to two-sided modules seems to be using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊗</mo><msup><mi>A</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">A\otimes A^{op}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span> modules. I sort of would like to see actual left and right actions (along with having certain constructions flip the side of the action in the natural way, which I think makes certain theorems in noncommutative algebra rather nice), but then you need to deal with figuring out how to make theorems about left modules also apply to right modules without lots of code duplication.  Like a <code>@[to_right]</code> attribute sort of like the <code>@[to_additive]</code>.</p>



<a name="280300370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280300370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280300370">(Apr 27 2022 at 03:40)</a>:</h4>
<p>Hi! Yes this stuff is definitely in scope for mathlib, but as Kyle says there are some surprising problems with getting it into a suitable form. I wish I knew the way forward.</p>



<a name="280305313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280305313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280305313">(Apr 27 2022 at 05:21)</a>:</h4>
<p><span class="user-mention" data-user-id="419946">@Haruhisa Enomoto</span> Welcome! I think Jacobson radical is already done (<a href="https://leanprover-community.github.io/mathlib_docs/find/ideal.jacobson">docs#ideal.jacobson</a>). Two-sided ideals, and quotients by them, are also done.</p>



<a name="280305322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280305322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280305322">(Apr 27 2022 at 05:21)</a>:</h4>
<p>The rest is very welcome, as others have said.</p>



<a name="280306406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280306406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280306406">(Apr 27 2022 at 05:44)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/ideal">docs#ideal</a> is left ideal, not two-sided, and <a href="https://leanprover-community.github.io/mathlib_docs/find/ideal.has_quotient">docs#ideal.has_quotient</a> and docs$ideal.jacobson assume <code>comm_ring</code>. <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> seems to be the latest(?)of a series of PRs to support development of noncommutative algebra.<br>
By the way, <a href="#narrow/stream/116395-maths/topic/working.20in.20namespace.20monoid/near/278297305">someone recently</a> re-formalized Ore localization of monoids (<a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/274597074">earlier formalization</a>).</p>



<a name="280307742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280307742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280307742">(Apr 27 2022 at 06:08)</a>:</h4>
<p>Ooh, my bad. I should have double checked. I thought that <a href="https://leanprover-community.github.io/mathlib_docs/find/ideal">docs#ideal</a> had been refactored to two-sided ideal some time ago.</p>



<a name="280308646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280308646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280308646">(Apr 27 2022 at 06:25)</a>:</h4>
<p>I have sometimes felt personally responsible for this "ideal = ideal of commutative ring" situation, because it was a historically early push by me and others to develop commutative algebra in Lean (when we still didn't know the answer to the question "can this system actually do MSc level commutative algebra?" back in 2017). I had thought that a more measured "Bourbaki-like" approach to ring theory (including the non-commutative case for as long as possible) might have saved us a bunch of mess later but more recently I'm wondering whether actually we got lucky, and trying to make the commutative case work earlier would have been really disspiriting.</p>
<p>I realise now that I am a bit unclear on the problems. Is it simply a reluctance on the part of people to have a bunch of code duplication, i.e. some new \bub_r for a right action and then a ton of duplicated code? Until we have an algorithm which writes this for us, is there a case for just biting the bullet like we did in category theory, where many limit files are 50% limits and then 50% colimits with the same structure? Or are there more fundamental issues with non-commutative algebra? I feel like at times I understand the problems well but then I don't think about them and forget.</p>



<a name="280310257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280310257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280310257">(Apr 27 2022 at 06:52)</a>:</h4>
<p>Right now the problem with right actions basically come down to:</p>
<ul>
<li>The <code>fails_quickly</code> linter doesn't like the typeclass instances in <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a></li>
<li>Defining <code>x •ᵣ r</code> (or <code>x &lt;• r</code> as I've suggested before) as <code>op r • x</code> runs into some minor ambiguity problems (I don't recall the example right now)</li>
<li>Inevitably we'll need right actions by nat and int, which create diamonds if we don't make add_comm_group uncomfortably bigger with new <code>rnsmul</code> and <code>rzsmul</code> fields</li>
</ul>



<a name="280316898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280316898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Haruhisa Enomoto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280316898">(Apr 27 2022 at 08:12)</a>:</h4>
<p>Thank all of you for comments! For (1), I now understand the scope of mathlib.<br>
Acutually my code is long (using lots of tactic mode) and should be refined a lot. Since I'm a newbie, I'll learn how to write good codes by read others' code.</p>
<p>For right actions, I understand first we should only consider commutative rings (since there're lots of commutative ring users than non-commutative ring!).<br>
If we consider statements about only "right" ideal or "right" modules, then we can just use the opposite ring, so maybe we don't have to care about duplication.<br>
But when considering two-sided ideals or (left R, right S)-bimodule, then I obviously want biaction framework, and cosidering bimodule is very fundamental in module theory.<br>
I see Eric Wieser's <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> built such a framework.<br>
I'm not familiar with how mathlib grows, but will this PR be available in future? What <code>fails_quickly</code> error means?</p>



<a name="280317496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280317496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280317496">(Apr 27 2022 at 08:19)</a>:</h4>
<p>(Quick aside: tactic mode is not an issue. It is used all over the place in mathlib.)<br>
I can't speak for Eric, but I think it's definitely the plan to have something like that PR get merged into mathlib. It has laid dormant a bit in the past few weeks (months?), but it can certainly be reprioritised if people are working on non-commutative ring theory again.</p>



<a name="280319310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280319310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280319310">(Apr 27 2022 at 08:39)</a>:</h4>
<p>Arguably the framework for bimodules exists (I mention it briefly in <a href="https://arxiv.org/abs/2108.10700">arxiv#2108.10700</a>), and <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> just hooks <code>algebra</code> into this framework</p>



<a name="280320097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280320097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280320097">(Apr 27 2022 at 08:47)</a>:</h4>
<p>I don't quite have the level of interest needed to dig into the linter failures, but am happy to keep resolving the merge conflicts every few months</p>



<a name="280324722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280324722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Haruhisa Enomoto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280324722">(Apr 27 2022 at 09:33)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span>   Thank you for letting me know your paper, I'll look through it, and thank you for your a lot of contribution!</p>



<a name="280325313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280325313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Haruhisa Enomoto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280325313">(Apr 27 2022 at 09:38)</a>:</h4>
<p>Then I have a (maybe general) question. If I want to contribute some ring theory using two-sided ideals now (it's just an assumption), should I use just mathlib in the current version, or use <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> in some sense?</p>



<a name="280325935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280325935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280325935">(Apr 27 2022 at 09:44)</a>:</h4>
<p>I dont think you need <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> for that</p>



<a name="280326042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280326042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280326042">(Apr 27 2022 at 09:45)</a>:</h4>
<p>You'd only need it for two-sided submodules of algebras. If you define a new <code>sub_bi_module R S M</code> type, then you can use <code>sub_bi_module R R R</code> for two-sided ideals. <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> only comes into play if you want to start talking about <code>sub_bi_module R A A</code>, and that's not interesting anyway as it's the same as <code>submodule R A</code>.</p>



<a name="280329394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280329394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Haruhisa Enomoto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280329394">(Apr 27 2022 at 10:21)</a>:</h4>
<p>OK I see, I misunderstood the aim of <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a>. Thank you.</p>



<a name="280616804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280616804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280616804">(Apr 29 2022 at 11:02)</a>:</h4>
<p>Hi Haruhisa, good to see you here. I don't have much to add to the question about what is difficult to the non-commutative setting. My impression from the times I have tried was that it is quite difficult for a beginner to do large refactors of the library, one runs into unexpected time-outs and diamonds, one is not really equipped to deal with. For example this was the case when I tried to do the task (which at the time seemed not too complicated to me) to extend the polynomial ring in one variable from being over a commutative ring to a non-commutative ring.  For possible directions, it seems to me that adding some basic notions of category theory / homological algebra is within the realm of possibility, maybe not for a total beginner, but for someone intermediate. For example, I wondered whether getting the definition of a (Quillen) exact category into mathlib could be a potential target. Then one can probably go on and add a lot of basic theory as laid out e.g. in "Exact categories in functional analysis". I mention it, because I would imagine you being interested in this as well.</p>



<a name="280620769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280620769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280620769">(Apr 29 2022 at 11:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="317890">Julian Külshammer</span> <a href="#narrow/stream/113489-new-members/topic/Haruhisa.20Enomoto/near/280616804">said</a>:</p>
<blockquote>
<p>For example this was the case when I tried to do the task (which at the time seemed not too complicated to me) to extend the polynomial ring in one variable from being over a commutative ring to a non-commutative ring. </p>
</blockquote>
<p>Wasn't this for multivariate polynomials?</p>



<a name="280620823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280620823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280620823">(Apr 29 2022 at 11:48)</a>:</h4>
<p>I agree though, this type of refactor can be a substantial amount of work</p>



<a name="280620836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280620836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280620836">(Apr 29 2022 at 11:48)</a>:</h4>
<p>None of which is particularly amenable to publication :(</p>



<a name="280630313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280630313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280630313">(Apr 29 2022 at 13:13)</a>:</h4>
<p>I don't quite remember, so you might be right that it was rather polynomial ring in commuting variables over a non-commutative ring.</p>



<a name="280735500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280735500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Haruhisa Enomoto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280735500">(Apr 30 2022 at 13:02)</a>:</h4>
<p>Now I wrote a code about Jacobson radical and local ring for the noncommutative setting, which is available at my solo Github page:<br>
<a href="https://github.com/haruhisa-enomoto/lean-noncommutative-ring/blob/master/src/nc_jacobson_ideal.lean">https://github.com/haruhisa-enomoto/lean-noncommutative-ring/blob/master/src/nc_jacobson_ideal.lean</a><br>
This contains:</p>
<ul>
<li>The intersection of all maximal left ideals (Jacobson radical) coincides with that of all maximal right ideals (expressed via opposite ring)</li>
<li>The famous characterization of an elements in the Jacobson radical.</li>
<li>A ring has a unique maximal left ideal (nc-local) iff it has a unique maximal right ideal (expressed via opposite ring).</li>
<li>The famous characterization of nc-local rings.</li>
</ul>
<p>Would it be worth contributing to mathlib?</p>



<a name="280735804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280735804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280735804">(Apr 30 2022 at 13:10)</a>:</h4>
<p>This looks really well written and absolutely the sort mathematics that mathlib is interested in. So I would say definitely yes it is worth contributing.</p>



<a name="280735811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280735811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280735811">(Apr 30 2022 at 13:11)</a>:</h4>
<p>Wooah that code looks really great! Well done! Have you been using Lean long? I am not an expert in the non-commutative side of things in Lean (all I know is that there are subtleties which I don't understand) but my gut feeling is that this stuff would be very much in scope.</p>



<a name="280735894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280735894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280735894">(Apr 30 2022 at 13:13)</a>:</h4>
<p>Could be mistaken for a mathlib file! Congrats!</p>



<a name="280735994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280735994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280735994">(Apr 30 2022 at 13:15)</a>:</h4>
<p>Little trick, you can use "dot notation" on your lemmas if you name them correctly. If <code>hu : is_unit u</code>, then to get <code>is_unit (op u)</code> you must do <code>is_unit_op_of_is_unit hu</code>. Yuck, too long. If you instead name it <code>is_unit.op</code>, then <code>hu.op</code> will do. Much shorter, and doesn't need brackets around.</p>



<a name="280757662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280757662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Haruhisa Enomoto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280757662">(Apr 30 2022 at 21:40)</a>:</h4>
<p>Thank you! So could someone give me access to mathlib repository? Github name is haruhisa-enomoto.<br>
And maybe there are two ways. First is to create a new file, second is to add noncommutative parts to <a href="https://github.com/leanprover-community/mathlib/blob/master/src/ring_theory/jacobson.lean">ring_theory.jacobon</a> and <a href="https://github.com/leanprover-community/mathlib/blob/master/src/ring_theory/ideal/local_ring.lean">ring_theory.ideal.local_ring</a>. Which is better?<br>
I think noncommutative part is quite long (and almost trivial for commutative ring's user), it's better to separate a file.</p>



<a name="280766385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280766385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280766385">(May 01 2022 at 01:33)</a>:</h4>
<p><span class="user-group-mention" data-user-group-id="2494">@maintainers</span> can GH user <code>haruhisa-enomoto</code> have write access to non-master branches?</p>



<a name="280766428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280766428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280766428">(May 01 2022 at 01:34)</a>:</h4>
<p>Making a new file is often a good option.</p>



<a name="280766805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280766805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280766805">(May 01 2022 at 01:45)</a>:</h4>
<p><span class="user-mention" data-user-id="419946">@Haruhisa Enomoto</span>, I've just given you write access to the mathlib repository! Looking forward to your PRs. :-)</p>



<a name="280784126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280784126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Haruhisa Enomoto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280784126">(May 01 2022 at 09:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/Haruhisa.20Enomoto/near/280735994">said</a>:</p>
<blockquote>
<p>Little trick, you can use "dot notation" on your lemmas if you name them correctly. If <code>hu : is_unit u</code>, then to get <code>is_unit (op u)</code> you must do <code>is_unit_op_of_is_unit hu</code>. Yuck, too long. If you instead name it <code>is_unit.op</code>, then <code>hu.op</code> will do. Much shorter, and doesn't need brackets around.</p>
</blockquote>
<p>Thanks for your advice! I'm not familiar with the dot notation, and in particular how it works.<br>
In <a href="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#declaring-structures">Structures and Records (Theorem proving in lean)</a>, the dot notation is mentioned (and it is the only one explanataion about dot notations I can find). From this I understand that the notation <code>p.foo</code> makes sense if the type of <code>p</code> is an inductive type (e.g. <code>T</code>) and <code>T.foo</code> is defined somewhere.<br>
But in the above case, the type of <code>hu</code> is <code>is_unit u</code> (and I can't see whether it is an inductive type),  and why <code>hu.op</code> together with <code>is_unit.op</code> then works?</p>



<a name="280784201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280784201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Haruhisa Enomoto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280784201">(May 01 2022 at 09:23)</a>:</h4>
<p>Or are there any good references for the dot notation in Lean?</p>



<a name="280784244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280784244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280784244">(May 01 2022 at 09:24)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/is_unit">docs#is_unit</a></p>



<a name="280784261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280784261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280784261">(May 01 2022 at 09:25)</a>:</h4>
<p>seems the answer is that it works with <code>def</code>s too :)</p>



<a name="280791486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280791486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280791486">(May 01 2022 at 12:17)</a>:</h4>
<p>Either dot notation works with basically every type, or every type for which you want dot notation to work with is inductive; what I'm saying is that "inductive" is a red herring. The rule is simply the one you said: if <code>x : T</code> then <code>x.foo</code> means <code>T.foo x</code> or more generally <code>T.foo _ _ .. _ x</code> where the <code>x</code> is put as the first explicit input of type <code>T</code> in the function <code>T.foo</code>.</p>



<a name="280793663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280793663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Haruhisa Enomoto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280793663">(May 01 2022 at 13:06)</a>:</h4>
<p>Thanks, I understand how to use dot notation for definitions, but I'm a little confused. In the above example, we have <code>hu : is_unit u</code>, so it seems to me that <code>hu.op</code> should mean something like <code>(is_unit u).op hu</code>, but we only have <code>is_unit.op</code>. What's happening here?</p>



<a name="280794352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280794352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280794352">(May 01 2022 at 13:22)</a>:</h4>
<p><code>(is_unit u).op </code> is resolved by lean to <code>Prop.op (is_unit u)</code> because <code>is_unit u : Prop</code>. Does that help at all?</p>



<a name="280794365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280794365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280794365">(May 01 2022 at 13:22)</a>:</h4>
<p>Lean looks at the type of your expression, extracts the <em>name</em> of the head symbol, then looks for that namespace</p>



<a name="280795675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Haruhisa%20Enomoto/near/280795675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Haruhisa Enomoto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Haruhisa.20Enomoto.html#280795675">(May 01 2022 at 13:54)</a>:</h4>
<p>Thanks, now I see.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/some.20general.20beginner.20questions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html">some general beginner questions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="270700614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270700614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miek Messerschmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270700614">(Feb 04 2022 at 11:19)</a>:</h4>
<p>I'm trying out LEAN for the first time and I'm very interested. I'm a functional analyst, so fine with math. I'm a quite accomplished Python coder, so not new to (imperative) programming. </p>
<p>After some weeks of reading up on how dependent type theory works and watching proofs on the Xena project youtube channel, I thought to try to prove 1+2+3+...+n = n*(n+1)/2 by induction using LEAN without any help, but got stuck at the steps that are obvious to humans, e.g., finding proofs of simple equalities like</p>
<p>N * (N - 1) + 2*N = N *(N +1)   with N : nat.</p>
<p>Is there any advice on overcoming such trivial and mathematically uninteresting roadblocks? My question is maybe more general than "which are the one or two tactics to use in this situation?", but perhaps rather: </p>
<p>1) How should I approach learning what will be useful and where to find it, or how to produce something useful myself, when 'suggest' and 'library_search' or an obvious rewrite fails to produce anything? </p>
<p>2) How does a beginner understand what a tactic actually does when its source code is a bit opaque to the beginner? If I'm more interested in getting on with the math, are the inner workings important to understand? E.g. encountering "exact congr_fun rfl" is easy to understand if you have a basic understanding of the type theory poke around in the source a bit, but something like what EXACTLY "linarith" does is harder to understand, but perhaps not as important.</p>
<p>3) How should one approach reading LEAN and writing LEAN for readability? I struggle sometimes to 'see the math' in LEAN code. E.g., Say a human wants to understand the mathematics in a formal proof written in LEAN with all comments deleted? I assume in practice that it will be far easier to step through a proof with the LEAN infoview than to try to only use ONLY the source code itself.</p>



<a name="270701553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270701553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270701553">(Feb 04 2022 at 11:27)</a>:</h4>
<p>I would say the best thing is what you are already doing: trying to formalize simple results, getting stuck (we've all been there!) and asking for help. Hare you tried the natural number game?</p>



<a name="270701739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270701739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270701739">(Feb 04 2022 at 11:29)</a>:</h4>
<p>In your specific example, you can try <code>ring</code> that may be close the goal immediately (<code>ring</code> should automatically do simple computations like this), or using a chain of <code>rw</code>. For example <code>rw mul_add</code> it's a start.</p>



<a name="270701741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270701741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270701741">(Feb 04 2022 at 11:29)</a>:</h4>
<p>You probably shouldn't try to read the implementation of complicated tactics like <code>linarith</code>, at least until you are quite skilled at reading lean code. Much better to read the tactic documentation: <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#linarith">tactic#linarith</a></p>



<a name="270701797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270701797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270701797">(Feb 04 2022 at 11:29)</a>:</h4>
<p>Welcome! Indeed, figuring out how to easily do the obvious is still the biggest challenge for me, and I'd say I'm pretty experienced with Lean :)</p>



<a name="270701852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270701852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270701852">(Feb 04 2022 at 11:30)</a>:</h4>
<ol>
<li>Generally my process for finding relevant results is <code>library_search</code>/<code>suggest</code> → <code>simp?</code> → search for useful-sounding strings → ask on the <a class="stream" data-stream-id="217875" href="/#narrow/stream/217875-Is-there-code-for-X.3F">#Is there code for X?</a> stream: <code>simp?</code> will sometimes tell you how to rephrase your goal in a way that the library is more useful for. And code search is more powerful than I initially expected since we use a very predictable naming scheme. So for your goal <code>n * (n - 1)</code> I'd try searching for "mul_sub_one" and "mul_pred" (no results unfortunately).</li>
</ol>



<a name="270701940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270701940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270701940">(Feb 04 2022 at 11:31)</a>:</h4>
<p>the key point to understanding what it can do is the line "<code>linarith</code> should prove any goal that is true in the theory of linear arithmetic over the rationals". That's a bit of jargon but it means that linarith can prove things like <code>x + y &lt; z -&gt; x &lt; 2 -&gt; 2 + y &lt; z</code></p>



<a name="270701976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270701976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270701976">(Feb 04 2022 at 11:31)</a>:</h4>
<ol start="2">
<li>Mathlib is unfortunately written in a style that makes it harder than necessary for beginners. When I want to understand how to use an area of the library, I'll just go through the statements and ignore the proofs, then later come back and see how specific things are done. Sometimes there are nicely-structured proofs but often we just want to finish it as quickly as possible.</li>
</ol>



<a name="270701981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270701981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270701981">(Feb 04 2022 at 11:31)</a>:</h4>
<p>Also, beware that working with expressions like <code>n*(n-1)/2</code>, for <code>n : nat</code> can be <em>very</em> frustrating . Try to avoid statement involving division of natural/integer numbers.</p>



<a name="270702243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270702243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270702243">(Feb 04 2022 at 11:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113489-new-members/topic/some.20general.20beginner.20questions/near/270701981">said</a>:</p>
<blockquote>
<p>Also, beware that working with expressions like <code>n*(n-1)/2</code>, for <code>n : nat</code> can be <em>very</em> frustrating . Try to avoid statement involving division of natural/integer numbers.</p>
</blockquote>
<p>This kind of advice can sometimes be found in the module documentation at the top of files. And sometimes it's a bit of community wisdom that you just have to be around long enough to pick up.</p>



<a name="270702252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270702252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270702252">(Feb 04 2022 at 11:34)</a>:</h4>
<p>Another good decision procedure to have under your belt is the <code>ring</code> tactic, which handles equations over a commutative ring or semiring. This is the closest thing to your goal, so that's what I would try, but as Riccardo says the subtraction and division will cause problems because they are not ring operations (subtraction on <code>nat</code> saturates on underflow), so a reasonable approach to proving the theorem is to first get rid of these operations using lemmas about subtraction and division, and then once everything is <code>+</code> and <code>*</code> then <code>ring</code> will finish the goal</p>



<a name="270702316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270702316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270702316">(Feb 04 2022 at 11:35)</a>:</h4>
<p>In that case I'd <br>
<span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113489-new-members/topic/some.20general.20beginner.20questions/near/270701981">said</a>:</p>
<blockquote>
<p>Also, beware that working with expressions like <code>n*(n-1)/2</code>, for <code>n : nat</code> can be <em>very</em> frustrating . Try to avoid statement involving division of natural/integer numbers.</p>
</blockquote>
<p>In that case, I'd advise using <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.asc_factorial">docs#nat.asc_factorial</a></p>



<a name="270702420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/some%20general%20beginner%20questions/near/270702420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/some.20general.20beginner.20questions.html#270702420">(Feb 04 2022 at 11:36)</a>:</h4>
<p>Since the statement includes subtraction only in <code>N - 1</code>, I'd handle <code>n = 0</code> as a special case, giving something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">*</span> <span class="o">(</span><span class="n">N</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">2</span><span class="bp">*</span><span class="n">N</span> <span class="bp">=</span> <span class="n">N</span> <span class="bp">*</span><span class="o">(</span><span class="n">N</span> <span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">cases</span> <span class="n">N</span><span class="bp">;</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">ring</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
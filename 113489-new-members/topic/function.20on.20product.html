---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/function.20on.20product.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html">function on product</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="201258059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201258059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201258059">(Jun 18 2020 at 12:02)</a>:</h4>
<p>Is there somewhere in Mathlib where I can find very primitive results on functions such that fxg \comp hxe = (f \comp h) x (g \comp e) where all functions have different domains and codomains exept from the obvious ones which need to be equal to make the equation work? It's not hard to prove it by myself but it would be cool to know if all these results are in Mathlib as I cannot really locate them. (I know the product function is written in Lean with λ abstraction but it was too long to write it with lean notation)</p>



<a name="201258568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201258568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201258568">(Jun 18 2020 at 12:08)</a>:</h4>
<p>Do you know how to use <code>library_search</code>?</p>



<a name="201258671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201258671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201258671">(Jun 18 2020 at 12:10)</a>:</h4>
<p>There are four strategies for finding statements in mathlib:</p>
<ol>
<li>learn the <a href="https://leanprover-community.github.io/contribute/naming.html">#naming</a> scheme</li>
<li>use <code>library_search</code> (sometime it helps to write a separate <code>example</code> with the statement you're after)</li>
<li>ask here</li>
<li>meander around in the source code!</li>
</ol>



<a name="201267835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201267835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201267835">(Jun 18 2020 at 13:32)</a>:</h4>
<p>I think following those more-or-less in order is good. In particular, by the time, you get to 3, you'll have an <code>example</code> that you can post with your question.</p>



<a name="201268074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201268074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201268074">(Jun 18 2020 at 13:34)</a>:</h4>
<p><span class="user-mention" data-user-id="267205">@Nicolò Cavalleri</span> I would encourage you to formalise your questions (i.e. actually post a piece of working code with a <code>sorry</code> and say "what is this precise function called"). If you do that, you get much more efficient answers, and often, using <code>library_search</code>, you can even find out the answers yourself.</p>



<a name="201276921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201276921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201276921">(Jun 18 2020 at 14:40)</a>:</h4>
<p>I am looking in Mathlib for lemmas of the kind:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">comp_of_prod_eq_prod_of_comp</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">×</span> <span class="n">D</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">x</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span> <span class="n">k</span> <span class="n">x</span><span class="bp">.</span><span class="n">snd</span><span class="o">))</span> <span class="err">∘</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">×</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span><span class="bp">.</span><span class="n">snd</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">×</span> <span class="n">C</span><span class="o">,</span> <span class="o">((</span><span class="n">h</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">x</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span> <span class="o">(</span><span class="n">k</span> <span class="err">∘</span> <span class="n">g</span><span class="o">)</span> <span class="n">x</span><span class="bp">.</span><span class="n">snd</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">refine</span> <span class="n">rfl</span>
</code></pre></div>


<p>library_search suggests refine rfl, but that is a tactic and does not point anywhere in mathlib. I am also wondering if there is a convenient notation for product of functions such as <code>(λ x : A × C, (f x.fst, g x.snd))</code></p>



<a name="201277210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201277210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201277210">(Jun 18 2020 at 14:42)</a>:</h4>
<p><code>rfl</code> means "this is true by definition"</p>



<a name="201277669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201277669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201277669">(Jun 18 2020 at 14:46)</a>:</h4>
<p>Not everything which is true by definition has a name in mathlib</p>



<a name="201277783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201277783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201277783">(Jun 18 2020 at 14:47)</a>:</h4>
<p>Product function -- good question!</p>



<a name="201278307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201278307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201278307">(Jun 18 2020 at 14:51)</a>:</h4>
<p>Does also <code>refine rfl</code> mean it is true by definition? The point is that if the goal is the rhs of = in the above lemma, exact lhs seems not to work, even if this is a simplification of my lemma so I am not entirely sure. That is why I needed to write the lemma separately</p>



<a name="201278470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201278470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201278470">(Jun 18 2020 at 14:52)</a>:</h4>
<p>You should be able to replace <code>by refine rfl</code> with just <code>rfl</code>. <code>refine</code> without any underscores just does the same thing as <code>exact</code>.</p>



<a name="201278538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201278538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201278538">(Jun 18 2020 at 14:53)</a>:</h4>
<p>This probably counts as a bug in<code>library_search</code> that it doesn't just print <code>rfl</code> here...</p>



<a name="201278675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201278675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201278675">(Jun 18 2020 at 14:54)</a>:</h4>
<p>I should also have <code>library_search</code> defer the <code>solve_by_elim</code> round until after the "only unfold <code>reducible</code> stuff" round...</p>



<a name="201278737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201278737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201278737">(Jun 18 2020 at 14:54)</a>:</h4>
<p>Sometimes you have to use <code>change</code> to change the goal into something defeq before Lean will accept a proof of that via <code>exact</code>.</p>



<a name="201278748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201278748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201278748">(Jun 18 2020 at 14:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/function.20on.20product/near/201278538">said</a>:</p>
<blockquote>
<p>This probably counts as a bug in<code>library_search</code> that it doesn't just print <code>rfl</code> here...</p>
</blockquote>
<p>Well... then "Try this" would also have to replace the <code>by</code>...</p>



<a name="201298633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201298633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201298633">(Jun 18 2020 at 17:13)</a>:</h4>
<p>What if I wanted to define <code>(λ x : A × C, (f x.fst, g x.snd))</code> to be <code>f.prod g</code>? I think I could probably do it but  I am a bit lost on what would be the standard way to do it</p>



<a name="201299320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201299320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201299320">(Jun 18 2020 at 17:19)</a>:</h4>
<p><span class="user-mention" data-user-id="267205">@Nicolò Cavalleri</span> This is "difficult" to achieve, because functions are such a basic notion that there is no good dot notation for them at the moment.</p>



<a name="201299354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201299354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201299354">(Jun 18 2020 at 17:19)</a>:</h4>
<p>You could get <code>function.prod f g</code> though</p>



<a name="201299774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201299774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201299774">(Jun 18 2020 at 17:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/function.20on.20product/near/201299354">said</a>:</p>
<blockquote>
<p>You could get <code>function.prod f g</code> though</p>
</blockquote>
<p>Are you suggesting to define <code>function.prod</code>? Or does it exist already? (In case my Lean says it does not exist!)</p>



<a name="201301453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201301453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201301453">(Jun 18 2020 at 17:36)</a>:</h4>
<p>This is <code>prod.map</code>.</p>



<a name="201301860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201301860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201301860">(Jun 18 2020 at 17:39)</a>:</h4>
<p>Aah, I didn't pay attention to the maths...</p>



<a name="201302032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201302032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201302032">(Jun 18 2020 at 17:41)</a>:</h4>
<p><span class="user-mention" data-user-id="267205">@Nicolò Cavalleri</span> <code>function.prod</code> (following current [informal?] naming conventions) would mean <code>f : A → B</code>, <code>g : A → C</code>, and then <code>function.prod f g : A → B × C</code>, the natural map <code>\lam x, (f x, g x)</code>.</p>



<a name="201302076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/function%20on%20product/near/201302076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20on.20product.html#201302076">(Jun 18 2020 at 17:41)</a>:</h4>
<p>I think <code>prod.map</code>, which is what you want, already exists in mathlib.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
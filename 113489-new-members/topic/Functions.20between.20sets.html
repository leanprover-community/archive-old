---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Functions.20between.20sets.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Functions.20between.20sets.html">Functions between sets</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="202874080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Functions%20between%20sets/near/202874080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Functions.20between.20sets.html#202874080">(Jul 04 2020 at 13:33)</a>:</h4>
<p>I want to prove this in a way that is easy to follow for someone taking a first class in analysis. In my mind, that means showing the intermediary goals in the sketch proof below. This doesn't compile because of coercion problems and I'm not sure how to make it work while still keeping a very explicit statement of what is intended. Help will be greatly appreciated.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">function</span>

<span class="kn">lemma</span> <span class="n">finite_of_inj</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">h1B</span> <span class="o">:</span> <span class="n">B</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">h2B</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">B</span><span class="o">)</span>
   <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">),</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
   <span class="n">cases</span> <span class="n">H</span> <span class="k">with</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span>
   <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">image</span> <span class="n">f</span> <span class="n">A</span> <span class="err">⊆</span> <span class="n">B</span><span class="o">,</span> <span class="o">{</span><span class="n">sorry</span><span class="o">},</span> <span class="c1">--does not compile</span>
   <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">set</span><span class="bp">.</span><span class="n">image</span> <span class="n">f</span> <span class="n">A</span><span class="o">,</span> <span class="n">bijective</span> <span class="n">g</span><span class="o">,</span> <span class="o">{</span><span class="n">sorry</span><span class="o">},</span> <span class="c1">-- bijective version of f</span>
   <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">finite</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">image</span> <span class="n">f</span> <span class="n">A</span><span class="o">),</span> <span class="o">{</span><span class="n">sorry</span><span class="o">},</span> <span class="c1">-- from h1</span>
   <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- goal should follow from h2, h3</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202874352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Functions%20between%20sets/near/202874352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Functions.20between.20sets.html#202874352">(Jul 04 2020 at 13:41)</a>:</h4>
<p>You're fighting type theory really hard here.</p>



<a name="202874714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Functions%20between%20sets/near/202874714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Functions.20between.20sets.html#202874714">(Jul 04 2020 at 13:52)</a>:</h4>
<p>If you want to prove this statement here is a better way to get started</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">function</span>

<span class="kn">lemma</span> <span class="n">finite_of_inj</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">h1B</span> <span class="o">:</span> <span class="n">B</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">h2B</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">B</span><span class="o">)</span>
   <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">),</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
   <span class="n">cases</span> <span class="n">H</span> <span class="k">with</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">range_factorization</span> <span class="n">f</span><span class="o">,</span>
   <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">bijective</span> <span class="n">g</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">subtype</span><span class="bp">.</span><span class="n">coind_injective</span> <span class="bp">_</span> <span class="n">hf</span><span class="o">,</span> <span class="n">surjective_onto_range</span><span class="bp">⟩</span><span class="o">,</span>
   <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">finite</span> <span class="o">(</span><span class="n">range</span> <span class="n">f</span><span class="o">),</span> <span class="o">{</span><span class="n">sorry</span><span class="o">},</span>
   <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- goal should follow from h2, h3</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202874723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Functions%20between%20sets/near/202874723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Functions.20between.20sets.html#202874723">(Jul 04 2020 at 13:52)</a>:</h4>
<p>The nonempty hypotheses are unnecessary</p>



<a name="202883373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Functions%20between%20sets/near/202883373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Functions.20between.20sets.html#202883373">(Jul 04 2020 at 17:25)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110032">@Reid Barton</span> <br>
Even starting as you indicate, <code>h3</code> is still difficult to get. In the end I settled on the following, which I post here for completeness.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">function</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">finite_of_inj</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">),</span> <span class="n">inj_on</span> <span class="n">f</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
   <span class="n">cases</span> <span class="n">H</span> <span class="k">with</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span>
   <span class="k">have</span> <span class="n">h0</span> <span class="o">:=</span> <span class="n">finite</span><span class="bp">.</span><span class="n">of_fintype</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">image</span> <span class="n">f</span> <span class="n">A</span><span class="o">),</span>
   <span class="n">exact</span> <span class="n">finite_of_finite_image</span> <span class="n">hf</span> <span class="n">h0</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
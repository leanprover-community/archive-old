---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/.60subst.60.20fails.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html">`subst` fails</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="263728798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263728798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263728798">(Dec 04 2021 at 20:03)</a>:</h4>
<p>Tactic <code>subst h₁</code> fails with error <em>"hypothesis 'h₁' is not of the form (x = t) or (t = x)"</em>,<br>
despite <code>h₁</code> being <code>a = y (classical.some h)</code>. Also, <code>rw h₁ at h</code> creates a new hypothesis instead of updating the existing hypothesis <code>h</code>. Is this a bug with <code>subst</code> and <code>rw</code>, or am I doing something wrong?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">f</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
  <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">h₀</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">z</span> <span class="bp">≠</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">{</span><span class="n">z₀</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">y</span> <span class="n">z₀</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">a</span><span class="o">,</span> <span class="n">by_cases</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="mi">0</span> <span class="o">},</span>
  <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h₀</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:=</span> <span class="n">classical.some_spec</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- subst h₁,</span>
  <span class="c1">-- rw h₁ at h,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Also, what is the best way to eliminate an existential quantifier when the goal is not a proposition? I was using <code>classical.some_spec</code> followed by <code>subst</code> so far, but is there a better way?</p>



<a name="263729168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263729168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263729168">(Dec 04 2021 at 20:12)</a>:</h4>
<p>All of this has to do with the fact that you're constructing data. There are ways out but it's a bit painful. Why do you even need to rewrite here? What are you trying to do?</p>



<a name="263729183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263729183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263729183">(Dec 04 2021 at 20:13)</a>:</h4>
<p>If this is meant to count the number of time you need to apply <code>y</code> to <code>z</code> to get <code>x</code>, this is not going to work because <code>y</code> might well exchange two elements which are not <code>x</code>.</p>



<a name="263729188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263729188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263729188">(Dec 04 2021 at 20:13)</a>:</h4>
<p>You may try using <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.find">docs#nat.find</a> instead.</p>



<a name="263729235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263729235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263729235">(Dec 04 2021 at 20:14)</a>:</h4>
<p>Doing <code>cases h₁</code> reveals the underlying problem: "left-hand-side depends on right-hand-side"</p>



<a name="263729428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263729428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263729428">(Dec 04 2021 at 20:19)</a>:</h4>
<p>It looks like you're trying to define a function that gives how many times you need to iterate <code>y</code> to get a particular value, but it's not necessarily true that every <code>a</code> is actually some nth iterate of <code>y</code> applied to <code>x</code>.</p>



<a name="263729737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263729737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263729737">(Dec 04 2021 at 20:27)</a>:</h4>
<p>That was a simplified use case just to show the issue. Here is the full signature:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">f</span>
  <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">exh</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">S</span> <span class="n">m</span><span class="o">))</span>
  <span class="o">(</span><span class="n">inj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">S</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">S</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ind</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">P</span> <span class="n">Z</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">P</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">S</span> <span class="n">m</span><span class="o">))</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>I am trying to implement a function that converts an arbitrary type to a natural number, as long as some conditions are satisfied. But it seems that dealing with existential quantifiers while constructing data is not so straightforward.</p>



<a name="263729796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263729796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263729796">(Dec 04 2021 at 20:28)</a>:</h4>
<p>You might consider a definition like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.lattice</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">f</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">Inf</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">y</span> <span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span><span class="o">}</span>
</code></pre></div>
<p>and then proving it has properties that you expect given additional hypotheses. (<em>Edit:</em> sent this right as your last message appeared.)</p>



<a name="263729909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263729909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263729909">(Dec 04 2021 at 20:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> <a href="#narrow/stream/113489-new-members/topic/.60subst.60.20fails/near/263728798">said</a>:</p>
<blockquote>
<p>Also, what is the best way to eliminate an existential quantifier when the goal is not a proposition? I was using <code>classical.some_spec</code> followed by <code>subst</code> so far, but is there a better way?</p>
</blockquote>
<p>I usually use <code>classical.some_spec</code> for this, but you can't always expect to be able to <code>subst</code> afterwards since it depends on the proof of a <code>Prop</code> that can include the variable.</p>



<a name="263730141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263730141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263730141">(Dec 04 2021 at 20:36)</a>:</h4>
<p>For the full signature, this is how I'd organize it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.lattice</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">to_nat</span>
  <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="n">Inf</span> <span class="o">{</span><span class="n">m</span> <span class="bp">|</span> <span class="n">S</span> <span class="bp">^</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="n">Z</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span>

<span class="kd">noncomputable</span> <span class="kd">lemma</span> <span class="n">f_equiv</span>
  <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">exh</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">S</span> <span class="n">m</span><span class="o">))</span>
  <span class="o">(</span><span class="n">inj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">S</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">S</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ind</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">P</span> <span class="n">Z</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">P</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">S</span> <span class="n">m</span><span class="o">))</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ℕ</span> <span class="bp">≃</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">S</span> <span class="bp">^</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="n">Z</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">to_nat</span> <span class="n">N</span> <span class="n">Z</span> <span class="n">S</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="263730213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263730213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263730213">(Dec 04 2021 at 20:38)</a>:</h4>
<p>or maybe just include <code>to_nat</code> in the definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">lemma</span> <span class="n">f_equiv</span>
  <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">exh</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">S</span> <span class="n">m</span><span class="o">))</span>
  <span class="o">(</span><span class="n">inj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">S</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">S</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ind</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">P</span> <span class="n">Z</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">P</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">S</span> <span class="n">m</span><span class="o">))</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ℕ</span> <span class="bp">≃</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">S</span> <span class="bp">^</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="n">Z</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">Inf</span> <span class="o">{</span><span class="n">m</span> <span class="bp">|</span> <span class="n">S</span> <span class="bp">^</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="n">Z</span> <span class="bp">=</span> <span class="n">n</span><span class="o">},</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">m</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="263730239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263730239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263730239">(Dec 04 2021 at 20:39)</a>:</h4>
<p>But the point is that you don't really need to hypotheses to define <em>some</em> function. You just need them to prove it does what you expect the definition to do.</p>



<a name="263730855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263730855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263730855">(Dec 04 2021 at 20:55)</a>:</h4>
<p>This approach looks too low-level. I suggest <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.of_bijective">docs#equiv.of_bijective</a>.</p>



<a name="263732362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263732362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263732362">(Dec 04 2021 at 21:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Good call, <code>Inf</code> was too hard to work with.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable</span> <span class="kd">lemma</span> <span class="n">f_equiv</span>
  <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">exh</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">≠</span> <span class="n">S</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">inj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">S</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">S</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ind</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">Z</span> <span class="bp">∈</span> <span class="n">P</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">S</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ℕ</span> <span class="bp">≃</span> <span class="n">N</span> <span class="o">:=</span>
<span class="n">equiv.of_bijective</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">S</span><span class="bp">^</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="n">Z</span><span class="o">)</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">m</span> <span class="n">m'</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">wlog</span> <span class="n">hl</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">m'</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">le_iff_exists_add.mp</span> <span class="n">hl</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">k</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">function.iterate_add</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hi</span> <span class="o">:=</span> <span class="n">function.injective.iterate</span> <span class="n">inj</span> <span class="n">m</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">function.iterate_succ_apply'</span><span class="o">]</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">false.elim</span> <span class="o">(</span><span class="n">exh</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hi.symm</span> <span class="n">rfl</span><span class="o">),</span> <span class="o">},</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">ind</span> <span class="o">{</span><span class="n">n'</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">S</span><span class="bp">^</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="n">Z</span> <span class="bp">=</span> <span class="n">n'</span><span class="o">}</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="mi">0</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="n">m</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
      <span class="n">use</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">function.iterate_succ_apply'</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="263733104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263733104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263733104">(Dec 04 2021 at 21:42)</a>:</h4>
<p>That should be a <code>def</code> not a <code>lemma</code></p>



<a name="263734718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263734718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263734718">(Dec 04 2021 at 22:14)</a>:</h4>
<p>Is it possible to build the noncomputable one out of the computer version, by filling these sorries?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">f_equiv</span>
  <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ind</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">P</span> <span class="n">Z</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">P</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">S</span> <span class="n">m</span><span class="o">))</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ind_Z</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">hZ</span> <span class="o">:</span> <span class="n">P</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">P</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">S</span> <span class="n">m</span><span class="o">)),</span> <span class="n">ind</span> <span class="n">P</span> <span class="n">Z</span> <span class="n">hZ</span> <span class="n">hS</span> <span class="bp">=</span> <span class="n">hZ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ind_S</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">hZ</span> <span class="o">:</span> <span class="n">P</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">P</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">S</span> <span class="n">m</span><span class="o">)),</span>
    <span class="n">ind</span> <span class="n">P</span> <span class="o">(</span><span class="n">S</span> <span class="n">n</span><span class="o">)</span> <span class="n">hZ</span> <span class="n">hS</span> <span class="bp">=</span> <span class="n">hS</span> <span class="n">_</span> <span class="o">(</span><span class="n">ind</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hZ</span> <span class="n">hS</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">ℕ</span> <span class="bp">≃</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">S</span><span class="bp">^</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="n">Z</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">ind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">n</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">nat.succ</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">ind_Z</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">function.iterate_succ_apply'</span><span class="o">,</span> <span class="n">ind_S</span><span class="o">,</span> <span class="n">x_ih</span><span class="o">],</span> <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">apply</span> <span class="n">plift.down</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">ind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">plift</span> <span class="bp">$</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="n">x</span> <span class="o">(</span><span class="n">plift.up</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">plift.up</span> <span class="n">_</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ind_Z</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">replace</span> <span class="n">hx</span> <span class="o">:=</span> <span class="n">plift.down</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">ind_S</span><span class="o">,</span> <span class="n">function.iterate_succ_apply'</span><span class="o">,</span> <span class="n">hx</span><span class="o">],</span> <span class="o">}</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">f_equiv_nc</span>
  <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">exh</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">≠</span> <span class="n">S</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">inj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">S</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">S</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ind</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">Z</span> <span class="bp">∈</span> <span class="n">P</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">S</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ℕ</span> <span class="bp">≃</span> <span class="n">N</span> <span class="o">:=</span>
<span class="n">f_equiv</span> <span class="n">N</span> <span class="n">Z</span> <span class="n">S</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">P</span> <span class="n">n</span> <span class="n">hZ</span> <span class="n">hS</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">P</span> <span class="n">hZ</span> <span class="n">hS</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">P</span> <span class="n">n</span> <span class="n">hZ</span> <span class="n">hS</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">)</span>
</code></pre></div>



<a name="263737474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263737474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263737474">(Dec 04 2021 at 23:21)</a>:</h4>
<p>There is no way to computably determine whether <code>n : N</code> is <code>Z</code> or not.</p>



<a name="263737599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263737599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263737599">(Dec 04 2021 at 23:24)</a>:</h4>
<p>Is this because you have an induction principle but not a recursion principle?</p>



<a name="263737610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263737610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263737610">(Dec 04 2021 at 23:25)</a>:</h4>
<p>Recursion lets me define a bool-valued <code>is_zero</code></p>



<a name="263737617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263737617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263737617">(Dec 04 2021 at 23:25)</a>:</h4>
<p>Yes. Specifically, computationally <code>exh</code>, <code>inj</code>, <code>ind</code> have no content because they are propositions, and obviously what's left is not enough to extract any data from <code>n : N</code>.</p>



<a name="263737621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263737621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263737621">(Dec 04 2021 at 23:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/.60subst.60.20fails/near/263737474">said</a>:</p>
<blockquote>
<p>There is no way to computably determine whether <code>n : N</code> is <code>Z</code> or not.</p>
</blockquote>
<p>I'm not sure what you mean by "computably" here, in my example the <code>sorry</code>s can be noncomputable.</p>



<a name="263737880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263737880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263737880">(Dec 04 2021 at 23:32)</a>:</h4>
<p>Oh, well in that case, of course it is possible in principle (because Kyle already showed how to prove that <code>ℕ ≃ N</code>). I guess another way to do it would be to define a relation <code>is_ind : \Pi (n : N) (x : P n), Prop</code> which is going to be the graph of <code>ind</code> and then prove using induction that there is a unique <code>x</code> with <code>is_ind n x</code> for each <code>n : N</code>.</p>



<a name="263737943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60subst%60%20fails/near/263737943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60subst.60.20fails.html#263737943">(Dec 04 2021 at 23:34)</a>:</h4>
<p>To define the relation you could use an inductive proposition with constructors <code>is_ind Z hZ</code> and <code>is_ind n x -&gt; is_ind (S n) (hS n x)</code>, or the corresponding impredicative definition</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html">ring not respecting arbitrary</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="228464853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228464853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228464853">(Mar 02 2021 at 18:54)</a>:</h4>
<p>Is it expected that <code>ring</code> will think that separate <code>arbitrary _</code> values are equal?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.ring</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">),</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">arbitrary</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">arbitrary</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">arbitrary</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">],</span>
  <span class="n">ring</span><span class="o">,</span> <span class="c1">-- 5 * a = 0</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="228465350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228465350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228465350">(Mar 02 2021 at 18:57)</a>:</h4>
<p>is <a href="https://leanprover-community.github.io/mathlib_docs/find/arbitrary/src">src#arbitrary</a> irreducible? Edit: yes</p>



<a name="228465645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228465645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228465645">(Mar 02 2021 at 18:59)</a>:</h4>
<p>I think by definition any terms constructed with the same function application must be equal to each other</p>



<a name="228465702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228465702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228465702">(Mar 02 2021 at 18:59)</a>:</h4>
<p>Then I am not sure what <code>arbitrary</code> is supposed to do.</p>



<a name="228465752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228465752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228465752">(Mar 02 2021 at 18:59)</a>:</h4>
<p>Well, it prevented you from replacing <code>a</code> with zero at least</p>



<a name="228467191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228467191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228467191">(Mar 02 2021 at 19:08)</a>:</h4>
<p>Right --here a=b right? This is nothing to do with <code>ring</code></p>



<a name="228467256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228467256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228467256">(Mar 02 2021 at 19:09)</a>:</h4>
<p>Yes</p>



<a name="228467272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228467272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228467272">(Mar 02 2021 at 19:09)</a>:</h4>
<p>I guess you could make a tactic that emits new definitions each time you invoke it?</p>



<a name="228467315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228467315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228467315">(Mar 02 2021 at 19:09)</a>:</h4>
<p>And then you'd have things that are still defeq under the <code>irreducible</code> veil, but are no longer syntactically equal to each other</p>



<a name="228467647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228467647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228467647">(Mar 02 2021 at 19:11)</a>:</h4>
<p>Or even:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[irreducible]</span> <span class="kd">def</span> <span class="n">arbitrary'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">default</span> <span class="n">α</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">),</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">arbitrary'</span> <span class="bp">`</span><span class="n">a</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">arbitrary'</span> <span class="bp">`</span><span class="n">b</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">arbitrary'</span> <span class="bp">`</span><span class="n">c</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">],</span>
  <span class="n">ring</span><span class="o">,</span> <span class="c1">-- 2 * a + (b + 2 * c) = 0</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="228467982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228467982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228467982">(Mar 02 2021 at 19:13)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.ring</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">arbitrary</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="n">refl</span> <span class="c1">-- this fails</span>
<span class="kd">end</span>
</code></pre></div>



<a name="228481636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228481636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228481636">(Mar 02 2021 at 20:39)</a>:</h4>
<p>That'll teach you to sorry data</p>



<a name="228483390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228483390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228483390">(Mar 02 2021 at 20:51)</a>:</h4>
<p>Then you'll be even more horrified at this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[irreducible]</span> <span class="kd">def</span> <span class="n">arbitrary'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">default</span> <span class="n">α</span>

<span class="c1">-- 1.1.17</span>
<span class="c1">-- (a) Find infinitely many matrices `B` such that `BA = I₂` when</span>
<span class="c1">-- `A = ![![2, 3], ![1, 2], ![2, 5]]`</span>
<span class="c1">-- (b) Prove that there is no matrix `C` such that `AC =  I₃`</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">]])</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">,</span> <span class="n">B.mul</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="n">ℚ</span><span class="o">),</span> <span class="n">A.mul</span> <span class="n">C</span> <span class="bp">≠</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">let</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">arbitrary'</span> <span class="bp">`</span><span class="n">c</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">set</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="bp">-</span> <span class="mi">4</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">-</span> <span class="mi">3</span> <span class="k">with</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">set</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="bp">-</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="mi">5</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">3</span> <span class="k">with</span> <span class="n">ha</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">arbitrary'</span> <span class="bp">`</span><span class="n">d</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">set</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">d</span> <span class="bp">+</span> <span class="mi">1</span> <span class="k">with</span> <span class="n">hf</span><span class="o">,</span>
    <span class="n">set</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="bp">-</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">d</span> <span class="bp">+</span> <span class="n">f</span><span class="o">)</span> <span class="k">with</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">set</span> <span class="n">B</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">f</span><span class="o">]]</span> <span class="k">with</span> <span class="n">hB</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">B</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">hA</span><span class="o">],</span>
    <span class="n">ext</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">fin_cases</span> <span class="n">i</span><span class="bp">;</span>
    <span class="n">fin_cases</span> <span class="n">j</span><span class="bp">;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">he</span><span class="o">,</span> <span class="n">hf</span><span class="o">]</span><span class="bp">;</span>
    <span class="n">ring</span> <span class="o">},</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="228484616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228484616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228484616">(Mar 02 2021 at 21:00)</a>:</h4>
<p>What's the punchline, for those of us on mobile?</p>



<a name="228484806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228484806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228484806">(Mar 02 2021 at 21:01)</a>:</h4>
<p>That I'm doing symbolic calculations on explicit matrices using mathlib</p>



<a name="228491707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228491707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228491707">(Mar 02 2021 at 21:45)</a>:</h4>
<p>Are you trying to use <code>arbitrary'</code> as a crutch for "infinitely many"?</p>



<a name="228492385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228492385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228492385">(Mar 02 2021 at 21:50)</a>:</h4>
<p>I guess the statement would be something like <code>∃ (s : set $ matrix (fin 2) (fin 3) ℚ) (hs : s.infinite), ∀ B ∈ s, B.mul A = 1)</code></p>



<a name="228492458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228492458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228492458">(Mar 02 2021 at 21:50)</a>:</h4>
<p>And then you use <code>set.range f</code> where <code>f</code> is a function from <code>prod ℚ ℚ</code> to a matrix</p>



<a name="228495556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228495556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228495556">(Mar 02 2021 at 22:10)</a>:</h4>
<p>For your example though, I don't think you need <code>arbirary' `name</code> at all - using <code>have c : ℚ := arbitrary _,</code> instead of <code>let</code> does the job</p>



<a name="228528903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228528903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228528903">(Mar 03 2021 at 03:25)</a>:</h4>
<p>You could also introduce variables in the statement and prove the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">B</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">d</span><span class="o">,</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">-</span><span class="mi">1</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="n">d</span><span class="o">,</span> <span class="bp">-</span> <span class="mi">4</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">-</span> <span class="mi">2</span><span class="o">,</span> <span class="n">d</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">]]</span>

<span class="kd">lemma</span> <span class="n">Binj</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">B</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ab</span><span class="o">,</span> <span class="o">(</span><span class="n">matrix.ext_iff.mpr</span> <span class="n">ab</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">0</span>

<span class="c1">-- 1.1.17</span>
<span class="c1">-- (a) Find infinitely many matrices `B` such that `BA = I₂` when</span>
<span class="c1">-- `A = ![![2, 3], ![1, 2], ![2, 5]]`</span>
<span class="c1">-- (b) Prove that there is no matrix `C` such that `AC =  I₃`</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">]])</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">B</span> <span class="n">ℚ</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">mul</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="n">ℚ</span><span class="o">),</span> <span class="n">A.mul</span> <span class="n">C</span> <span class="bp">≠</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">fin_cases</span> <span class="n">i</span><span class="bp">;</span>
    <span class="n">fin_cases</span> <span class="n">j</span><span class="bp">;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hA</span><span class="o">,</span> <span class="n">B</span><span class="o">]</span><span class="bp">;</span>
    <span class="n">ring</span> <span class="o">},</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>at this point, all that you are missing is that <code>ℚ</code> is infinite.</p>



<a name="228545545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228545545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228545545">(Mar 03 2021 at 06:53)</a>:</h4>
<p>Should <a href="https://leanprover-community.github.io/mathlib_docs/find/infinite">docs#infinite</a> have more instances?</p>



<a name="228545620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228545620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228545620">(Mar 03 2021 at 06:54)</a>:</h4>
<p>For instance, instances for prod, sum, sigma, and pi would all be good starts</p>



<a name="228546173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228546173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228546173">(Mar 03 2021 at 07:02)</a>:</h4>
<p>It seems like there will be a lot of proof search in those instances</p>



<a name="228546940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228546940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228546940">(Mar 03 2021 at 07:11)</a>:</h4>
<p>Is it morally any different to instance searches for fintype?</p>



<a name="228547666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228547666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228547666">(Mar 03 2021 at 07:22)</a>:</h4>
<p>Yes, because fintype is a conjunctive property in most cases, which means that you can prove or disprove in linear time wrt the type expression</p>



<a name="228547864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228547864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228547864">(Mar 03 2021 at 07:24)</a>:</h4>
<p>Ah right, we end up with a similar problem to <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.nontrivial">docs#pi.nontrivial</a></p>



<a name="228547954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228547954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228547954">(Mar 03 2021 at 07:25)</a>:</h4>
<p>Although we could probably solve it in the same way?</p>



<a name="228548979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228548979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228548979">(Mar 03 2021 at 07:36)</a>:</h4>
<p>In this specific case, you could either use the natural numbers, instead of \Q, in the matrix <code>B</code>, or use <code>char_zero</code>, right?</p>



<a name="228595708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228595708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228595708">(Mar 03 2021 at 14:01)</a>:</h4>
<p>Probably, but I didn't want to deal with nat division</p>



<a name="228596697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ring%20not%20respecting%20arbitrary/near/228596697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ring.20not.20respecting.20arbitrary.html#228596697">(Mar 03 2021 at 14:07)</a>:</h4>
<p>Ah, actually, I meant to say that replacing \Q by ℤ worked:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">]])</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">B</span> <span class="n">ℤ</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">mul</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">fin_cases</span> <span class="n">i</span><span class="bp">;</span>
  <span class="n">fin_cases</span> <span class="n">j</span><span class="bp">;</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hA</span><span class="o">,</span> <span class="n">B</span><span class="o">]</span><span class="bp">;</span>
  <span class="n">ring</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
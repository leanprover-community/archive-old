---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Decidability.20with.20fintype.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html">Decidability with fintype</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="305273668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305273668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305273668">(Oct 21 2022 at 02:52)</a>:</h4>
<p>Hi, I currently have a hypothesis </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">h1</span><span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.connected_component_mk</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">A</span>
</code></pre></div>
<p>I would like to break the exists to get said a. Cases gives me error "induction tactic failed, recursor 'Exists.dcases_on' can only eliminate into Prop".  I know I can use choose or classical.some, but for interest of understanding how this works, I'd like to not use anything like that. Let me note that V is fintype, so it appears to me that this should be easy to do (algorithmically, one might just go through every a:V and find one). How would one code this, if possible? Thanks for your help.</p>



<a name="305274260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305274260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305274260">(Oct 21 2022 at 03:01)</a>:</h4>
<p><code>have ⟨a,h2⟩ := h1</code> destructures an existential proposition</p>



<a name="305274740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305274740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305274740">(Oct 21 2022 at 03:08)</a>:</h4>
<p>I get "invalid 'begin-end' expression, ',' expected" when I do this (I have indeed written , at the end of the line). And when I click inside the &lt;&gt; I get "unknown identifier 'a'",  "unknown identifier 'h2'" as errors</p>



<a name="305274797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305274797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305274797">(Oct 21 2022 at 03:10)</a>:</h4>
<p>Is this Lean 3?</p>



<a name="305275072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305275072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305275072">(Oct 21 2022 at 03:15)</a>:</h4>
<p>I am going to guess it probably is, stop offering Lean 4 advice, and go to bed. :)</p>



<a name="305275080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305275080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305275080">(Oct 21 2022 at 03:15)</a>:</h4>
<p>are you in term mode or tactic mode?</p>



<a name="305275152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305275152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305275152">(Oct 21 2022 at 03:16)</a>:</h4>
<p>if you're in tactic mode it might explain why that destructuring syntax didn't work... but that's besides the point</p>



<a name="305275163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305275163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305275163">(Oct 21 2022 at 03:17)</a>:</h4>
<p>Yeah Lean 3</p>



<a name="305275243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305275243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305275243">(Oct 21 2022 at 03:18)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.choose">docs#fintype.choose</a> exists, but it requires proof of uniqueness</p>



<a name="305275245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305275245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305275245">(Oct 21 2022 at 03:18)</a>:</h4>
<p>Tactic mode, inside a begin...end block</p>



<a name="305275276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305275276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305275276">(Oct 21 2022 at 03:19)</a>:</h4>
<p>Interesting, but sadly it is not unique</p>



<a name="305275692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305275692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305275692">(Oct 21 2022 at 03:26)</a>:</h4>
<p>my instinct tells me that Lean probably won't allow you to computably choose a "random" element that satisfies some predicate</p>



<a name="305275727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305275727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305275727">(Oct 21 2022 at 03:27)</a>:</h4>
<p>for example, you might try to take the finset of elements in the fintype and convert it to a list, but <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.to_list">docs#finset.to_list</a> is noncomputable</p>



<a name="305275806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305275806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305275806">(Oct 21 2022 at 03:29)</a>:</h4>
<p>the reason the uniqueness proof is needed with <code>fintype.choose</code> is because it removes the element of randomness and narrows down the search to a single mathematically defined object</p>



<a name="305275918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305275918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305275918">(Oct 21 2022 at 03:31)</a>:</h4>
<p>I'm far from a Lean expert, so it's possible that there's a method that I'm unaware of... perhaps someone else will weigh in</p>



<a name="305276085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305276085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305276085">(Oct 21 2022 at 03:34)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/nat.find">docs#nat.find</a> only requires an existence proof, but (I think) that's because you have an order and you're specifically requesting the "least" one, so it's not random</p>



<a name="305276240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305276240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305276240">(Oct 21 2022 at 03:37)</a>:</h4>
<p>if your fintype has a well founded order on it, you might be able to find what you need using <a href="https://leanprover-community.github.io/mathlib_docs/find/is_well_founded.fix">docs#is_well_founded.fix</a></p>



<a name="305276504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305276504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305276504">(Oct 21 2022 at 03:43)</a>:</h4>
<p>Ok yeah I see what you mean. In my head something being finite (having cardinality n) means there is an bijection between that and {1,...n}, but that may not be true in this type theory stuff (I'm still pretty new) and so we can't computably choose one such bijection (im looking at <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.trunc_fin_bijection">docs#fintype.trunc_fin_bijection</a> for instance but there is some weird trunc thing going on to maintain computability). I was mostly trying to use this for some decidability properties that are required for when adding stuff in the graph theory part of mathlib. I liked the idea of it being the most elementary possible, but I'm really close to just doing everything classically. Not sure how people working on mathlib feel about that?</p>



<a name="305276607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305276607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305276607">(Oct 21 2022 at 03:45)</a>:</h4>
<blockquote>
<p>I liked the idea of it being the most elementary possible, but I'm really close to just doing everything classically. Not sure how people working on mathlib feel about that?</p>
</blockquote>
<p>Like are they okay with using the axiom of choice all over the place?</p>



<a name="305278631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305278631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305278631">(Oct 21 2022 at 04:24)</a>:</h4>
<blockquote>
<p>In my head something being finite (having cardinality n) means there is an bijection between that and {1,...n}, but that may not be true in this type theory stuff (I'm still pretty new) and so we can't computably choose one such bijection </p>
</blockquote>
<p>You can choose the first element of a list using <a href="https://leanprover-community.github.io/mathlib_docs/find/list.find">docs#list.find</a>, but <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset">docs#multiset</a> is a quotient of <code>list</code> where the order is forgotten, so there is no longer a well-defined first element, and <a href="https://leanprover-community.github.io/mathlib_docs/find/finset">docs#finset</a> (which underlies <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype">docs#fintype</a>) consists of multisets without duplicate elements. So you can't pick an element if it's it not unique, without using some extra structure (like a linear order to narrow down to a unique element) or choice. If you are in a proof and not constructing data, <code>obtain ⟨a,h2⟩ := h1</code> should work though, because any two proofs of the same Prop are same to Lean, no matter what <code>a</code> you use in the proof.</p>



<a name="305278680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305278680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305278680">(Oct 21 2022 at 04:24)</a>:</h4>
<p>Jérémie, are you trying to prove something using such an <code>a : V</code>, or construct data? Seems like the latter, since you are trying to eliminate into something that isn't Prop. How would your constructed data vary if you somehow chose a different <code>a' : V</code>?</p>



<a name="305284935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305284935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305284935">(Oct 21 2022 at 06:00)</a>:</h4>
<p>Yeah, if <code>cases</code> doesn't work it sounds like you're abusing tactic mode ie your goal is not a true-false statement. Just use <code>exists.some</code>in this case.</p>



<a name="305362313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305362313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305362313">(Oct 21 2022 at 14:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="507101">Jérémie Turcotte</span> <a href="#narrow/stream/113489-new-members/topic/Decidability.20with.20fintype/near/305276504">said</a>:</p>
<blockquote>
<p>In my head something being finite (having cardinality n) means there is a bijection between that and {1,...n}, but that may not be true in this type theory stuff (I'm still pretty new) and so we can't computably choose one such bijection</p>
</blockquote>
<p>If <em>something</em> is finite, there indeed exists a bijection between it and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left\{1,\dots,n\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span>. It has nothing to do with computability.</p>



<a name="305374761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Decidability%20with%20fintype/near/305374761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Decidability.20with.20fintype.html#305374761">(Oct 21 2022 at 14:59)</a>:</h4>
<p>Yeah that's actually the definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/finite">docs#finite</a>. However since it's a Prop you can't get back the bijection computably: no matter what bijection you use to prove finiteness, the resulting proofs are all equal; this is called proof irrelevance in type theory. The idea is that you can't get back lost/forgotten information computably. <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.trunc_fin_bijection">docs#fintype.trunc_fin_bijection</a> uses a quotient (<a href="https://leanprover-community.github.io/mathlib_docs/find/trunc">docs#trunc</a>) to collapse all bijections to a single element; it is computable because a term in the <code>trunc</code> type carries no more information than the mere existence of a bijection. This "truncated" bijection can then be used to define other data that does not depend on the choice of the bijection.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
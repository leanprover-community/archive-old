---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/classical.2Esome.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html">classical.some</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204970949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204970949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anya Michaelsen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204970949">(Jul 24 2020 at 21:56)</a>:</h4>
<p>Hi! I've been working on writing a theorem for the Chinese Remainder Theorem ring isomorphism.  I already have a theorem that gives the existence of a solution to a pair of congruences and want to use that to define one of the isomorphism maps. When proving that this map and the projection are inverses for the ring isomorphism, I ran into `classical.some _'  in my goal and am not sure how to work with this, i.e. access the properties that it has. I looked at the docs for classical.some and classical.some_spec but since I didn't create the classical.some (it seems to have been generated by the function.inverse goal on simplification), I'm not sure how to use these. Here is a snap shot of the code: </p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">CRTwith2</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span><span class="o">:</span> <span class="n">coprime</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">npos</span><span class="o">:</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">mpos</span><span class="o">:</span> <span class="n">m</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span>  <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">n</span><span class="bp">*</span><span class="n">m</span><span class="o">)</span> <span class="err">≃</span><span class="bp">+*</span> <span class="n">zmod</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">zmod</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="c1">--define maps</span>
    <span class="n">use</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)),</span>
    <span class="n">intro</span> <span class="n">xy</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">CRT</span> <span class="o">:=</span> <span class="n">CRTwith2exist</span> <span class="n">xy</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">val</span> <span class="n">xy</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">val</span> <span class="n">n</span> <span class="n">m</span> <span class="n">npos</span> <span class="n">mpos</span> <span class="n">H</span><span class="o">,</span>
    <span class="c">/-</span><span class="cm">theorem CRTwith2exist (a1 a2 M1 M2 : ℕ ) (M1pos : 0 &lt; M1) (M2pos : 0 &lt; M2) (H : coprime M1 M2) :</span>
<span class="cm">                         ∃ x : ℕ , modeq M1 x a1 ∧ modeq M2 x a2 -/</span>
    <span class="n">choose</span> <span class="n">x</span> <span class="n">Hx</span> <span class="kn">using</span> <span class="n">CRT</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">x</span><span class="o">,</span>

    <span class="c1">-- show inverses (needs classical.some)</span>
    <span class="o">{</span>
        <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span>
        <span class="c1">-- Goal here: ⊢ ↑(classical.some _) = y</span>
    <span class="o">},</span>
    <span class="c1">--show other proprties...</span>
<span class="kn">end</span>
</code></pre></div>


<p>Clicking on 'classical.some _' in Lean Infoview yields this <a href="/user_uploads/3121/hiStRoybtS6IK3-eI3Wbv3ui/image.png">picture</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/hiStRoybtS6IK3-eI3Wbv3ui/image.png" title="picture"><img src="/user_uploads/3121/hiStRoybtS6IK3-eI3Wbv3ui/image.png"></a></div>



<a name="204972463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204972463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204972463">(Jul 24 2020 at 22:18)</a>:</h4>
<p><span class="user-mention" data-user-id="306595">@Anya Michaelsen</span> can you post complete working code (i.e. include all imports)?</p>



<a name="204975932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204975932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204975932">(Jul 24 2020 at 23:19)</a>:</h4>
<p>You might like the definition</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm">-</span>
<span class="cm">A convenience method for extracting the property satisfied by a term which is merely equal to</span>
<span class="cm">`classical.some _`.</span>
<span class="cm">-/</span>
<span class="kn">lemma</span> <span class="n">classical</span><span class="bp">.</span><span class="n">spec_of_eq_some</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">w</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>that Johan and I recently wanted while working on sheaves, to deal with something just like this.</p>



<a name="204975948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204975948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204975948">(Jul 24 2020 at 23:19)</a>:</h4>
<p>(It will eventually be PR'd to mathlib, but you can copy and paste it and use already.)</p>



<a name="204977959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204977959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anya Michaelsen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204977959">(Jul 25 2020 at 00:00)</a>:</h4>
<p>Here the full code for this file. The other version of <code>CRTwith2exists</code> is in a file CRT.lean (the first import) </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">CRT</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">modeq</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">ring</span>
<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">open</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">modeq</span> <span class="n">zmod</span> <span class="n">CRT</span>

<span class="c1">-------------------------ISOMORPHISM VERSION--------------------------</span>

<span class="kn">theorem</span> <span class="n">CRTwith2</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span><span class="o">:</span> <span class="n">coprime</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">npos</span><span class="o">:</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">mpos</span><span class="o">:</span> <span class="n">m</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span>  <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">n</span><span class="bp">*</span><span class="n">m</span><span class="o">)</span> <span class="err">≃</span><span class="bp">+*</span> <span class="n">zmod</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">zmod</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="c1">--define maps</span>
    <span class="n">use</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)),</span>
    <span class="n">intro</span> <span class="n">xy</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">CRT</span> <span class="o">:=</span> <span class="n">CRTwith2exist</span> <span class="n">xy</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">val</span> <span class="n">xy</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">val</span> <span class="n">n</span> <span class="n">m</span> <span class="n">npos</span> <span class="n">mpos</span> <span class="n">H</span><span class="o">,</span>
    <span class="c">/-</span><span class="cm">theorem CRTwith2exist (a1 a2 M1 M2 : ℕ ) (M1pos : 0 &lt; M1) (M2pos : 0 &lt; M2) (H : coprime M1 M2) :</span>
<span class="cm">                         ∃ x : ℕ , modeq M1 x a1 ∧ modeq M2 x a2 -/</span>
    <span class="n">choose</span> <span class="n">x</span> <span class="n">Hx</span> <span class="kn">using</span> <span class="n">CRT</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">x</span><span class="o">,</span>

    <span class="c1">-- show inverses (needs classical.some)</span>
    <span class="o">{</span>
        <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span>
        <span class="c1">-- Goal here: ⊢ ↑(classical.some _) = y</span>
    <span class="o">},</span>
    <span class="c1">--show other proprties...</span>
<span class="kn">end</span>
</code></pre></div>



<a name="204979432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204979432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204979432">(Jul 25 2020 at 00:31)</a>:</h4>
<p>Unfortunately this doesn't help us as a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>.</p>



<a name="204979481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204979481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204979481">(Jul 25 2020 at 00:32)</a>:</h4>
<p>The point is to give us a chunk of code to copy and paste into VSCode, so we can play with it.</p>



<a name="204979679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204979679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204979679">(Jul 25 2020 at 00:37)</a>:</h4>
<p>This is difficult partly because you're using tactics to create data. In fact <code>CRTwith2</code> should be a <code>def</code>, not a <code>theorem</code>.</p>



<a name="204979738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204979738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204979738">(Jul 25 2020 at 00:38)</a>:</h4>
<p>is there a way to construct <code>≃+*</code> where you only give the forward map?</p>



<a name="204979815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204979815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204979815">(Jul 25 2020 at 00:40)</a>:</h4>
<p>this pattern (product a ring isomorphism by giving a ring map that's bijective) ought to be in the library already</p>



<a name="204980279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204980279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204980279">(Jul 25 2020 at 00:52)</a>:</h4>
<p>So there's <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.of_bijective">docs#equiv.of_bijective</a> and the extra fields of <code>ring_hom</code> only pertain to the forward map, so this should work. I suggest defining a plain <code>equiv</code> using <code>equiv.of_bijective</code> first and then extending it to a <code>ring_hom</code>.</p>



<a name="204980388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204980388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204980388">(Jul 25 2020 at 00:55)</a>:</h4>
<p>I recently constructed a <code>≃+*</code> using the antipattern <code>{ ..f, ..e}</code>, where <code>f</code> was a <code>ring_hom</code> and <code>e</code> an <code>equiv</code>. I'd also be happy to have a named constructor for this, or to learn where it is.</p>



<a name="204980590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204980590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204980590">(Jul 25 2020 at 00:59)</a>:</h4>
<p>why is that an antipattern? It's actually doing something you can't achieve with a named constructor, namely verifying a defeq</p>



<a name="204981093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204981093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204981093">(Jul 25 2020 at 01:12)</a>:</h4>
<p>does it actually verify a defeq, or does it just check that the <code>ring_hom</code> proofs also type check against the <code>equiv</code> fields (or vice versa?)</p>



<a name="204981159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204981159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204981159">(Jul 25 2020 at 01:13)</a>:</h4>
<p>But yeah, since <code>ring_hom</code> only has extra <code>Prop</code> fields, it would make sense to have a constructor from <code>equiv</code> and <code>ring_hom</code> plus a hypothesis of <code>=</code></p>



<a name="204982284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204982284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204982284">(Jul 25 2020 at 01:45)</a>:</h4>
<p>Hmm, okay, I see it's not so bad.</p>



<a name="204995277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/204995277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#204995277">(Jul 25 2020 at 08:50)</a>:</h4>
<p>Maybe we should switch to <code>is_ring_hom</code>? Oh wait...</p>



<a name="205001886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/classical.some/near/205001886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/classical.2Esome.html#205001886">(Jul 25 2020 at 12:21)</a>:</h4>
<p>Well, the issue was never really <code>is_ring_hom</code> existing, it was being a class</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
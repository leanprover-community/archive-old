---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Type.20classes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html">Type classes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="181731847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/181731847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> yuppie <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#181731847">(Nov 23 2019 at 21:23)</a>:</h4>
<p>Hey everybody,</p>
<p>I am trying to prove a basic algebra homework. If every element of a group (actually not necessarily finite, but let's forget about that) has order 2 the group is commutative. Here is my code snippet:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">order_of_element</span>

<span class="kn">variable</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">T</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span><span class="bp">*</span><span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="bp">=</span><span class="n">y</span><span class="bp">*</span><span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">h</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">h</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">o</span> <span class="o">:=</span> <span class="n">mul_left_inj</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">o</span> <span class="k">with</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">cases</span> <span class="o">(</span><span class="n">mul_right_inj</span> <span class="n">b</span><span class="o">)</span> <span class="k">with</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_assoc</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_assoc</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_one</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_assoc</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_assoc</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">mul_assoc</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">l</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">U</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">order_of</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">→</span> <span class="n">comm_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">mul_comm</span> <span class="o">:</span> <span class="n">comm_group</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mul_comm</span>
<span class="kn">end</span>
</pre></div>


<p>The lemma T type checks (ok it might not be pretty but it works). But I wanted to rewrite it in a way that looks more "native" (how you would find it on a exercise sheet). And I tried theorem U but somehow I don't really get the type class comm_group (or type classes in general). How do you repair this?</p>
<p>Thanks for your help!</p>



<a name="181733857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/181733857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#181733857">(Nov 23 2019 at 22:27)</a>:</h4>
<p>Here is what I would do, I shortened <code>T</code> a bit by using a new lemma fixed the statement of <code>U</code> and try to explain typeclasses a little, hope it helps!</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span>

<span class="c1">-- this is a useful lemma, it is used 3 times even in the on paper proof</span>
<span class="kn">lemma</span> <span class="n">W</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span><span class="o">))</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- multiply by x⁻¹</span>
    <span class="n">rwa</span> <span class="o">[</span><span class="n">pow_two</span><span class="o">,</span> <span class="n">inv_mul_cancel_left</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">T</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">W</span> <span class="o">(</span><span class="n">h</span> <span class="n">x</span><span class="o">),</span> <span class="c1">-- our lemma applies here call it `this`</span>
  <span class="c1">-- instead of using this we can just write W (h (blah)) explicitly everywhere if we want</span>
  <span class="k">have</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">this</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">),</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="n">mul_inv_rev</span><span class="o">,</span> <span class="err">←</span> <span class="n">this</span> <span class="n">x</span><span class="o">,</span> <span class="err">←</span> <span class="n">this</span> <span class="n">y</span><span class="o">]</span> <span class="n">at</span> <span class="n">l</span><span class="o">,</span> <span class="c1">-- (a*b)⁻¹ = b⁻¹ *a⁻¹ and our lemma twice</span>
<span class="kn">end</span>

<span class="c1">-- the original formulation order_of x = 2 is bad, the order of 1 is always 1</span>
<span class="c1">-- so no such groups existed! instead we want the order to be divide 2</span>
<span class="kn">lemma</span> <span class="n">Q</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">order_of</span> <span class="n">x</span> <span class="err">∣</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">begin</span>
  <span class="n">cases</span> <span class="o">(</span><span class="n">h</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h_1</span><span class="o">,</span> <span class="n">pow_mul</span><span class="o">,</span> <span class="n">pow_order_of_eq_one</span><span class="o">,</span> <span class="n">one_pow</span><span class="o">],</span> <span class="c1">-- use whatever divisibility we have</span>
<span class="kn">end</span>

<span class="c1">-- to add a typeclass for α we define an instance of it</span>
<span class="c1">-- in fact to give a comm_group we have to give the group structure</span>
<span class="c1">-- and the statement that multiplication commutes, so we assume a given group structure</span>
<span class="c1">-- [group α] like normal, but we name it g [g : group α], so we can refer to it</span>
<span class="c1">-- this is the last line ..g it says &quot;use the group structure coming from g&quot;</span>
<span class="c1">-- so we just have to prove commutativity by combining our lemmas</span>
<span class="kn">instance</span> <span class="n">order_two_comm_group</span> <span class="o">[</span><span class="n">g</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">order_of</span> <span class="n">x</span> <span class="err">∣</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">comm_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">mul_comm</span> <span class="o">:=</span> <span class="n">T</span> <span class="o">(</span><span class="n">Q</span> <span class="n">h</span><span class="o">),</span>
  <span class="bp">..</span><span class="n">g</span> <span class="o">}</span>
</pre></div>



<a name="181996889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/181996889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> yuppie <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#181996889">(Nov 27 2019 at 07:47)</a>:</h4>
<p>Hey, thanks for the answer!</p>
<p>It works like a charm but I cannot find any documentation about this <code>..g</code> syntax. Is it syntactic sugar for something else and has an alternative name? Moreover when I delete the last line</p>
<div class="codehilite"><pre><span></span><span class="bp">..</span><span class="n">g</span>
</pre></div>


<p>I get the following error message:</p>
<div class="codehilite"><pre><span></span>/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;mul&#39; was not provided
/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;mul_assoc&#39; was not provided
/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;one&#39; was not provided
/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;one_mul&#39; was not provided
/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;mul_one&#39; was not provided
/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;inv&#39; was not provided
/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;mul_left_inv&#39; was not provided
/home/double-curly.lean:37:14: error: type mismatch at field &#39;mul_comm&#39;
  T (Q h)
has type
  ∀ (x y : α), x * y = y * x
but is expected to have type
  ∀ (a b : α), a * b = b * a
</pre></div>


<p>The last two expressions - don't they have the same type?</p>



<a name="181996950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/181996950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#181996950">(Nov 27 2019 at 07:48)</a>:</h4>
<p>About <code>..g</code>: It roughly means "for fields that I didn't bother to tell you, just copy them from <code>g</code>"</p>



<a name="181996963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/181996963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#181996963">(Nov 27 2019 at 07:49)</a>:</h4>
<p>That's why you get all the "field <code>bla</code> not provided" errors when you delete <code>..g</code></p>



<a name="181998601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/181998601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> yuppie <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#181998601">(Nov 27 2019 at 08:23)</a>:</h4>
<p>I thought that it roughly means that. But do you know where this is explained in more detail? What about the error message complaining about the different naming of variables? Why does that pop up?</p>



<a name="181998672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/181998672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#181998672">(Nov 27 2019 at 08:24)</a>:</h4>
<p>No, I've never read the documentation... so I can't help you there.</p>



<a name="181998683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/181998683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#181998683">(Nov 27 2019 at 08:24)</a>:</h4>
<p>The different variable names shouldn't matter. It's likely something else that's wrong under the hood. I agree that the second error is confusing and unhelpful</p>



<a name="181998784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/181998784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> yuppie <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#181998784">(Nov 27 2019 at 08:27)</a>:</h4>
<p>Oh ok, thanks!</p>



<a name="182000057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/182000057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#182000057">(Nov 27 2019 at 08:50)</a>:</h4>
<p>Where did you look for documentation? It's explained in the chapter of TPIL about structure: <a href="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#objects" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#objects">https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#objects</a></p>



<a name="182000081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/182000081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#182000081">(Nov 27 2019 at 08:50)</a>:</h4>
<p>The confusing error message is probably because you have two multiplications on the same type.</p>



<a name="182000091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/182000091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#182000091">(Nov 27 2019 at 08:51)</a>:</h4>
<p>But it's hard to tell without code we could test.</p>



<a name="182006966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/182006966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#182006966">(Nov 27 2019 at 10:41)</a>:</h4>
<p>What the error isn't telling you is that the <code>*</code> in the first case has a type class instance that is constructed from the missing fields, but since you didn't provide the fields it put <code>sorry</code> in for the type class, while it is expecting a structure literal (which is what shows up in the "official" type for <code>mul_comm</code>)</p>



<a name="182006984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/182006984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#182006984">(Nov 27 2019 at 10:41)</a>:</h4>
<p>Basically it is error compounding - the first few errors cause more errors down the line</p>



<a name="182009278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/182009278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#182009278">(Nov 27 2019 at 11:14)</a>:</h4>
<p>In short, "field mul not provided" also means "don't take anything I say about multiplication seriously after this point"</p>



<a name="182049328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/182049328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Elvorfirilmathredia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#182049328">(Nov 27 2019 at 19:09)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span>

<span class="c1">-- this is a useful lemma, it is used 3 times even in the on paper proof</span>
<span class="kn">lemma</span> <span class="n">W</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span><span class="o">))</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- multiply by x⁻¹</span>
    <span class="n">rwa</span> <span class="o">[</span><span class="n">pow_two</span><span class="o">,</span> <span class="n">inv_mul_cancel_left</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


</blockquote>
<p>I'm still getting used to Lean so this is probably a stupid question, but why can I not write <code>have := congr_arg (group.mul (x⁻¹)) h</code> ?</p>
<p>Hm, <code>has_mul.mul</code> works ...</p>



<a name="182049701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20classes/near/182049701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20classes.html#182049701">(Nov 27 2019 at 19:13)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span>

<span class="c1">-- this is a useful lemma, it is used 3 times even in the on paper proof</span>
<span class="kn">lemma</span> <span class="n">W</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">group</span><span class="bp">.</span><span class="n">mul</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span><span class="o">))</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="err">^</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="mi">1</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="n">pow_two</span><span class="o">,</span> <span class="n">inv_mul_cancel_left</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>[sorry if someone else posted, I'm on the underground with sporadic reception]. <code>rw</code> works with syntactic equality not definitional equality.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
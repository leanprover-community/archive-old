---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/stlc.20terms.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html">stlc terms</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="240795106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240795106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240795106">(May 31 2021 at 06:03)</a>:</h4>
<p>If I understand correctly, in the untyped lambda calculus, we have the inductive definition for terms as something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
</code></pre></div>
<p>In this [1] and other formulations of the simply typed lambda calculus I am confused to see this definition unaltered. I had guessed that it would have been amended to incorporate the typing rules somehow. It seems to say that we can have a term of something like <code>app (10) (20)</code>? But then what would its type be? It wouldn't have one by the typing rules right? Doesn't every term have to have a type?<br>
[1] <a href="https://softwarefoundations.cis.upenn.edu/current/plf-current/Stlc.html">https://softwarefoundations.cis.upenn.edu/current/plf-current/Stlc.html</a></p>



<a name="240795693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240795693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240795693">(May 31 2021 at 06:15)</a>:</h4>
<p>I guess further down in the same document it says that some terms are untypable. I guess programs like Coq and Lean have additional rules to prohibit untypable terms?</p>



<a name="240795804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240795804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240795804">(May 31 2021 at 06:17)</a>:</h4>
<p>Right, in this formulation typing only comes later as some sort of deduction system on these terms, like in the "Typing" section of the book you linked. And then you can start to ask and to prove things like whether a term is well typed, to infer the type of a term (or give an error if it's ill typed), that some operations preserve well typing and so on. And you can indeed have ill typed terms like you point out, but you are generally interested in those well typed</p>



<a name="240795860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240795860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240795860">(May 31 2021 at 06:18)</a>:</h4>
<p>This, if I remember correctly the terminology is sometimes called Curry-style typing.</p>



<a name="240795873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240795873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240795873">(May 31 2021 at 06:18)</a>:</h4>
<p>But you can also implement the types as intrinsic part of the definition of terms, which is Church-style typing</p>



<a name="240795974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240795974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240795974">(May 31 2021 at 06:21)</a>:</h4>
<p>Interesting. So Coq and Lean and similar programs use Church style typing?</p>



<a name="240795989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240795989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240795989">(May 31 2021 at 06:21)</a>:</h4>
<p>Where you would have something <code>term : ty -&gt; Type</code> and then <code>app (a b) : term (a --&gt; b) -&gt; term a -&gt; term b</code> so to speak. And this way it will not make sense, by definition to speak of ill typed terms, they don't exist</p>



<a name="240796058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240796058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240796058">(May 31 2021 at 06:22)</a>:</h4>
<p>That I don't know, but I think not, though I'm out of my knowledge zone here</p>



<a name="240796164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240796164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240796164">(May 31 2021 at 06:24)</a>:</h4>
<p>Thank you. Is <code>ty</code> a misprint for <code>Type</code>?</p>



<a name="240796291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240796291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240796291">(May 31 2021 at 06:27)</a>:</h4>
<p>No, that would be the simple types of the lambda calculus you are implementing, as opposed to Type, the Lean types, or the types of the system you are implementing it in</p>



<a name="240796376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240796376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240796376">(May 31 2021 at 06:28)</a>:</h4>
<p>So you would have probably an inductive definition of <code>ty</code> saying stuff like "if a and b are types in ty, you can construct a function type in ty"</p>



<a name="240796703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240796703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240796703">(May 31 2021 at 06:34)</a>:</h4>
<p>A function type <code>a --&gt; b</code> I mean, in my notation above, I think I didn't explain that very good</p>



<a name="240796763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240796763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240796763">(May 31 2021 at 06:35)</a>:</h4>
<p>I think I see. term is a constructor that takes a ty and returns a Type. And app takes two Types and returns a Type.</p>



<a name="240796955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240796955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240796955">(May 31 2021 at 06:38)</a>:</h4>
<p>Is that right?</p>



<a name="240797093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240797093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240797093">(May 31 2021 at 06:40)</a>:</h4>
<p><code>term</code> would be an inductive type indexed by <code>ty</code>, and <code>ty</code> would be an inductive type. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">ty</span>
<span class="bp">|</span> <span class="n">some_constant_type</span> <span class="o">:</span> <span class="n">ty</span>
<span class="bp">|</span> <span class="n">function_type</span> <span class="o">:</span> <span class="n">ty</span> <span class="bp">-&gt;</span> <span class="n">ty</span> <span class="bp">-&gt;</span> <span class="n">ty</span>

<span class="kd">infixr</span> <span class="bp">`==&gt;`</span> <span class="o">:</span> <span class="mi">50</span> <span class="o">:=</span> <span class="n">ty.function_type</span>

<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="n">ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ty</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="o">(</span><span class="n">a</span> <span class="bp">==&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">term</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">term</span> <span class="n">b</span>
</code></pre></div>



<a name="240797110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240797110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240797110">(May 31 2021 at 06:41)</a>:</h4>
<p>Something like this</p>



<a name="240797163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240797163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240797163">(May 31 2021 at 06:42)</a>:</h4>
<p><code>app</code> takes two terms (<em>of appropriate types, by definition</em>) and returns a term (<em>of appropriate type, by definition</em>)</p>



<a name="240797285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240797285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240797285">(May 31 2021 at 06:43)</a>:</h4>
<p>I see. Cool. Thank you!</p>



<a name="240800379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240800379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240800379">(May 31 2021 at 07:25)</a>:</h4>
<p>It would be interesting and maybe educational to see what the full formalization of just the simply typed lambda portion of Coq or Lean is, in Coq or Lean. Especially if a user could interact with it in such a way as to manually apply each typing rule, reduction, etc. Basically to see and interact with what is going on behind the scenes. And then see what is changed by adding polymorphism, etc.</p>



<a name="240803763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240803763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240803763">(May 31 2021 at 08:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/stlc.20terms/near/240795974">said</a>:</p>
<blockquote>
<p>Interesting. So Coq and Lean and similar programs use Church style typing?</p>
</blockquote>
<p>Yes. The key difference with church style typing is that a type appears in the term constructor for lambda, <code>\lam x: T, e</code> rather than an unspecified <code>\lam x, e</code> like in your original inductive type</p>



<a name="240851757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240851757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240851757">(May 31 2021 at 16:29)</a>:</h4>
<p>How does adding a type in the term constructor for lambda prevent the construction of a term that is not typable, like <code>app (10) (20)</code>?</p>



<a name="240852746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240852746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240852746">(May 31 2021 at 16:41)</a>:</h4>
<p>If I understand Mario correctly I was mistaken in calling my construction there Church typing (or rather, it is Church typing, but you don't need all that for it to count as Church typing), and I should've probably spoken about implicitly vs explicitly typed syntaxes.</p>



<a name="240853026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240853026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240853026">(May 31 2021 at 16:45)</a>:</h4>
<p>So, yes, you can speak of <code>app (10) (20)</code> which is a term even though it is ill-typed</p>



<a name="240853081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240853081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240853081">(May 31 2021 at 16:46)</a>:</h4>
<p>I see.</p>



<a name="240856928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240856928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240856928">(May 31 2021 at 17:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/stlc.20terms/near/240800379">said</a>:</p>
<blockquote>
<p>It would be interesting and maybe educational to see what the full formalization of just the simply typed lambda portion of Coq or Lean is, in Coq or Lean. Especially if a user could interact with it in such a way as to manually apply each typing rule, reduction, etc. Basically to see and interact with what is going on behind the scenes. And then see what is changed by adding polymorphism, etc.</p>
</blockquote>
<p>Is this possible, or maybe does it already exist?</p>



<a name="240858209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240858209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240858209">(May 31 2021 at 17:53)</a>:</h4>
<p>Maybe Lean metaprogramming would interest you? I don't know much about it, but if I understand correctly it exposes the Lean implementation of these constructions to you, within Lean, so that you can play around with them and see what happens internally. I don't know about simply typed fragments and so on.</p>



<a name="240858371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240858371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240858371">(May 31 2021 at 17:55)</a>:</h4>
<p>Or do you mean a full formalization in the sense of defining these systems in Lean and proving stuff about them?</p>



<a name="240859119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240859119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240859119">(May 31 2021 at 18:06)</a>:</h4>
<p>Yes, a full formalization in Lean or Coq. I'm not as interested in proving stuff about them as in being able to do stuff like see how a term is typed or reduced step by step. Doing something like this more formally:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">1</span><span class="bp">.</span> <span class="o">[],</span> <span class="o">[]</span> <span class="o">::</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">|-</span> <span class="n">g</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span> <span class="bp">;</span> <span class="n">Var</span>
<span class="mi">2</span><span class="bp">.</span> <span class="o">[],</span> <span class="o">[]</span> <span class="o">::</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">|-</span> <span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span> <span class="bp">;</span> <span class="n">Var</span>
<span class="mi">3</span><span class="bp">.</span> <span class="o">[],</span> <span class="o">[]</span> <span class="o">::</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">|-</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">;</span> <span class="n">Var</span>
<span class="mi">4</span><span class="bp">.</span> <span class="o">[],</span> <span class="o">[]</span> <span class="o">::</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">|-</span> <span class="n">f</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">;</span> <span class="n">App</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="mi">5</span><span class="bp">.</span> <span class="o">[],</span> <span class="o">[]</span> <span class="o">::</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">|-</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">;</span> <span class="n">App</span> <span class="mi">1</span> <span class="mi">4</span>
<span class="mi">6</span><span class="bp">.</span> <span class="o">[],</span> <span class="o">[]</span> <span class="o">::</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">|-</span> <span class="k">fun</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">=&gt;</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span> <span class="bp">;</span> <span class="n">Lam</span> <span class="mi">5</span>
<span class="mi">7</span><span class="bp">.</span> <span class="o">[],</span> <span class="o">[]</span> <span class="o">::</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">|-</span> <span class="k">fun</span> <span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">=&gt;</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">;</span> <span class="n">Lam</span> <span class="mi">6</span>
<span class="mi">8</span><span class="bp">.</span> <span class="o">[],</span> <span class="o">[]</span> <span class="bp">|-</span> <span class="k">fun</span> <span class="n">g</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">=&gt;</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)))</span> <span class="o">:</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">((</span><span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span><span class="o">))</span> <span class="bp">;</span> <span class="n">Lam</span> <span class="mi">7</span>
</code></pre></div>



<a name="240859200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240859200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240859200">(May 31 2021 at 18:07)</a>:</h4>
<p>It sounds like playing around with <code>expr</code> is close to what you want.</p>



<a name="240859211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240859211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240859211">(May 31 2021 at 18:07)</a>:</h4>
<p>(I.e., the metaprogramming suggestion by Horatiu above.)</p>



<a name="240859349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240859349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240859349">(May 31 2021 at 18:09)</a>:</h4>
<p>Hmm. Where could I find more info?</p>



<a name="240859599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240859599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240859599">(May 31 2021 at 18:13)</a>:</h4>
<p>The tactic writing tutorial, the youtube tutorial on metaprogramming by Rob Lewis, and here on zulip</p>



<a name="240859797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240859797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240859797">(May 31 2021 at 18:16)</a>:</h4>
<p>Thank you.</p>



<a name="240859848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240859848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240859848">(May 31 2021 at 18:17)</a>:</h4>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span> ooh, you could also work with Lean 4. It's mostly implemented in Lean 4 itself.</p>



<a name="240859935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240859935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240859935">(May 31 2021 at 18:18)</a>:</h4>
<p>Nice.</p>



<a name="240859953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240859953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240859953">(May 31 2021 at 18:19)</a>:</h4>
<p>I'll take a look.</p>



<a name="240860531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240860531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240860531">(May 31 2021 at 18:26)</a>:</h4>
<p>Hmm. It looks like the kernel is in C++.</p>



<a name="240878556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240878556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240878556">(May 31 2021 at 23:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/stlc.20terms/near/240803763">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/stlc.20terms/near/240795974">said</a>:</p>
<blockquote>
<p>Interesting. So Coq and Lean and similar programs use Church style typing?</p>
</blockquote>
<p>Yes. The key difference with church style typing is that a type appears in the term constructor for lambda, <code>\lam x: T, e</code> rather than an unspecified <code>\lam x, e</code> like in your original inductive type</p>
</blockquote>
<p>Do you also mean that Coq and Lean use a formalization like the one given by Horatiu?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">ty</span>
<span class="bp">|</span> <span class="n">some_constant_type</span> <span class="o">:</span> <span class="n">ty</span>
<span class="bp">|</span> <span class="n">function_type</span> <span class="o">:</span> <span class="n">ty</span> <span class="bp">-&gt;</span> <span class="n">ty</span> <span class="bp">-&gt;</span> <span class="n">ty</span>

<span class="kd">infixr</span> <span class="bp">`==&gt;`</span> <span class="o">:</span> <span class="mi">50</span> <span class="o">:=</span> <span class="n">ty.function_type</span>

<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="n">ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ty</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="o">(</span><span class="n">a</span> <span class="bp">==&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">term</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">term</span> <span class="n">b</span>
</code></pre></div>



<a name="240898738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/240898738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#240898738">(Jun 01 2021 at 06:16)</a>:</h4>
<p>No, application does not have type arguments. See <code>expr.app</code>. But lambda does.</p>



<a name="241988211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241988211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241988211">(Jun 08 2021 at 21:21)</a>:</h4>
<p>Is this correct (in Haskell)? Are the types for the var term and the bound variable in the abs term the same or should they differ?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">data</span> <span class="kt">Nat</span> <span class="ow">=</span> <span class="kt">O</span> <span class="o">|</span> <span class="kt">S</span> <span class="kt">Nat</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">Atomic</span> <span class="o">|</span> <span class="kt">Arrow</span> <span class="kt">Type</span> <span class="kt">Type</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">Nat</span> <span class="o">|</span> <span class="kt">App</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="o">|</span> <span class="kt">Abs</span> <span class="kt">Nat</span> <span class="kt">Type</span> <span class="kt">Term</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>


<span class="kr">type</span> <span class="kt">Expr</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Term</span><span class="p">,</span> <span class="kt">Type</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Expr</span><span class="p">]</span>

<span class="kr">type</span> <span class="kt">Proof</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Context</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">)</span>


<span class="c1">-- Typing rules</span>

<span class="nf">applyVar</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Proof</span>
<span class="nf">applyVar</span> <span class="n">c</span> <span class="n">e</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">elem</span> <span class="n">e</span> <span class="n">c</span> <span class="kr">then</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"bad input"</span>

<span class="nf">applyApp</span> <span class="ow">::</span> <span class="kt">Proof</span> <span class="ow">-&gt;</span> <span class="kt">Proof</span> <span class="ow">-&gt;</span> <span class="kt">Proof</span>
<span class="nf">applyApp</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="kt">Arrow</span> <span class="n">s11</span> <span class="n">s12</span><span class="p">))</span> <span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span> <span class="o">&amp;&amp;</span> <span class="n">s11</span> <span class="o">==</span> <span class="n">s2</span> <span class="kr">then</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="p">(</span><span class="kt">App</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">,</span> <span class="n">s12</span><span class="p">))</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"bad input"</span>
<span class="nf">applyApp</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>

<span class="nf">applyAbs</span> <span class="ow">::</span> <span class="kt">Proof</span> <span class="ow">-&gt;</span> <span class="kt">Proof</span>
<span class="nf">applyAbs</span> <span class="p">(((</span><span class="kt">Var</span> <span class="n">v</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="kt">:</span> <span class="n">es</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span> <span class="ow">=</span> <span class="p">(</span><span class="n">es</span><span class="p">,</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">v</span> <span class="n">s1</span> <span class="n">t</span><span class="p">,</span> <span class="kt">Arrow</span> <span class="n">s1</span> <span class="n">s2</span><span class="p">))</span>
<span class="nf">applyAbs</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>

<span class="cm">{-</span>
<span class="cm">Example:</span>

<span class="cm">*Main&gt; applyApp (applyVar [(Var O, Arrow Atomic Atomic), (Var (S O), Atomic)] (Var O, (Arrow Atomic Atomic))) (applyVar [(Var O, Arrow Atomic Atomic), (Var (S O), Atomic)] (Var (S O), Atomic))</span>
<span class="cm">([(Var O,Arrow Atomic Atomic),(Var (S O),Atomic)],(App (Var O) (Var (S O)),Atomic))</span>
<span class="cm">-}</span>
</code></pre></div>



<a name="241988503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241988503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241988503">(Jun 08 2021 at 21:24)</a>:</h4>
<p>I think you want <code>applyVar</code> and similar definitions to return the type of the expression, rather than returning a context</p>



<a name="241988524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241988524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241988524">(Jun 08 2021 at 21:24)</a>:</h4>
<p>the context should be an additional argument to all the functions like a reader monad</p>



<a name="241988899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241988899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241988899">(Jun 08 2021 at 21:27)</a>:</h4>
<p>Your typing rules allow a single variable to have multiple types, which is not correct, or at least will significantly complicate substitution</p>



<a name="241989148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241989148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241989148">(Jun 08 2021 at 21:29)</a>:</h4>
<p>Are you thinking in terms of how to make it get the type of a given expression in a given context?</p>



<a name="241989693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241989693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241989693">(Jun 08 2021 at 21:34)</a>:</h4>
<p>yes, typecheckers usually have two functions, mutually defined: give me the type of a term, or check that this term has this type. The signatures are something like <code>Context -&gt; Term -&gt; option Type</code> and <code>Context -&gt; Term -&gt; Type -&gt; bool</code></p>



<a name="241989967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241989967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241989967">(Jun 08 2021 at 21:36)</a>:</h4>
<p>the second one is easily defined in terms of the first:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="nf">infer</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Type</span>
<span class="o">...</span>

<span class="nf">check</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">check</span> <span class="n">c</span> <span class="n">e</span> <span class="n">ty</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">infer</span> <span class="n">c</span> <span class="n">e</span> <span class="kr">of</span>
  <span class="kt">Just</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">ty</span>
  <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
</code></pre></div>



<a name="241990150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241990150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241990150">(Jun 08 2021 at 21:37)</a>:</h4>
<p>If you use <code>error</code> for error handling, then these can have type <code>Type</code> and <code>Unit</code> respectively, although that might cause haskell to delete calls to the unit function</p>



<a name="241990505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241990505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241990505">(Jun 08 2021 at 21:40)</a>:</h4>
<p>I see. I wasn't going for a type checker, but that was going to be the next attempt. Thank you. Do I have the data definitions right, especially in regard to the types for the var term and the bound variable in the abs term? Are the var terms just identifiers that can be added to the context and used as bound variables in abstraction?</p>



<a name="241992261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241992261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241992261">(Jun 08 2021 at 21:49)</a>:</h4>
<p>There are two general approaches here, known as "named variables" vs "de bruijn variables". You are using the "named variables" approach, even though the names are numbers here (they could be strings as well). The named variables approach has the advantage that you don't need to define or think about "lifting" terms when they go under a binder, but you do have to check for bound variable capture. de Bruijn variables refer to a binder by the number of nested binders, which makes alpha renaming and substitution a bit easier but adds lifting, and also makes it harder to read the resulting terms because the names of variables are implicit</p>



<a name="241992380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241992380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241992380">(Jun 08 2021 at 21:50)</a>:</h4>
<p>If you were to use the de bruijn variables approach, <code>Abs</code> would look like <code>Abs Type Term</code>, with no <code>Nat</code> argument since it always introduces the variable now named 0 and everything else shifts up</p>



<a name="241992880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241992880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241992880">(Jun 08 2021 at 21:55)</a>:</h4>
<p>I see. So the Term and Type data definitions are right for the named variables approach? I think Coq and Lean use de bruijn variables?</p>



<a name="241994045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241994045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241994045">(Jun 08 2021 at 22:07)</a>:</h4>
<p>Yes. Lean uses a combination of named and de bruijn variables called "locally nameless": variables inside a term are de bruijn, but binders are "opened" when they enter the local context, at which point they are replaced with "local constants" that are basically named variables</p>



<a name="241994165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241994165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241994165">(Jun 08 2021 at 22:08)</a>:</h4>
<p>HOL Light implements STLC using the named variables approach</p>



<a name="241994469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241994469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241994469">(Jun 08 2021 at 22:10)</a>:</h4>
<p>Interesting. Thank you!</p>



<a name="241997092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241997092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241997092">(Jun 08 2021 at 22:41)</a>:</h4>
<p>Is there a base type built into the STLC for Coq and Lean, or do inductive types take the place of that?</p>



<a name="241997480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241997480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241997480">(Jun 08 2021 at 22:47)</a>:</h4>
<p>Base types are only needed when there are no type constructors other than things like arrow. Practical systems will usually have some specific types there. Lean has a bunch of "base types": <code>Type u</code> and <code>Prop</code>, inductive types, and axiomatic constants</p>



<a name="241997620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241997620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241997620">(Jun 08 2021 at 22:48)</a>:</h4>
<p>HOL Light has <code>bool</code> (aka <code>Prop</code>) and <code>ind</code> (an infinite type used to build <code>nat</code>) as base types</p>



<a name="241997963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241997963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241997963">(Jun 08 2021 at 22:53)</a>:</h4>
<p>And types also become included as terms as an extension to the STLC?</p>



<a name="241999031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241999031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241999031">(Jun 08 2021 at 23:06)</a>:</h4>
<p>In dependently typed languages, types are also terms, so lambda and variables also appear as types</p>



<a name="241999121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241999121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241999121">(Jun 08 2021 at 23:08)</a>:</h4>
<p>well, even plain STLC often has type variables, but they are a separate class from regular variables. That's probably closer to HOL though</p>



<a name="241999827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/241999827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#241999827">(Jun 08 2021 at 23:18)</a>:</h4>
<p>It's not like adding another constructor like <code>data Term = Var Nat | App Term Term | Abs Nat Type Term | TypeC Type</code>?</p>



<a name="242001800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242001800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242001800">(Jun 08 2021 at 23:47)</a>:</h4>
<p>No, in DTT you have one inductive type containing all of the constructors of <code>Type</code> and <code>Term</code></p>



<a name="242001822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242001822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242001822">(Jun 08 2021 at 23:47)</a>:</h4>
<p>that has the side effect of making <code>Abs</code> a type constructor and <code>Arrow</code> a term constructor, because the two syntactic classes are unified</p>



<a name="242001916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242001916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242001916">(Jun 08 2021 at 23:49)</a>:</h4>
<p>If you have an embedding like <code>TypeC</code> that only means that every type is a term, but doesn't permit using <code>App</code> and <code>Abs</code> in types</p>



<a name="242001963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242001963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242001963">(Jun 08 2021 at 23:49)</a>:</h4>
<p>for example <code>list A</code> is a type in lean which can be rendered <code>App (Const "List") (Var 0)</code>, where <code>App</code> is the same <code>App</code> as used on terms</p>



<a name="242002354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242002354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242002354">(Jun 08 2021 at 23:55)</a>:</h4>
<p>You couldn't use <code>App (TypeC (Const "List")) ((TypeC (Var 0))</code>?<br>
Would unifying them like that imply that every term is a type? That isn't true right?</p>



<a name="242002710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242002710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242002710">(Jun 09 2021 at 00:00)</a>:</h4>
<p>That would be a <code>Term</code>, but not a <code>Type</code></p>



<a name="242002726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242002726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242002726">(Jun 09 2021 at 00:00)</a>:</h4>
<p>we want <code>List A</code> to be a type</p>



<a name="242003018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242003018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242003018">(Jun 09 2021 at 00:05)</a>:</h4>
<p>I see. But does unifying them in one inductive type remove the distinction between terms and types altogether? Aren't there base terms that are not types?</p>



<a name="242003045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242003045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242003045">(Jun 09 2021 at 00:05)</a>:</h4>
<p>I thought all types were terms, but not all terms were types.</p>



<a name="242012825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242012825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242012825">(Jun 09 2021 at 02:58)</a>:</h4>
<p>Is this right? Do I need to worry about the fact that inserting a value into the context that already has the value does not give an error, but overwrites the existing type for it?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- Modified from https://softwarefoundations.cis.upenn.edu/plf-current/Typechecking.html</span>

<span class="kr">import</span> <span class="nn">Data.Map</span>


<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">Atomic</span> <span class="o">|</span> <span class="kt">Arrow</span> <span class="kt">Type</span> <span class="kt">Type</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">String</span> <span class="o">|</span> <span class="kt">App</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="o">|</span> <span class="kt">Abs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>


<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Type</span>


<span class="nf">getType</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Type</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">v</span> <span class="n">gamma</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">App</span> <span class="n">tm1</span> <span class="n">tm2</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="p">(</span><span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm1</span><span class="p">,</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm2</span><span class="p">)</span> <span class="kr">of</span>
    <span class="p">(</span><span class="kt">Just</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="n">ty11</span> <span class="n">ty12</span><span class="p">),</span> <span class="kt">Just</span> <span class="n">ty2</span><span class="p">)</span> <span class="ow">-&gt;</span>
      <span class="kr">if</span> <span class="n">ty11</span> <span class="o">==</span> <span class="n">ty2</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="n">ty12</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">v</span> <span class="n">ty1</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">v</span> <span class="n">ty1</span> <span class="n">gamma</span> <span class="kr">in</span>
  <span class="kr">case</span> <span class="n">getType</span> <span class="n">gamma'</span> <span class="n">tm1</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="n">ty2</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="n">ty1</span> <span class="n">ty2</span><span class="p">)</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">Examples:</span>

<span class="cm">*Main&gt; getType (Data.Map.fromList [("a", Atomic)]) (Var "a")</span>
<span class="cm">Just Atomic</span>

<span class="cm">*Main&gt; getType (Data.Map.fromList [("a", Atomic), ("b", (Arrow Atomic Atomic))]) (App (Var "b") (Var "a"))</span>
<span class="cm">Just Atomic</span>

<span class="cm">*Main&gt; getType (Data.Map.fromList [("b", Atomic)]) (Abs "a" Atomic (Var "b"))</span>
<span class="cm">Just (Arrow Atomic Atomic)</span>
<span class="cm">-}</span>
</code></pre></div>



<a name="242147274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147274">(Jun 10 2021 at 00:25)</a>:</h4>
<p>I can't prove anything with this in its current form, correct? Not even limited propositional logic? What is the next minimal extension required to do that?</p>



<a name="242147447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147447">(Jun 10 2021 at 00:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/stlc.20terms/near/242003018">said</a>:</p>
<blockquote>
<p>I see. But does unifying them in one inductive type remove the distinction between terms and types altogether? Aren't there base terms that are not types?</p>
</blockquote>
<p>In DTT, the distinction between types and terms is a matter of typechecking, not syntax. A type is something whose type is <code>*</code> (in a haskell like language) or <code>Sort u</code> for lean</p>



<a name="242147488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147488">(Jun 10 2021 at 00:30)</a>:</h4>
<p>I see.</p>



<a name="242147551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147551">(Jun 10 2021 at 00:30)</a>:</h4>
<blockquote>
<p>Is this right? Do I need to worry about the fact that inserting a value into the context that already has the value does not give an error, but overwrites the existing type for it?</p>
</blockquote>
<p>That's okay as long as the updates to the context are functional / temporary within a scope. Once you are out of the scope with the shadowed variable the variable needs to go back to its old type</p>



<a name="242147575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147575">(Jun 10 2021 at 00:31)</a>:</h4>
<p>you can also accomplish this by keeping the context as an ordered list and doing linear search when looking variables up in the context</p>



<a name="242147669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147669">(Jun 10 2021 at 00:33)</a>:</h4>
<p>In haskell the former approach is easier since <code>Data.Map</code> is already a persistent map, and that's what you did</p>



<a name="242147753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147753">(Jun 10 2021 at 00:34)</a>:</h4>
<p>your typechecker looks correct</p>



<a name="242147766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147766">(Jun 10 2021 at 00:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/stlc.20terms/near/242147274">said</a>:</p>
<blockquote>
<p>I can't prove anything with this in its current form, correct? Not even limited propositional logic? What is the next minimal extension required to do that?</p>
</blockquote>
<p>Well it's haskell, so no</p>



<a name="242147777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147777">(Jun 10 2021 at 00:34)</a>:</h4>
<p>You can just transpose all of this to lean though</p>



<a name="242147820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147820">(Jun 10 2021 at 00:35)</a>:</h4>
<p>You mean no type checker I write in Haskell can prove propositional logic? Because Haskell itself can't prove propositional logic?</p>



<a name="242147832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147832">(Jun 10 2021 at 00:35)</a>:</h4>
<p>I mean if you want to prove the correctness of the typechecker</p>



<a name="242147852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147852">(Jun 10 2021 at 00:35)</a>:</h4>
<p>If you want to write a prover in haskell that works fine</p>



<a name="242147915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147915">(Jun 10 2021 at 00:36)</a>:</h4>
<p>Oh. No, I'm not worried about formally checking it. This is more a learning exercise for now.</p>



<a name="242147919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242147919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242147919">(Jun 10 2021 at 00:36)</a>:</h4>
<p>If you want to extend STLC to intuitionistic logic you need some more constructors like and / or</p>



<a name="242150783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242150783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242150783">(Jun 10 2021 at 01:32)</a>:</h4>
<p>This topic was moved by <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> to <a class="stream-topic" data-stream-id="236446" href="/#narrow/stream/236446-Type-theory/topic/stlc.20terms">#Type theory &gt; stlc terms</a></p>



<a name="242150877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242150877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242150877">(Jun 10 2021 at 01:34)</a>:</h4>
<p>I'm not sure what happened. If I click on the topic in Type theory there is no history.</p>



<a name="242150973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242150973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242150973">(Jun 10 2021 at 01:36)</a>:</h4>
<p>and <code>getType _ trivial = Just True</code>?</p>



<a name="242150975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242150975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242150975">(Jun 10 2021 at 01:36)</a>:</h4>
<p>you sure about that?</p>



<a name="242150979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242150979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242150979">(Jun 10 2021 at 01:36)</a>:</h4>
<p>I see the history, try reloading</p>



<a name="242151001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/stlc%20terms/near/242151001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/stlc.20terms.html#242151001">(Jun 10 2021 at 01:37)</a>:</h4>
<p>Ok. Yes, needed to reload.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html">my code is so egregious</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="240893199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240893199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240893199">(Jun 01 2021 at 04:19)</a>:</h4>
<p>any tips to make this code look less egregious</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.basic</span>
<span class="kn">import</span> <span class="n">data.list.sort</span>

<span class="kd">def</span> <span class="n">adaptor</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">ℤ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">head</span><span class="o">::</span><span class="n">rest</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">rest</span> <span class="bp">=</span> <span class="o">[]</span> <span class="k">then</span> <span class="n">head</span> <span class="k">else</span> <span class="n">min</span> <span class="n">head</span> <span class="o">(</span><span class="n">adaptor</span> <span class="n">rest</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">aux3</span> <span class="o">(</span><span class="n">values</span> <span class="n">values'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">values</span> <span class="bp">~</span> <span class="n">values'</span><span class="o">)</span> <span class="o">:</span> <span class="n">adaptor</span> <span class="n">values</span> <span class="bp">=</span> <span class="n">adaptor</span> <span class="n">values'</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">h</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span> <span class="n">he</span> <span class="n">hf</span> <span class="n">hg</span> <span class="n">hh</span> <span class="n">aw</span> <span class="n">ajd</span> <span class="n">jvkd</span> <span class="n">akdls</span> <span class="n">fks</span> <span class="n">ala</span> <span class="n">fvn</span> <span class="n">wow</span> <span class="n">vnd</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">adaptor</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">adaptor</span><span class="o">,</span>
  <span class="n">split_ifs</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">list.perm_nil.mp</span> <span class="o">(</span><span class="n">hf.symm</span><span class="o">),</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h_1</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h_1</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">list.perm_nil.mp</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hg</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">adaptor</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">adaptor</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">adaptor</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">adaptor</span><span class="o">,</span>
  <span class="n">split_ifs</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h_1</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">hh</span> <span class="o">::</span> <span class="n">ajd</span> <span class="bp">≠</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.cons_ne_nil</span> <span class="n">hh</span> <span class="n">ajd</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">hh</span> <span class="o">::</span> <span class="n">ajd</span> <span class="bp">≠</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.cons_ne_nil</span> <span class="n">hh</span> <span class="n">ajd</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h_1</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">min_comm</span><span class="o">],</span>
  <span class="n">rw</span> <span class="n">min_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">min_assoc</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">min_comm</span> <span class="o">(</span><span class="n">adaptor</span> <span class="n">ajd</span><span class="o">)</span> <span class="n">aw</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">wow</span><span class="o">,</span> <span class="n">vnd</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="240893254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240893254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240893254">(Jun 01 2021 at 04:20)</a>:</h4>
<p>Absolute <a href="https://github.com/leanprover-community/mathlib/issues/1">#1</a> suggestion --- learn to use braces to delimit subgoals!</p>



<a name="240893284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240893284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240893284">(Jun 01 2021 at 04:21)</a>:</h4>
<p>Basically if <em>ever</em> a tactic results in multiple goals, the next line should start with a brace. (Exceptions only if the next line is <code>swap</code> or <code>show</code> to reorder the goals.)</p>



<a name="240893300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240893300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240893300">(Jun 01 2021 at 04:21)</a>:</h4>
<p>After that, read the <a href="https://leanprover-community.github.io/contribute/style.html">#style</a> guide.</p>



<a name="240893343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240893343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240893343">(Jun 01 2021 at 04:22)</a>:</h4>
<p>Put multiple <code>rw</code> on the same line using <code>rw [a, b, c]</code>.</p>



<a name="240893361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240893361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240893361">(Jun 01 2021 at 04:22)</a>:</h4>
<p>If a tactic introduces new hypotheses that you actually use, name them yourself instead of using the auto-generated names.</p>



<a name="240893381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240893381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240893381">(Jun 01 2021 at 04:23)</a>:</h4>
<p>(all those comments are without even attempting to read the statement or proof. :-)</p>



<a name="240893503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240893503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240893503">(Jun 01 2021 at 04:25)</a>:</h4>
<p>You should rarely be using <code>rw adaptor</code> where <code>adaptor</code> is an inductive definition. Instead, make sure you have proved the appropriate <code>@[simp] lemma adaptor_nil : ... := rfl</code> and <code>@[simp] lemma adaptor_cons : ... := rfl</code> lemmas. (Or use the <code>@[simps]</code> attribute to automatically generate them.)</p>



<a name="240893553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240893553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240893553">(Jun 01 2021 at 04:26)</a>:</h4>
<p>Writing good <code>@[simp]</code> lemmas is essential for nearly every definition you write.</p>



<a name="240893587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240893587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240893587">(Jun 01 2021 at 04:26)</a>:</h4>
<p>(You should always be hoping that the borings corners of your proof are <code>by { intros, ext, simp, }</code>, and when they are not, you should wonder if they could be.)</p>



<a name="240894009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240894009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240894009">(Jun 01 2021 at 04:36)</a>:</h4>
<p>(Okay, maybe that it slightly overstating the case. But good <code>@[ext]</code> and <code>@[simp]</code> lemmas make life easier for everyone who comes afterwards, so are worth thinking about!)</p>



<a name="240902625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240902625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240902625">(Jun 01 2021 at 07:13)</a>:</h4>
<p>From a more mathematical point of view, you might find it easier to leverage the existing lemma <code>list.perm.foldr_eq</code>. Here's my attempt at this approach:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.basic</span>
<span class="kn">import</span> <span class="n">data.list.sort</span>

<span class="kd">def</span> <span class="n">adaptor</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">ℤ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">head</span><span class="o">::</span><span class="n">rest</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">rest</span> <span class="bp">=</span> <span class="o">[]</span> <span class="k">then</span> <span class="n">head</span> <span class="k">else</span> <span class="n">min</span> <span class="n">head</span> <span class="o">(</span><span class="n">adaptor</span> <span class="n">rest</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">adaptor_aux</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">with_top</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="o">(</span><span class="n">l.map</span> <span class="n">coe</span><span class="o">)</span><span class="bp">.</span><span class="n">foldr</span> <span class="o">(</span><span class="bp">⊓</span><span class="o">)</span> <span class="bp">⊤</span>

<span class="kd">lemma</span> <span class="n">adaptor_aux_cons_ne_top</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">adaptor_aux</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="bp">≠</span> <span class="bp">⊤</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">hl</span><span class="o">,</span> <span class="o">(</span><span class="n">with_top.coe_ne_top</span> <span class="o">(</span><span class="n">inf_eq_top_iff.mp</span> <span class="n">hl</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>

<span class="kd">lemma</span> <span class="n">adaptor_aux_eq_top</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">adaptor_aux</span> <span class="n">l</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="bp">↔</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">list.nil</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">hl</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">l</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">adaptor_aux_cons_ne_top</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span> <span class="n">congr_arg</span> <span class="n">adaptor_aux</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">adaptor_eq_adaptor_aux</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">adaptor</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">option.get_or_else</span> <span class="o">(</span><span class="n">adaptor_aux</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">a</span> <span class="n">l</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">hl</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">list.nil</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">hl</span><span class="o">,</span>
      <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">with_top.coe_eq_coe</span><span class="o">,</span>
      <span class="n">change</span> <span class="bp">↑</span><span class="o">(</span><span class="n">ite</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span> <span class="bp">⊓</span> <span class="n">_</span><span class="o">))</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">option.get_or_else_of_ne_none</span> <span class="o">(</span><span class="n">adaptor_aux_cons_ne_top</span> <span class="n">a</span> <span class="n">l</span><span class="o">),</span> <span class="n">if_neg</span> <span class="n">hl</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">with_top.coe_inf</span><span class="o">],</span>
      <span class="n">change</span> <span class="n">_</span> <span class="bp">⊓</span> <span class="n">some</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">option.get_or_else_of_ne_none</span> <span class="o">(</span><span class="n">mt</span> <span class="o">(</span><span class="n">adaptor_aux_eq_top</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hl</span><span class="o">)],</span>
      <span class="n">refl</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">aux3_aux</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">adaptor_aux</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">adaptor_aux</span> <span class="n">l₂</span> <span class="o">:=</span>
<span class="n">list.perm.foldr_eq</span> <span class="n">inf_left_comm</span> <span class="o">(</span><span class="n">list.perm.map</span> <span class="n">coe</span> <span class="n">h</span><span class="o">)</span> <span class="bp">⊤</span>

<span class="kd">lemma</span> <span class="n">aux3</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">adaptor</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">adaptor</span> <span class="n">l₂</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">adaptor_eq_adaptor_aux</span><span class="o">,</span> <span class="n">adaptor_eq_adaptor_aux</span><span class="o">,</span> <span class="n">aux3_aux</span><span class="o">]</span>
</code></pre></div>



<a name="240924604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/my%20code%20is%20so%20egregious/near/240924604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/my.20code.20is.20so.20egregious.html#240924604">(Jun 01 2021 at 10:57)</a>:</h4>
<p>For an approach closer to your initial version, you can also do this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.basic</span>
<span class="kn">import</span> <span class="n">data.list.sort</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">adaptor</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">head</span><span class="o">::</span><span class="n">rest</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">rest</span> <span class="bp">=</span> <span class="o">[]</span> <span class="k">then</span> <span class="n">head</span> <span class="k">else</span> <span class="n">min</span> <span class="n">head</span> <span class="o">(</span><span class="n">adaptor</span> <span class="n">rest</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">adaptor</span>

<span class="kd">lemma</span> <span class="n">cons_eq_min</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">l0</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">≠</span> <span class="o">[]),</span> <span class="n">adaptor</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">x</span> <span class="o">(</span><span class="n">adaptor</span> <span class="n">l</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">l0</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">l0</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">cons_eq</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">p₁</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">≠</span> <span class="o">[])</span> <span class="o">(</span><span class="n">p₂</span> <span class="o">:</span> <span class="n">l₂</span> <span class="bp">≠</span> <span class="o">[])</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">adaptor</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">adaptor</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">adaptor</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">l₁</span><span class="o">)</span> <span class="bp">=</span> <span class="n">adaptor</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">cons_eq_min</span> <span class="n">p₁</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">((</span><span class="n">congr_arg</span> <span class="n">_</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">cons_eq_min</span> <span class="n">p₂</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">aux3</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">adaptor</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">adaptor</span> <span class="n">l₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">h</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span> <span class="n">_</span> <span class="n">hf</span> <span class="n">hg</span> <span class="n">_</span> <span class="n">_</span> <span class="n">g</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">wow</span> <span class="n">vnd</span><span class="bp">;</span> <span class="n">clear</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">hd</span> <span class="k">with</span> <span class="n">a</span> <span class="n">l</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">hf.symm.eq_nil</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">cons_eq</span> <span class="o">(</span><span class="n">l.cons_ne_nil</span> <span class="n">a</span><span class="o">)</span> <span class="n">_</span> <span class="n">hg</span><span class="o">,</span>
      <span class="n">exact</span> <span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">l.not_perm_nil_cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">hf.trans</span> <span class="o">(</span><span class="n">list.perm_nil.mpr</span> <span class="n">j</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">g</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">min_comm</span> <span class="n">_</span> <span class="n">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">min_left_comm</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">wow.trans</span> <span class="n">vnd</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">adaptor</span>
</code></pre></div>
<p>Note that with this version you again have to walk around the weirdness of the definition of <code>adaptor</code> for <code>[]</code>, but you do it "internally".</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
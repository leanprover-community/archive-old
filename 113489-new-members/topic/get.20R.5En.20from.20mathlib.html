---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html">get R^n from mathlib</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="308907343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/308907343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#308907343">(Nov 10 2022 at 02:06)</a>:</h4>
<p>Hello Lean-Prover Community,</p>
<p>I'm very new to Lean. I've completed Kevin Buzzard's Natural Number Game, and the tutorial project exercise files. I'm in the process of reading Theorem Proving in Lean.</p>
<p>As a hands-on learning exercise, I'd like to try formalizing some theorems from a textbook I have; it covers basic real analysis and linear algebra. I want to work at the same level of generality as the book, taking from mathlib anything that the book assumes.</p>
<p>I quickly run up against a roadblock. How does one import/construct a definition for R^n from mathlib?</p>
<p>(side note, are there any beginner resources doing similar formalizations that I might learn from?)</p>



<a name="308908424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/308908424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#308908424">(Nov 10 2022 at 02:22)</a>:</h4>
<p>The standard approach is to use <code>fin n \-&gt; \R</code> (sorry for the lack of unicode... I'm writing this on mobile). With the right imports (some sufficiently deep file from <code>linear_algebra</code> would suffice), this would obtain a structure of a vector space over the reals</p>



<a name="308908466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/308908466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#308908466">(Nov 10 2022 at 02:23)</a>:</h4>
<p>Following along b/c I have a similar goal -- would like to do linear algebra done right, and import only the minimum from <code>mathlib</code> -- if there's material for how get the minimums from <code>mathlib</code> without all the proofs that one wants to reconstruct.</p>



<a name="308908477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/308908477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#308908477">(Nov 10 2022 at 02:23)</a>:</h4>
<p>Another useful thing to look at is mathlib's matrix notation, found here <a href="https://tqft.net/mathlib/data/matrix/notation">file#data/matrix/notation</a></p>



<a name="308909430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/308909430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#308909430">(Nov 10 2022 at 02:36)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="243562">@Adam Topaz</span> for the response!</p>
<p>My understanding of <code>fin n /to \R</code> is a function type from <code>fin n</code> to <code>\R</code>, but I have not seen <code>fin</code>. Is it some kind of index type? Where can I learn more?</p>



<a name="308909559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/308909559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#308909559">(Nov 10 2022 at 02:38)</a>:</h4>
<p><code>fin n</code> is a type with <code>n</code> elements. So functions from <code>fin n</code> to <code>R</code> can be thought of as n-tuples of real numbers.</p>



<a name="308909615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/308909615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#308909615">(Nov 10 2022 at 02:39)</a>:</h4>
<p>I think <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> covers this?</p>



<a name="308909662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/308909662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#308909662">(Nov 10 2022 at 02:39)</a>:</h4>
<p>Maybe not.</p>



<a name="308910454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/308910454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#308910454">(Nov 10 2022 at 02:49)</a>:</h4>
<p>I found <a href="https://leanprover-community.github.io/mathlib_docs/data/fin/vec_notation.html">https://leanprover-community.github.io/mathlib_docs/data/fin/vec_notation.html</a> (sorry, no idea what magic embeds doc links)</p>



<a name="308935694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/308935694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#308935694">(Nov 10 2022 at 07:57)</a>:</h4>
<p>That notation works for concrete numerals like elements of <code>fin 4 -&gt; \R</code>.</p>



<a name="308935907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/308935907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#308935907">(Nov 10 2022 at 07:59)</a>:</h4>
<p>Mathematicians would write the type <code>fin n -&gt; \R</code> as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mi mathvariant="double-struck">R</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathrm{Hom}(\{0,1,\ldots,n-1\},\R).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Hom</span></span><span class="mopen">({</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbb">R</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></p>



<a name="308936032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/308936032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#308936032">(Nov 10 2022 at 08:00)</a>:</h4>
<p>That's our "model" in mathlib for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\R^n.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></p>



<a name="309012437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/309012437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#309012437">(Nov 10 2022 at 15:26)</a>:</h4>
<p>As an observation, there's a trend where one tries to do undergraduate math using <code>mathlib</code> but one ends up doing category theory</p>



<a name="309026997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/309026997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#309026997">(Nov 10 2022 at 16:31)</a>:</h4>
<p>The arrow is not the category theory arrow, it's the function arrow. So it's not category theory yet.</p>



<a name="309029122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/309029122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#309029122">(Nov 10 2022 at 16:42)</a>:</h4>
<p>This has nothing to do with category theory! This is the usual definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>. People often lie to themselves and pretend <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> is an iterated product of individual copies of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span> but they don't mean it. An element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">\R^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> doesn't look like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((x, y), z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>, it looks like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0, x_1,  x_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> which is exactly description of a map from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0, 1, 2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">}</span></span></span></span>, aka <code>fin 3</code>, to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span>.</p>



<a name="309031776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/309031776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#309031776">(Nov 10 2022 at 16:55)</a>:</h4>
<p>I only wrote the Hom thing to explain another way of thinking about the function type.</p>



<a name="309037018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/309037018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#309037018">(Nov 10 2022 at 17:21)</a>:</h4>
<p>I was jokingly referring to the homomorphism.</p>
<p>But it's true, though. The documentation for linear algebra "basic" states that "This file defines the basics of linear algebra. It sets up the "categorical/lattice structure" of modules over a ring, submodules, and linear maps" and the underlying definition of a vector space is in terms of <code>module</code> where the documentation is "A module is a generalization of vector spaces to a scalar semiring. It consists of a scalar semiring R and an additive monoid of "vectors" M, connected by a "scalar multiplication" operation r • x : M (where r : R and x : M) with some natural associativity and distributivity axioms similar to those on a ring."</p>
<p>This isn't quite at the "a monad is a monoid in the category of endofunctors" level, but it's close.</p>
<p>A reasonably rigorous undergraduate linear algebra text like Axler starts with an "ordered list of length n" (which does conform to <code>fin n</code>) and the basic axioms of a vector space.</p>



<a name="309038000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/309038000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#309038000">(Nov 10 2022 at 17:25)</a>:</h4>
<p>I wonder whether it's better to discard all that and start with <code>set</code> and define closed addition and scalar multiplication?</p>



<a name="309040737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/309040737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#309040737">(Nov 10 2022 at 17:38)</a>:</h4>
<p>Linear algebra is not linear algebra without linear maps. I suppose that's what the word "category" is referring to in the quote you mentioned.</p>



<a name="309043564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/309043564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#309043564">(Nov 10 2022 at 17:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="542196">Arien Malec</span> <a href="#narrow/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib/near/309038000">said</a>:</p>
<blockquote>
<p>I wonder whether it's better to discard all that and start with <code>set</code> and define closed addition and scalar multiplication?</p>
</blockquote>
<p>I predict this will be an immense pain.</p>



<a name="309045879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/309045879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#309045879">(Nov 10 2022 at 18:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib/near/309043564">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="542196">Arien Malec</span> <a href="#narrow/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib/near/309038000">said</a>:</p>
<blockquote>
<p>I wonder whether it's better to discard all that and start with <code>set</code> and define closed addition and scalar multiplication?</p>
</blockquote>
<p>I predict this will be an immense pain.</p>
</blockquote>
<p>Probably. I guess I'm asking (from those who have taught or learned theorem proving in undergraduate math) what the the best way to use <code>mathlab</code> without pulling too much in, where the point is to re-derive and prove the same things that <code>mathlib</code> has already proved.</p>



<a name="309065363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/309065363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#309065363">(Nov 10 2022 at 19:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="542196">Arien Malec</span> <a href="#narrow/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib/near/309038000">said</a>:</p>
<blockquote>
<p>I wonder whether it's better to discard all that and start with <code>set</code> and define closed addition and scalar multiplication?</p>
</blockquote>
<p>Perhaps you already know this, but <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule">docs#submodule</a> does exactly that</p>



<a name="309065493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/309065493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#309065493">(Nov 10 2022 at 19:45)</a>:</h4>
<p>But sets aren't the building blocks of Lean, <code>Type</code>s are; so you rarely start with sets, instead starting with <code>Type</code>s and later specializing to <code>set</code>s.</p>



<a name="309068699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/309068699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#309068699">(Nov 10 2022 at 20:02)</a>:</h4>
<p>No, I didn't know that <code>submodule</code> automatizes linear spaces... Mm, so I could start with <a class="stream-topic" data-stream-id="288720" href="/#narrow/stream/288720-mathlib-documentation/topic/submodule">#mathlib documentation &gt; submodule</a>  and then do my own proofs from there &amp; pick up more of <code>mathlib</code> as I've already covered it?</p>
<p>I love <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>'s work on NNG (and I've now redone Complex NG in standard Lean3), and want to recreate that for reasonably undergraduately values of abstract linear algebra.</p>



<a name="312766706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/312766706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#312766706">(Nov 29 2022 at 04:50)</a>:</h4>
<p>Reviving this topic ...</p>
<p>I have come across a hurdle in my quest to formalize some undergraduate math.</p>
<p>I am trying to define the standard basis vectors for R^n. Minimally, I have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">R</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">ℝ</span>

<span class="kd">def</span> <span class="n">e</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">j</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H</span><span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">decidable.em</span> <span class="o">(</span><span class="n">i</span><span class="bp">=</span><span class="n">j</span><span class="o">),</span>
  <span class="n">cases</span> <span class="n">H</span> <span class="k">with</span> <span class="n">heq</span> <span class="n">hneq</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>It's this final <code>cases</code> that gives an error: "induction tactic failed, recursor 'or.dcases_on' can only eliminate into Prop". As I understand it, the issue lies in fact of trying to construct a non-Prop value from a Prod inductive type (or). I believe the relevant text is found in <a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#axiomatic-details">7.8 Axiomatic Details (TPL)</a>, where it states "Generally speaking, for an inductive type in Prop, the motive of the elimination rule is required to be in Prop." Please correct me if I'm mistaken.</p>
<p>I guess my question is, what's my alternative? How can I define the standard basis vectors as I've set up above?</p>



<a name="312766906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/312766906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#312766906">(Nov 29 2022 at 04:52)</a>:</h4>
<p>In general it might not be a good idea to construct data in tactic mode.<br>
In this case you can do <code>refine if (h : i = j) then _ else _</code>.</p>



<a name="312767486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/312767486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#312767486">(Nov 29 2022 at 05:01)</a>:</h4>
<p>I see, thanks Andrew. Is your suggestion of  <code>refine if (h : i = j) then _ else _</code> for tactic mode or term mode?</p>



<a name="312768180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/312768180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#312768180">(Nov 29 2022 at 05:09)</a>:</h4>
<p>That is in tactic mode.  <code>refine</code> is a tactic.</p>



<a name="312768298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/312768298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#312768298">(Nov 29 2022 at 05:10)</a>:</h4>
<p>To elaborate further, tactic modes are generally designed for proofs, so the terms they produce might not be easy to manipulate. The most basic tactics (<code>intro</code>, <code>refine</code>, <code>apply</code>, <code>exact</code>) might be fine, some might be okay if you know what you are doing (<code>dsimp</code>, <code>change</code>, <code>cases</code>, ...), but other tactics will probably give unreadable and unusable terms.</p>



<a name="312768583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/312768583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#312768583">(Nov 29 2022 at 05:14)</a>:</h4>
<p>Thanks for the elaboration! Do you mind showing me how you would write this in term mode? Here is my try:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">e</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="n">n</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">or.rec_on</span> <span class="o">(</span><span class="n">decidable.em</span> <span class="o">(</span><span class="n">i</span><span class="bp">=</span><span class="n">j</span><span class="o">))</span> <span class="mi">1</span> <span class="mi">0</span>
</code></pre></div>
<p>I get a new error ""eliminator" elaborator failed to compute the motive", but I suspect it's the same issue.</p>
<p>Can you explain for me how we are getting around this issue of recursing on "or" (inductively defined Prop) and producing data (a real number) ?</p>



<a name="312768656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/312768656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#312768656">(Nov 29 2022 at 05:15)</a>:</h4>
<p>Btw, I am trying not to use classical until I need to</p>



<a name="312768833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/312768833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#312768833">(Nov 29 2022 at 05:16)</a>:</h4>
<p><code>if i = j then 1 else 0</code>. I believe this doesn't use classical but I might be wrong.</p>



<a name="312769074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/312769074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#312769074">(Nov 29 2022 at 05:19)</a>:</h4>
<p>Aha! I found <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html?highlight=else#decidable-propositions">10.4 Decidable Propositions (TPL)</a> which talks exactly about this if-then-else requiring decidable props. Wonderful!</p>



<a name="312786459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/312786459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#312786459">(Nov 29 2022 at 08:07)</a>:</h4>
<p>You might also want <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.single">docs#pi.single</a></p>



<a name="312837442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/get%20R%5En%20from%20mathlib/near/312837442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> King Crawford <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib.html#312837442">(Nov 29 2022 at 13:03)</a>:</h4>
<p>Try <code>by_cases i = j,</code> as an alternative to <code>have H: i = j ∨ ¬i = j, from decidable.em (i=j)</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
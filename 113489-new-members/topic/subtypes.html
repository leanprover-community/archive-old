---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/subtypes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html">subtypes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="226251679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226251679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226251679">(Feb 13 2021 at 16:00)</a>:</h4>
<p>I'm a bit confused about how subtypes work. This <code>simp [h]</code> doesn't close the subgoal:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.basic</span>
<span class="kn">import</span> <span class="n">ring_theory.power_series.basic</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kd">def</span> <span class="n">mv_restricted_power_series</span> <span class="o">(</span><span class="n">σ</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="bp">//</span> <span class="n">tendsto</span> <span class="n">f</span> <span class="n">cofinite</span> <span class="o">(</span><span class="n">nhds</span> <span class="mi">0</span><span class="o">)}</span>

<span class="kn">namespace</span> <span class="n">mv_restricted_power_series</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">σ</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">zero</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">mv_power_series.has_zero.zero</span><span class="o">,</span> <span class="n">tendsto_const_nhds</span><span class="o">⟩}</span>

<span class="kd">theorem</span> <span class="n">exists_max</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">norm</span> <span class="o">(</span><span class="n">f.val</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">norm</span> <span class="o">(</span><span class="n">f.val</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">em</span> <span class="o">(</span><span class="n">f</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span>
  <span class="o">{</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
  <span class="o">},</span>
  <span class="o">{}</span>
<span class="kd">end</span>
</code></pre></div>
<p>But if I change <code>cases em (f = 0)</code> to <code>cases em (f.val = 0)</code> it does close the goal. I don't get why this makes such a big difference; wouldn't it be more natural to write <code>f  = 0</code>?</p>



<a name="226252295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226252295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226252295">(Feb 13 2021 at 16:06)</a>:</h4>
<p>what imports do I need to make this a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="226252336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226252336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226252336">(Feb 13 2021 at 16:07)</a>:</h4>
<p>Edited, added them.</p>



<a name="226252418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226252418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226252418">(Feb 13 2021 at 16:09)</a>:</h4>
<p>I think there are some simp lemmas missing.</p>



<a name="226252505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226252505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226252505">(Feb 13 2021 at 16:10)</a>:</h4>
<p>Some simp lemmas that need to be written for <code>mv_restricted_power_series</code>? Or things missing from one of the imports?</p>



<a name="226252544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226252544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226252544">(Feb 13 2021 at 16:11)</a>:</h4>
<p>If <code>h : f = 0</code> then  <code>simp [h]</code> takes you to <code>0.val x</code> and then to <code>↑0 x</code> and then it gets stuck</p>



<a name="226252643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226252643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226252643">(Feb 13 2021 at 16:13)</a>:</h4>
<p>If <code>h : f.val = 0</code> then the simp does a <code>pi.zero_apply</code>, which I guess it doesn't want to do if <code>h : f = 0</code></p>



<a name="226252836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226252836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226252836">(Feb 13 2021 at 16:17)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">subtype.val</span><span class="o">⟩</span>

<span class="kd">@[simp, norm_cast]</span> <span class="kd">lemma</span> <span class="n">coe_zero</span> <span class="o">:</span>
  <span class="o">((</span><span class="mi">0</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">exists_max</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">norm</span> <span class="o">(</span><span class="n">f.val</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">norm</span> <span class="o">(</span><span class="n">f.val</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">em</span> <span class="o">(</span><span class="n">f</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">},</span> <span class="c1">-- works now</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226252896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226252896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226252896">(Feb 13 2021 at 16:18)</a>:</h4>
<p>ahh amazing, thanks!</p>



<a name="226252917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226252917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226252917">(Feb 13 2021 at 16:18)</a>:</h4>
<p><code>simp</code> changes <code>f.val</code> into <code>↑f</code> it seems, so you need a simp lemma saying that the coerced 0 is still 0.</p>



<a name="226252927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226252927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226252927">(Feb 13 2021 at 16:19)</a>:</h4>
<p>Right ok that makes sense</p>



<a name="226252941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226252941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226252941">(Feb 13 2021 at 16:19)</a>:</h4>
<p>The trick with these things is to look at the goal left by <code>simp</code> (in this case one involving <code>↑0</code>) and to ask "why did it not get any further than this?" and the answer is that the lemma you want to apply next (namely <code>↑0 = 0</code>) is not there.</p>



<a name="226252992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226252992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226252992">(Feb 13 2021 at 16:20)</a>:</h4>
<p>Making definitions is much harder than proving theorems, but after a while you just pick up the tricks of what needs to be done.</p>



<a name="226253635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226253635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226253635">(Feb 13 2021 at 16:32)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- don't want them to be explicit for this next function</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">σ</span> <span class="n">R</span><span class="o">}</span>

<span class="kn">open</span> <span class="n">mv_power_series</span>

<span class="kd">def</span> <span class="n">coeff</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">coeff</span> <span class="n">R</span> <span class="n">c</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">@[ext]</span> <span class="kd">lemma</span> <span class="n">ext</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">coeff</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">coeff</span> <span class="n">g</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">ext</span> <span class="n">c</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">c</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">ext_iff</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">coeff</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">coeff</span> <span class="n">g</span> <span class="n">c</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span> <span class="n">h</span> <span class="bp">▸</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">ext</span> <span class="n">f</span> <span class="n">g</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">exists_max</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">norm</span> <span class="o">(</span><span class="n">f.val</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">norm</span> <span class="o">(</span><span class="n">f.val</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">em</span> <span class="o">(</span><span class="n">f</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">},</span> <span class="c1">-- works now</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">ext_iff</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="gr">sorry</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p><span class="user-mention" data-user-id="235423">@Ashwin Iyengar</span>  that's how I'd start. Any new type needs an extensionality lemma.</p>



<a name="226253811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226253811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226253811">(Feb 13 2021 at 16:35)</a>:</h4>
<p>Nice, thanks</p>



<a name="226253883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226253883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226253883">(Feb 13 2021 at 16:36)</a>:</h4>
<p>In fact looking at <code>mv_power_series</code> the <code>coeff</code> function should be an R-module hom really.</p>



<a name="226253911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226253911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226253911">(Feb 13 2021 at 16:37)</a>:</h4>
<p>so another thing you might want to do is to make <code>mv_restricted_power_series σ R</code> into an <code>R</code>-module and then beef up the definition of <code>coeff</code></p>



<a name="226254174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226254174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226254174">(Feb 13 2021 at 16:41)</a>:</h4>
<p>Of course it's entirely up to you how you do this. If you're thinking about a PR (and you perhaps should be) then you might want to look at the beginning of the <a href="https://github.com/leanprover-community/mathlib/blob/master/src/ring_theory/power_series/basic.lean">power series file</a> in mathlib, where they do exactly what I decided was the best idea -- give it an R-module structure and then define coeff and ext. They also defined monomial. These things will ultimately make your life easier in the end.</p>



<a name="226254276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226254276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226254276">(Feb 13 2021 at 16:43)</a>:</h4>
<p>Cool yeah that's basically what I was planning to do after getting to grips with the library a bit more</p>



<a name="226254326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226254326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226254326">(Feb 13 2021 at 16:44)</a>:</h4>
<p>I know several cases of beginners who have started exactly this way -- made a PR to mathlib generalising something which was already there.</p>



<a name="226254338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226254338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226254338">(Feb 13 2021 at 16:44)</a>:</h4>
<p>Ashvni (who you know), Amelia and Jason (both IC UGs) all started like this.</p>



<a name="226254390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226254390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226254390">(Feb 13 2021 at 16:45)</a>:</h4>
<p>If you do nothing more than to make it a ring under the assumption of the ultrametric inequality then this is already really useful. Then you come back to look at it 3 months later and other random people have built on top of it. It's the way the library grows.</p>



<a name="226378684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226378684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226378684">(Feb 15 2021 at 12:38)</a>:</h4>
<p>I would expect that in my instantiation of an <code>add_comm_group</code>, I should just be able to do <code>rfl</code> for <code>add_assoc</code> because I added a <code>coe_add</code> but it doesn't work. Is there a simple way to prove <code>add_assoc</code> which essentially just says "it's true because it's true for the supertype"? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.basic</span>
<span class="kn">import</span> <span class="n">ring_theory.power_series.basic</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kd">noncomputable theory</span>

<span class="kd">def</span> <span class="n">mv_restricted_power_series</span> <span class="o">(</span><span class="n">σ</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_field</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="bp">//</span> <span class="n">tendsto</span> <span class="n">f</span> <span class="n">cofinite</span> <span class="o">(</span><span class="n">nhds</span> <span class="mi">0</span><span class="o">)}</span>

<span class="kn">namespace</span> <span class="n">mv_restricted_power_series</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">σ</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_field</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">subtype.val</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">zero</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">mv_power_series.has_zero.zero</span><span class="o">,</span> <span class="n">tendsto_const_nhds</span><span class="o">⟩}</span>

<span class="kd">@[simp, norm_cast]</span> <span class="kd">lemma</span> <span class="n">coe_zero</span> <span class="o">:</span>
  <span class="o">((</span><span class="mi">0</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">f.val</span> <span class="bp">+</span> <span class="n">g.val</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">tendsto.add</span> <span class="n">f.2</span> <span class="n">g.2</span><span class="o">⟩</span>

<span class="kd">@[simp, norm_cast]</span> <span class="kd">lemma</span> <span class="n">coe_add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">a.add</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">neg</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">-</span><span class="n">f.val</span><span class="o">,</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">f_conv</span> <span class="o">:=</span> <span class="n">metric.tendsto_nhds.1</span> <span class="n">f.2</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">f_conv</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">metric.tendsto_nhds</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">f_conv</span><span class="o">,</span>
<span class="kd">end</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="n">add</span><span class="o">,</span>
  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">zero_add</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">add_zero</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">neg</span> <span class="o">:=</span> <span class="n">neg</span><span class="o">,</span>
  <span class="n">add_left_neg</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">add_comm</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>



<a name="226381254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226381254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226381254">(Feb 15 2021 at 13:05)</a>:</h4>
<p>One thing that seems to work is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">add</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">],</span> <span class="n">apply</span> <span class="n">add_assoc</span><span class="o">,</span>  <span class="o">},</span>
</code></pre></div>



<a name="226383645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226383645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226383645">(Feb 15 2021 at 13:28)</a>:</h4>
<p><code>ext</code> ought to help here too, after those rintros</p>



<a name="226383982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226383982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226383982">(Feb 15 2021 at 13:32)</a>:</h4>
<p><code>  add_assoc := λ _ _ _, by {ext, simp only [add_assoc, coe_add]},</code> would be the way I would prove it. <code>by {ext, simp [add_assoc]} works too, but is slower. Note that </code>add_assoc<code> is not a </code>simp` lemma so needs to be added explicitly.</p>



<a name="226384060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226384060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226384060">(Feb 15 2021 at 13:33)</a>:</h4>
<p><code>rfl</code> means "this is true by definition, if you unfold all the definitions", so it won't work here, because if you unfold all the definitions you are reduced to associativity of addition for multivariable power series, which is true, but not true by definition -- it's true because of a theorem (in fact an axiom, namely associativity of addition on R).</p>



<a name="226384502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226384502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226384502">(Feb 15 2021 at 13:37)</a>:</h4>
<p>Thanks all! <code>ext</code> was the key that I wasn't aware existed.</p>



<a name="226385836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226385836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226385836">(Feb 15 2021 at 13:48)</a>:</h4>
<p>The <code>ext</code> lemma we proved earlier was tagged with <code>@[ext]</code>, which means that the <code>ext</code> tactic will use it. But actually I guess the reason it's working without that ext lemma is that the <code>ext</code> tactic is using <code>subtype.ext</code> and then the <code>ext</code> lemma for <code>mv_power_series</code>.</p>
<p>Here's a proof of <code>neg</code> which just says "f.2 says some filter tends to 0, so the corresponding filter for -f tends to -0".</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">neg</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">-</span><span class="n">f.val</span><span class="o">,</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">tendsto.comp</span> <span class="n">continuous_at_neg</span> <span class="n">f.2</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">neg_zero.symm</span><span class="o">,</span>
<span class="kd">end</span><span class="o">⟩</span>
</code></pre></div>



<a name="226385944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226385944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226385944">(Feb 15 2021 at 13:50)</a>:</h4>
<p>The implementation for something like <a href="https://leanprover-community.github.io/mathlib_docs/find/submonoid.to_monoid/src">src#submonoid.to_monoid</a> ought to show how <code>ext</code> is normally used here</p>



<a name="226386050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226386050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226386050">(Feb 15 2021 at 13:50)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span><span class="n">show_term</span><span class="o">{</span><span class="n">ext</span><span class="o">},</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">,</span> <span class="n">coe_add</span><span class="o">]},</span>
</code></pre></div>
<p>shows that it's using subtype.ext and then the ext lemma for mv power series</p>



<a name="226386132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226386132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226386132">(Feb 15 2021 at 13:51)</a>:</h4>
<p>Actually it seems like <code>ext</code> isn't used at all, and the proofs are just transferred across the injectivity of <code>coe</code>, using <a href="https://leanprover-community.github.io/mathlib_docs/find/function.injective.add_comm_monoid">docs#function.injective.add_comm_monoid</a></p>



<a name="226386931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226386931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226386931">(Feb 15 2021 at 13:57)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">coe_injective</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subtype.coe_injective</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">add</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_neg</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">neg</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">coe_injective.add_comm_group</span> <span class="n">_</span> <span class="n">rfl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span>
</code></pre></div>



<a name="226387009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226387009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226387009">(Feb 15 2021 at 13:58)</a>:</h4>
<p>There's the <code>rfl</code>s you were hoping to see</p>



<a name="226387113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226387113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226387113">(Feb 15 2021 at 13:58)</a>:</h4>
<p>How can this work? One has to check that the subtype condition is preserved by addition and negation.</p>



<a name="226387208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226387208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226387208">(Feb 15 2021 at 13:59)</a>:</h4>
<p>That's why you have to define<code> add</code> and <code>neg</code> yourself</p>



<a name="226387216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226387216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226387216">(Feb 15 2021 at 13:59)</a>:</h4>
<p>Oh I see, you use the contructions of add and neg</p>



<a name="226387308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226387308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226387308">(Feb 15 2021 at 14:00)</a>:</h4>
<p>(deleted)</p>



<a name="226387623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226387623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226387623">(Feb 15 2021 at 14:02)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">neg</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">-</span><span class="n">f.val</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">tendsto.comp</span> <span class="n">continuous_at_neg</span> <span class="n">f.2</span><span class="o">⟩</span>
</code></pre></div>



<a name="226387751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226387751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226387751">(Feb 15 2021 at 14:03)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">neg</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">-</span><span class="n">f.val</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">tendsto.neg</span> <span class="n">f.2</span><span class="o">⟩</span>
</code></pre></div>



<a name="226387879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226387879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226387879">(Feb 15 2021 at 14:04)</a>:</h4>
<p>No need to ever translate into epsilons.</p>



<a name="226415479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226415479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226415479">(Feb 15 2021 at 18:09)</a>:</h4>
<p>Thanks. This code works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">R</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨</span><span class="n">r</span> <span class="bp">•</span> <span class="n">f.val</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">tendsto.comp</span> <span class="o">((</span><span class="n">mul_left_continuous</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="n">tendsto</span> <span class="mi">0</span><span class="o">)</span> <span class="n">f.property</span><span class="o">⟩}</span>
</code></pre></div>
<p>but now I want to use <a href="https://leanprover-community.github.io/mathlib_docs/find/function.injective.semimodule">docs#function.injective.semimodule</a> to show that restricted power series are an R-module. The problem is that it's not clear that <code>coe</code> is an additive monoid homomorphism. My understanding is that morphisms should be bundled. So what's the best way of stating that <code>coe</code> is a homomorphism? Then I can do something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">coe_injective.semimodule</span> <span class="n">_</span> <span class="bp">???</span>
</code></pre></div>



<a name="226415902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226415902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226415902">(Feb 15 2021 at 18:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">coe_hom</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">coe</span><span class="o">,</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">coe_zero</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">coe_add</span> <span class="o">}</span>
</code></pre></div>



<a name="226415918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226415918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226415918">(Feb 15 2021 at 18:15)</a>:</h4>
<p>Ah ok so treat it as a separate thing. Thanks!</p>



<a name="226415984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226415984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226415984">(Feb 15 2021 at 18:15)</a>:</h4>
<p>yeah it's kind of annoying. In Lean 4 we might be able to go back to the <code>instance : is_add_monoid_hom coe</code> approach but in Lean 3 the separate thing approach turned out to be nicer.</p>



<a name="226416421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226416421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226416421">(Feb 15 2021 at 18:21)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">function.injective.semimodule</span> <span class="n">R</span> <span class="n">coe_hom</span> <span class="n">coe_hom_injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span>
</code></pre></div>
<p>works but I can't get <code>coe_hom_injective.semimodule ...</code> to work.</p>



<a name="226416591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226416591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226416591">(Feb 15 2021 at 18:23)</a>:</h4>
<p>Yeah I guess <code>coe_injective</code> doesn't know that <code>coe</code> is a hom</p>



<a name="226416697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226416697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226416697">(Feb 15 2021 at 18:24)</a>:</h4>
<p>Can you post an updated <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="226416718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226416718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226416718">(Feb 15 2021 at 18:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.basic</span>
<span class="kn">import</span> <span class="n">ring_theory.power_series.basic</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kd">noncomputable theory</span>

<span class="kd">def</span> <span class="n">mv_restricted_power_series</span> <span class="o">(</span><span class="n">σ</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="bp">//</span> <span class="n">tendsto</span> <span class="n">f</span> <span class="n">cofinite</span> <span class="o">(</span><span class="n">nhds</span> <span class="mi">0</span><span class="o">)}</span>

<span class="kn">namespace</span> <span class="n">mv_restricted_power_series</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">σ</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_field</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">subtype.val</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">coe_injective</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">subtype.coe_injective</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f.val</span> <span class="bp">+</span> <span class="n">g.val</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">tendsto.add</span> <span class="n">f.2</span> <span class="n">g.2</span><span class="o">⟩⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">tendsto_const_nhds</span><span class="o">⟩⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_neg</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">-</span><span class="n">f.val</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">tendsto.neg</span> <span class="n">f.2</span><span class="o">⟩⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">R</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨</span><span class="n">r</span> <span class="bp">•</span> <span class="n">f.val</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">tendsto.comp</span> <span class="o">((</span><span class="n">mul_left_continuous</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="n">tendsto</span> <span class="mi">0</span><span class="o">)</span> <span class="n">f.property</span><span class="o">⟩}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">coe_injective.add_comm_group</span> <span class="n">_</span> <span class="n">rfl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">coe_hom</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">coe</span><span class="o">,</span>
    <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">function.injective.semimodule</span> <span class="n">R</span> <span class="n">coe_hom</span> <span class="n">coe_injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span>
</code></pre></div>



<a name="226416991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226416991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226416991">(Feb 15 2021 at 18:28)</a>:</h4>
<p>Hey, nice <code>has_scalar.smul</code> proof :-) You can use <code>f.2</code> for <code>f.property</code> if you want (and <code>f.1</code> for <code>f.val</code>) -- but I'm not sure that there is any particular preference for one over the other, I'm just noting this general trick of X.1 and X.2 which works in large generality. Note that X.3 doesn't work :-( (in situations where it's meaningful, e.g. if X is a proof of P and Q and R) -- it's X.2.2.</p>



<a name="226417335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226417335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226417335">(Feb 15 2021 at 18:32)</a>:</h4>
<p>Ok, yeah either way I should probably pick a convention and stick to it</p>



<a name="226417369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226417369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226417369">(Feb 15 2021 at 18:32)</a>:</h4>
<p>I sort of like <code>f.val</code> and <code>f.property</code> because they're less ambiguous, but maybe that hasn't been the design principle?</p>



<a name="226417406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226417406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226417406">(Feb 15 2021 at 18:33)</a>:</h4>
<p>No, I agree about the lack of ambiguity, stick with them, I was just pointing out a trick.</p>



<a name="226417485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226417485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226417485">(Feb 15 2021 at 18:34)</a>:</h4>
<p>Honestly, the only reason I said it was that </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="o">{</span><span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨</span><span class="n">r</span> <span class="bp">•</span> <span class="n">f.val</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">tendsto.comp</span> <span class="o">((</span><span class="n">mul_left_continuous</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="n">tendsto</span> <span class="mi">0</span><span class="o">)</span> <span class="n">f.property</span><span class="o">⟩}</span>
</code></pre></div>
<p>is over 100 characters long, and there's a 100 character limit per line in mathlib, and this trick got it back down to under 100 characters :-)</p>



<a name="226417556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226417556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226417556">(Feb 15 2021 at 18:35)</a>:</h4>
<p>Ah good to know</p>



<a name="226418204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226418204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226418204">(Feb 15 2021 at 18:42)</a>:</h4>
<p>Usually coercion is used as the simp-normal form in place of <code>.val</code> or <code>.1</code></p>



<a name="226418252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226418252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226418252">(Feb 15 2021 at 18:43)</a>:</h4>
<p>That is,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">R</span> <span class="o">(</span><span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨</span><span class="n">r</span> <span class="bp">•</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">tendsto.comp</span> <span class="o">((</span><span class="n">mul_left_continuous</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="n">tendsto</span> <span class="mi">0</span><span class="o">)</span> <span class="n">f.prop</span><span class="o">⟩}</span>
</code></pre></div>



<a name="226418512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226418512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226418512">(Feb 15 2021 at 18:46)</a>:</h4>
<blockquote>
<p>Note that X.3 doesn't work :-( (in situations where it's meaningful, e.g. if X is a proof of P and Q and R) -- it's X.2.2.</p>
</blockquote>
<p>By the way, while I would be all for such an abbreviation, it makes X.2 ambiguous</p>



<a name="226423757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226423757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226423757">(Feb 15 2021 at 19:44)</a>:</h4>
<p>Also <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I would think that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span> <span class="kd">lemma</span> <span class="n">ext</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">f.val</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">g.val</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">ext</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">n</span><span class="o">}</span>
</code></pre></div>
<p>is more natural than</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span> <span class="kd">lemma</span> <span class="n">ext</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">mv_restricted_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">coeff</span> <span class="n">R</span> <span class="n">n</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">coeff</span> <span class="n">R</span> <span class="n">n</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">ext</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">n</span><span class="o">}</span>
</code></pre></div>
<p>but maybe  I'm missing something? Is the idea that using <code>coeff</code> is more elegant because it doesn't rely on the precise definition of <code>mv_power_series</code> or <code>mv_restricted_power_series</code>?</p>



<a name="226424431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226424431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226424431">(Feb 15 2021 at 19:52)</a>:</h4>
<p>I am always a bit edgy about abuse of definitional equality. What you say is exactly what worries me -- but I know that some computer scientists would find your suggestion more elegant. Your code breaks if someone refactors mv_power_series to be e.g. a completion of k[sigma]/I^n with I the ideal generated by the sigma, whereas mine uses the interface so doesn't break. I've seen definitions change in the past in mathlib. On the other hand the current definition of power series seems to be one which makes everyone happy right now so maybe it's unlikely to change in future. Abuse of definitional equality is really handy when you're writing slick term mode proofs at the beginning of your API. After a while it basically becomes irrelevant though, because e.g. if you're trying to prove that Tate algebras in finitely many variables over a complete nonarchimedean normed field are Noetherian then these issues are not really the important ones -- you're going to write a long tactic proof there so who cares what the definition is under the hood.</p>



<a name="226424679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226424679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226424679">(Feb 15 2021 at 19:55)</a>:</h4>
<p>I see. Yeah it's the little things like this I get perplexed by, like e.g. right now I'm stuck trying to convert <code>hd: ¬⇑(coeff R d) f = 0</code> to <code>hd: ¬∥f.val d∥ = 0</code></p>



<a name="226424783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226424783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226424783">(Feb 15 2021 at 19:57)</a>:</h4>
<p>You can probably <code>change ¬(f.val d = 0) at hd</code> because these will be definitional.</p>



<a name="226424823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226424823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226424823">(Feb 15 2021 at 19:58)</a>:</h4>
<p>But one thing you should definitely do is to decide once and for all whether you're going to refer to to the d'th coefficient of f via f.val d or coeff R d f or whatever, and then stick to your convention, and write simp lemmas changing every other convention to your convention.</p>



<a name="226425081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes/near/226425081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.html#226425081">(Feb 15 2021 at 20:01)</a>:</h4>
<p>A tactic a day...</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html">Transforming the type of a function</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="198948512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198948512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198948512">(May 27 2020 at 20:28)</a>:</h4>
<p>I've got the following definition, where I want to get the restrictions into the type because I'm going to end up taking a product of a function <code>a (n : nat) (is_prime : nat.prime n) : nat</code> over this set, and this way I can just use bigoperators.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">subtype</span>

<span class="n">def</span> <span class="n">primes_le</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">//</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">m</span><span class="o">}</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">r</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">//</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">m</span><span class="o">}</span> <span class="bp">=</span> <span class="n">finset</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">//</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">m</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">x_le_n</span><span class="o">,</span> <span class="n">x_prime</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">exact</span> <span class="bp">⟨</span><span class="n">nat</span><span class="bp">.</span><span class="n">lt_succ_iff</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">x_le_n</span><span class="o">,</span> <span class="n">x_prime</span><span class="bp">⟩</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">x_lt_sn</span><span class="o">,</span> <span class="n">x_prime</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">exact</span> <span class="bp">⟨</span><span class="n">nat</span><span class="bp">.</span><span class="n">lt_succ_iff</span><span class="bp">.</span><span class="n">mp</span> <span class="n">x_lt_sn</span><span class="o">,</span> <span class="n">x_prime</span> <span class="bp">⟩</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">r</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_filter</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_range</span><span class="o">]</span> <span class="kn">using</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">filter</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span><span class="bp">.</span><span class="n">attach</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>However, proving anything about this set is not obviously possible; it doesn't behave nicely under <code>unfold</code>, which is to be expected because I'm in tactic mode, which is always a big no-no when defining a function.</p>
<p>I'm going to want both <code>m &lt;= n</code> and <code>nat.prime m</code> in scope when I take my product over <code>primes_le n</code>. One way to proceed is to just use <code>finset.filter nat.prime (finset.range (n + 1))</code> in the definition of <code>primes_le</code>, and then at every call site I could prove <code>m &lt;= n</code> and <code>nat.prime m</code>; another way would be to provide an explicit function <code>finset {m:nat // m \in finset.filter nat.prime (finset.range (n + 1))}</code> to <code>finset {m : nat // m &lt;= n and nat.prime m}</code> and compose that with my <code>primes_le</code>. What's the One True Answer? I'm inclined to think the latter.</p>



<a name="198951217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951217">(May 27 2020 at 20:48)</a>:</h4>
<p>You're defining a certain finite subset of the primes which are at most n?</p>



<a name="198951472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951472">(May 27 2020 at 20:51)</a>:</h4>
<p>I'm defining exactly the primes which are at most n, but I need the fact that they're at most n to be stored with them, so that when I <code>prod x in primes_le 10, f x</code> I'll be able to pass the fact that <code>x</code> is prime into <code>f</code></p>



<a name="198951525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951525">(May 27 2020 at 20:51)</a>:</h4>
<p><code>finset X</code> is the type of finite subsets of <code>X</code></p>



<a name="198951545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951545">(May 27 2020 at 20:51)</a>:</h4>
<p>Not the assertion that X is finite</p>



<a name="198951676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951676">(May 27 2020 at 20:52)</a>:</h4>
<p>In fact my next theorem, the one that sparked this question, is a proof that <code>primes_le 10</code> contains every prime leq 10</p>



<a name="198951690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951690">(May 27 2020 at 20:52)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> There's a bit of an art to using <code>finset.prod</code> and <code>finset.sum</code></p>



<a name="198951701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951701">(May 27 2020 at 20:53)</a>:</h4>
<p>But what is <code>f</code> in your case?</p>



<a name="198951766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951766">(May 27 2020 at 20:53)</a>:</h4>
<p>Are you sure that this is true though? You're using simp to construct data. I have no idea what data it constructed. It's like you defined a natural number using simp and are now complaining that you don't know what it is</p>



<a name="198951803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951803">(May 27 2020 at 20:53)</a>:</h4>
<p>I think <code>primes_le n := (range (n+1)).filter prime</code> would work. Haven't you used something like that in the other PRs?</p>



<a name="198951883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951883">(May 27 2020 at 20:54)</a>:</h4>
<p>I don't know if it has a good name, it's used in Erdos's proof of Bertrand's postulate, it's the multiplicity of the prime p in 2n choose n:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">subtype</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">prime</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">choose</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">multiplicity</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">multiplicity</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">private</span> <span class="n">def</span> <span class="n">α</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">is_prime</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">multiplicity</span> <span class="n">p</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">choose</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">get</span> <span class="err">$</span>
  <span class="k">begin</span>
    <span class="k">have</span> <span class="n">not_one</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span><span class="bp">.</span><span class="n">ne_one</span> <span class="n">is_prime</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">nat</span><span class="bp">.</span><span class="n">choose</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">choose_pos</span> <span class="o">(</span><span class="k">by</span> <span class="n">linarith</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">fin</span> <span class="o">:</span> <span class="n">multiplicity</span><span class="bp">.</span><span class="n">finite</span> <span class="n">p</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">choose</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">multiplicity</span><span class="bp">.</span><span class="n">finite_nat_iff</span> <span class="n">p</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">choose</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">not_one</span><span class="o">,</span> <span class="n">pos</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">multiplicity</span><span class="bp">.</span><span class="n">finite_iff_dom</span><span class="bp">.</span><span class="mi">1</span> <span class="n">fin</span><span class="o">),</span>
  <span class="kn">end</span>
</code></pre></div>



<a name="198951930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951930">(May 27 2020 at 20:54)</a>:</h4>
<p>I need the term of type <code>nat.prime p</code> when I call this</p>



<a name="198951998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951998">(May 27 2020 at 20:55)</a>:</h4>
<p>I'm not using simp to construct data, as such - at least, not from a programmer's perspective; I'm using simp to transform the type of that data</p>



<a name="198951999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198951999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198951999">(May 27 2020 at 20:55)</a>:</h4>
<p>But you don't use <code>is_prime</code> in that defintion, right?</p>



<a name="198952034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952034">(May 27 2020 at 20:55)</a>:</h4>
<p>I use it to prove that p is not 1, for example</p>



<a name="198952044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952044">(May 27 2020 at 20:55)</a>:</h4>
<p>Ooh, you do, because of the <code>.get</code></p>



<a name="198952084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952084">(May 27 2020 at 20:55)</a>:</h4>
<p>Johan's idea will give you this. You're using complicated tactics to define data which can't be right. Complicated tactics are for proofs. Do you understand what I'm saying about what finset X means?</p>



<a name="198952264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952264">(May 27 2020 at 20:56)</a>:</h4>
<p>I do understand, yes; I have an auxiliary lemma I'm going to prove immediately afterwards stating that while all I know of <code>primes_le</code> from its type alone is that it is some finite subset of {primes less than or equal to n}, in fact it contains all the primes less than or equal to n</p>



<a name="198952298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952298">(May 27 2020 at 20:57)</a>:</h4>
<p>I think you want <code>finset.attach</code>.</p>



<a name="198952322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952322">(May 27 2020 at 20:57)</a>:</h4>
<p>And <code>prod_attach</code></p>



<a name="198952327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952327">(May 27 2020 at 20:57)</a>:</h4>
<p>I use finset.attach to create this in the first place, yes</p>



<a name="198952356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952356">(May 27 2020 at 20:57)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> One option is to cheat, and define your function on non-<code>prime</code>s as well:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">private</span> <span class="n">def</span> <span class="n">α</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="n">prime</span> <span class="k">then</span>
  <span class="o">(</span><span class="n">multiplicity</span> <span class="n">p</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">choose</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">get</span> <span class="err">$</span>
  <span class="k">begin</span>
    <span class="k">have</span> <span class="n">not_one</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">hp</span><span class="bp">.</span><span class="n">ne_one</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">nat</span><span class="bp">.</span><span class="n">choose</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">choose_pos</span> <span class="o">(</span><span class="k">by</span> <span class="n">linarith</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">fin</span> <span class="o">:</span> <span class="n">multiplicity</span><span class="bp">.</span><span class="n">finite</span> <span class="n">p</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">choose</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">multiplicity</span><span class="bp">.</span><span class="n">finite_nat_iff</span> <span class="n">p</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">choose</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">not_one</span><span class="o">,</span> <span class="n">pos</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">multiplicity</span><span class="bp">.</span><span class="n">finite_iff_dom</span><span class="bp">.</span><span class="mi">1</span> <span class="n">fin</span><span class="o">),</span>
  <span class="kn">end</span>
<span class="k">else</span> <span class="mi">0</span>
</code></pre></div>



<a name="198952361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952361">(May 27 2020 at 20:57)</a>:</h4>
<p>Oh, prod_attach looks promising</p>



<a name="198952412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952412">(May 27 2020 at 20:58)</a>:</h4>
<p>Hah, that does sound quite mathlibby, actually</p>



<a name="198952476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952476">(May 27 2020 at 20:58)</a>:</h4>
<p>Thanks, I'll see if I can <code>prod_attach</code> it and also see what it looks like with that cheat</p>



<a name="198952504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952504">(May 27 2020 at 20:59)</a>:</h4>
<p>Also, to make it readable, I would put the proof that you pass to <code>.get</code> in a lemma</p>



<a name="198952529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952529">(May 27 2020 at 20:59)</a>:</h4>
<p>Isn't this already defined? I think the name <code>padic_val</code> is not good for it (in metamath I used "pCnt" or "prime count" because p-adic valuation could also mean 1/p^k)</p>



<a name="198952677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952677">(May 27 2020 at 21:00)</a>:</h4>
<p>But <code>padic_val</code> probably isn't defined for arbitrary <code>p</code>.</p>



<a name="198952706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952706">(May 27 2020 at 21:00)</a>:</h4>
<p>So in that case you need the <code>attach</code> approach</p>



<a name="198952734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952734">(May 27 2020 at 21:00)</a>:</h4>
<p>Actually looks like it uses the cheat:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">padic_val_rat</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">1</span>
<span class="k">then</span> <span class="o">(</span><span class="n">multiplicity</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="n">q</span><span class="bp">.</span><span class="n">num</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span>
    <span class="o">(</span><span class="n">multiplicity</span><span class="bp">.</span><span class="n">finite_int_iff</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">h</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">rat</span><span class="bp">.</span><span class="n">num_ne_zero_of_ne_zero</span> <span class="n">h</span><span class="bp">.</span><span class="mi">1</span><span class="bp">⟩</span><span class="o">)</span> <span class="bp">-</span>
  <span class="o">(</span><span class="n">multiplicity</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="n">q</span><span class="bp">.</span><span class="n">denom</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span>
    <span class="o">(</span><span class="n">multiplicity</span><span class="bp">.</span><span class="n">finite_int_iff</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">h</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="k">by</span> <span class="n">exact_mod_cast</span> <span class="n">rat</span><span class="bp">.</span><span class="n">denom_ne_zero</span> <span class="bp">_⟩</span><span class="o">)</span>
<span class="k">else</span> <span class="mi">0</span>
</code></pre></div>



<a name="198952810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952810">(May 27 2020 at 21:01)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">has_zero</span><span class="o">]</span> <span class="kn">using</span> <span class="mi">1</span>
</code></pre></div>



<a name="198952856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952856">(May 27 2020 at 21:01)</a>:</h4>
<p>Wrong thread?</p>



<a name="198952910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952910">(May 27 2020 at 21:01)</a>:</h4>
<p>No, I see</p>



<a name="198952956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952956">(May 27 2020 at 21:02)</a>:</h4>
<p>I don't understand why Patrick's proposal for a definition isn't as crazy as what I just wrote</p>



<a name="198952957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198952957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198952957">(May 27 2020 at 21:02)</a>:</h4>
<p>How do I know simp has actually used what I told it to use</p>



<a name="198953043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953043">(May 27 2020 at 21:02)</a>:</h4>
<p>There is <code>fintype</code> for proving that a type is finite.</p>



<a name="198953080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953080">(May 27 2020 at 21:03)</a>:</h4>
<p>This is talking about another definition, i guess. Not the <code>\a</code> that we were discussing right now</p>



<a name="198953117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953117">(May 27 2020 at 21:03)</a>:</h4>
<p>Aha, I see. I have to scroll up.</p>



<a name="198953210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953210">(May 27 2020 at 21:04)</a>:</h4>
<p>It's a bit disappointing that there is no <code>padic_val_nat</code></p>



<a name="198953303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953303">(May 27 2020 at 21:05)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">primes_le</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">filter</span> <span class="n">prime</span>

<span class="n">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="err">\</span><span class="n">prod</span> <span class="n">p</span> <span class="k">in</span> <span class="n">primes_le</span> <span class="n">n</span><span class="o">,</span> <span class="n">padic_val</span><span class="o">(</span><span class="bp">_</span><span class="n">nat</span><span class="o">)</span> <span class="n">p</span> <span class="n">n</span>
</code></pre></div>



<a name="198953323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953323">(May 27 2020 at 21:05)</a>:</h4>
<p>That's what I would go for, I think</p>



<a name="198953468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953468">(May 27 2020 at 21:06)</a>:</h4>
<p>Sigh, I've got a nontrivial amount of proof about the properties of my existing <code>\a</code></p>



<a name="198953476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953476">(May 27 2020 at 21:06)</a>:</h4>
<p>Such is life</p>



<a name="198953687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953687">(May 27 2020 at 21:08)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> So... ask more questions on zulip</p>



<a name="198953742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953742">(May 27 2020 at 21:09)</a>:</h4>
<p>Also, maybe you can just rename your <code>\a</code> to <code>padic_val_nat</code> and weaken the assumptions a bit.</p>



<a name="198953753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953753">(May 27 2020 at 21:09)</a>:</h4>
<p>Then you don't loose that much work at all</p>



<a name="198953763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953763">(May 27 2020 at 21:09)</a>:</h4>
<p>Your definition neatly decomposes as the <code>padic_val</code> of a particular number. Any theorems that are just theorems about <code>padic_val</code> should be generalized (and are probably already proven), and stuff about the central binomial coefficient should still be in your proof as before</p>



<a name="198953776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/198953776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#198953776">(May 27 2020 at 21:09)</a>:</h4>
<p>Yeah, I suspect lots of it should be salvageable</p>



<a name="199250256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/199250256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#199250256">(May 30 2020 at 10:37)</a>:</h4>
<p>So people wouldn't object to me adding a new function <code>padic_val_nat</code> in the general neighbourhood of the existing mathlib <code>lemma padic_val_rat_of_int (z : ℤ) (hp : p ≠ 1) (hz : z ≠ 0) :  padic_val_rat p (z : ℚ) = (multiplicity (p : ℤ) z).get (finite_int_iff.2 ⟨hp, hz⟩)</code> that calls through to <code>padic_val_rat</code>, along with lemmas like <code>padic_val_rat_of_int</code> that equate it with the existing <code>padic_val_rat</code>?</p>



<a name="199250358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/199250358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#199250358">(May 30 2020 at 10:40)</a>:</h4>
<p>Maybe <span class="user-mention" data-user-id="110596">@Rob Lewis</span> or <span class="user-mention" data-user-id="110044">@Chris Hughes</span> could chime in, because I think there used to be something called <code>padic_val</code> or <code>padic_val_nat</code> that was replaced by <code>multiplicity</code>, and was very similar to what you are suggesting</p>



<a name="199250789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/199250789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#199250789">(May 30 2020 at 10:52)</a>:</h4>
<p>I can believe that replacing <code>padic_val</code> with multiplicity was a mistake. It happens all the time that you want to raise something to the power of the multiplicity, and obviously this gets messy. I think the best way is to state theorems in the form <code>(n : nat) (hn : n ∈ multiplicity p x)</code> so you don't have <code>get</code> in all the statements, which I did not do when I wrote multiplicity. This might make the interface okay, but it also may well be worth having a version that defaults to zero.</p>



<a name="199251613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transforming%20the%20type%20of%20a%20function/near/199251613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transforming.20the.20type.20of.20a.20function.html#199251613">(May 30 2020 at 11:12)</a>:</h4>
<p>Since <code>(multiplicity p x).dom</code> is decidable, it should at least be possible to use <code>(multiplicity p x).to_option.iget</code> (there should be an <code>roption.iget</code> for this)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/set.20vs.20subtype.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html">set vs subtype</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="246219948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246219948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246219948">(Jul 16 2021 at 13:06)</a>:</h4>
<p>If in an involved example :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">I</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">:</span>
</code></pre></div>
<p>I want to construct objects which are of type <code>set I</code> or are subtypes of <code>I</code>, and then mainly work on the cardinals of those object.<br>
Which is a better defn for these objects? <code>{i : I | p i}</code> or <code>{i : I // p i}</code>?</p>



<a name="246220096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246220096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246220096">(Jul 16 2021 at 13:08)</a>:</h4>
<p>Which one would be more convenient?</p>



<a name="246220561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246220561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246220561">(Jul 16 2021 at 13:12)</a>:</h4>
<p>If you use <code>{i : I | p i}</code> as a type you're really using <code>↥{i : I | p i}</code> aka <code>{i : I // i ∈ {j : I | p j}}</code></p>



<a name="246220609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246220609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246220609">(Jul 16 2021 at 13:13)</a>:</h4>
<p>So it's usually better to state lemmas as <code>{i : I // p i}</code> or even just <code>subtype p</code> which means the same thing</p>



<a name="246220659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246220659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246220659">(Jul 16 2021 at 13:13)</a>:</h4>
<p>Otherwise you risk ending up with <code>(∈ {j : I | p j})</code> as a really silly (but thankfully defeq) spelling of <code>p</code> in some places</p>



<a name="246220965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246220965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246220965">(Jul 16 2021 at 13:16)</a>:</h4>
<p>If you have fintype, then you can use finset.filter. That will be nicer to prove things about the cardinality than juggling set.finite.to_finset.card</p>



<a name="246222606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246222606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246222606">(Jul 16 2021 at 13:30)</a>:</h4>
<p>Is there a defined notion of "union" of subtypes?</p>



<a name="246222885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246222885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246222885">(Jul 16 2021 at 13:32)</a>:</h4>
<p>Is there a way of declaring things like <code>{i : I | p i}</code> as a <code>finset</code> directly as <code>I</code> is a <code>fintype</code> here? <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span></p>



<a name="246222980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246222980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246222980">(Jul 16 2021 at 13:33)</a>:</h4>
<p>(finset.univ.filter p)</p>



<a name="246223158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246223158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246223158">(Jul 16 2021 at 13:34)</a>:</h4>
<p>there's also ⊕ but that's probably not gonna be nice to use (and is a disjoint union, not a normal one)</p>



<a name="246224227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246224227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246224227">(Jul 16 2021 at 13:43)</a>:</h4>
<p>It might help if you can give more context so we can un- <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> this</p>



<a name="246225144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246225144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246225144">(Jul 16 2021 at 13:51)</a>:</h4>
<p>I was looking for some general suggestions before going into details. I will post more specific problems when I get.</p>



<a name="246225889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246225889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246225889">(Jul 16 2021 at 13:57)</a>:</h4>
<p>Your suggestions have been very helpful for a good start!</p>



<a name="246229245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246229245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246229245">(Jul 16 2021 at 14:21)</a>:</h4>
<p>Is there any version of statements that the card of the union of two disjoint <code>finsets</code> or <code>subtype</code> of a <code>fintype</code> is the sum of their separate cardinals?</p>



<a name="246229722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246229722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246229722">(Jul 16 2021 at 14:25)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.card_sum">docs#fintype.card_sum</a>?</p>



<a name="246229767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246229767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246229767">(Jul 16 2021 at 14:25)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_union_eq">docs#finset.card_union_eq</a>?</p>



<a name="246229925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246229925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246229925">(Jul 16 2021 at 14:26)</a>:</h4>
<p>Note how I just guessed the names based on what the statement would be, which is especially powerful combined with vscode autocomplete</p>



<a name="246246351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246246351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246246351">(Jul 16 2021 at 16:29)</a>:</h4>
<p>Could anyone please give some suggestions on proving</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">data.matrix.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">I</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">fintype</span> <span class="n">matrix</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">lemma</span> <span class="n">row_dot_product_split</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">I</span> <span class="n">I</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">i₁</span> <span class="n">i₂</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span>
<span class="n">dot_product</span> <span class="o">(</span><span class="n">H</span> <span class="n">i₁</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="n">i₂</span><span class="o">)</span> <span class="bp">=</span>
<span class="bp">∑</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">//</span> <span class="n">H</span> <span class="n">i₁</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">H</span> <span class="n">i₂</span> <span class="n">j</span><span class="o">},</span> <span class="n">H</span> <span class="n">i₁</span> <span class="n">j.1</span> <span class="bp">*</span> <span class="n">H</span> <span class="n">i₂</span> <span class="n">j.1</span> <span class="bp">+</span>
<span class="bp">∑</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">//</span> <span class="n">H</span> <span class="n">i₁</span> <span class="n">j</span> <span class="bp">≠</span> <span class="n">H</span> <span class="n">i₂</span> <span class="n">j</span><span class="o">},</span> <span class="n">H</span> <span class="n">i₁</span> <span class="n">j.1</span> <span class="bp">*</span> <span class="n">H</span> <span class="n">i₂</span> <span class="n">j.1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">dot_product</span><span class="o">],</span>
  <span class="c1">--rw [← finset.sum_to_finset_eq_subtype] fails,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="246246651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246246651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246246651">(Jul 16 2021 at 16:32)</a>:</h4>
<p>I don't know why the quoted out tactic fails.</p>



<a name="246248237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246248237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246248237">(Jul 16 2021 at 16:44)</a>:</h4>
<p>You might have an easier time if you generalize your problem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">sum_subtype_split</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="n">j</span> <span class="bp">=</span>
    <span class="bp">∑</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">j</span><span class="o">},</span> <span class="n">f</span> <span class="n">j</span> <span class="bp">+</span> <span class="bp">∑</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//¬</span> <span class="n">p</span> <span class="n">j</span><span class="o">},</span> <span class="n">f</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">dot_product_split</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dot_product</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span>
    <span class="bp">∑</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">//</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">w</span> <span class="n">j</span><span class="o">},</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">w</span> <span class="n">j</span> <span class="bp">+</span> <span class="bp">∑</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">//</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">≠</span> <span class="n">w</span> <span class="n">j</span><span class="o">},</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">w</span> <span class="n">j</span> <span class="o">:=</span>
<span class="n">sum_subtype_split</span> <span class="n">_</span> <span class="n">_</span>
</code></pre></div>



<a name="246250049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246250049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246250049">(Jul 16 2021 at 16:59)</a>:</h4>
<p>This is just the thing we discussed yesterday:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">I</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">fintype</span> <span class="n">matrix</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">to_additive</span><span class="o">]</span> <span class="n">prod_dite</span>

<span class="kd">lemma</span> <span class="n">sum_subtype_split</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="n">j</span> <span class="bp">=</span>
    <span class="bp">∑</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">j</span><span class="o">},</span> <span class="n">f</span> <span class="n">j</span> <span class="bp">+</span> <span class="bp">∑</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//¬</span> <span class="n">p</span> <span class="n">j</span><span class="o">},</span> <span class="n">f</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span><span class="n">fintype.sum_dite</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">_</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">_</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span><span class="o">)]</span>

<span class="kd">lemma</span> <span class="n">dot_product_split</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dot_product</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span>
    <span class="bp">∑</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">//</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">w</span> <span class="n">j</span><span class="o">},</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">w</span> <span class="n">j</span> <span class="bp">+</span> <span class="bp">∑</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">//</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">≠</span> <span class="n">w</span> <span class="n">j</span><span class="o">},</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">w</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">dot_product</span><span class="o">,</span> <span class="bp">←</span><span class="n">fintype.sum_dite</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span> <span class="n">_</span><span class="o">,</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">w</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span> <span class="n">_</span><span class="o">,</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">w</span> <span class="n">j</span><span class="o">)]</span> <span class="o">}</span>
</code></pre></div>



<a name="246250192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246250192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246250192">(Jul 16 2021 at 17:00)</a>:</h4>
<p>Are you trying to split the sum onto the support and not support?</p>



<a name="246250468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246250468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246250468">(Jul 16 2021 at 17:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/set.20vs.20subtype/near/246250192">said</a>:</p>
<blockquote>
<p>Are you trying to split the sum onto the support and not support?</p>
</blockquote>
<p>No, temporarily not.</p>



<a name="246251449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246251449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246251449">(Jul 16 2021 at 17:10)</a>:</h4>
<p>You can also split the <code>f</code> into an <code>ite</code></p>



<a name="246251962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246251962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246251962">(Jul 16 2021 at 17:14)</a>:</h4>
<p>by using <code>simp only</code>?</p>



<a name="246252964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246252964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246252964">(Jul 16 2021 at 17:22)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">data.matrix.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">I</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">fintype</span> <span class="n">matrix</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">to_additive</span><span class="o">]</span> <span class="n">prod_dite</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">prod_filter_univ</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.filter</span> <span class="n">p</span> <span class="n">finset.univ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∏</span> <span class="n">i</span> <span class="o">:</span> <span class="n">subtype</span> <span class="n">p</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span>
<span class="n">finset.prod_bij</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">pa</span><span class="o">,</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">pa</span><span class="o">⟩)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">dot_product_split</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dot_product</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span>
    <span class="bp">∑</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">//</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">w</span> <span class="n">j</span><span class="o">},</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">w</span> <span class="n">j</span> <span class="bp">+</span> <span class="bp">∑</span> <span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">//</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">≠</span> <span class="n">w</span> <span class="n">j</span><span class="o">},</span> <span class="n">v</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">w</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">dot_product</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="k">if</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">w</span> <span class="n">i</span> <span class="k">then</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">w</span> <span class="n">i</span> <span class="k">else</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">w</span> <span class="n">i</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">dot_product</span><span class="o">,</span> <span class="n">if_t_t</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset.sum_ite</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_filter_univ</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_filter_univ</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="246255890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246255890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246255890">(Jul 16 2021 at 17:43)</a>:</h4>
<p>Very cool!</p>



<a name="246273063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246273063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246273063">(Jul 16 2021 at 20:16)</a>:</h4>
<p>I think sum_filter_univ is PR-worthy</p>



<a name="246273157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246273157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246273157">(Jul 16 2021 at 20:17)</a>:</h4>
<p>Frankly that's the statement I expected <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_subtype">docs#finset.sum_subtype</a> to have</p>



<a name="246273355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/246273355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#246273355">(Jul 16 2021 at 20:19)</a>:</h4>
<p><code>finset.prod_subtype</code> is better for rewrites:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">prod_filter_univ</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.filter</span> <span class="n">p</span> <span class="n">finset.univ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∏</span> <span class="n">i</span> <span class="o">:</span> <span class="n">subtype</span> <span class="n">p</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">finset.prod_subtype</span><span class="o">,</span>
  <span class="n">simp</span>
<span class="kd">end</span>
</code></pre></div>



<a name="247690031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247690031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247690031">(Jul 30 2021 at 10:17)</a>:</h4>
<p>Is there already a way to extend this to a union in mathlib?</p>



<a name="247690121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247690121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247690121">(Jul 30 2021 at 10:18)</a>:</h4>
<p>Although I am experimenting with the notation <code>fintype.card (⋃(i : fin k), left_coset (γ i) H) = ∑ (i : fin k), fintype.card (left_coset (γ i) H)</code>.</p>



<a name="247691094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247691094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247691094">(Jul 30 2021 at 10:31)</a>:</h4>
<p>Can you give a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> with imports and variables?</p>



<a name="247691846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247691846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247691846">(Jul 30 2021 at 10:40)</a>:</h4>
<p>Induction on k will be the way here. But you should express it in terms of finset.card instead.</p>



<a name="247691974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247691974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247691974">(Jul 30 2021 at 10:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">group_theory.coset</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">group_theory.order_of_element</span>
<span class="kn">import</span> <span class="n">data.equiv.basic</span>
<span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">data.list.defs</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="kd">@[ext]</span> <span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">Hnonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hcover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hdisjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∩</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span>


<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">H</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">lemma</span> <span class="n">lagrange_long_sum_attempt_3</span>
<span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span><span class="o">,</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">G</span><span class="o">}</span>
<span class="o">{</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)}</span>
<span class="o">{</span><span class="n">h₃</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">set.univ</span><span class="o">}:</span>
<span class="n">fintype.card</span> <span class="n">H</span> <span class="bp">∣</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="o">:=</span> <span class="c1">--the size of the subgroup H divides the size of the group G</span>
<span class="kd">begin</span>
  <span class="c1">--partition G into left cosets of H `done`</span>

  <span class="c1">--G is finite, so exists g₁, g₂, ..., gₖ s.t. g₁H, ..., gₖH partition G `done?`</span>

  <span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">set.univ</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">fintype.of_equiv_card</span> <span class="o">(</span><span class="n">equiv.set.univ</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">h₄</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">P</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">dvd_of_mul_left_eq</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">coe_sort</span> <span class="n">set.univ</span> <span class="bp">=</span> <span class="n">coe_sort</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">congr_arg</span> <span class="n">coe_sort</span> <span class="n">h₃.symm</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="247691990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247691990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247691990">(Jul 30 2021 at 10:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/set.20vs.20subtype/near/247691846">said</a>:</p>
<blockquote>
<p>Induction on k will be the way here. But you should express it in terms of finset.card instead.</p>
</blockquote>
<p>Ah alright I'll work to make that adjustment.</p>



<a name="247692013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247692013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247692013">(Jul 30 2021 at 10:43)</a>:</h4>
<p>Either that or rewriting by <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.card_sigma">docs#fintype.card_sigma</a>, and then showing an equivalence between <code>⋃ i, left_coset (γ i) H</code> and <code>\Sigma i, left_coset (γ i) H</code></p>



<a name="247692054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247692054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247692054">(Jul 30 2021 at 10:43)</a>:</h4>
<p>When we say an mwe, we mean something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="bp">...</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>i.e. code that doesn't contain any of the context needed to arrive at that goal</p>



<a name="247692149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247692149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247692149">(Jul 30 2021 at 10:44)</a>:</h4>
<p>Aaaah alright I'll redo it for practice sake</p>



<a name="247692176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247692176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247692176">(Jul 30 2021 at 10:45)</a>:</h4>
<p>Lean can likely produce one for you if you put <code>extract_goal</code> after your <code>have</code></p>



<a name="247692189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247692189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247692189">(Jul 30 2021 at 10:45)</a>:</h4>
<p>Which is something that is mentioned at <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="247694084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247694084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247694084">(Jul 30 2021 at 11:09)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">group_theory.coset</span>
<span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="bp">↥</span><span class="n">H</span><span class="o">]</span>
  <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">G</span><span class="o">}</span>
  <span class="o">{</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↑</span><span class="n">H</span><span class="o">)}</span>
  <span class="o">{</span><span class="n">h₃</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↑</span><span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">set.univ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₄</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="bp">↥</span><span class="n">set.univ</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">(</span><span class="n">P_C</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">G</span><span class="o">))</span>
  <span class="o">(</span><span class="n">P_Hnonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">),</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P_C</span> <span class="bp">→</span> <span class="n">X.nonempty</span><span class="o">)</span>
  <span class="o">(</span><span class="n">P_Hcover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P_C</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">)</span>
  <span class="o">(</span><span class="n">P_Hdisjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">),</span>
                   <span class="n">X</span> <span class="bp">∈</span> <span class="n">P_C</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">∈</span> <span class="n">P_C</span> <span class="bp">→</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∩</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">),</span>
         <span class="n">X</span> <span class="bp">∈</span>
           <span class="o">{</span><span class="n">C</span> <span class="o">:=</span> <span class="n">P_C</span><span class="o">,</span>
            <span class="n">Hnonempty</span> <span class="o">:=</span> <span class="n">P_Hnonempty</span><span class="o">,</span>
            <span class="n">Hcover</span> <span class="o">:=</span> <span class="n">P_Hcover</span><span class="o">,</span>
            <span class="n">Hdisjoint</span> <span class="o">:=</span> <span class="n">P_Hdisjoint</span><span class="o">}</span><span class="bp">.</span><span class="n">C</span> <span class="bp">→</span>
         <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="bp">↑</span><span class="n">H</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">set.univ</span> <span class="bp">=</span> <span class="bp">↥⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↑</span><span class="n">H</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fintype.card</span> <span class="o">(</span><span class="bp">↥⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↑</span><span class="n">H</span><span class="o">)</span> <span class="bp">=</span>
    <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">fintype.card</span> <span class="bp">↥</span><span class="o">(</span><span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↑</span><span class="n">H</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">admit</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="247694156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247694156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247694156">(Jul 30 2021 at 11:10)</a>:</h4>
<p>Which was through <code>extract_goal</code> vs</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">group_theory.coset</span>
<span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">H</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">G</span><span class="o">}</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="247694250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247694250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247694250">(Jul 30 2021 at 11:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/set.20vs.20subtype/near/247692013">said</a>:</p>
<blockquote>
<p>Either that or rewriting by <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.card_sigma">docs#fintype.card_sigma</a>, and then showing an equivalence between <code>⋃ i, left_coset (γ i) H</code> and <code>\Sigma i, left_coset (γ i) H</code></p>
</blockquote>
<p>I see what's happening here though. Either way cheers.</p>



<a name="247694583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247694583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247694583">(Jul 30 2021 at 11:15)</a>:</h4>
<p>Note that that example is false, it's only true  with <code>injective (λ (i : fin k), left_coset (γ i) ↑H)</code></p>



<a name="247694724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247694724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247694724">(Jul 30 2021 at 11:17)</a>:</h4>
<p>That's hypothesis h2, isn't it? Or have I written something wrong?</p>



<a name="247694751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247694751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247694751">(Jul 30 2021 at 11:18)</a>:</h4>
<p>Aaaah I see in the mwe</p>



<a name="247694849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247694849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247694849">(Jul 30 2021 at 11:19)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">group_theory.coset</span>
<span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">H</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">G</span><span class="o">}</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)}</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>Right this makes sense.</p>



<a name="247696898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247696898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247696898">(Jul 30 2021 at 11:43)</a>:</h4>
<p>Here's the equiv I'm thinking of:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The union of a family of disjoint sets is isomorphic to the disjoint union -/</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">equiv.set.sigma_of_disjoint</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">disjoint</span> <span class="o">(</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">↥⋃</span> <span class="n">i</span><span class="o">,</span> <span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="bp">≃</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="bp">↥</span><span class="o">(</span><span class="n">S</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">set.mem_Union.mp</span> <span class="n">u.prop</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">h.some</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">h.some_spec</span><span class="o">⟩,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="o">⟨</span><span class="n">s.2</span><span class="o">,</span> <span class="n">set.mem_Union.mpr</span> <span class="o">⟨</span><span class="n">s.1</span><span class="o">,</span> <span class="n">s.2.prop</span><span class="o">⟩⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">sigma.subtype_ext</span> <span class="o">(</span><span class="kd">begin</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">generalize_proofs</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">by_contra</span> <span class="n">hfst</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">set.not_disjoint_iff.mpr</span> <span class="o">⟨(</span><span class="n">s.snd</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">h.some_spec</span><span class="o">,</span> <span class="n">s.snd.prop</span><span class="o">⟩</span> <span class="o">(</span><span class="n">hS</span> <span class="n">h.some</span> <span class="n">s.fst</span> <span class="n">hfst</span><span class="o">),</span>
  <span class="kd">end</span><span class="o">)</span> <span class="n">rfl</span> <span class="o">}</span>
</code></pre></div>



<a name="247710692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247710692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247710692">(Jul 30 2021 at 13:53)</a>:</h4>
<p>I can't for the life of me figure out why my VSC has an issue with sigma.subtype_ext</p>



<a name="247711663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247711663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247711663">(Jul 30 2021 at 14:00)</a>:</h4>
<p>Maybe you have a (very) old version of mathlib</p>



<a name="247916901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247916901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247916901">(Aug 02 2021 at 12:58)</a>:</h4>
<p>Oh, that exists already as <a href="https://leanprover-community.github.io/mathlib_docs/find/set.Union_eq_sigma_of_disjoint">docs#set.Union_eq_sigma_of_disjoint</a></p>



<a name="247916947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20vs%20subtype/near/247916947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20vs.20subtype.html#247916947">(Aug 02 2021 at 12:59)</a>:</h4>
<p>And should probably be renamed to say <code>equiv</code> not <code>eq</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
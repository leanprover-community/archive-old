---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Schnorr.20Group.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html">Schnorr Group</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="191378165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191378165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191378165">(Mar 22 2020 at 03:40)</a>:</h4>
<p>Hi everyone, I am trying to prove a simple theorem about Schnorr  group ( <a href="https://en.wikipedia.org/wiki/Schnorr_group" target="_blank" title="https://en.wikipedia.org/wiki/Schnorr_group">https://en.wikipedia.org/wiki/Schnorr_group</a> ), but getting some typeclass synthesis error for hypothesis Hh1 Hh2 Hg.  </p>
<div class="codehilite"><pre><span></span>import data.zmod.basic data.nat.prime
  data.zmod.quadratic_reciprocity

namespace ElGamal

/-
A Schnorr group is a large prime-order subgroup of ℤ∗𝑝,
the multiplicative group of integers modulo 𝑝.
To generate such a group, we find 𝑝=𝑞𝑟+1 such that 𝑝 and 𝑞
are prime. Then, we choose any ℎ
in the range 1&lt;ℎ&lt;𝑝 such that ℎ^r ≠ 1 (mod𝑝)
The value 𝑔=ℎ^𝑟(mod𝑝) is a generator of a subgroup ℤ∗𝑝 of order 𝑞.
By Fermat&#39;s little theorem
g^q = h^(rq) = h^(p-1) = 1 (mod p)
-/

variables
  (p : ℕ) (q : ℕ) (r : ℕ+)
  (Hp : nat.prime p)
  (Hq : nat.prime q)
  (Hdiv : p = q * r + 1)
  (h : zmodp p Hp)
  (Hh₁ : 1 &lt; h &lt; p)
  (Hh₂ : h^r ≠ 1)
  (g : zmodp p Hp) /- generator of a subgroup of ℤ⋆p of order q -/
  (Hg : g = h^r)

include p q r Hp Hq Hdiv h Hh₁ Hh₂ Hg
theorem generate_proof : g ^ q = 1 :=
begin
  /-
   rewrite Hg,
   associativity would turn the goal
   (h ^ r) ^ q = 1  into h ^ (r * q).
   r * q = p - 1.
   Use Fermat little theorem from
   fermat little to prove it -/

end







end ElGamal
</pre></div>



<a name="191380564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191380564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191380564">(Mar 22 2020 at 04:59)</a>:</h4>
<p>The typeclass is <code>has_lt (zmodp p Hp)</code> so lean is telling you it doesn't know what <code>&lt;</code> means for <code>zmodp</code> which makes sense, there is no nice notion of <code>lt</code>on integers modulo a prime .</p>



<a name="191380615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191380615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191380615">(Mar 22 2020 at 05:00)</a>:</h4>
<p>The sentiment you are trying to express with <code>Hh1</code> is really just that the residue class <code>h</code> is not 0.</p>



<a name="191380630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191380630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191380630">(Mar 22 2020 at 05:01)</a>:</h4>
<p>The second one is <code>has_pow (zmodp p Hp) ℕ+</code>which is telling you that lean can't take a positive natural power of an element of this type, you could argue that this is an oversight. But the easiest fix is to take <code>h^r.val</code> instead.</p>



<a name="191380737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191380737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191380737">(Mar 22 2020 at 05:04)</a>:</h4>
<p>You could also take <code>r</code> of type nat instead. That might be less work in the long run.</p>



<a name="191380806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191380806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191380806">(Mar 22 2020 at 05:06)</a>:</h4>
<p>Spoilers below:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">prime</span>
  <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span><span class="bp">.</span><span class="n">quadratic_reciprocity</span>

<span class="kn">namespace</span> <span class="n">ElGamal</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">A Schnorr group is a large prime-order subgroup of ℤ∗𝑝,</span>
<span class="cm">the multiplicative group of integers modulo 𝑝.</span>
<span class="cm">To generate such a group, we find 𝑝=𝑞𝑟+1 such that 𝑝 and 𝑞</span>
<span class="cm">are prime. Then, we choose any ℎ</span>
<span class="cm">in the range 1&lt;ℎ&lt;𝑝 such that ℎ^r ≠ 1 (mod𝑝)</span>
<span class="cm">The value 𝑔=ℎ^𝑟(mod𝑝) is a generator of a subgroup ℤ∗𝑝 of order 𝑞.</span>
<span class="cm">By Fermat&#39;s little theorem</span>
<span class="cm">g^q = h^(rq) = h^(p-1) = 1 (mod p)</span>
<span class="cm">-/</span>

<span class="kn">variables</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hp</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">p</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hq</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">q</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hdiv</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="bp">*</span> <span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hh₁</span> <span class="o">:</span> <span class="n">h</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hh₂</span> <span class="o">:</span> <span class="n">h</span><span class="err">^</span><span class="n">r</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> generator of a subgroup of ℤ⋆p of order q -/</span>
  <span class="o">(</span><span class="n">Hg</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">h</span><span class="err">^</span><span class="n">r</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">Hh₁</span>
<span class="n">include</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">Hp</span> <span class="n">Hq</span> <span class="n">Hdiv</span> <span class="n">h</span> <span class="n">Hh₁</span> <span class="n">Hh₂</span> <span class="n">Hg</span>
<span class="kn">theorem</span> <span class="n">generate_proof</span> <span class="o">:</span> <span class="n">g</span> <span class="err">^</span> <span class="n">q</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
   <span class="n">rewrite</span> <span class="n">Hg</span><span class="o">,</span>
   <span class="n">rw</span> <span class="err">←</span> <span class="n">pow_mul</span><span class="o">,</span>
   <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
   <span class="k">have</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">q</span> <span class="bp">*</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pred_eq_of_eq_succ</span> <span class="n">Hdiv</span><span class="o">,</span>
   <span class="n">rw</span> <span class="err">←</span> <span class="n">this</span><span class="o">,</span>
   <span class="n">exact</span> <span class="n">zmodp</span><span class="bp">.</span><span class="n">fermat_little</span> <span class="n">Hp</span> <span class="n">Hh₁</span><span class="o">,</span>
<span class="kn">end</span>







<span class="kn">end</span> <span class="n">ElGamal</span>
</pre></div>



<a name="191384045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191384045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191384045">(Mar 22 2020 at 07:05)</a>:</h4>
<p>Thanks for the answer <span class="user-mention" data-user-id="127136">@Alex J. Best</span> . Now, I am wondering about the error. <br>
If I comment the proof 'generator_proof', then the error goes way. </p>
<div class="codehilite"><pre><span></span>variables
  (p : ℕ) (q : ℕ) (r : ℕ)
  (Hr : 2 ≤ r)
  (Hp : nat.prime p)
  (Hq : nat.prime q)
  (Hdiv : p = q * r + 1)
  (h : zmodp p Hp)
  (Hh₁ : h ≠ 0)
  (Hh₂ : h^r ≠ 1)
  (g : zmodp p Hp) /- generator of a subgroup of ℤ⋆p of order q -/
  (Hg : g = h^r)


include Hg
theorem generator_proof : g ^ q = 1 :=
begin
  rw [Hg, &lt;- pow_mul, mul_comm],
  have Ht : p - 1 = q * r := nat.pred_eq_of_eq_succ Hdiv,
  rw &lt;- Ht, exact zmodp.fermat_little Hp Hh₁
end

variables
  (prikey : zmodp q Hq) /- private key -/
  (pubkey : zmodp p Hp) /- public key -/
  (Hrel : pubkey = g^prikey.val)

def elgamal_enc (m : zmodp p Hp) (r : zmodp q Hq) :=
  (g^r.val, g^m.val * h^r.val)

kernel failed to type check declaration &#39;elgamal_enc&#39; this is usually due to a buggy tactic or a bug in the builtin elaborator
elaborated type:
  Π (p q : ℕ) (Hp : nat.prime p) (Hq : nat.prime q) (h g : zmodp p Hp),
    g = h ^ r → ℕ → zmodp p Hp → zmodp q Hq → zmodp p Hp × zmodp p Hp
elaborated value:
  λ (p q : ℕ) (Hp : nat.prime p) (Hq : nat.prime q) (h g : zmodp p Hp) (Hg : g = h ^ r) (r : ℕ) (m : zmodp p Hp)
  (r : zmodp q Hq), (g ^ r.val, g ^ m.val * h ^ r.val)
nested exception message:
failed to add declaration to environment, it contains local constants
</pre></div>



<a name="191384381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191384381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191384381">(Mar 22 2020 at 07:14)</a>:</h4>
<p>This goes away for me if I wrap the previous declaration and preceding <code>include</code> in <code>section ... end</code> it seems lean doesn't like including these extra hypotheses.</p>



<a name="191384386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191384386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191384386">(Mar 22 2020 at 07:14)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">prime</span>
  <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span><span class="bp">.</span><span class="n">quadratic_reciprocity</span>

<span class="kn">variables</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hr</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hp</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">p</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hq</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">q</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hdiv</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="bp">*</span> <span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hh₁</span> <span class="o">:</span> <span class="n">h</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hh₂</span> <span class="o">:</span> <span class="n">h</span><span class="err">^</span><span class="n">r</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> generator of a subgroup of ℤ⋆p of order q -/</span>
  <span class="o">(</span><span class="n">Hg</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">h</span><span class="err">^</span><span class="n">r</span><span class="o">)</span>

<span class="kn">section</span>
<span class="n">include</span> <span class="n">Hg</span> <span class="n">Hdiv</span> <span class="n">Hh₁</span>
<span class="kn">theorem</span> <span class="n">generator_proof</span> <span class="o">:</span> <span class="n">g</span> <span class="err">^</span> <span class="n">q</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">Hg</span><span class="o">,</span> <span class="bp">&lt;-</span> <span class="n">pow_mul</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">Ht</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">q</span> <span class="bp">*</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pred_eq_of_eq_succ</span> <span class="n">Hdiv</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">Ht</span><span class="o">,</span> <span class="n">exact</span> <span class="n">zmodp</span><span class="bp">.</span><span class="n">fermat_little</span> <span class="n">Hp</span> <span class="n">Hh₁</span>
<span class="kn">end</span>
<span class="kn">end</span>

<span class="kn">variables</span>
  <span class="o">(</span><span class="n">prikey</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">q</span> <span class="n">Hq</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> private key -/</span>
  <span class="o">(</span><span class="n">pubkey</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> public key -/</span>
  <span class="o">(</span><span class="n">Hrel</span> <span class="o">:</span> <span class="n">pubkey</span> <span class="bp">=</span> <span class="n">g</span><span class="err">^</span><span class="n">prikey</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>

<span class="n">def</span> <span class="n">elgamal_enc</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">q</span> <span class="n">Hq</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">g</span><span class="err">^</span><span class="n">r</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">g</span><span class="err">^</span><span class="n">m</span><span class="bp">.</span><span class="n">val</span> <span class="bp">*</span> <span class="n">h</span><span class="err">^</span><span class="n">r</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">elgamal_enc</span>
</pre></div>


<p>works</p>



<a name="191384685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191384685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191384685">(Mar 22 2020 at 07:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Schnorr.20Group/near/191384381" title="#narrow/stream/113489-new-members/topic/Schnorr.20Group/near/191384381">said</a>:</p>
<blockquote>
<p>This goes away for me if I wrap the previous declaration and preceding <code>include</code> in <code>section ... end</code> it seems lean doesn't like including these extra hypotheses.</p>
</blockquote>
<p>I tried to move all the variable declared after the proof 'generator_proof' before it, but the error is still the same.    <br>
Anyway, your solution is working, so it's fine.</p>



<a name="191385428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191385428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191385428">(Mar 22 2020 at 07:54)</a>:</h4>
<p>Right the issue is the include line which adds the unneeded hypotheses (for elgamal_enc) <code>Hg Hdiv Hh₁</code> to all following declarations.</p>



<a name="191385536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191385536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191385536">(Mar 22 2020 at 07:58)</a>:</h4>
<p>Why does this find is not returning any lemma?  I want to prove Ht1. </p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="n">find</span> <span class="o">(</span><span class="bp">_</span> <span class="err">^</span> <span class="bp">_</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">def</span> <span class="n">elgamal_enc</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">q</span> <span class="n">Hq</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">g</span><span class="err">^</span><span class="n">r</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">g</span><span class="err">^</span><span class="n">m</span><span class="bp">.</span><span class="n">val</span> <span class="bp">*</span> <span class="n">pubkey</span><span class="err">^</span><span class="n">r</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>

<span class="n">def</span> <span class="n">elgamal_dec</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span> <span class="bp">×</span>  <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">c</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span><span class="bp">.</span><span class="mi">1</span><span class="err">^</span><span class="n">prikey</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span><span class="bp">⁻¹</span>

<span class="n">include</span> <span class="n">Hrel</span>
<span class="kn">lemma</span> <span class="n">elgama_enc_dec_identity</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="n">m</span> <span class="n">r</span><span class="o">,</span> <span class="n">elgamal_dec</span> <span class="n">p</span> <span class="n">q</span> <span class="n">Hp</span> <span class="n">Hq</span> <span class="n">prikey</span>
      <span class="o">(</span><span class="n">elgamal_enc</span> <span class="n">p</span> <span class="n">q</span> <span class="n">Hp</span> <span class="n">Hq</span> <span class="n">g</span> <span class="n">pubkey</span> <span class="n">m</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span><span class="err">^</span><span class="n">m</span><span class="bp">.</span><span class="n">val</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">elgamal_enc</span> <span class="n">elgamal_dec</span><span class="o">,</span>
  <span class="n">intros</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">Hrel</span><span class="o">,</span> <span class="bp">&lt;-</span> <span class="n">pow_mul</span><span class="o">,</span> <span class="bp">&lt;-</span> <span class="n">pow_mul</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">Ht₁</span> <span class="o">:</span> <span class="n">g</span> <span class="err">^</span> <span class="o">(</span><span class="n">prikey</span><span class="bp">.</span><span class="n">val</span> <span class="bp">*</span> <span class="n">r</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">Ht₂</span> <span class="o">:</span> <span class="n">r</span><span class="bp">.</span><span class="n">val</span> <span class="bp">*</span> <span class="n">prikey</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">prikey</span><span class="bp">.</span><span class="n">val</span> <span class="bp">*</span> <span class="n">r</span><span class="bp">.</span><span class="n">val</span> <span class="o">:=</span>
       <span class="n">mul_comm</span> <span class="n">r</span><span class="bp">.</span><span class="n">val</span> <span class="n">prikey</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">Ht₂</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_inv_cancel</span> <span class="n">Ht₁</span><span class="o">],</span> <span class="n">ring</span>
<span class="kn">end</span>
</pre></div>



<a name="191387840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191387840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191387840">(Mar 22 2020 at 09:19)</a>:</h4>
<p>What is <code>elgamal_dec</code>? You might find the tactic <code>library_search</code> more useful than <code>find</code></p>



<a name="191388272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191388272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191388272">(Mar 22 2020 at 09:34)</a>:</h4>
<p>Updated the code.</p>



<a name="191388766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191388766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191388766">(Mar 22 2020 at 09:47)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">elgamal_enc</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">q</span> <span class="n">Hq</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">g</span><span class="err">^</span><span class="n">r</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">g</span><span class="err">^</span><span class="n">m</span><span class="bp">.</span><span class="n">val</span> <span class="bp">*</span> <span class="n">pubkey</span><span class="err">^</span><span class="n">r</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>

<span class="n">def</span> <span class="n">elgamal_dec</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span> <span class="bp">×</span>  <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">c</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span><span class="bp">.</span><span class="mi">1</span><span class="err">^</span><span class="n">prikey</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span><span class="bp">⁻¹</span>

<span class="n">include</span> <span class="n">Hrel</span> <span class="n">Hg</span> <span class="n">Hh₁</span>
<span class="kn">lemma</span> <span class="n">elgama_enc_dec_identity</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="n">m</span> <span class="n">t</span><span class="o">,</span> <span class="n">elgamal_dec</span> <span class="n">p</span> <span class="n">q</span> <span class="n">Hp</span> <span class="n">Hq</span> <span class="n">prikey</span>
      <span class="o">(</span><span class="n">elgamal_enc</span> <span class="n">p</span> <span class="n">q</span> <span class="n">Hp</span> <span class="n">Hq</span> <span class="n">g</span> <span class="n">pubkey</span> <span class="n">m</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span><span class="err">^</span><span class="n">m</span><span class="bp">.</span><span class="n">val</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">elgamal_enc</span> <span class="n">elgamal_dec</span><span class="o">,</span>
  <span class="n">intros</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">Hrel</span><span class="o">,</span> <span class="bp">&lt;-</span> <span class="n">pow_mul</span><span class="o">,</span> <span class="bp">&lt;-</span> <span class="n">pow_mul</span><span class="o">],</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="k">begin</span> <span class="n">rw</span> <span class="n">Hg</span><span class="o">,</span> <span class="n">exact</span> <span class="n">pow_ne_zero</span> <span class="n">r</span> <span class="n">Hh₁</span><span class="o">,</span> <span class="kn">end</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">Ht₁</span> <span class="o">:</span> <span class="n">g</span> <span class="err">^</span> <span class="o">(</span><span class="n">prikey</span><span class="bp">.</span><span class="n">val</span> <span class="bp">*</span> <span class="n">t</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">pow_ne_zero</span> <span class="o">(</span><span class="n">prikey</span><span class="bp">.</span><span class="n">val</span> <span class="bp">*</span> <span class="n">t</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">Ht₂</span> <span class="o">:</span> <span class="n">t</span><span class="bp">.</span><span class="n">val</span> <span class="bp">*</span> <span class="n">prikey</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">prikey</span><span class="bp">.</span><span class="n">val</span> <span class="bp">*</span> <span class="n">t</span><span class="bp">.</span><span class="n">val</span> <span class="o">:=</span>
       <span class="n">mul_comm</span> <span class="n">t</span><span class="bp">.</span><span class="n">val</span> <span class="n">prikey</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">Ht₂</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_inv_cancel</span> <span class="n">Ht₁</span><span class="o">],</span> <span class="n">ring</span>
<span class="kn">end</span>
</pre></div>



<a name="191388775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191388775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191388775">(Mar 22 2020 at 09:47)</a>:</h4>
<p>You need g nonzero</p>



<a name="191388779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191388779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191388779">(Mar 22 2020 at 09:48)</a>:</h4>
<p>For which you need h nonzero</p>



<a name="191391707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191391707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191391707">(Mar 22 2020 at 11:13)</a>:</h4>
<p>Thanks Alex.  I am looking for a vector library, and I see two vector library in mathlib, vector2 and vector3.</p>



<a name="191391758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191391758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191391758">(Mar 22 2020 at 11:14)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/78ffbae077c50ed8ee060b3ac544f6f1d4359f39/src/number_theory/dioph.lean#L109" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/78ffbae077c50ed8ee060b3ac544f6f1d4359f39/src/number_theory/dioph.lean#L109">https://github.com/leanprover-community/mathlib/blob/78ffbae077c50ed8ee060b3ac544f6f1d4359f39/src/number_theory/dioph.lean#L109</a></p>



<a name="191391836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191391836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191391836">(Mar 22 2020 at 11:16)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/c718a22925872db4cb5f64c36ed6e6a07bdf647c/src/data/vector2.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/c718a22925872db4cb5f64c36ed6e6a07bdf647c/src/data/vector2.lean">https://github.com/leanprover-community/mathlib/blob/c718a22925872db4cb5f64c36ed6e6a07bdf647c/src/data/vector2.lean</a></p>



<a name="191391839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191391839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191391839">(Mar 22 2020 at 11:16)</a>:</h4>
<p>Which one would suggest to use ?</p>



<a name="191392164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191392164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191392164">(Mar 22 2020 at 11:25)</a>:</h4>
<p>Use vector</p>



<a name="191392580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191392580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191392580">(Mar 22 2020 at 11:36)</a>:</h4>
<p>Thanks Kevin.</p>



<a name="191392704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191392704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191392704">(Mar 22 2020 at 11:40)</a>:</h4>
<p>By the way Coq has a nice extraction facility, and you can extract any Coq program into Haskell, OCaml, or Scheme. I am wondering if there is something like this in Lean?</p>



<a name="191395571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191395571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191395571">(Mar 22 2020 at 12:58)</a>:</h4>
<p>In lean 4 you should be able to extract to...umm...C? I don't have a clue about this stuff</p>



<a name="191420721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191420721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191420721">(Mar 22 2020 at 22:55)</a>:</h4>
<p>We really should give <code>#find</code> some additional love.</p>



<a name="191424796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191424796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191424796">(Mar 23 2020 at 00:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span>  That would make the life easier for new comers used to Coq's search pattern. I found linear_search quite nice because it just gives me some lemma from the remote corners of the mathlib library.</p>



<a name="191439246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191439246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191439246">(Mar 23 2020 at 07:35)</a>:</h4>
<p>I am looking for a lemma to prove that </p>
<div class="codehilite"><pre><span></span><span class="n">ms</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">),</span>
<span class="bp">_</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="n">ms</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
<span class="n">rs</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">zmodp</span> <span class="n">q</span> <span class="n">Hq</span><span class="o">),</span>
<span class="bp">_</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="n">rs</span> <span class="bp">=</span> <span class="n">n</span>
<span class="err">⊢</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">zip_with</span> <span class="n">f</span>  <span class="n">ms</span> <span class="n">rs</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span>
</pre></div>


<p>I could find anything using  <strong> find </strong>  or  <strong>library_search</strong></p>



<a name="191440038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191440038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191440038">(Mar 23 2020 at 07:47)</a>:</h4>
<p>I agree that <code>list.zip_with</code> doesn't seem to have been given much love in mathlib! It's defined in core, and for some of these things <code>data.list.basic</code> just makes an API, but apparently not here. I think it might be a hole in the library, although I would imagine it's not hard to prove by induction on n?</p>



<a name="191459587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191459587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191459587">(Mar 23 2020 at 11:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>   If, say, my goal is to prove equality x = x, then I can use tactic or write the exact terms.  I am wondering how can I see the terms build using the tactics ?</p>



<a name="191467620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191467620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191467620">(Mar 23 2020 at 12:49)</a>:</h4>
<p><code>#print</code></p>



<a name="191467621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191467621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191467621">(Mar 23 2020 at 12:49)</a>:</h4>
<p>(deleted)</p>



<a name="191540210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191540210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191540210">(Mar 23 2020 at 21:37)</a>:</h4>
<p>#print is just printing the type signature.  For this code</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">vector_ciphertext_mult</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">vector</span> <span class="o">(</span><span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span> <span class="bp">×</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">vector</span> <span class="o">(</span><span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span> <span class="bp">×</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span> <span class="n">n</span> <span class="bp">-&gt;</span>
  <span class="n">vector</span> <span class="o">(</span><span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span> <span class="bp">×</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="bp">⟨</span><span class="n">cs₁</span> <span class="o">,</span> <span class="n">Hc₁</span><span class="bp">⟩</span>  <span class="bp">⟨</span><span class="n">cs₂</span><span class="o">,</span> <span class="n">Hc₂</span><span class="bp">⟩</span> <span class="o">:=</span>
    <span class="bp">⟨</span><span class="n">list</span><span class="bp">.</span><span class="n">zip_with</span> <span class="o">(</span><span class="n">ciphertext_mult</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">)</span> <span class="n">cs₁</span>  <span class="n">cs₂</span><span class="o">,</span>
    <span class="k">begin</span>
      <span class="k">have</span> <span class="n">Ht</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="n">cs₁</span> <span class="bp">=</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="n">cs₂</span> <span class="o">:=</span>
      <span class="k">begin</span> <span class="n">rw</span> <span class="o">[</span><span class="n">Hc₁</span><span class="o">,</span> <span class="n">Hc₂</span><span class="o">]</span> <span class="kn">end</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">Hc₁</span><span class="o">,</span> <span class="n">apply</span> <span class="n">zip_with_len_l</span><span class="o">,</span> <span class="n">exact</span> <span class="n">Ht</span><span class="o">,</span>
    <span class="kn">end</span> <span class="bp">⟩</span>
</pre></div>


<p>The output of #print vector_ciphertext_mult </p>
<div class="codehilite"><pre><span></span>def ElGamal.vector_ciphertext_mult : Π (p : ℕ) (Hp : nat.prime p) {n : ℕ},
  vector (zmodp p Hp × zmodp p Hp) n → vector (zmodp p Hp × zmodp p Hp) n → vector (zmodp p Hp × zmodp p Hp) n :=
λ (p : ℕ) (Hp : nat.prime p) {n : ℕ}, vector_ciphertext_mult._main p Hp
</pre></div>


<p>But I want to see the CIC terms build by tactics.</p>



<a name="191540532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191540532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191540532">(Mar 23 2020 at 21:40)</a>:</h4>
<p>The proof term is there, it's everything after the <code>:=</code>.</p>



<a name="191543401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191543401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191543401">(Mar 23 2020 at 22:06)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  Seems like something I  misunderstood about Lean, so let me give a similar analogy from Coq. In Coq, when you write tactic to solve some goal, under the hood it is constructing a Gallina (CIC) term (which you could have written manually, but no one does this because it is very cumbersome). Now at any point of the time, if you want to see the CIC (Gallina) terms, then you simply write 'Show Proof', and it will print all the Gallina (CIC) terms constructed so far. </p>
<p>In my 'vector_ciphertext_mult' program, there are two things: a list (which I believe is in CIC) and a proof (but written in tactic mode). I want to see how the proof terms  appears in CIC (or core language) because I don't think tactics are part of core language in Lean.</p>



<a name="191548790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191548790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191548790">(Mar 23 2020 at 23:00)</a>:</h4>
<p>Sorry, I guess I was a bit unclear, I meant the part after <code>:=</code> in the output of <code>#print vector_ciphertext_mult</code>, namely: <code>λ (p : ℕ) (Hp : nat.prime p) {n : ℕ}, vector_ciphertext_mult._main p Hp</code>. </p>
<p>That is a term, not a tactic. I don't know if you would consider that in the "core" language of Lean since you can also <a href="https://github.com/leanprover-community/lean/blob/master/doc/export_format.md" target="_blank" title="https://github.com/leanprover-community/lean/blob/master/doc/export_format.md">export</a> something even lower level. I've never played around with that though.</p>



<a name="191549864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191549864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191549864">(Mar 23 2020 at 23:13)</a>:</h4>
<p>I think you just have to keep digging. Can you see that your definition is essentially <code>vector_ciphertext_mult._main</code>? Why don't you <code>#print</code> that, and then keep printing stuff?</p>
<p>Hey -- do you know about <code>set_option pp.all true</code>? Try that before a #print statement, it gives you much more information.</p>



<a name="191558695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Schnorr%20Group/near/191558695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Schnorr.20Group.html#191558695">(Mar 24 2020 at 01:25)</a>:</h4>
<p>Sorry for the confusion. Some how I missed   the <code>._main</code> part in the <code> vector_ciphertext_mult._main p Hp </code>.  Thanks again <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> .</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
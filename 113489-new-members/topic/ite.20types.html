---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/ite.20types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html">ite types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="220282964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220282964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220282964">(Dec 17 2020 at 18:31)</a>:</h4>
<p>To make this work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">my_zero</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ℕ</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">zero</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">ℤ</span><span class="o">)}</span>
</code></pre></div>
<p>I guess I have to supply a proof that <code>¬ (2 ≤ 1)</code>, but where?</p>



<a name="220283058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220283058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220283058">(Dec 17 2020 at 18:32)</a>:</h4>
<p><code>by rw if_neg; [exact (0:int), norm_num]</code></p>



<a name="220283407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220283407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220283407">(Dec 17 2020 at 18:35)</a>:</h4>
<p>Hmm... this doesn't work</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">my_zero</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ℕ</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">if_neg</span><span class="bp">;</span> <span class="o">[</span><span class="n">exact</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">int</span><span class="o">)</span><span class="bp">;</span> <span class="n">norm_num</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div>



<a name="220283651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220283651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220283651">(Dec 17 2020 at 18:37)</a>:</h4>
<p>I think it should be <code>[exact (0:int), norm_num]</code></p>



<a name="220283987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220283987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220283987">(Dec 17 2020 at 18:39)</a>:</h4>
<p><code>exact (0:int); norm_num</code> works. Thanks!</p>



<a name="220284226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220284226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220284226">(Dec 17 2020 at 18:41)</a>:</h4>
<p>You also don't have to do it this way, you could use the definition <code>by exact {zero := (0 : ℤ)}</code> or <code>show has_zero ℤ, by apply_instance</code></p>



<a name="220284464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220284464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220284464">(Dec 17 2020 at 18:43)</a>:</h4>
<p>but this relies on definitional equality, so in some general situation, if you only have a proof of the condition of the <code>ite</code>, then these won't work</p>



<a name="220284587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220284587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220284587">(Dec 17 2020 at 18:44)</a>:</h4>
<p><code>ite (2 ≤ 1) ℕ ℤ</code> is <em>definitionally</em> <code>ℤ</code>?</p>



<a name="220284623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220284623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220284623">(Dec 17 2020 at 18:44)</a>:</h4>
<p>So it is!</p>



<a name="220284652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220284652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220284652">(Dec 17 2020 at 18:44)</a>:</h4>
<p>as long as you're using the constructive <code>decidable</code> instance</p>



<a name="220284916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220284916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220284916">(Dec 17 2020 at 18:46)</a>:</h4>
<p>Ah... I actually do want something more complicated than <code>2 ≤ 1</code>, more like this: <code>2^k ≤ 2^(2^(4-k)) - 1</code>.</p>



<a name="220285022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285022">(Dec 17 2020 at 18:47)</a>:</h4>
<p>I mean, it was always pretty unlikely someone would intentionally write <code>ite (2 ≤ 1) ℕ ℤ</code>.</p>



<a name="220285059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285059">(Dec 17 2020 at 18:47)</a>:</h4>
<p>I think you'll find the system fighting you at every step if you go down this path</p>



<a name="220285163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285163">(Dec 17 2020 at 18:48)</a>:</h4>
<p>probably a better approach is something like <code>{x : \Z // 2^k ≤ 2^(2^(4-k)) - 1 -&gt; x &gt;= 0}</code></p>



<a name="220285460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285460">(Dec 17 2020 at 18:51)</a>:</h4>
<p>Oh... so the <code>x &gt;= 0</code> is to choose between <code>\N</code> and <code>\Z</code>? How about choosing between arbitrary types there?</p>



<a name="220285506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285506">(Dec 17 2020 at 18:51)</a>:</h4>
<p>well, I might be extracting the wrong assumptions from your choice of <code>N</code> and <code>Z</code> then</p>



<a name="220285528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285528">(Dec 17 2020 at 18:51)</a>:</h4>
<p>like I'm assuming you're next going to ask how to define <code>has_add</code>, and then how to prove that <code>x + 0 = x</code></p>



<a name="220285612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285612">(Dec 17 2020 at 18:52)</a>:</h4>
<p>another option is to use an inductive type with constructors for <code>N</code> and <code>Z</code></p>



<a name="220285646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285646">(Dec 17 2020 at 18:52)</a>:</h4>
<p>I actually want more complicated types than N and Z, it was just a minimal (not) working example</p>



<a name="220285674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285674">(Dec 17 2020 at 18:52)</a>:</h4>
<p>or other types</p>



<a name="220285689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285689">(Dec 17 2020 at 18:52)</a>:</h4>
<p>or maybe an inductive family that bakes this <code>2^k ≤ 2^(2^(4-k)) - 1</code> condition in somehow</p>



<a name="220285728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285728">(Dec 17 2020 at 18:53)</a>:</h4>
<p>yeah that's what I mean</p>



<a name="220285761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285761">(Dec 17 2020 at 18:53)</a>:</h4>
<p>in fact, you might find that the assumption isn't necessary in some situations</p>



<a name="220285809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220285809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220285809">(Dec 17 2020 at 18:53)</a>:</h4>
<p>which means that the inductive type is actually a union of several different types in general, which may or may not be a problem</p>



<a name="220286046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220286046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220286046">(Dec 17 2020 at 18:56)</a>:</h4>
<p>Say, if we replace N and Z by arbitrary types U and V, what becomes of the <code>x &gt;= 0</code> condition in</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">\</span><span class="n">Z</span> <span class="bp">//</span> <span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">4</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">-&gt;</span> <span class="n">x</span> <span class="bp">&gt;=</span> <span class="mi">0</span><span class="o">}</span>
</code></pre></div>
<p>?</p>



<a name="220286187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220286187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220286187">(Dec 17 2020 at 18:56)</a>:</h4>
<p>this is an obviously useful condition which I don't think we have a way to express other than <code>\ex (q : \Q), x = q</code></p>



<a name="220286263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220286263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220286263">(Dec 17 2020 at 18:57)</a>:</h4>
<p>apparently we have a definition <code>irrational</code> <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="220286485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220286485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220286485">(Dec 17 2020 at 18:59)</a>:</h4>
<p>oh with the new version you can't do it this way, of course</p>



<a name="220286530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220286530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220286530">(Dec 17 2020 at 19:00)</a>:</h4>
<p>this is a danger of "minimal", it encourages answerable questions, which is good, but they might not have too much relevance to the real question</p>



<a name="220286652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220286652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220286652">(Dec 17 2020 at 19:00)</a>:</h4>
<p>How about <code>ite (2^k ≤ 2^(2^(4-k)) - 1) U V</code> where <code>U</code> and <code>V</code> are types... is it bad to use <code>ite</code> here?<br>
(Sorry for all the edits.)</p>



<a name="220286679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220286679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220286679">(Dec 17 2020 at 19:01)</a>:</h4>
<p>And of course the person with the question can't be expected to preserve exactly the relevant aspects of the question, otherwise they would probably be able to answer it themselves</p>



<a name="220286935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220286935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220286935">(Dec 17 2020 at 19:03)</a>:</h4>
<p>It's probably never a good idea to use <code>ite</code> on types</p>



<a name="220287196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220287196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220287196">(Dec 17 2020 at 19:05)</a>:</h4>
<p>This sounds similar to my topic about using <code>sum.elim U V</code> as a type...</p>



<a name="220287201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220287201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220287201">(Dec 17 2020 at 19:05)</a>:</h4>
<p>(deleted)</p>



<a name="220287450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220287450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220287450">(Dec 17 2020 at 19:08)</a>:</h4>
<p>How about this: how to implement types U_1, ... U_n where if <code>(2^k ≤ 2^(2^(n-k)) - 1)</code> then <code>U_k= fin k</code>(say) and otherwise <code>U_k = finset (fin k)</code> (say)</p>



<a name="220288384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220288384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220288384">(Dec 17 2020 at 19:15)</a>:</h4>
<p>well, hopefully you don't care about actual equality of types</p>



<a name="220288544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220288544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220288544">(Dec 17 2020 at 19:16)</a>:</h4>
<p>one possibility is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">U</span> <span class="o">(</span><span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk₁</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">U</span> <span class="n">n</span> <span class="n">k</span>
<span class="bp">|</span> <span class="n">mk₂</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">k</span><span class="o">)</span> <span class="bp">→</span> <span class="n">U</span> <span class="n">n</span> <span class="n">k</span>
</code></pre></div>



<a name="220288576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220288576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220288576">(Dec 17 2020 at 19:16)</a>:</h4>
<p>but really, the question can't be answered from this perspective</p>



<a name="220288629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220288629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220288629">(Dec 17 2020 at 19:17)</a>:</h4>
<p>Types describe what you can do with something, and we have no idea what you want to do with these U_k</p>



<a name="220288823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220288823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220288823">(Dec 17 2020 at 19:18)</a>:</h4>
<p>It's hard enough to figure out the right definitions when you know what you're doing (literally)</p>



<a name="220289033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220289033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220289033">(Dec 17 2020 at 19:20)</a>:</h4>
<p>That looks promising, although I get <code>invalid return type</code></p>



<a name="220289086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220289086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220289086">(Dec 17 2020 at 19:20)</a>:</h4>
<p>It should just be <code>U</code> there, not <code>U n k</code></p>



<a name="220289641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220289641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220289641">(Dec 17 2020 at 19:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  well briefly, I want to prove things about elements of the type <code>Σ k, U k</code>. Maybe your solution will do the trick!</p>



<a name="220290102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220290102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220290102">(Dec 17 2020 at 19:28)</a>:</h4>
<p>You can adapt the type reid gave to incorporate the sigma too:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">U</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk₁</span> <span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">U</span>
<span class="bp">|</span> <span class="n">mk₂</span> <span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">k</span><span class="o">)</span> <span class="bp">→</span> <span class="n">U</span>
</code></pre></div>



<a name="220290130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220290130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220290130">(Dec 17 2020 at 19:28)</a>:</h4>
<p>if you only need this sigma type then you can just use off-the-shelf types</p>



<a name="220290206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220290206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220290206">(Dec 17 2020 at 19:29)</a>:</h4>
<p><code>(Σ k (H : 2^k ≤ 2^(2^(n-k)) - 1), fin k) ⊕ (Σ k (H : ¬ 2^k ≤ 2^(2^(n-k)) - 1), finset (fin k))</code></p>



<a name="220290403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220290403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220290403">(Dec 17 2020 at 19:30)</a>:</h4>
<p>That said, in a particular application you might want to use a custom type to get more meaningful names than <code>sum.inr</code></p>



<a name="220300994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220300994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220300994">(Dec 17 2020 at 20:54)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> that looks good although is there some typo?</p>



<a name="220301219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220301219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220301219">(Dec 17 2020 at 20:56)</a>:</h4>
<p>Do you mean</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">Σ</span> <span class="n">k</span><span class="o">:</span><span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span><span class="bp">→</span> <span class="n">fin</span> <span class="n">k</span><span class="o">)</span> <span class="bp">⊕</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">k</span><span class="o">:</span><span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">¬</span> <span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span>  <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">k</span><span class="o">))</span>
</code></pre></div>
<p>?</p>



<a name="220412442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220412442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220412442">(Dec 18 2020 at 18:44)</a>:</h4>
<p>You want to write your own definition that takes an <code>x</code> and returns the <code>k</code>. Here are some examples on how to do this, depending on how you choose to define the type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>

<span class="c1">-- Reid's example (fixed)</span>
<span class="kd">def</span> <span class="n">my_type</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">Σ'</span> <span class="n">k</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">),</span> <span class="n">fin</span> <span class="n">k</span><span class="o">)</span> <span class="bp">⊕</span> <span class="o">(</span><span class="bp">Σ'</span> <span class="n">k</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">¬</span> <span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">),</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">k</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">my_k</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">my_type</span> <span class="n">n</span><span class="o">),</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">sum.inl</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">x</span><span class="o">⟩)</span> <span class="o">:=</span> <span class="n">k</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">sum.inr</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">x</span><span class="o">⟩)</span> <span class="o">:=</span> <span class="n">k</span>

<span class="c1">-- another way to define `k`</span>
<span class="kd">def</span> <span class="n">my_k_alternate</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">my_type</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">sum.elim</span> <span class="n">psigma.fst</span> <span class="n">psigma.fst</span> <span class="n">x</span>


<span class="c1">-- maybe more convenient?</span>
<span class="kd">def</span> <span class="n">my_type'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="bp">Σ</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">//</span> <span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">}</span> <span class="bp">⊕</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">k</span><span class="o">)</span> <span class="bp">//</span> <span class="bp">¬</span> <span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">my_k'</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">my_type'</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">x.1</span>

<span class="c1">-- Mario's example</span>
<span class="kd">inductive</span> <span class="n">U</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk₁</span> <span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">U</span>
<span class="bp">|</span> <span class="n">mk₂</span> <span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">k</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">k</span><span class="o">))</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">k</span><span class="o">)</span> <span class="bp">→</span> <span class="n">U</span>

<span class="kn">open</span> <span class="n">U</span>

<span class="kd">def</span> <span class="n">U_k</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">U</span> <span class="n">n</span><span class="o">),</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mk₁</span> <span class="n">k</span> <span class="n">H</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">k</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mk₂</span> <span class="n">k</span> <span class="n">H</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">k</span>
</code></pre></div>



<a name="220424135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220424135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220424135">(Dec 18 2020 at 20:25)</a>:</h4>
<p>Awesome <span class="user-mention" data-user-id="111080">@Floris van Doorn</span>  . Had not heard of the modified Σ type <code>Σ'</code> before.</p>



<a name="220430993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ite%20types/near/220430993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ite.20types.html#220430993">(Dec 18 2020 at 21:37)</a>:</h4>
<p>That syntax is <a href="https://leanprover-community.github.io/mathlib_docs/find/psigma">docs#psigma</a>, right?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
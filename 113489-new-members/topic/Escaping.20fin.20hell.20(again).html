---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html">Escaping fin hell (again)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="218135545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218135545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218135545">(Nov 27 2020 at 23:10)</a>:</h4>
<p>I had a really hard time with this proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Given a permutation of [0, n-1] , create a permutation of `[0, n]` that</span>
<span class="sd">    moves `n` into position `i` and leaves the rest untouched-/</span>
<span class="kd">def</span> <span class="n">equiv.perm.snoc</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">fin.last</span> <span class="n">n</span> <span class="k">then</span> <span class="n">i</span> <span class="k">else</span> <span class="n">fin.succ_above</span> <span class="n">i</span> <span class="o">(</span><span class="n">e</span> <span class="o">((</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">pred_above</span> <span class="n">x</span> <span class="n">h</span><span class="o">)),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">fin.last</span> <span class="n">n</span> <span class="k">else</span> <span class="n">fin.succ_above</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">e.symm</span> <span class="bp">$</span> <span class="n">i.pred_above</span> <span class="n">x</span> <span class="n">h</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">by_cases</span> <span class="n">hnl</span> <span class="o">:</span> <span class="n">fin.last</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span><span class="o">,</span>
      <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">h3</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">hnl</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h1</span><span class="o">,</span>
        <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">dif_pos</span> <span class="n">hnl.symm</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">false.elim</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)},</span>
      <span class="o">{</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h1</span><span class="o">,</span>
        <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">dif_pos</span> <span class="n">hnl.symm</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">false.elim</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)},</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span><span class="o">,</span>
      <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h1</span><span class="o">,</span>
      <span class="o">{</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h1</span><span class="o">,</span>
        <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">dif_neg</span> <span class="o">(</span><span class="n">ne.symm</span> <span class="n">hnl</span><span class="o">)]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">false.elim</span> <span class="o">(</span><span class="n">fin.succ_above_ne</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">),</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">false.elim</span> <span class="o">(</span><span class="n">hnl</span> <span class="n">h.symm</span><span class="o">),</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span> <span class="o">},</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">sorry</span> <span class="o">}</span>
</code></pre></div>
<p>The <code>dite</code>s were very hard to simplify, and I had to close a lot of trivial contradictions I'd rather just vanished.</p>
<p>Am I missing a tactic here?</p>
<p>( I expect I can do <code>right_inv</code>, but I'd rather wait to see if there's a trick I missed!)</p>



<a name="218186799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218186799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218186799">(Nov 28 2020 at 23:49)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.equiv.fin</span>

<span class="sd">/-- Given a permutation `e` of [0, n-1] , create a permutation of `[0, n]` that</span>
<span class="sd">    moves `n` into position `i`, and shifts `e x &gt; i` up one. -/</span>
<span class="kd">def</span> <span class="n">equiv.perm.snoc</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">fin.last</span> <span class="n">n</span> <span class="k">then</span> <span class="n">i</span> <span class="k">else</span> <span class="n">fin.succ_above</span> <span class="n">i</span> <span class="o">(</span><span class="n">e</span> <span class="o">((</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">pred_above</span> <span class="n">x</span> <span class="n">h</span><span class="o">)),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">fin.last</span> <span class="n">n</span> <span class="k">else</span> <span class="n">fin.succ_above</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">e.symm</span> <span class="bp">$</span> <span class="n">i.pred_above</span> <span class="n">x</span> <span class="n">h</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">rcases</span> <span class="n">eq_or_lt_of_le</span> <span class="n">x.le_last</span> <span class="k">with</span> <span class="n">rfl</span><span class="bp">|</span><span class="n">hnl</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">dif_pos</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">fin.last</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">ne_of_lt</span> <span class="n">hnl</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">fin.pred_above_succ_above</span><span class="o">,</span> <span class="n">equiv.symm_apply_apply</span><span class="o">,</span> <span class="n">dif_neg</span><span class="o">,</span>
                 <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">fin.succ_above_pred_above</span><span class="o">,</span> <span class="n">fin.succ_above_ne</span><span class="o">]}</span> <span class="o">},</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">sorry</span> <span class="o">}</span>
</code></pre></div>



<a name="218186847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218186847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218186847">(Nov 28 2020 at 23:50)</a>:</h4>
<p>I didn't touch your data defns, but there's probably a neater way of defining that.</p>



<a name="218187781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218187781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218187781">(Nov 29 2020 at 00:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.equiv.fin</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">fin.pred_last</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">fin.pred</span> <span class="o">(</span><span class="n">fin.last</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">ne_of_gt</span> <span class="n">fin.last_pos</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fin.last</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">fin.pred_above_of_last</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fin.last</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">≠</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fin.pred_above</span> <span class="n">k</span> <span class="o">(</span><span class="n">fin.last</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">fin.last</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">fin.pred_above</span><span class="o">,</span> <span class="n">dif_neg</span> <span class="o">(</span><span class="n">not_lt_of_le</span> <span class="n">k.le_last</span><span class="o">),</span> <span class="n">fin.pred_last</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">fin.pred_above_last</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fin.pred_above</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="n">k</span> <span class="o">(</span><span class="n">ne_of_lt</span> <span class="n">h</span><span class="o">)</span> <span class="bp">=</span> <span class="n">k.cast_lt</span> <span class="n">h</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">fin.pred_above</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">h</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}</span>

<span class="sd">/-- Given a permutation `e` of [0, n-1] , create a permutation of `[0, n]` that</span>
<span class="sd">    moves `n` into position `i`, and shifts `e x &gt; i` up one. -/</span>
<span class="kd">def</span> <span class="n">equiv.perm.snoc</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">fin.last</span> <span class="n">n</span> <span class="k">then</span> <span class="n">i</span> <span class="k">else</span> <span class="n">fin.succ_above</span> <span class="n">i</span> <span class="o">(</span><span class="n">e</span> <span class="o">((</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">pred_above</span> <span class="n">x</span> <span class="n">h</span><span class="o">)),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">fin.last</span> <span class="n">n</span> <span class="k">else</span> <span class="n">fin.succ_above</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">e.symm</span> <span class="bp">$</span> <span class="n">i.pred_above</span> <span class="n">x</span> <span class="n">h</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">by_cases</span> <span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">fin.last</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">H</span><span class="o">,</span> <span class="n">dif_pos</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">H</span><span class="o">,</span> <span class="n">fin.pred_above_succ_above</span><span class="o">,</span> <span class="n">equiv.symm_apply_apply</span><span class="o">,</span> <span class="n">dif_neg</span><span class="o">,</span>
                 <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">fin.succ_above_pred_above</span><span class="o">,</span> <span class="n">fin.succ_above_ne</span><span class="o">]}</span> <span class="o">},</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">by_cases</span> <span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">H</span><span class="o">,</span> <span class="n">dif_pos</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="c1">-- this could be a lemma too, but I was advised against it</span>
      <span class="k">have</span> <span class="n">nel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">k.cast_succ</span> <span class="bp">≠</span> <span class="n">fin.last</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="n">ne_of_lt</span> <span class="n">k.cast_succ_lt_last</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">H</span><span class="o">,</span> <span class="n">nel</span><span class="o">,</span> <span class="n">dif_neg</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">fin.succ_above_last</span><span class="o">,</span>
                 <span class="n">fin.pred_above_last</span> <span class="o">(</span><span class="n">fin.cast_succ_lt_last</span> <span class="n">_</span><span class="o">),</span> <span class="n">fin.cast_lt_cast_succ</span><span class="o">,</span>
                 <span class="n">equiv.apply_symm_apply</span><span class="o">,</span> <span class="n">fin.succ_above_pred_above</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="218187785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218187785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218187785">(Nov 29 2020 at 00:18)</a>:</h4>
<p>Feel free to PR.</p>



<a name="218187842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218187842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218187842">(Nov 29 2020 at 00:20)</a>:</h4>
<p>The crucial part for <code>left_inv</code> was knowing that <code>fin.succ_above_ne</code> is a lemma, but it's not a <code>simp</code> one because it provides an <code>ne</code> statement.</p>



<a name="218202139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218202139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218202139">(Nov 29 2020 at 08:16)</a>:</h4>
<p>Thanks!</p>



<a name="218202146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218202146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218202146">(Nov 29 2020 at 08:17)</a>:</h4>
<p>I've realized I should probably replace <code>fin.last n</code> with a generic <code>j</code> argument</p>



<a name="218202148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218202148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218202148">(Nov 29 2020 at 08:17)</a>:</h4>
<p>And also that I no longer need this for the proof I was working on...</p>



<a name="218203373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218203373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218203373">(Nov 29 2020 at 08:58)</a>:</h4>
<p>Do you still need the "split sum over univ into disjoint sets given involutive function etc"?</p>



<a name="218204783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218204783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218204783">(Nov 29 2020 at 09:43)</a>:</h4>
<p>I found that exists already, mostly</p>



<a name="218204842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218204842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218204842">(Nov 29 2020 at 09:44)</a>:</h4>
<p>It turns out that in asking for the Y in my XY problem, I found an X' that used Y in mathlib that was already most of the way towards the X I wanted</p>



<a name="218218295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218218295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218218295">(Nov 29 2020 at 16:00)</a>:</h4>
<p>I think the possibly mathlib-suitable version is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Given a permutation of [0, n-1] , create a permutation of `[0, n]` that</span>
<span class="sd">    inserts `i` in the input and `j` in the output, and maps one to the other. -/</span>
<span class="kd">def</span> <span class="n">equiv.perm.insert_fin</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">):</span>
  <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">j</span> <span class="k">else</span> <span class="n">fin.succ_above</span> <span class="n">j</span> <span class="o">(</span><span class="n">e</span> <span class="o">(</span><span class="n">i.pred_above</span> <span class="n">x</span> <span class="n">h</span><span class="o">)),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">j</span> <span class="k">then</span> <span class="n">i</span> <span class="k">else</span> <span class="n">fin.succ_above</span> <span class="n">i</span> <span class="o">(</span><span class="n">e.symm</span> <span class="bp">$</span> <span class="n">j.pred_above</span> <span class="n">x</span> <span class="n">h</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="k">else</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">fin.succ_above_ne</span><span class="o">],</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">j</span> <span class="k">then</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="k">else</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">fin.succ_above_ne</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>



<a name="218219086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218219086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218219086">(Nov 29 2020 at 16:22)</a>:</h4>
<p>Or perhaps these:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Given a permutation of [0, n-1] , create a permutation of `[0, n]` that</span>
<span class="sd">    leaves a hole around `i`. -/</span>
<span class="kd">def</span> <span class="n">equiv.perm.fin_succ_above</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">i</span> <span class="k">else</span> <span class="n">fin.succ_above</span> <span class="n">i</span> <span class="o">(</span><span class="n">e</span> <span class="bp">$</span> <span class="n">i.pred_above</span> <span class="n">x</span> <span class="n">h</span><span class="o">),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">i</span> <span class="k">else</span> <span class="n">fin.succ_above</span> <span class="n">i</span> <span class="o">(</span><span class="n">e.symm</span> <span class="bp">$</span> <span class="n">i.pred_above</span> <span class="n">x</span> <span class="n">h</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="k">else</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">fin.succ_above_ne</span><span class="o">],</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="k">else</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">fin.succ_above_ne</span><span class="o">]</span> <span class="o">}</span>

<span class="sd">/-- Given a permutation of `[0, n]` that leaves `i` unchanged, create a permutation of `[0, n - 1]` that</span>
<span class="sd">ignores `i`. -/</span>
<span class="kd">def</span> <span class="n">equiv.perm.fin_pred_above</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">i.pred_above</span> <span class="o">(</span><span class="n">e</span> <span class="bp">$</span> <span class="n">i.succ_above</span> <span class="n">x</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">h'</span><span class="o">,</span> <span class="n">i.succ_above_ne</span> <span class="n">x</span> <span class="bp">$</span> <span class="n">e.injective</span> <span class="bp">$</span> <span class="n">h'.trans</span> <span class="n">h.symm</span><span class="o">),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">i.pred_above</span> <span class="o">(</span><span class="n">e.symm</span> <span class="bp">$</span> <span class="n">i.succ_above</span> <span class="n">x</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">h'</span><span class="o">,</span> <span class="n">i.succ_above_ne</span> <span class="n">x</span> <span class="bp">$</span> <span class="n">e.symm.injective</span> <span class="bp">$</span> <span class="n">h'.trans</span> <span class="o">(</span><span class="n">e.apply_eq_iff_eq_symm_apply.mp</span> <span class="n">h</span><span class="o">)),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>



<a name="218220571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218220571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218220571">(Nov 29 2020 at 17:07)</a>:</h4>
<p>hm, I would prefer to see this factored a bit to go via <code>option (fin n)</code></p>



<a name="218220630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218220630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218220630">(Nov 29 2020 at 17:08)</a>:</h4>
<p>That is, there is an equiv <code>fin (n+1) ~= option (fin n)</code> that sends <code>i</code> to <code>none</code> and is otherwise monotone</p>



<a name="218220652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218220652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218220652">(Nov 29 2020 at 17:09)</a>:</h4>
<p>and then from an equiv <code>option A ~= option B</code> you can construct <code>A ~= B</code> (I think we have this already)</p>



<a name="218221421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218221421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218221421">(Nov 29 2020 at 17:31)</a>:</h4>
<p>So something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="n">functor.map_equiv</span> <span class="n">option</span>

<span class="sd">/-- An equivalence that leaves a hole around `i`, into which `none` is mapped -/</span>
<span class="kd">def</span> <span class="n">equiv.option_equiv_fin_succ_above</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">option</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">≃</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x.cases_on'</span> <span class="n">i</span> <span class="o">(</span><span class="n">fin.succ_above</span> <span class="n">i</span><span class="o">),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">none</span> <span class="k">else</span> <span class="n">some</span> <span class="o">(</span><span class="n">i.pred_above</span> <span class="n">x</span> <span class="n">h</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">fin.succ_above_ne</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="k">else</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">fin.succ_above_ne</span><span class="o">]</span> <span class="o">}</span>

<span class="c1">-- the definition higher in the thread</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">)</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">equiv.option_equiv_fin_succ_above</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">perm_congr</span> <span class="o">(</span><span class="n">functor.map_equiv</span> <span class="n">option</span> <span class="n">e</span><span class="o">)</span>
</code></pre></div>



<a name="218221955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218221955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218221955">(Nov 29 2020 at 17:46)</a>:</h4>
<p>What should that definition be called? <code>fin.succ_above_option</code>? Reverse it and use <code>fin.pred_above_option</code>?</p>



<a name="218223740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Escaping%20fin%20hell%20%28again%29/near/218223740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Escaping.20fin.20hell.20(again).html#218223740">(Nov 29 2020 at 18:30)</a>:</h4>
<p>Opened <a href="https://github.com/leanprover-community/mathlib/issues/5145">#5145</a> so that this doesn't get forgotten</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/nonconstructive.20proofs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html">nonconstructive proofs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="251257248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251257248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Teixeira <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251257248">(Aug 30 2021 at 16:44)</a>:</h4>
<p>Is it possible to write non constructive proofs in LEAN??</p>



<a name="251257403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251257403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251257403">(Aug 30 2021 at 16:45)</a>:</h4>
<p>yes</p>



<a name="251257405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251257405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251257405">(Aug 30 2021 at 16:45)</a>:</h4>
<p>Yes, using <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.choice">docs#classical.choice</a></p>



<a name="251257497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251257497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251257497">(Aug 30 2021 at 16:45)</a>:</h4>
<p>Most mathematics in mathlib makes no attempt to be constructive</p>



<a name="251273746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251273746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251273746">(Aug 30 2021 at 18:36)</a>:</h4>
<p>Mathematicians like playing in easy mode. They can get much further on in the quest that way.</p>



<a name="251274795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251274795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Sawin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251274795">(Aug 30 2021 at 18:43)</a>:</h4>
<p>What fraction of the results in mathlib, if they were proved constructively, would produce a useful algorithm?</p>



<a name="251275920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251275920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251275920">(Aug 30 2021 at 18:50)</a>:</h4>
<p>if it were useful it would be in core Lean, right?</p>



<a name="251276117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251276117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251276117">(Aug 30 2021 at 18:52)</a>:</h4>
<p>The stuff where you can clearly do it constructively is in my experience mostly done constructively.  Sometimes this makes it harder to use (or perhaps harder for beginners to use).</p>



<a name="251276184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251276184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251276184">(Aug 30 2021 at 18:52)</a>:</h4>
<p><span class="user-mention" data-user-id="230900">@Will Sawin</span> Sometimes we use constructive results. But running time blows up quickly.</p>



<a name="251276264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251276264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251276264">(Aug 30 2021 at 18:53)</a>:</h4>
<p>I think that Chris used it a couple of times when doing computations modulo small <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>, when he formalized quadratic reciprocity and sum of 4 squares</p>



<a name="251276379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251276379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251276379">(Aug 30 2021 at 18:54)</a>:</h4>
<p>Because for small <code>n</code> you can just do computations by brute force, and if stuff is done constructively, the algorithm for the brute force is handed to you by Lean.</p>



<a name="251276444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251276444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251276444">(Aug 30 2021 at 18:54)</a>:</h4>
<p>But in most cases the definitions that are good for elegant proofs are bad for fast computations.</p>



<a name="251276754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251276754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251276754">(Aug 30 2021 at 18:57)</a>:</h4>
<p>We do computed proofs often via <code>norm_num</code> =)</p>



<a name="251276899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251276899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251276899">(Aug 30 2021 at 18:57)</a>:</h4>
<p>But in terms of data structures, or enumerating over inductive data types, yes, a lot of algorithms are very slow.</p>



<a name="251278707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251278707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251278707">(Aug 30 2021 at 19:09)</a>:</h4>
<p>Maybe another illustrative example is finite sets.  To be as generic as possible, they're defined to be duplicate-free lists up to reordering. The only requirement they have is that there be an algorithm for testing equality.  The only possible algorithm for testing set membership in this situation takes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> time, since every element of that list must be compared for equality.</p>
<p>If finite sets could require that there be a computable total order, then that could be dropped down to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>ln</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\ln n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">ln</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> using a tree representation for the finite set.  Practical finite sets use hashing, which have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> set membership (for small enough finite sets... so not completely accurate).</p>
<p>So, while finite sets are constructive, and most operations on them are constructive (in that they are backed by algorithms), they're not exactly the algorithms you'd <em>want</em> to use in practice.</p>
<p>There doesn't seem to be a good way to have multiple algorithms and data structures with different characteristics for the same mathematical object, short of redefining the object and proving all its properties multiple times...</p>
<p>It would be cool if there were a way to have the pure math version of an object then provide computational definitions along with hints for how Lean should evaluate something. Maybe even if there were a way to write a typeclass that could give computational meaning to <code>noncomputable</code> definitions, which I don't think is possible with the way <code>noncomputable</code> works.</p>



<a name="251279087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251279087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251279087">(Aug 30 2021 at 19:11)</a>:</h4>
<p>Isn't this Lean 4's <code>@implementedBy</code>?</p>



<a name="251280025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251280025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251280025">(Aug 30 2021 at 19:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/nonconstructive.20proofs/near/251276444">said</a>:</p>
<blockquote>
<p>But in most cases the definitions that are good for elegant proofs are bad for fast computations.</p>
</blockquote>
<p>A fabulous case in point being the natural numbers. Ever tried to prove multiplication is associative by binary induction (i.e. induction on length of binary representation of number)?</p>



<a name="251280420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251280420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251280420">(Aug 30 2021 at 19:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> That's a bit different -- as far as I understand, it gives just one implementation for something. It would be nice if you could have different implementations depending on which typeclasses are available, since additional structure can allow for faster algorithms. You sort have to go for the lowest common denominator without this.</p>



<a name="251280536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251280536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251280536">(Aug 30 2021 at 19:21)</a>:</h4>
<p>You could have a version of the function that has more constraints (your typeclass constraints), and that one is <code>implementedBy</code></p>



<a name="251280621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251280621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251280621">(Aug 30 2021 at 19:22)</a>:</h4>
<p>Right -- for example matrix multiplication is done very differently for sparse matrices compared with the generic case.</p>



<a name="251280675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251280675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251280675">(Aug 30 2021 at 19:22)</a>:</h4>
<p>The sparse matrix case is hard, because how do you infer that you have a sparse matrix?</p>



<a name="251280735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251280735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251280735">(Aug 30 2021 at 19:23)</a>:</h4>
<p>Because the user tells you? This is for people wanting to do computations, right? Don't ask me :-)</p>



<a name="251280837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251280837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251280837">(Aug 30 2021 at 19:24)</a>:</h4>
<p>That's how it works in computer algebra packages, you just use the matrix multiplication function but give it some added switch to say "please use this algo at this point"</p>



<a name="251281202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/251281202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#251281202">(Aug 30 2021 at 19:27)</a>:</h4>
<p><a href="https://doc.sagemath.org/html/en/tutorial/tour_linalg.html#sparse-linear-algebra">example using Sage</a></p>



<a name="252677422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252677422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252677422">(Sep 09 2021 at 19:00)</a>:</h4>
<p>One way it seems you can work with noncomputable definitions and then provide (multiple) ways to compute them is through a "classicalized" version of a type.  Every noncomputable value can be represented as a singleton set:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">sval</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">singleton</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">s</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">})</span>

<span class="kd">prefix</span> <span class="bp">`!`</span><span class="o">:</span><span class="mi">100</span> <span class="o">:=</span> <span class="n">sval</span>

<span class="kd">def</span> <span class="n">sval.incl</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">!</span><span class="n">α</span> <span class="o">:=</span> <span class="o">⟨{</span><span class="n">x</span><span class="o">},</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
</code></pre></div>
<p>For example, the infimum of a set of natural numbers in <code>noncomputable</code>, but we can erase this keyword using this type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Inf'</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">!</span><span class="n">ℕ</span> <span class="o">:=</span> <span class="o">⟨{</span><span class="n">Inf</span> <span class="n">s</span><span class="o">},</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
</code></pre></div>
<p>The next ingredient is a typeclass similar to <code>decidable</code> that provides a computation (when one is available):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">computable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">!</span><span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compute</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">compute_spec</span> <span class="o">:</span> <span class="n">compute</span> <span class="bp">∈</span> <span class="n">v.s</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">sval.compute</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">!</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">computable</span> <span class="n">v</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">computable.compute</span> <span class="n">v</span>
</code></pre></div>
<p>For example, the infimum is computable if the set has decidable membership and if nonemptiness is decidable:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">nat.Inf'_computable</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">s</span><span class="o">)]</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">decidable</span> <span class="n">s.nonempty</span><span class="o">]</span> <span class="o">:</span> <span class="n">computable</span> <span class="o">(</span><span class="n">Inf'</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">...</span> <span class="n">something</span> <span class="n">involving</span> <span class="n">nat.find</span> <span class="bp">...</span>
</code></pre></div>
<p>It can also be computable if you know exactly what the set is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">nat.Inf'_interval</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">computable</span> <span class="o">(</span><span class="n">Inf'</span> <span class="o">(</span><span class="n">set.Ici</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Inf'</span><span class="o">]⟩</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">Inf'</span> <span class="o">(</span><span class="n">set.Ici</span> <span class="mi">100</span><span class="o">))</span><span class="bp">.</span><span class="n">compute</span>
<span class="c1">-- 100</span>
</code></pre></div>



<a name="252677749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252677749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252677749">(Sep 09 2021 at 19:03)</a>:</h4>
<p>By the way, <code>sval</code> is also known as <a href="https://leanprover-community.github.io/mathlib_docs/find/erased">docs#erased</a></p>



<a name="252677836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252677836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252677836">(Sep 09 2021 at 19:03)</a>:</h4>
<p>It's not the most convenient to work with, but there are a few interesting Lean-computable equivalences.</p>
<ul>
<li><code>set (!α) ≃ set α</code></li>
<li><code>!set α ≃ set α</code></li>
<li><code>!(Π (x : α), β x) ≃ (Π (x : α), !β x)</code> and <code>!(α → β) ≃ (α → !β)</code></li>
</ul>
<p>It's also a monad, so at least that's something.</p>



<a name="252677924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252677924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252677924">(Sep 09 2021 at 19:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Thanks, I knew there had to be something like this already.</p>



<a name="252678141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252678141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252678141">(Sep 09 2021 at 19:05)</a>:</h4>
<p>Here's a gist <a href="https://gist.github.com/kmill/a67dae0e6cdf8ff8897d37a0563f8d4b">https://gist.github.com/kmill/a67dae0e6cdf8ff8897d37a0563f8d4b</a> with the experiment</p>



<a name="252678454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252678454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252678454">(Sep 09 2021 at 19:08)</a>:</h4>
<p>(I'd wanted to try making some <code>computable</code> classes that would demonstrate you could use <code>ordset</code> as an intermediate representation when taking some unions of finsets, but I didn't get to it, if it's even possible.)</p>



<a name="252678662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252678662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252678662">(Sep 09 2021 at 19:09)</a>:</h4>
<p>That's nice that <code>erased</code> erases its data -- I'd worried about whether <code>sval</code> would develop enormous symbolic representations.</p>



<a name="252679708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252679708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252679708">(Sep 09 2021 at 19:16)</a>:</h4>
<p>One more example of <code>computable</code>, for noncomputable finite sets (showing only some illustrative definitions and lemmas):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">finset'</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">!</span><span class="n">finset</span> <span class="n">α</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_union</span> <span class="o">(</span><span class="n">finset'</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="o">⟨{</span><span class="n">u</span> <span class="bp">|</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">classical</span><span class="o">,</span> <span class="n">exact</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">s.val</span> <span class="bp">∪</span> <span class="n">t.val</span> <span class="o">}},</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩</span>

<span class="kd">lemma</span> <span class="n">mem_union</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">change</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">sval.incl</span> <span class="n">_</span> <span class="bp">↔</span> <span class="n">_</span><span class="o">,</span>  <span class="n">simp</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">computable</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">computable</span> <span class="n">t</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">computable</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>

<span class="kd">abbreviation</span> <span class="n">a</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">sval.incl</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">}</span>
<span class="kd">abbreviation</span> <span class="n">b</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">sval.incl</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">}</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∪</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">compute</span>
<span class="c1">-- {1, 2, 3, 4}</span>
</code></pre></div>
<p>(This needs <code>a</code> and <code>b</code> to be reducible since it's relying on another instance that says anything created with <code>sval.incl</code> is computable.)</p>



<a name="252680314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252680314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252680314">(Sep 09 2021 at 19:21)</a>:</h4>
<p>This is pretty neat but it's worth considering the trade-off compared to something in the style of <code>norm_num</code> (or even <code>simp</code>). As an extreme example, in order to prove that a given number is composite, <code>norm_num</code> could invoke an external program to factor the number.</p>



<a name="252680550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252680550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252680550">(Sep 09 2021 at 19:23)</a>:</h4>
<p>Also, <code>norm_num</code> is allowed to fail sometimes, while decidability instances generally can't, unless you do the bulk of the computation in the typeclass inference search itself</p>



<a name="252680554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252680554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252680554">(Sep 09 2021 at 19:23)</a>:</h4>
<p>The biggest advantage of something like <code>computable</code> is that you get a meta-level proof that there is an algorithm to compute the thing... but if you only really care about <em>actually computing</em> it then this isn't really necessary.</p>



<a name="252680713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252680713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252680713">(Sep 09 2021 at 19:24)</a>:</h4>
<p>(this is basically the same as Mario's point that <code>norm_num</code> is allowed to fail)</p>



<a name="252680790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252680790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252680790">(Sep 09 2021 at 19:25)</a>:</h4>
<p>Yeah, I don't think this is very useful for compile-time (the likes of <code>norm_num</code> and <code>simp</code>).  It seems like it could be useful for when you want to compile programs and want to be able to automatically select good-ish algorithms.</p>



<a name="252680840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252680840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252680840">(Sep 09 2021 at 19:25)</a>:</h4>
<p>while also being able to use the standard mathematical definitions, which come with a whole library of lemmas</p>



<a name="252680922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252680922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252680922">(Sep 09 2021 at 19:26)</a>:</h4>
<p>It's definitely an improvement over trying to make your algorithm be the definition, I think.</p>



<a name="252680928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252680928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252680928">(Sep 09 2021 at 19:26)</a>:</h4>
<p>For example, for interval arithmetic computations on real numbers it is convenient to make the calculation blow up if you divide by zero, but that means that the space of successfully evaluating terms is very complicated and depends on the output of previous computations</p>



<a name="252682038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252682038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252682038">(Sep 09 2021 at 19:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/nonconstructive.20proofs/near/252680554">said</a>:</p>
<blockquote>
<p>The biggest advantage of something like <code>computable</code> is that you get a meta-level proof that there is an algorithm to compute the thing... but if you only really care about <em>actually computing</em> it then this isn't really necessary.</p>
</blockquote>
<p>This all applies to <code>decidable</code> too, right?</p>
<p>One reason I was looking into this was to see whether <code>decidable</code> could feasibly be removed from all the mathematical definitions, and whether it could be relegated to <code>computable</code> instances.</p>



<a name="252682217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252682217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252682217">(Sep 09 2021 at 19:36)</a>:</h4>
<p>Yes, <code>decidable</code> has roughly the same characteristics as <code>computable</code> here</p>



<a name="252682336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252682336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252682336">(Sep 09 2021 at 19:37)</a>:</h4>
<p><code>decidable</code> can't be removed from definitions with computational content, whether it is spelled <code>decidable</code> or <code>computable</code></p>



<a name="252682523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252682523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252682523">(Sep 09 2021 at 19:38)</a>:</h4>
<p>Note that your <code>finset'</code> definition does not make <code>finset</code> obsolete, because it depends on <code>finset</code></p>



<a name="252682551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252682551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252682551">(Sep 09 2021 at 19:38)</a>:</h4>
<p>the theorems about <code>finset</code> would continue to have all the same decidability assumptions</p>



<a name="252683426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252683426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252683426">(Sep 09 2021 at 19:44)</a>:</h4>
<p>I designed <code>computable</code> to be the <code>Type</code>-level version of <code>decidable</code> -- I meant the question rhetorically.</p>
<p>And sure, I used <code>finset</code> to implement <code>finset'</code>, but I didn't have to.  The point of the example is that <code>finset</code> can be used as a computational backend to the classical notion of a finite set.  <code>finset</code> certainly needs its decidability assumptions.</p>



<a name="252683645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252683645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252683645">(Sep 09 2021 at 19:46)</a>:</h4>
<p>It's not clear that we gain that much by having <code>finset'</code> though, compared to <code>open_locale classical</code> + <code>finset</code></p>



<a name="252683766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252683766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252683766">(Sep 09 2021 at 19:47)</a>:</h4>
<p>It's certainly possible to have a version of <code>finset</code> with no computational content; <code>finite</code> does basically that</p>



<a name="252683956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252683956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252683956">(Sep 09 2021 at 19:48)</a>:</h4>
<p>explicitly erasing computational content isn't usually that productive, since it just removes some <code>noncomputable</code> markings</p>



<a name="252683960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252683960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252683960">(Sep 09 2021 at 19:48)</a>:</h4>
<p>Based on your saying "whether it is spelled <code>decidable</code> or <code>computable</code>" I'm thinking what I said isn't clear:<br>
<span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/nonconstructive.20proofs/near/252682038">said</a>:</p>
<blockquote>
<p>One reason I was looking into this was to see whether <code>decidable</code> could feasibly be removed from all the mathematical definitions, and whether it could be relegated to <code>computable</code> instances.</p>
</blockquote>
<p>This is what I'm referring to specifically:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">computable</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">computable</span> <span class="n">t</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">computable</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>It's moving any trace of <code>decidable</code> from definitions and lemmas about mathematical definitions to descriptions of how you might compute them.</p>



<a name="252684132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252684132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252684132">(Sep 09 2021 at 19:49)</a>:</h4>
<p>This is also a much more precise way to give computational meaning to expressions, since you can make use of any additional typeclasses the types might satisfy.</p>



<a name="252684635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252684635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252684635">(Sep 09 2021 at 19:51)</a>:</h4>
<p>It's still not good enough for e.g. selecting sparse matrix vs dense matrix representation, but sure, this works alright for <code>decidable</code></p>



<a name="252684665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252684665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252684665">(Sep 09 2021 at 19:51)</a>:</h4>
<p>so for example, get rid of <code>ite</code> with its <code>decidable</code> argument, and instead write a <code>computable</code> instance for it which carries the <code>decidable</code> hypothesis</p>



<a name="252684763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252684763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252684763">(Sep 09 2021 at 19:52)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- ite, but without decidability -/</span>
<span class="kd">def</span> <span class="n">ite'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">!</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">!</span><span class="n">α</span> <span class="o">:=</span>
<span class="o">⟨{</span><span class="n">v</span> <span class="bp">|</span> <span class="o">(</span><span class="n">c</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">x.s</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">¬</span><span class="n">c</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">y.s</span><span class="o">)},</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">c</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">x.val</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">y.val</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="o">},</span>
<span class="kd">end</span><span class="o">⟩</span>

<span class="sd">/-- When the proposition is decidable, compute the ite' with ite. -/</span>
<span class="kd">instance</span> <span class="n">ite'.compute</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">c</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">!</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">computable</span> <span class="n">x</span><span class="o">]</span> <span class="o">[</span><span class="n">computable</span> <span class="n">y</span><span class="o">]</span> <span class="o">:</span> <span class="n">computable</span> <span class="o">(</span><span class="n">ite'</span> <span class="n">c</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">ite</span> <span class="n">c</span> <span class="n">x.compute</span> <span class="n">y.compute</span><span class="o">,</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">ite'</span><span class="o">,</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">{</span><span class="n">contextual</span><span class="o">:=</span><span class="n">tt</span><span class="o">},</span>
<span class="kd">end</span><span class="o">⟩</span>
</code></pre></div>



<a name="252684878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252684878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252684878">(Sep 09 2021 at 19:53)</a>:</h4>
<p>This is using the <code>!</code> type, which is annoying -- I wish it were more seamless -- but in principle it seems to work.</p>



<a name="252684911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252684911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252684911">(Sep 09 2021 at 19:53)</a>:</h4>
<p>I was thinking of a noncomputable version</p>



<a name="252684925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252684925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252684925">(Sep 09 2021 at 19:53)</a>:</h4>
<p>You can write <code>ite'</code> more simply as <code>launder (by classical; exact ite c x y)</code> where <code>launder</code> is an identity function on <code>!α</code> that makes any term computable</p>



<a name="252685296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252685296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252685296">(Sep 09 2021 at 19:56)</a>:</h4>
<p>Proving these things can be annoying for recursive functions though</p>



<a name="252685482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252685482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252685482">(Sep 09 2021 at 19:58)</a>:</h4>
<p>I would rather come at this from the other direction: introduce <code>ite'</code> and use it only when the decidability argument gets in the way</p>



<a name="252685574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252685574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252685574">(Sep 09 2021 at 19:59)</a>:</h4>
<p>(and it would be defined simply as <code>by classical; exact ite c x y</code>, <code>noncomputable</code> notwithstanding)</p>



<a name="252685772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252685772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252685772">(Sep 09 2021 at 20:00)</a>:</h4>
<p>It would be nice if there were a way to coerce <code>noncomputable</code> terms to <code>!α</code>.  It's not clear to me how you'd do it without the coercion itself being <code>noncomputable</code>.</p>



<a name="252685897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252685897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252685897">(Sep 09 2021 at 20:01)</a>:</h4>
<p>I didn't fully understand what <code>launder</code> was about -- did you mean it would be this coercion?</p>



<a name="252687109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252687109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252687109">(Sep 09 2021 at 20:09)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.erased</span>

<span class="kd">axiom</span> <span class="n">magic</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">ℕ</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">magic'</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">magic</span> <span class="c1">-- if we use it directly, it is noncomputable</span>

<span class="kd">def</span> <span class="n">magic''</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">magic.1</span><span class="o">,</span> <span class="n">magic.2</span><span class="o">⟩</span> <span class="c1">-- laundering it makes it computable</span>

<span class="kd">def</span> <span class="n">launder</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">s.1</span><span class="o">,</span> <span class="n">s.2</span><span class="o">⟩</span>

<span class="c1">-- Using launder directly doesn't work, because lean doesn't unfold it</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">magic'''</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">launder</span> <span class="n">magic</span>

<span class="kd">notation</span> <span class="bp">`</span><span class="n">launder</span><span class="bp">`</span> <span class="n">s</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">s.1</span><span class="o">,</span> <span class="n">s.2</span><span class="o">⟩</span>

<span class="c1">-- @[inline] also doesn't work (and lean 3 doesn't have macroInline), but a notation does</span>
<span class="kd">def</span> <span class="n">magic''''</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">launder</span> <span class="n">magic</span>
</code></pre></div>



<a name="252688137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/252688137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#252688137">(Sep 09 2021 at 20:16)</a>:</h4>
<p>Oh, looks like <code>abbreviation</code> works, wasn't expecting that</p>



<a name="273931887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/273931887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#273931887">(Mar 03 2022 at 07:11)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> and <span class="user-mention" data-user-id="306601">@Kyle Miller</span> , I found this thread by searching for "nonconstructive <code>ite</code>". Did anything like this end up getting added to mathlib? (I hope it's ok to respond to an old thread)</p>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/nonconstructive.20proofs/near/252683645">said</a>:</p>
<blockquote>
<p>It's not clear that we gain that much by having <code>finset'</code> though, compared to <code>open_locale classical</code> + <code>finset</code></p>
</blockquote>
<p>Quick comment -- I ran into problems a few weeks ago from trying to use <code>open_locale classical</code> + <code>finset</code>, problems coming from decidability diamonds. Basically the solution I was told was to explicitly provide decidability instances rather than using <code>open_locale classical</code>.</p>
<p>I don't really understand decidability,  but (now that I'm trying to use it appropriately) I just ran into a similar kind of problem with two superficially identical <code>ite</code> expressions with different decidability instances. It would definitely be very nice to have a way to do this that doesn't involve any decidability at all.</p>



<a name="273939026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/273939026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#273939026">(Mar 03 2022 at 08:33)</a>:</h4>
<p>Yes, <code>open_locale classical</code> was an attempt to fix some decidability issues but now there are better ways (the rule of thumb is that if the statement of a declaration needs one then add it as an assumption, and if a proof needs one then use the <code>classical</code> tactic). This is what you do in the other thread but you still seem to get into problems :-/</p>



<a name="273939636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nonconstructive%20proofs/near/273939636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nonconstructive.20proofs.html#273939636">(Mar 03 2022 at 08:38)</a>:</h4>
<p>I do appreciate your help <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
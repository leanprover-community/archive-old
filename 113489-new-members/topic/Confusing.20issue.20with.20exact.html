---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html">Confusing issue with exact</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="292328011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292328011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292328011">(Aug 07 2022 at 16:37)</a>:</h4>
<p>Having just closed one help thread, I'm immediately back with another. Sorry!</p>
<p>I'm experimenting with defining <code>findp</code> (probably a bad name) on <code>list</code>. It's a version of <code>find</code> that requires a proof that a matching item exists, and is therefore able to return <code>α</code> instead of <code>option α</code>. I'm using it to define another function <code>overlap</code>, which gives the longest common tail and prefix between two lists. This is all just for learning purposes.</p>
<p>I've run into an issue where two lemmas that look very similar to me (<code>findp_mem</code> and <code>findp_pred</code>) seem to behave differently. One works fine with a simple <code>exact</code>, the other gives a confusing error.</p>
<p>Apologies for the long code sample! I've stripped this down to only the relevant lemmas, and replaced irrelevant bodies with <code>sorry</code> to try to keep things reasonably compact.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="c1">-- There exists some item that is in the list and matches a predicate.</span>
<span class="kd">def</span> <span class="n">containsp</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">a</span>

<span class="c1">-- find is some when containsp.</span>
<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">find_containsp</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span>
<span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">l.containsp</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">l.find</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">is_some</span> <span class="o">:=</span> <span class="gr">sorry</span>


<span class="c1">-- Version of find that takes in a proof of containsp.</span>
<span class="c1">-- Avoids exposing option publicly, because we know containsp.</span>
<span class="kd">def</span> <span class="n">findp</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span>
<span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">l.containsp</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">option.get</span> <span class="n">_</span> <span class="o">(</span><span class="n">find</span> <span class="n">p</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">find_containsp</span> <span class="n">p</span> <span class="n">l</span> <span class="n">q</span><span class="o">)</span>


<span class="c1">-- The return value of findp is a member of the list.</span>
<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">findp_mem</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span>
<span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>
<span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">l.containsp</span> <span class="n">p</span><span class="o">}</span> <span class="o">:</span>
<span class="o">(</span><span class="n">l.findp</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">l</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- The return value of findp matches the predicate.</span>
<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">findp_pred</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span>
<span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>
<span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">l.containsp</span> <span class="n">p</span><span class="o">}</span> <span class="o">:</span>
<span class="n">p</span> <span class="o">(</span><span class="n">l.findp</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>


<span class="c1">-- A common tail and suffix always exist between two lists.</span>
<span class="c1">-- (Allowing [])</span>
<span class="kd">lemma</span> <span class="n">overlap_exists_aux</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
<span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="n">l₁.tails.containsp</span> <span class="o">(</span><span class="bp">&lt;+</span><span class="o">:</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- The longest tail/suffix of l₁ that is also a prefix of l₂.</span>
<span class="kd">def</span> <span class="n">overlap</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">findp</span> <span class="o">(</span><span class="bp">&lt;+</span><span class="o">:</span> <span class="n">l₂</span><span class="o">)</span> <span class="n">l₁.tails</span> <span class="o">(</span><span class="n">overlap_exists_aux</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span>

<span class="c1">-- The overlap is in l₁.tails by trivial application of findp_mem.</span>
<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">overlap_tail</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
<span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
<span class="o">(</span><span class="n">overlap</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">l₁.tails</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">overlap</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">findp_mem</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">set_option</span> <span class="n">pp.proofs</span> <span class="n">true</span>

<span class="c1">-- The overlap is a prefix of l₂ by trivial application of findp_pred.</span>
<span class="c1">-- Except that this doesn't work...</span>
<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">overlap_prefix</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
<span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">&lt;+</span><span class="o">:</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">(</span><span class="n">overlap</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">overlap</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">findp_pred</span><span class="o">,</span> <span class="c1">-- Apparently not</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">list</span>
</code></pre></div>
<p>The issue is at the end, in <code>overlap_prefix</code>.</p>
<p>The <code>exact</code> fails to match, and I don't understand why. I can sort of understand that it might be something to do with matching up the <code>q</code> proof parameter to <code>findp</code>, but I don't understand why it would work in <code>overlap_tail</code> and not in <code>overlap_prefix</code>. None of the standard auto solving tactics are getting anywhere to give me a clue here.</p>
<p>So a multipart question: What's the explanation for these behaving differently, and what can I do to fix it?</p>
<p>Sorry for spamming Zulip with so many questions these last few days! Lean is fun, but my debugging skills from traditional programming aren't getting me very far here yet!</p>



<a name="292328522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292328522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292328522">(Aug 07 2022 at 16:48)</a>:</h4>
<p>It seems to need some help to be able to deduce what <code>p</code> is. That needs some higher-order unification I believe, or at least some unification that goes down the wrong path somewhere.</p>
<p>I didn't golf the proof here, I just left it in the form where I got it to work.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">overlap_prefix</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
<span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">&lt;+</span><span class="o">:</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">(</span><span class="n">overlap</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">overlap</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">findp_pred</span> <span class="n">_</span> <span class="o">(</span><span class="bp">&lt;+</span><span class="o">:</span> <span class="n">l₂</span><span class="o">),</span>
  <span class="n">apply</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="292328538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292328538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292328538">(Aug 07 2022 at 16:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">overlap_prefix</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
<span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">&lt;+</span><span class="o">:</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">(</span><span class="n">overlap</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">findp_pred</span> <span class="n">_</span> <span class="o">(</span><span class="bp">&lt;+</span><span class="o">:</span> <span class="n">l₂</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
</code></pre></div>



<a name="292328633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292328633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292328633">(Aug 07 2022 at 16:51)</a>:</h4>
<p>Huh. Thanks!</p>
<p>It's cool that that works, but do we have an explanation for why that's needed for <code>findp_pred</code> and not for <code>findp_mem</code>?</p>



<a name="292328768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292328768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292328768">(Aug 07 2022 at 16:54)</a>:</h4>
<p>I haven't dug into it, but my guess is it's the difference between a list argument appearing twice in the expression and a predicate argument.</p>



<a name="292328792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292328792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292328792">(Aug 07 2022 at 16:55)</a>:</h4>
<p>I don't know how much this applies to Lean, but from my traditional programming background I care a lot about creating high quality APIs. It feels like I'm doing something wrong if <code>findp_pred</code> is hard to use in this way. Is there something I can change about the definition that will make the simple use (<code>exact findp_pred</code>) work? I don't like providing a lemma that <code>library_search</code> isn't even able to find for some reason.</p>



<a name="292328872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292328872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292328872">(Aug 07 2022 at 16:56)</a>:</h4>
<p>And it seems problematic that <code>simp</code> also doesn't know how to use it.</p>



<a name="292328987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292328987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292328987">(Aug 07 2022 at 16:59)</a>:</h4>
<p><code>simp</code> can't apply lemmas unless they have a symbolic "head", so for example it has to be about <code>f x y</code> where <code>f</code> is not an argument, but an actual constant</p>



<a name="292329042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329042">(Aug 07 2022 at 17:00)</a>:</h4>
<p>That's because it stores all its lemmas in a table indexed by the head for performance</p>



<a name="292329090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329090">(Aug 07 2022 at 17:01)</a>:</h4>
<p>A simple change to <code>findp_pred</code> is to make <code>p</code> be an explicit argument, and then say that <code>findp_pred</code> is a technical lemma that you apply in specific situations. I'm not sure if there's a good way to ensure Lean will solve the unification constraints correctly on its own (maybe someone has a trick though)</p>



<a name="292329160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329160">(Aug 07 2022 at 17:02)</a>:</h4>
<p>By the way, you can write the goal as <code>overlap l₁ l₂ &lt;+: l₂</code>, this isn't getting in the way of typechecking</p>



<a name="292329258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329258">(Aug 07 2022 at 17:05)</a>:</h4>
<p>Huh. So the reason <code>findp_mem</code> does work with <code>simp</code> is that <code>mem</code> is a constant head. That makes some sense.</p>



<a name="292329322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329322">(Aug 07 2022 at 17:06)</a>:</h4>
<p>I think generally <code>findp_pred</code> would have the <code>l.containsp p</code> argument be explicit, since in practice you probably would want it to be explicit (and a user can always supply a <code>_</code> if not)</p>



<a name="292329388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329388">(Aug 07 2022 at 17:08)</a>:</h4>
<p>By the way, there's a more accurate rule for simp. Simp has two levels of tables: each relation can have simp lemmas. So, for example, it needs to be <code>f x y = foo</code> with <code>f</code> a constant. There is a special case that every <code>Prop</code> simp lemma that proves <code>foo</code> turns into <code>foo = true</code> and gets added to the <code>=</code> table.</p>



<a name="292329547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329547">(Aug 07 2022 at 17:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Confusing.20issue.20with.20exact/near/292329090">said</a>:</p>
<blockquote>
<p>A simple change to <code>findp_pred</code> is to make <code>p</code> be an explicit argument, and then say that <code>findp_pred</code> is a technical lemma that you apply in specific situations. I'm not sure if there's a good way to ensure Lean will solve the unification constraints correctly on its own (maybe someone has a trick though)</p>
</blockquote>
<p>To clarify, you're not saying that this would enable <code>simp</code> and similar to use this lemma automatically, are you? I've been experimenting with making arguments explicit but it doesn't seem to have changed that behaviour.</p>



<a name="292329559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329559">(Aug 07 2022 at 17:13)</a>:</h4>
<p>You are correct, I'm not suggesting that <code>simp</code> would be able to handle it. It's just easier to use the lemma if it's an explicit argument.</p>



<a name="292329636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329636">(Aug 07 2022 at 17:15)</a>:</h4>
<p>Oh! I think maybe I've just understood something weird about the <code>find</code> (not <code>findp</code>) lemmas!</p>



<a name="292329647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329647">(Aug 07 2022 at 17:15)</a>:</h4>
<p>They're defined like this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">list.find_some</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span>
<span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>
<span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
<span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">list.find</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">option.some</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
<span class="n">p</span> <span class="n">a</span>
</code></pre></div>
<p>This implicit <code>a</code> feels weird, but is that a trick to get around this problem?</p>



<a name="292329648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329648">(Aug 07 2022 at 17:15)</a>:</h4>
<p>A way to think about the relationship between <code>findp_pred</code> and <code>overlap_prefix</code> is that you're instantiating a generic family of lemmas into a concrete case. (Some programming languages, like Ada, require you to instantiate generics explicitly, unlike languages like C++ or Java that try to be more automatic.)</p>



<a name="292329701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329701">(Aug 07 2022 at 17:16)</a>:</h4>
<p>I think you'd usually find <code>a</code> to be implicit like that in mathlib since it's determined by <code>H</code> in a straightforward way</p>



<a name="292329710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329710">(Aug 07 2022 at 17:17)</a>:</h4>
<p>but, depending on how you intend to use <code>find_some</code>, you might choose to make it explicit</p>



<a name="292329769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329769">(Aug 07 2022 at 17:18)</a>:</h4>
<p>Design consideration: do you think you'll have <code>list.find p l = option.some a</code> proofs in that form lying around? If so, then it'll be easy to use, if not, maybe make some of these arguments explicit so you can more easily provide a proof of <code>H</code> inline and have the type all set up for you, or accept that you'll write <code>(begin ... end : list.find p l = option.some a)</code> with the relevant <code>p</code>, <code>l</code>, and <code>a</code></p>



<a name="292329800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329800">(Aug 07 2022 at 17:19)</a>:</h4>
<p>(In Lean 4 this is less of an issue because you can write <code>list.find_some (l := [1,2,3]) my_H</code> to specify <code>l</code>)</p>



<a name="292329861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329861">(Aug 07 2022 at 17:20)</a>:</h4>
<p>I was wondering whether something like this was somehow better, although it looks like it would still have the same head problem.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">findp_pred2</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span>
<span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>
<span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">l.containsp</span> <span class="n">p</span><span class="o">}</span>
<span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
<span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="n">l.findp</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
<span class="n">p</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="292329931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329931">(Aug 07 2022 at 17:22)</a>:</h4>
<p>That's a useful pattern sometimes, for example if you want to <code>apply findp_pred2</code> and have it generate an equality goal for you</p>



<a name="292329940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292329940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292329940">(Aug 07 2022 at 17:22)</a>:</h4>
<p>But I'm not sure it's better or worse. You can also use <a href="https://leanprover-community.github.io/mathlib_docs/find/convert">docs#convert</a> to generate those equality goals</p>



<a name="292330109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292330109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292330109">(Aug 07 2022 at 17:26)</a>:</h4>
<p>Hmm, interesting.</p>



<a name="292330131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292330131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292330131">(Aug 07 2022 at 17:27)</a>:</h4>
<p>So to summarise, probably the best thing that I can do is make <code>p</code> explicit, so that I can do <code>exact findp_pred (&lt;+: l₂),</code>.</p>
<p>But there's nothing much I can do about <code>library_search</code>, <code>simp</code>, and other automation tactics not being able to use this automatically.</p>



<a name="292330223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292330223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292330223">(Aug 07 2022 at 17:29)</a>:</h4>
<p>And maybe make <code>q</code> explicit too. Although so far I've not found a need to specify it explicitly, because it seems to always be inferred from <code>findp</code>.</p>



<a name="292330230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292330230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292330230">(Aug 07 2022 at 17:29)</a>:</h4>
<p>Yeah, <code>simp</code> is impossible (though of course it will find <code>overlap_prefix</code>), and <code>library_search</code> is unlikely (since <code>exact</code>/<code>apply</code> fails, which is how it finds relevant lemmas -- it really tries to <code>apply</code> the entire library!)</p>



<a name="292330313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292330313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292330313">(Aug 07 2022 at 17:30)</a>:</h4>
<p>The point about <code>q</code> being explicit is that you're not always going to have a goal to unify against -- you might want to create a <code>p (l.findp p q)</code> proof from scratch in the middle of a proof.</p>



<a name="292330410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292330410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292330410">(Aug 07 2022 at 17:33)</a>:</h4>
<p>Oh. Right. I think that makes sense. So I guess I should make both <code>p</code> and <code>q</code> explicit in <code>findp_mem</code> too, right?</p>



<a name="292330464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292330464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292330464">(Aug 07 2022 at 17:34)</a>:</h4>
<p>Yeah when I first realised how much of a blunt instrument <code>library_search</code> is that caught me by surprise! Surely there's some better way of indexing for that, but I've not given it any thought and the people who build it know far more about it than I do!</p>



<a name="292330560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292330560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292330560">(Aug 07 2022 at 17:37)</a>:</h4>
<p>It turned out that anything you could write in Lean that could speed it up only slowed it down because then less was being done by the stuff written in C++</p>



<a name="292330718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292330718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292330718">(Aug 07 2022 at 17:40)</a>:</h4>
<p>Somehow <code>findp_mem</code> doesn't lead the unifier down a bad path, so you might get away with just <code>q</code> explicit. I'd say, though, that you should make your decisions based on pain points in whatever you're writing. Choosing which arguments work well implicit seems to be an art, and there are no hard rules.</p>



<a name="292330822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292330822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292330822">(Aug 07 2022 at 17:43)</a>:</h4>
<p>A good rule of thumb is that it's safe to start out making sure every implicit argument can be inferred from the explicit arguments.</p>
<p>But this rule doesn't always hold! <a href="https://leanprover-community.github.io/mathlib_docs/find/inhabited.default">docs#inhabited.default</a> uses the return type to infer its implicit argument, and that tends to work fine. But it's not trying to infer an applied function, like in your <code>findp_pred</code>, which is more difficult for Lean.</p>



<a name="292330980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292330980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292330980">(Aug 07 2022 at 17:47)</a>:</h4>
<p>Well for learning purposes, I've been trying to develop <code>findp</code> to a standard that could be included in mathlib, so it's hard to know what other people's pain points would be. For now, I'm tempted to make it explicit in <code>findp_mem</code> too simply for symmetry with <code>findp_pred</code>, but that's probably not a smart way to decide.</p>



<a name="292331037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292331037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292331037">(Aug 07 2022 at 17:48)</a>:</h4>
<p>Out of interest, do you think <code>findp</code> would be a useful addition to mathlib? I've (mostly) found it easier to use than dealing with the <code>option</code> result when proving things about <code>find</code>, but I'm a clueless newb so I don't know about others.</p>



<a name="292331529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292331529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292331529">(Aug 07 2022 at 17:59)</a>:</h4>
<blockquote>
<p>Well for learning purposes, I've been trying to develop findp to a standard that could be included in mathlib</p>
</blockquote>
<p>I think I'm telling you how mathlib standards come to be -- usually it's good if you have a project you're working on where these definitions and lemmas are used, you see what works and doesn't about them, they get refined through that experience, and then you contribute them to mathlib once they've proved to be useful (and then they get refined even more during code review). It's hard (or impossible) to know the right design ahead of time, and with experience you get more lucky.</p>



<a name="292331719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292331719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292331719">(Aug 07 2022 at 18:03)</a>:</h4>
<p><code>findp</code> seems like it could be useful -- I haven't done much with <code>list.find</code> or <code>&lt;+:</code> though, so I can't say for sure.</p>
<p>I'm surprised there's not already a <code>containsp</code>...</p>



<a name="292331781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292331781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292331781">(Aug 07 2022 at 18:04)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.any">docs#list.any</a> is close</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">list.containsp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="n">l.any</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>



<a name="292331874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292331874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292331874">(Aug 07 2022 at 18:06)</a>:</h4>
<p>Yes, there was some reason that I didn't use <code>any</code>, but I can't remember what it was so I should probably revisit that!</p>



<a name="292331906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292331906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292331906">(Aug 07 2022 at 18:08)</a>:</h4>
<p>Isn't it just <code>l.any p</code>? I think <code>a  ∈ l</code> is implicitly true.</p>



<a name="292332051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292332051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292332051">(Aug 07 2022 at 18:10)</a>:</h4>
<p>There was something about it handling <code>bool</code> instead of <code>Prop</code> that I decided was awkward for some reason, but that decision was made after midnight and I'm not sure what it was based on.</p>



<a name="292332145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292332145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292332145">(Aug 07 2022 at 18:13)</a>:</h4>
<p>I'm not sure what the right thing to do is -- a lot of times it seems like it's better to stay in the Prop world and use decidable instances -- so having a function like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">list.any'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">l.any</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>
<p>can be useful. But then you need to add an instance that this is decidable, so it's a lot of boilerplate.</p>



<a name="292332241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292332241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292332241">(Aug 07 2022 at 18:15)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list</span>
<span class="kn">import</span> <span class="n">data.bool.all_any</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="c1">-- There exists some item that is in the list and matches a predicate.</span>
<span class="kd">def</span> <span class="n">list.containsp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">a</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l.containsp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">l.any</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">list.any_iff_exists</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">list.containsp</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="292332476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292332476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292332476">(Aug 07 2022 at 18:20)</a>:</h4>
<p>Hmm. I don't think I fully understand the naming scheme with the apostrophe. Is there a good reason the <code>Prop</code> version of <code>any</code> would be called <code>any'</code>, or is it just a hacky way of doing an overload?</p>



<a name="292332579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292332579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292332579">(Aug 07 2022 at 18:23)</a>:</h4>
<p>Apostrophes are occasionally used to give alternative definitions/lemmas in mathlib, but I'm not following any scheme here really. It's just meant to be a <a href="https://en.wikipedia.org/wiki/Prime_(symbol)">prime symbol</a></p>



<a name="292332637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Confusing%20issue%20with%20exact/near/292332637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Confusing.20issue.20with.20exact.html#292332637">(Aug 07 2022 at 18:24)</a>:</h4>
<p>Cool. For some reason, I'd assumed that the apostrophe versions were for internal use and should generally be avoided, so good to know it's just an alternative.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
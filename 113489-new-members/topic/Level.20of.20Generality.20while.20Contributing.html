---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html">Level of Generality while Contributing</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="276545887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276545887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276545887">(Mar 24 2022 at 22:08)</a>:</h4>
<p>Hi there, I had a question relating to contributing to mathlib as a newer mathematician. </p>
<p>The other week I was working with even/odd functions, and I found that the definitions I was familiar with were not in mathlib.</p>
<p>I created some simple definitions that work for what I want to do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">even_fun</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">odd_fun</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>But when I asked about it on zulip, it looks like if I wanted to contribute to mathlib, I would need the most generalized version of it:</p>
<p><span class="user-mention silent" data-user-id="197836">Jireh Loreaux</span> <a href="#narrow/stream/113489-new-members/topic/even.2Fodd.20functions/near/273317780">said</a>:</p>
<blockquote>
<p>I haven't seen it (which doesn't mean it isn't there!), but if we did have it, then the appropriate level of generality would be something like an involutive linear map on a vector space over a field of characteristic different from 2. Any such map decomposes the vector space into a fixed part, and an anti-fixed part. For even functions (the fixed part) the involution is (lambda x, f x) -&gt; (lambda x, f -x). (Sorry, on mobile)</p>
</blockquote>
<p>As of right now, I'm not quite sure how to implement that definition, but I do have this definition that works for my needs. </p>
<p>I am curious about the standpoint of having specialized versions of theorems in mathlib, like my basic ones I've defined</p>
<p>To me it makes sense to have at least one form of the definition (generalized or not) in mathlib at any point in time so that at least some people can use it (rather than none) and then over time work on getting the most generalized version in.</p>
<p>What do you think?</p>



<a name="276547087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276547087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276547087">(Mar 24 2022 at 22:21)</a>:</h4>
<p>I think another way to say Jireh's suggestion is that even/odd functions correspond to eigenvectors of the domain-reversing involution associated to the eigenvalues 1 and -1. (Though Jireh is explaining, additionally, the even/odd direct sum decomposition.)</p>



<a name="276547384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276547384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276547384">(Mar 24 2022 at 22:24)</a>:</h4>
<p>I'm not sure what the "right" generalization of even/odd should be.  One thing that comes to mind is how the fact it's centered at 0 is arbitrary, so that could be generalized as well -- rather than the involution acting on a vector space, it could also be an involution on an affine space.</p>



<a name="276548598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276548598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276548598">(Mar 24 2022 at 22:41)</a>:</h4>
<p>One formalization:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.eigenspace</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">act</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">module.End</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">is_even</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="bp">∈</span> <span class="n">module.End.eigenspace</span> <span class="o">(</span><span class="n">act</span> <span class="o">(</span><span class="n">has_neg.neg</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">))</span> <span class="mi">1</span>
<span class="kd">def</span> <span class="n">is_odd</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="bp">∈</span> <span class="n">module.End.eigenspace</span> <span class="o">(</span><span class="n">act</span> <span class="o">(</span><span class="n">has_neg.neg</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">))</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">is_even_iff</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">is_even</span> <span class="n">f</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_even</span><span class="o">,</span> <span class="n">module.End.mem_eigenspace_iff</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">congr_fun</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">is_odd_iff</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">is_odd</span> <span class="n">f</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">f</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_odd</span><span class="o">,</span> <span class="n">module.End.mem_eigenspace_iff</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">congr_fun</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276548610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276548610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276548610">(Mar 24 2022 at 22:41)</a>:</h4>
<p>There's probably something somewhere in the library that can replace <code>act</code></p>



<a name="276549455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276549455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276549455">(Mar 24 2022 at 22:51)</a>:</h4>
<p>That said, there's probably no reason to define <code>is_even</code> and <code>is_odd</code> in such a complicated way if you can write lemmas showing a definition is equivalent to the fancy (and "right") definition, so I might go with this (using <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>'s suggestion from the other thread):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.eigenspace</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">def</span> <span class="n">function.is_even</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_neg</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">function.is_odd</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_neg</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_neg</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">f</span> <span class="n">x</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">act</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">module.End</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">is_even_iff</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">function.is_even</span> <span class="n">f</span> <span class="bp">↔</span> <span class="n">f</span> <span class="bp">∈</span> <span class="n">module.End.eigenspace</span> <span class="o">(</span><span class="n">act</span> <span class="o">(</span><span class="n">has_neg.neg</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">))</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">module.End.mem_eigenspace_iff</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">congr_fun</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">is_odd_iff</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">function.is_odd</span> <span class="n">f</span> <span class="bp">↔</span> <span class="n">f</span> <span class="bp">∈</span> <span class="n">module.End.eigenspace</span> <span class="o">(</span><span class="n">act</span> <span class="o">(</span><span class="n">has_neg.neg</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">))</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">module.End.mem_eigenspace_iff</span><span class="o">,</span> <span class="n">neg_smul</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">congr_fun</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276549586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276549586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276549586">(Mar 24 2022 at 22:53)</a>:</h4>
<p>So as a beginner if I find something not included in mathlib, but I'm not aware of the most general definition, would you recommend me to try to PR with that definition?</p>



<a name="276551248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276551248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276551248">(Mar 24 2022 at 23:11)</a>:</h4>
<p>Others can overrule me, but I would do the following: ask on Zulip, "I'm considering implementing concept X using method Y, is this a good approach, or should I attempt it a different way?" Then people can provide input before you PR. That way, when you do PR, you likely won't have to rewrite everything from scratch.</p>
<p>Note: in mathlib, we are at least sometimes willing to wait a long time to have things done the "right" way. Other times, we decide it's important enough to have a given thing that we forgo such considerations. </p>
<p>As for the specific even/odd discussion above, I'll write something up tonight or tomorrow showing the kind of thing I was thinking. </p>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> zero isn't quite as arbitrary when you think of the involution on the vector space of functions as additive group inversion on the domain (of course, yes, you can have other involutions of the domain)</p>



<a name="276551463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276551463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276551463">(Mar 24 2022 at 23:13)</a>:</h4>
<p><span class="user-mention" data-user-id="367659">@Callum Cassidy-Nolan</span> I don't think I can give a blanket recommendation.  You can try asking <a class="stream" data-stream-id="217875" href="/#narrow/stream/217875-Is-there-code-for-X.3F">#Is there code for X?</a> whether something is already in mathlib or if it's close to something already in mathlib, and there's also <a class="stream" data-stream-id="116395" href="/#narrow/stream/116395-maths">#maths</a> to discuss how you might formalize something and to draw up a plan. A problem with just doing a PR is that not everyone is reviewing everything, so it might not get so much attention.</p>
<p>There can also be many ways to generalize something, so it takes gaining some kind of consensus to know if something is "most" general. This is a matter of thinking through the sorts of theorems you're wanting to prove, what sorts of math we're each personally interested in formalizing, what resources (e.g. time) we have to do the formalization, and so on. We don't want to generalize just for the sake of generalization -- if we think no one is going to prove theorems about generalized even/odd functions (or, if they do, it's going to be a long long time from now), then it can be a waste of effort. If you're not careful, you might do the <em>wrong</em> generalization due to lack of foresight (this is a common software engineering problem...)</p>



<a name="276551743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276551743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276551743">(Mar 24 2022 at 23:17)</a>:</h4>
<p><span class="user-mention" data-user-id="197836">@Jireh Loreaux</span> I get that the domain is a vector space and that even/odd corresponds to the isotypic components of representation of the group generated by <code>has_neg.neg</code> acting on the domain (and I do like this generalization). My question is whether this is the "right" generalization, given the theory what might be in the theory of even/odd functions.</p>



<a name="276551772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276551772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276551772">(Mar 24 2022 at 23:17)</a>:</h4>
<p>Like if you're considering power series representations of functions centered at different points, you probably want to generalize even/odd to this situation.</p>



<a name="276551911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276551911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276551911">(Mar 24 2022 at 23:19)</a>:</h4>
<p>(But that would also be more complicated, since I guess you want more of a pseudogroup acting on the domain to deal with the radius of convergence.)</p>



<a name="276551915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276551915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276551915">(Mar 24 2022 at 23:19)</a>:</h4>
<p>By the way, the reason I was thinking about this generalization is that it occurs all over:</p>
<ol>
<li>Complex numbers with conjugation as real-linear involution -&gt; real and imaginary parts.</li>
<li>Square matrices with transpose -&gt; symmetric and skew-symmetric parts.</li>
<li>Yes, power series</li>
<li>Adjoint operation in *-Algebras</li>
<li>Even and odd functions</li>
</ol>



<a name="276551965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276551965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276551965">(Mar 24 2022 at 23:19)</a>:</h4>
<p>I never required objects to be functions in my original proposal.</p>



<a name="276552055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276552055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276552055">(Mar 24 2022 at 23:20)</a>:</h4>
<p>For power series you could just work with formal multilinear series and ignore convergence</p>



<a name="276552168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276552168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276552168">(Mar 24 2022 at 23:22)</a>:</h4>
<p>Oh, I misread part of your proposal: I thought you were talking about, essentially, taking a representation V of a group then considering Hom(V, W) for some reason.</p>



<a name="276552199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276552199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276552199">(Mar 24 2022 at 23:22)</a>:</h4>
<p>This generality is why I considered it to be the right generalization, but of course I'm open to other ideas.</p>



<a name="276552288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276552288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276552288">(Mar 24 2022 at 23:23)</a>:</h4>
<p>Regarding the generalization you're talking about, would you want to do anything other than studying <code>module.End.eigenspace T 1</code> and <code>module.End.eigenspace T (-1)</code> for some involution <code>T</code>?</p>



<a name="276552714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276552714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276552714">(Mar 24 2022 at 23:27)</a>:</h4>
<p>I hadn't thought about it that much (other than this is one of my pet problems to give to linear algebra students and then show them how to occurs everywhere). </p>
<p>Basically all I was thinking is that if we are going to do this at all, then it probably makes sense to have a uniform definition and API. Just plug in a linear involution, get out the relevant fixed and anti-fixed submodules and the decomposition.</p>



<a name="276552793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276552793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276552793">(Mar 24 2022 at 23:28)</a>:</h4>
<p>That being said, if we think it's not worth the effort that's fine too.</p>



<a name="276552942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276552942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276552942">(Mar 24 2022 at 23:30)</a>:</h4>
<p>I think it's worth the effort to flesh all that out. I just think that, except for all the surrounding theory and the decomposition in char-not-2 (including projections), we sort of already have it.</p>



<a name="276689504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276689504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276689504">(Mar 25 2022 at 22:57)</a>:</h4>
<p>This is basically the kind of thing I was thinking. The names might be improved, and of course for fields with characteristic different from 2 we could prove more specialized stuff.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Copyright (c) 2022 Jireh Loreaux. All rights reserved.</span>
<span class="cm">Released under Apache 2.0 license as described in the file LICENSE.</span>
<span class="cm">Authors: Jireh Loreaux</span>
<span class="cm">-/</span>
<span class="kn">import</span> <span class="n">linear_algebra.eigenspace</span>
<span class="kn">import</span> <span class="n">algebra.direct_sum.module</span>

<span class="c">/-</span><span class="cm">! # Linear involution decomposition</span>

<span class="cm">Throughout mathematics a certain phenomenon can be observed which amounts to the decomoposition of</span>
<span class="cm">some module into two pieces, one of which is fixed by a given operation and the other of which is</span>
<span class="cm">anti-fixed. As examples:</span>

<span class="cm">1. The decomposition of `z : ℂ` into `z = z.re + I * z.im` with the operation of `conj`.</span>
<span class="cm">2. The decomposition of a matrix into its symmetric and skew-symmetric parts with the transpose</span>
<span class="cm">  operation.</span>
<span class="cm">3. The decomposition of an operator into its selfadjoint and skew-selfadjoint parts, with the</span>
<span class="cm">  adjoint operation.</span>
<span class="cm">4. The decomposition of a real-valued function into its even and odd parts, with the operation</span>
<span class="cm">  given by `λ f : ℝ → ℝ, λ x, f (-x)`.</span>
<span class="cm">5. The decomposition of a polynomial into its even and odd parts.begin</span>
<span class="cm">6. The decomposition of complex-valued measures into their real and imaginary parts.</span>

<span class="cm">All of these are unified by a common thread. There is a linear involution acting on the module.</span>
<span class="cm">Here we ellucidate that role.</span>
<span class="cm">-/</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">lin_inv</span> <span class="o">:</span> <span class="n">module.End</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">linear_involution</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="kn">local</span> <span class="kd">postfix</span> <span class="bp">`†`</span><span class="o">:</span><span class="n">std.prec.max_plus</span> <span class="o">:=</span> <span class="n">lin_inv</span>

<span class="kd">def</span> <span class="n">fixed</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">lin_inv.eigenspace</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">anti_fixed</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">lin_inv.eigenspace</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">lin_inv</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">mem_fixed_def</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">fixed</span> <span class="n">lin_inv</span> <span class="bp">↔</span> <span class="n">m</span><span class="bp">†</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">•</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">module.End.mem_eigenspace_iff</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">mem_fixed_iff</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">fixed</span> <span class="n">lin_inv</span> <span class="bp">↔</span> <span class="n">m</span><span class="bp">†</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">mem_fixed_def</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">one_smul</span> <span class="n">R</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">mem_anti_fixed_def</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">anti_fixed</span> <span class="n">lin_inv</span> <span class="bp">↔</span> <span class="n">m</span><span class="bp">†</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">•</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">module.End.mem_eigenspace_iff</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">mem_anti_fixed_iff</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">anti_fixed</span> <span class="n">lin_inv</span> <span class="bp">↔</span> <span class="n">m</span><span class="bp">†</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">m</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">mem_anti_fixed_def</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">neg_smul</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">add_lin_inv_self_fixed</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">involutive</span> <span class="n">lin_inv</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">m</span> <span class="bp">+</span> <span class="n">m</span><span class="bp">†</span> <span class="bp">∈</span> <span class="n">fixed</span> <span class="n">lin_inv</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h.right_inverse</span> <span class="n">m</span><span class="o">,</span> <span class="n">add_comm</span> <span class="n">m</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">sub_lin_inv_self_anti_fixed</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">involutive</span> <span class="n">lin_inv</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">m</span> <span class="bp">-</span> <span class="n">m</span><span class="bp">†</span> <span class="bp">∈</span> <span class="n">anti_fixed</span> <span class="n">lin_inv</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h.right_inverse</span> <span class="n">m</span><span class="o">,</span> <span class="n">add_comm</span> <span class="n">m</span><span class="o">]</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">lin_inv</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">fixed_anti_fixed_pair</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">fixed</span> <span class="n">lin_inv</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">anti_fixed</span> <span class="n">lin_inv</span>

<span class="kn">open</span> <span class="n">submodule</span>

<span class="kd">lemma</span> <span class="n">fixed_anti_fixed_sum</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">))</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">h₂.unit</span><span class="bp">⁻¹</span> <span class="bp">•</span> <span class="n">m</span> <span class="bp">+</span> <span class="o">(</span><span class="n">h₂.unit</span><span class="bp">⁻¹</span> <span class="bp">•</span> <span class="n">m</span><span class="o">)</span><span class="bp">†</span> <span class="bp">+</span> <span class="o">(</span><span class="n">h₂.unit</span><span class="bp">⁻¹</span> <span class="bp">•</span> <span class="n">m</span> <span class="bp">-</span> <span class="o">(</span><span class="n">h₂.unit</span><span class="bp">⁻¹</span> <span class="bp">•</span> <span class="n">m</span><span class="o">)</span><span class="bp">†</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">units.smul_def</span><span class="o">,</span> <span class="n">add_add_sub_cancel</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">smul_add</span><span class="o">,</span> <span class="bp">←</span><span class="n">two_smul</span> <span class="n">R</span> <span class="n">m</span><span class="o">,</span> <span class="n">smul_smul</span><span class="o">,</span> <span class="n">h₂.coe_inv_mul</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">lin_inv</span><span class="o">}</span>
<span class="kd">lemma</span> <span class="n">sup_fixed_anti_fixed</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">involutive</span> <span class="n">lin_inv</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">fixed</span> <span class="n">lin_inv</span><span class="o">)</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">anti_fixed</span> <span class="n">lin_inv</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span>
<span class="n">eq_top_iff'.mpr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">mem_sup.mpr</span>
  <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">add_lin_inv_self_fixed</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span>
   <span class="n">_</span><span class="o">,</span> <span class="n">sub_lin_inv_self_anti_fixed</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span>
   <span class="n">fixed_anti_fixed_sum</span> <span class="n">lin_inv</span> <span class="n">h₂</span> <span class="n">m</span><span class="o">⟩)</span>

<span class="kd">lemma</span> <span class="n">zero_of_fixed_of_anti_fixed</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">))</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hm₁</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">fixed</span> <span class="n">lin_inv</span><span class="o">)</span> <span class="o">(</span><span class="n">hm₂</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">anti_fixed</span> <span class="n">lin_inv</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_fixed_iff</span><span class="o">,</span> <span class="n">mem_anti_fixed_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">hm₁</span> <span class="n">hm₂</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hm₃</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">two_smul</span><span class="o">],</span> <span class="n">nth_rewrite</span> <span class="mi">1</span> <span class="bp">←</span><span class="n">hm₁</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hm₂</span><span class="o">,</span> <span class="n">add_neg_self</span><span class="o">]</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="bp">↑</span><span class="n">h₂.unit</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">•</span> <span class="o">((</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">•</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">↑</span><span class="n">h₂.unit</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">•</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">congr_arg2</span> <span class="n">_</span> <span class="n">rfl</span> <span class="n">hm₃</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">smul_smul</span><span class="o">,</span> <span class="n">h₂.coe_inv_mul</span><span class="o">]</span> <span class="n">using</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">inf_fixed_anti_fixed</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">involutive</span> <span class="n">lin_inv</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">fixed</span> <span class="n">lin_inv</span><span class="o">)</span> <span class="bp">⊓</span> <span class="o">(</span><span class="n">anti_fixed</span> <span class="n">lin_inv</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">submodule.eq_bot_iff</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span> <span class="n">zero_of_fixed_of_anti_fixed</span> <span class="n">h₂</span> <span class="o">(</span><span class="n">mem_inf.mp</span> <span class="n">hm</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">mem_inf.mp</span> <span class="n">hm</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">linear_involution</span>
</code></pre></div>



<a name="276689715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Level%20of%20Generality%20while%20Contributing/near/276689715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Level.20of.20Generality.20while.20Contributing.html#276689715">(Mar 25 2022 at 23:00)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>, see above.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
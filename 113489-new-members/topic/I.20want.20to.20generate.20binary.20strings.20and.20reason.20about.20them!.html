---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html">I want to generate binary strings and reason about them!</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="223024072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223024072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223024072">(Jan 17 2021 at 04:40)</a>:</h4>
<p>A couple of questions:<br>
1/ This is how I generate binary strings of length n.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">data.list.range</span>

<span class="kn">open</span> <span class="n">list</span>

<span class="kd">def</span> <span class="n">strings</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">[[]]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">((</span><span class="n">strings</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">string</span><span class="o">,</span> <span class="o">[</span><span class="n">string</span> <span class="bp">++</span> <span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">string</span> <span class="bp">++</span> <span class="o">[</span><span class="mi">1</span><span class="o">]]))</span><span class="bp">.</span><span class="n">join</span>

<span class="k">#eval</span> <span class="n">strings</span> <span class="mi">3</span>
</code></pre></div>
<p>But it takes forever for this code to generate strings of length 20 (and it happens to gobble up my RAM too, <span aria-label="sob" class="emoji emoji-1f62d" role="img" title="sob">:sob:</span>) even though this C++ can generate strings perfectly fine:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mask</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">);</span> <span class="n">mask</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>How can I optimize the Lean code?<br>
2/ How do I generate binary strings of length n (again) that are lexicographically less than or equal to a certain binary string (also of length n)? Should I just kind of 'filter' the binary strings? Or are there more elegant approaches?</p>



<a name="223024094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223024094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223024094">(Jan 17 2021 at 04:41)</a>:</h4>
<p>As usual, thanks in advance!</p>



<a name="223024197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223024197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223024197">(Jan 17 2021 at 04:44)</a>:</h4>
<p>Is it important that they are actually strings? Mathlib has some code on bitvectors: <a href="https://leanprover-community.github.io/mathlib_docs/data/bitvec/core.html">https://leanprover-community.github.io/mathlib_docs/data/bitvec/core.html</a></p>



<a name="223024211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223024211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223024211">(Jan 17 2021 at 04:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!/near/223024197">said</a>:</p>
<blockquote>
<p>Is it important that they are actually strings? Mathlib has some code on bitvectors: <a href="https://leanprover-community.github.io/mathlib_docs/data/bitvec/core.html">https://leanprover-community.github.io/mathlib_docs/data/bitvec/core.html</a></p>
</blockquote>
<p>No, they can be bitvectors. I didn't know that mathlib has bitvectors.</p>



<a name="223024670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223024670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223024670">(Jan 17 2021 at 04:58)</a>:</h4>
<p>First of all, your code isn't tail call optimized (does Lean have TCO?). Additionally, appending to the end of a list is O(N). If you're constructing the lists, either place in the front (using cons), or use a different data structure</p>



<a name="223024759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223024759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223024759">(Jan 17 2021 at 05:01)</a>:</h4>
<blockquote>
<p>does Lean have TCO?</p>
</blockquote>
<p>No, but it doesn't hurt to pretend that it did</p>



<a name="223024854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223024854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223024854">(Jan 17 2021 at 05:03)</a>:</h4>
<p>Regarding optimizing this, it depends on what you want to generate the strings for. It's probably a bad idea to construct a list of all exponentially-many strings lexicographically less than a given string, you want some more implicit representation that generates the strings on demand</p>



<a name="223024894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223024894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223024894">(Jan 17 2021 at 05:04)</a>:</h4>
<p>A cheat to construct the lists would be some combination on list.range with nat.digits with a base of 2.</p>



<a name="223024897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223024897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223024897">(Jan 17 2021 at 05:04)</a>:</h4>
<p>That said, your <code>strings</code> function isn't bad if the point is to have a reference implementation that the efficient one is refining</p>



<a name="223024968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223024968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223024968">(Jan 17 2021 at 05:06)</a>:</h4>
<p>it's important to distinguish "program you can easily reason about" from "program that runs fast". Although lean programs can to some extent satisfy both criteria they pull in opposite directions and it's usually best to keep them separate</p>



<a name="223025432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223025432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223025432">(Jan 17 2021 at 05:22)</a>:</h4>
<p>For <code>strings</code>, assuming you want that exact type signature (which in particular implies that you have to construct the entire list of lists in memory before printing it, unlike the C++ version), I would suggest:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">selections_aux</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">[]</span> <span class="o">::</span> <span class="n">r</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">l.foldr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">selections_aux</span> <span class="n">n</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">list.cons</span> <span class="n">a</span><span class="o">))</span> <span class="n">r</span>

<span class="kd">def</span> <span class="n">selections</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">selections_aux</span> <span class="n">l</span> <span class="n">n</span> <span class="n">id</span> <span class="o">[]</span>

<span class="k">#eval</span> <span class="n">selections</span> <span class="mi">3</span> <span class="o">[</span><span class="n">ff</span><span class="o">,</span> <span class="n">tt</span><span class="o">]</span>
</code></pre></div>



<a name="223025707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223025707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223025707">(Jan 17 2021 at 05:30)</a>:</h4>
<p>and you can use that as the basis for a program to compute those less than a given binary string:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">below_aux</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">t</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">[]</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">[]</span> <span class="c1">-- impossible</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">ff</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">below_aux</span> <span class="n">n</span> <span class="n">t</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">list.cons</span> <span class="n">ff</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">tt</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span>
  <span class="n">selections_aux</span> <span class="o">[</span><span class="n">ff</span><span class="o">,</span> <span class="n">tt</span><span class="o">]</span> <span class="n">n</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">list.cons</span> <span class="n">ff</span><span class="o">)</span> <span class="bp">$</span>
  <span class="n">below_aux</span> <span class="n">n</span> <span class="n">t</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">list.cons</span> <span class="n">tt</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">below</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span> <span class="n">below_aux</span> <span class="n">l.length</span> <span class="n">l</span> <span class="n">id</span>

<span class="k">#eval</span> <span class="n">below</span> <span class="o">[</span><span class="n">tt</span><span class="o">,</span> <span class="n">tt</span><span class="o">,</span> <span class="n">ff</span><span class="o">]</span>
</code></pre></div>



<a name="223034387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223034387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223034387">(Jan 17 2021 at 09:36)</a>:</h4>
<p>So this function composition trick is a way to append to a linked list in O(1) right? Or am I missing something?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">iota</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="o">(</span><span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">id</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">iota</span> <span class="n">n</span> <span class="bp">∘</span> <span class="n">list.cons</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="223034538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223034538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223034538">(Jan 17 2021 at 09:41)</a>:</h4>
<p>So it seems that in the <code>(list ℕ → list ℕ)</code> encoding, the identity function is the empty list and <code>list.cons some_value</code> is a list with one element.</p>



<a name="223034600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223034600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223034600">(Jan 17 2021 at 09:42)</a>:</h4>
<p>Indeed. In fact, we have a type for this encoding, called <code>dlist</code></p>



<a name="223034604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223034604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223034604">(Jan 17 2021 at 09:43)</a>:</h4>
<p>it's a technique cribbed from haskell</p>



<a name="223034657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223034657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223034657">(Jan 17 2021 at 09:44)</a>:</h4>
<p>The version just above is a slightly more advanced version of the trick where we have built both mapping and appending into the recursive function</p>



<a name="223034715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223034715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223034715">(Jan 17 2021 at 09:46)</a>:</h4>
<p>The usual way you would prove theorems about that function is to prove that <code>selections_aux n l f r = map f (selections_aux n l id []) ++ r</code>, so that you only have to worry about the case where the last two parameters are <code>id</code> and <code>[]</code></p>



<a name="223034728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223034728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223034728">(Jan 17 2021 at 09:47)</a>:</h4>
<p>take a look at <a href="https://leanprover-community.github.io/mathlib_docs/find/list.sublists'_aux_eq_sublists'">docs#list.sublists'_aux_eq_sublists'</a> for example</p>



<a name="223045570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223045570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223045570">(Jan 17 2021 at 14:36)</a>:</h4>
<p>After hours of poring over documentation I still couldn't understand how your code works. I have absolutely no functional programming experience. If you or someone else could explain both the <code>selections</code> and the <code>below</code> function I would really appreciate it.</p>



<a name="223063957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223063957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223063957">(Jan 17 2021 at 21:25)</a>:</h4>
<p><span class="user-mention" data-user-id="270523">@Huỳnh Trần Khanh</span> a nice property of purely functional programming languages like lean is that you can substitute a name for the thing it's defined as. sounds very reasonable if you are a mathematician, but this is crazy talk in C++</p>



<a name="223064034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064034">(Jan 17 2021 at 21:26)</a>:</h4>
<p>eg if i have the C++ program <code>int x = 0; int c = ++x, return c + c;</code> i can't just inline the definition of <code>c</code> --- <code>int x = 0; return ++x + ++x</code> is a very differnet program</p>



<a name="223064074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064074">(Jan 17 2021 at 21:27)</a>:</h4>
<p>my point being that a great way to understand functional programs is to just substitute definitions to get a feeling for how the execution of a program works</p>



<a name="223064158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064158">(Jan 17 2021 at 21:28)</a>:</h4>
<p>when you don't have variable mutation (like in lean), a common trick is to define a new <code>_aux</code> function that takes the current-state of your variables as arguments</p>



<a name="223064193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064193">(Jan 17 2021 at 21:29)</a>:</h4>
<p>that function is usually recursive, and by changing the arguments you call yourself with, you emulate statefully mutating your variables</p>



<a name="223064257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064257">(Jan 17 2021 at 21:30)</a>:</h4>
<p>so <code>selections</code> above is the entry point, which calls <code>selections_aux</code> with the initial values of its arguments</p>



<a name="223064287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064287">(Jan 17 2021 at 21:31)</a>:</h4>
<p>that is to say, <code>selections</code> is just a convenience function for calling <code>selections_aux</code>, so it suffices to understand the latter</p>



<a name="223064322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064322">(Jan 17 2021 at 21:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">selections_aux</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">[]</span> <span class="o">::</span> <span class="n">r</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">l.foldr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">selections_aux</span> <span class="n">n</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">list.cons</span> <span class="n">a</span><span class="o">))</span> <span class="n">r</span>
</code></pre></div>
<p>here we are pattern matching on the last three arguments of the function</p>



<a name="223064391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064391">(Jan 17 2021 at 21:32)</a>:</h4>
<p>the <code>| 0     f r :=</code> syntax denotes a pattern match, which is sorta like a C++ case statement on steroids</p>



<a name="223064429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064429">(Jan 17 2021 at 21:33)</a>:</h4>
<p>since the type of the function is <code>:  ℕ → (list α → β) → list β → list β</code>, that means there are three arguments of types:  <br>
1) <code>ℕ</code> <br>
2) a function <code>(list α → β)</code> -- taking a list of alphas and returning a beta <br>
3) <code>list β</code> </p>
<p>and then this function finally returns a <code>list β</code></p>



<a name="223064513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064513">(Jan 17 2021 at 21:34)</a>:</h4>
<p>with this in mind, we return to <code>| 0     f r := ...</code>, which does the <code>...</code> ONLY when the <code>ℕ</code> argument is <code>0</code></p>



<a name="223064536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064536">(Jan 17 2021 at 21:35)</a>:</h4>
<p>and it binds the <code>(list α → β)</code> parameter to the name <code>f</code>, likewise the <code>list β</code> to <code>r</code></p>



<a name="223064593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064593">(Jan 17 2021 at 21:36)</a>:</h4>
<p>after the <code>:=</code> comes the return value. it needs to be of type <code>list β</code></p>



<a name="223064611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064611">(Jan 17 2021 at 21:36)</a>:</h4>
<p><code>f []</code> is a function call to <code>f</code> with an empty list, and <code>::</code> puts an element at the begining of a list.</p>



<a name="223064619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064619">(Jan 17 2021 at 21:37)</a>:</h4>
<p>so this expression inserts <code>f []</code> at the beginning of <code>r</code></p>



<a name="223064653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064653">(Jan 17 2021 at 21:37)</a>:</h4>
<p>it's not immediately clear to me what's happening here, so let's look at the next pattern match</p>



<a name="223064706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064706">(Jan 17 2021 at 21:38)</a>:</h4>
<p>patterns are tried from top to bottom, so  <code>| (n+1) f r :</code> is tried only when the <code>ℕ</code> is NOT zero (otherwise the first case would have run already)</p>



<a name="223064719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064719">(Jan 17 2021 at 21:38)</a>:</h4>
<p>it binds the same <code>f</code> and <code>r</code> parameters, but additionally now binds <code>n</code> to be one less than the <code>ℕ</code> argument</p>



<a name="223064730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064730">(Jan 17 2021 at 21:39)</a>:</h4>
<p>(why? because it's saying that <code>n + 1</code> is the argument that was passed, so <code>n</code> is one less than that)</p>



<a name="223064755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064755">(Jan 17 2021 at 21:39)</a>:</h4>
<p>let's ignore the <code>foldr</code> bit for a second, and look at the recursive call. <code>selections_aux n (f ∘ list.cons a)</code></p>



<a name="223064821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064821">(Jan 17 2021 at 21:40)</a>:</h4>
<p>notice that we're calling <code>selections_aux</code> with <code>n</code> --- that is, one less than the argument we started with</p>



<a name="223064855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064855">(Jan 17 2021 at 21:41)</a>:</h4>
<p>as such you can sort of reimagine the execution of this function as a while loop of the form</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">while</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="bp">//</span> <span class="k">do</span> <span class="n">something</span>
  <span class="n">n</span> <span class="c1">--;</span>
<span class="o">}</span>
</code></pre></div>



<a name="223064949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064949">(Jan 17 2021 at 21:42)</a>:</h4>
<p>sorry to leave you hanging here, but i need to run</p>



<a name="223064963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064963">(Jan 17 2021 at 21:43)</a>:</h4>
<p>one last thing to point out before i do is that not only is <code>n</code> getting smaller in this loop</p>



<a name="223064970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064970">(Jan 17 2021 at 21:43)</a>:</h4>
<p>but also <code>f</code> is being expanded to <code>(f ∘ list.cons a)</code></p>



<a name="223064984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223064984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223064984">(Jan 17 2021 at 21:43)</a>:</h4>
<p>so in our mock C program:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">while</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="bp">//</span> <span class="k">do</span> <span class="n">something</span>
  <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">list.cons</span> <span class="n">a</span><span class="bp">;</span>
  <span class="n">n</span> <span class="c1">--;</span>
<span class="o">}</span>
</code></pre></div>



<a name="223065069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223065069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223065069">(Jan 17 2021 at 21:45)</a>:</h4>
<p>(this isn't exactly true due to the <code>foldr</code>, but it's a good mental approximation of the recursive transformation)</p>



<a name="223065135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223065135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223065135">(Jan 17 2021 at 21:46)</a>:</h4>
<p>happy to help dig through this furrther with you later</p>



<a name="223065382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223065382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sandy Maguire <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223065382">(Jan 17 2021 at 21:52)</a>:</h4>
<p>you got thrown a doozy for your first glimpse at functional programming!</p>



<a name="223076629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223076629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223076629">(Jan 18 2021 at 02:54)</a>:</h4>
<p>Okay, so here's the idea behind <code>selections</code>. The goal, slightly generalized from your original statement of producing all binary strings of length n, is to produce a list of all lists of length n consisting of the elements of the input list. These are going to have the first element of the list varying the most slowly, and the last element of the list varies on each consecutive item. So for example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">selections</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">2</span> <span class="bp">=</span> <span class="o">[[</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">],</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">],</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">],</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">],</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">],</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">],</span> <span class="o">[</span><span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="o">],</span> <span class="o">[</span><span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">],</span> <span class="o">[</span><span class="n">c</span><span class="o">,</span> <span class="n">c</span><span class="o">]]</span>
</code></pre></div>
<p>The key to computing this is to first figure out a recursive formula for doing so. The n=0 case is just <code>[[]]</code>, that is, there is one string and it has length 0, and (n+1) long string is obtained by appending <code>a</code> to each element of the list, and concatenating it with adding <code>b</code>, and so on, like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">selections</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">2</span> <span class="bp">=</span>
  <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">selections</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">++</span>
  <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">b</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">selections</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">++</span>
  <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">selections</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">++</span> <span class="o">[]</span>
</code></pre></div>
<p>We can write this directly as a definition, it's a bit simpler than the one I gave:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">selections'</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="o">[[]]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list.join</span> <span class="bp">$</span> <span class="n">l.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">list.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">selections'</span> <span class="n">n</span><span class="o">))</span>

<span class="k">#eval</span> <span class="n">selections'</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="mi">2</span>
<span class="c1">-- [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]</span>
</code></pre></div>
<p>This version is also correct, and you can check that it has the same behavior as <code>selections</code>. Just to go over the recursive case here a bit, we can write the append of a bunch of lists <code>l1 ++ l2 ++ l3 ++ []</code> as <code>list.join [l1, l2, l3]</code>, and each list is like <code>map (λ x, a::x) (selections [a,b,c] 1)</code> that I mentioned before (The <code>[a,b,c]</code> part is omitted in lean because it's a parameter in the recursion).</p>



<a name="223077229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223077229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223077229">(Jan 18 2021 at 03:11)</a>:</h4>
<p>However, this method of producing lists is inefficient, because in each step of the recursion we are constructing a bunch of lists, mapping over them (which involves making a new copy of each list), and then appending them (which involves making a bunch of intermediate lists). So we're going to be allocating new lists many times before we're done. The key observation here is that each recursive call to <code>selections</code> is in a context of a map and an append, so if we had a function <code>selections_aux l a f r</code> that was defined as <code>map f (selections l a) ++ r</code>, then we could express the recursive case from before as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">selections</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">2</span> <span class="bp">=</span>
  <span class="n">selections_aux</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="bp">$</span>
  <span class="n">selections_aux</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">b</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="bp">$</span>
  <span class="n">selections_aux</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">[]</span>
</code></pre></div>
<p>The neat thing about mapping and appending is that both of these are associative in the sense that a map of a map is a map and an append of an append is an append, so we can generalize this equation to if we also had to map more things:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">selections</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">++</span> <span class="n">r</span> <span class="bp">=</span>
  <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">selections</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">++</span>
  <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">b</span><span class="o">::</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">selections</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">++</span>
  <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">selections</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">++</span> <span class="n">r</span>
</code></pre></div>
<p>so that if we write this with <code>selections_aux</code>, we get</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">selections_aux</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">2</span> <span class="n">f</span> <span class="n">r</span> <span class="bp">=</span>
  <span class="n">selections_aux</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">x</span><span class="o">))</span> <span class="bp">$</span>
  <span class="n">selections_aux</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">b</span><span class="o">::</span><span class="n">x</span><span class="o">))</span> <span class="bp">$</span>
  <span class="n">selections_aux</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">))</span> <span class="n">r</span>
</code></pre></div>
<p>which is a proper recursive equation for <code>selections_aux</code>.</p>
<p>Since we aren't appending lists directly anymore, we can't use <code>list.join</code> as before; we actually want to use <code>list.foldr</code> here, which does the operation</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span><span class="bp">.</span><span class="n">foldr</span> <span class="n">g</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">a</span> <span class="o">(</span><span class="n">g</span> <span class="n">b</span> <span class="o">(</span><span class="n">g</span> <span class="n">c</span> <span class="n">r</span><span class="o">))</span>
</code></pre></div>
<p>We have to provide a function <code>g</code> which will be applied with the arguments <code>a</code>, <code>b</code>, <code>c</code> in turn and the result from the remainder of the list, which is the same structure as above. So rewriting our example equation one more time we get</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">selections_aux</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">2</span> <span class="n">f</span> <span class="n">r</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span><span class="bp">.</span><span class="n">foldr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">selections_aux</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">y</span><span class="o">::</span><span class="n">x</span><span class="o">)))</span> <span class="n">r</span>
</code></pre></div>
<p>and now if we just generalize <code>[a,b,c]</code> and <code>1</code> in this equation we get the actual recursive equation for <code>selections_aux</code>.</p>
<p>The base case was previously <code>selections 0 l = [[]]</code>, but now that we have to map and append, we need</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">selections</span> <span class="mi">0</span> <span class="n">l</span><span class="o">)</span> <span class="bp">++</span> <span class="n">r</span>
<span class="bp">=</span> <span class="n">map</span> <span class="n">f</span> <span class="o">[[]]</span> <span class="bp">++</span> <span class="n">r</span>
<span class="bp">=</span> <span class="o">[</span><span class="n">f</span> <span class="o">[]]</span> <span class="bp">++</span> <span class="n">r</span>
<span class="bp">=</span> <span class="n">f</span> <span class="o">[]</span> <span class="o">::</span> <span class="n">r</span>
</code></pre></div>
<p>so that's why the zero case is <code>f [] :: r</code>.</p>
<p>The result:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">selections_aux</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">[]</span> <span class="o">::</span> <span class="n">r</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">l.foldr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">selections_aux</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">y</span><span class="o">::</span><span class="n">x</span><span class="o">)))</span> <span class="n">r</span>
</code></pre></div>
<p>and we can rewrite the lambda into a composition for the original version.</p>



<a name="223077841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223077841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223077841">(Jan 18 2021 at 03:28)</a>:</h4>
<p><span class="user-mention" data-user-id="375678">@Sandy Maguire</span>, this function is really a recursive function, it's not a while loop in disguise because it calls itself recursively m times where m is the length of the input list (2 in the case of binary strings) in each recursive call. The recursion has depth exactly n, which is why you get <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">m^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> elements in the list in the end - the call tree a perfectly balanced m-way tree of depth n. If you were to render it in C++, you would still need a recursion. (There are ways to do it iteratively but that's a really different algorithm than the one here.) Here's a Rust version of the algorithm, with variables named analogously to the lean version:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">selections_aux</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">r</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">n</span><span class="p">.</span><span class="n">checked_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">f2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">selections_aux</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">selections</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w"></span>
<span class="w">  </span><span class="n">selections_aux</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[],</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">r</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">selections</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="223078211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223078211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223078211">(Jan 18 2021 at 03:39)</a>:</h4>
<p>(btw, you can use the button in the top left of the code snippet to test/edit this code)</p>



<a name="223080795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223080795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223080795">(Jan 18 2021 at 04:48)</a>:</h4>
<p>Just for fun, here's an iterative implementation with O(n) memory usage:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">selections_foreach</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="n">T</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[])</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">it1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">iter</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it1</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="n">it1</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="o">'</span><span class="na">next</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">rev</span><span class="p">().</span><span class="n">zip</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">rev</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">continue</span><span class="w"> </span><span class="nl">'next</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">iter</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">selections_foreach</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>



<a name="223127172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223127172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223127172">(Jan 18 2021 at 14:37)</a>:</h4>
<p>So the <code>β</code> type parameter represents both the <code>list ℕ</code> type and the <code>ℕ</code> type right?</p>



<a name="223127506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223127506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223127506">(Jan 18 2021 at 14:39)</a>:</h4>
<p>which one?</p>



<a name="223127600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223127600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223127600">(Jan 18 2021 at 14:40)</a>:</h4>
<p>In the <code>selections_aux</code> function</p>



<a name="223127688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223127688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223127688">(Jan 18 2021 at 14:41)</a>:</h4>
<p>in <code>selections_aux</code>, the beta type parameter only needs to be <code>list A</code> in order to be useful for <code>selections</code>, but it can be generalized so why not</p>



<a name="223127721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223127721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223127721">(Jan 18 2021 at 14:41)</a>:</h4>
<p>since <code>selections</code> uses <code>id</code> for the function <code>f</code> that implies that <code>list A = B</code></p>



<a name="223127833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223127833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223127833">(Jan 18 2021 at 14:42)</a>:</h4>
<p>and when using <code>selections</code> to produce a list of bools you need <code>A = bool</code>, or to make a list of nat you need <code>A = nat</code></p>



<a name="223138339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223138339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223138339">(Jan 18 2021 at 16:05)</a>:</h4>
<p>Thanks a lot! Now I understand how the <code>selections</code> function works. I substituted polymorphic stuff with concrete types and the <code>foldr</code> function with ordinary function composition and the <code>selections</code> function now makes total sense!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">selections_aux</span> <span class="o">(</span><span class="n">alphabet</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="o">(</span><span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">ℕ</span><span class="o">))</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="n">current_string</span> <span class="n">accumulated_list</span> <span class="o">:=</span> <span class="n">current_string</span> <span class="o">[]</span> <span class="o">::</span> <span class="n">accumulated_list</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">current_string</span> <span class="n">accumulated_list</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">selections_aux</span> <span class="n">n</span> <span class="o">(</span><span class="n">current_string</span> <span class="bp">∘</span> <span class="n">list.cons</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">selections_aux</span> <span class="n">n</span> <span class="o">(</span><span class="n">current_string</span> <span class="bp">∘</span> <span class="n">list.cons</span> <span class="mi">1</span><span class="o">))</span> <span class="n">accumulated_list</span>
</code></pre></div>



<a name="223138444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223138444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223138444">(Jan 18 2021 at 16:06)</a>:</h4>
<p>It feels a lot like solving cryptograms.</p>



<a name="223147009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223147009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223147009">(Jan 18 2021 at 17:28)</a>:</h4>
<p>Going the other way (finding the general thing which can apply in more than one situation) is called abstraction, and it seems to be a common feature of both maths and computer science. Spotting  underlying patterns is something mathematicians can get excited about.</p>



<a name="223245514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223245514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223245514">(Jan 19 2021 at 15:46)</a>:</h4>
<p>Tomorrow I will implement the "digit dynamic programming" algorithm in Lean. But I want to make sure that my definitions are alright first.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">strings</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">nat.to_digits</span> <span class="mi">2</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">popcount</span> <span class="o">(</span><span class="n">string</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">string.foldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">accumulated</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">digit</span><span class="o">,</span> <span class="n">accumulated</span> <span class="bp">+</span> <span class="n">digit</span><span class="o">)</span> <span class="mi">0</span>
<span class="kd">def</span> <span class="n">total_popcount</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">strings</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">foldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">accumulated</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">current_string</span><span class="o">,</span> <span class="n">accumulated</span> <span class="bp">+</span> <span class="n">popcount</span> <span class="n">current_string</span><span class="o">)</span> <span class="mi">0</span>
</code></pre></div>
<p>Are the definitions alright? Any suggestions?</p>



<a name="223245727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223245727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223245727">(Jan 19 2021 at 15:48)</a>:</h4>
<p>The <code>total_popcount</code> function computes the number of <code>1</code> digits in the binary representations of numbers from 0 to n - 1.</p>



<a name="223247568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223247568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223247568">(Jan 19 2021 at 16:01)</a>:</h4>
<p>So again, <a href="https://cses.fi/paste/ace3f13c3d25a24513f457/">here is the code I'm going to port to Lean</a>.</p>



<a name="223250372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223250372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223250372">(Jan 19 2021 at 16:21)</a>:</h4>
<p>Not relevant to your porting, but <code>λ accumulated, λ digit, _</code> is long for <code>λ accumulated digit, _</code>, and <code>(λ accumulated, λ digit, accumulated + digit)</code> is long for <code>(+)</code>.</p>



<a name="223346814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223346814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223346814">(Jan 20 2021 at 09:04)</a>:</h4>
<p>Alright, ported! Now how do I prove that the <code>dp</code> function is equivalent to the <code>total_popcount</code> function?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">data.list.range</span>
<span class="kn">open</span> <span class="n">list</span>

<span class="kd">def</span> <span class="n">strings</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">nat.to_digits</span> <span class="mi">2</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">popcount</span> <span class="o">(</span><span class="n">string</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">string.foldl</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="mi">0</span>
<span class="kd">def</span> <span class="n">total_popcount</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">strings</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">foldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">accumulated</span> <span class="n">current_string</span><span class="o">,</span> <span class="n">accumulated</span> <span class="bp">+</span> <span class="n">popcount</span> <span class="n">current_string</span><span class="o">)</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">dp_cardinality</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">tt</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">ff</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ff</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">tt</span> <span class="bp">+</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">_</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">tt</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">tt</span>

<span class="kd">def</span> <span class="n">dp_popcount</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">_</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ff</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">tt</span> <span class="bp">+</span> <span class="o">(</span><span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">ff</span> <span class="bp">+</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">ff</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">_</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">tt</span> <span class="bp">+</span> <span class="o">(</span><span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">tt</span> <span class="bp">+</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">tt</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list.reverse</span> <span class="o">((</span><span class="n">nat.to_digits</span> <span class="mi">2</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">ff</span> <span class="k">else</span> <span class="n">tt</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">dp</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">dp_popcount</span> <span class="o">(</span><span class="n">to_bool</span> <span class="n">n</span><span class="o">)</span> <span class="n">ff</span>
</code></pre></div>



<a name="223346882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223346882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223346882">(Jan 20 2021 at 09:05)</a>:</h4>
<p>Memoizing the parameters would yield an algorithm that runs in logarithmic time!</p>



<a name="223347417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223347417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223347417">(Jan 20 2021 at 09:10)</a>:</h4>
<p>Another tip: your <code>popcount</code> is just <code>string.sum</code>, which will make the proof marginally easier. It's tempting in fact to just define <code>total_popcount</code> as <code>(((range n).map $ nat.to_digits 2).map list.sum).sum</code>, which eliminates the other two definitions.</p>



<a name="223379860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223379860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223379860">(Jan 20 2021 at 14:34)</a>:</h4>
<p>I am genuinely stuck. I have never proved something like this before. Can anyone please help me out, thanks in advance. I guess there would be some sort of plumbing to convert between different representations right?</p>



<a name="223379956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223379956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223379956">(Jan 20 2021 at 14:35)</a>:</h4>
<p>Why don't you start by formalising your question and adding it to the MWE above? People like explicit <code>sorry</code>ed proofs.</p>



<a name="223380119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223380119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223380119">(Jan 20 2021 at 14:36)</a>:</h4>
<p>Also, why not sketch a (non-Lean) proof of what you want to do?</p>



<a name="223380348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223380348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223380348">(Jan 20 2021 at 14:38)</a>:</h4>
<p>Alright so here is the MWE with an explicit <code>sorry</code>'d proof.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">data.list.range</span>
<span class="kn">open</span> <span class="n">list</span>

<span class="kd">def</span> <span class="n">popcount</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(((</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="bp">$</span> <span class="n">nat.to_digits</span> <span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">list.sum</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span>

<span class="kd">def</span> <span class="n">dp_cardinality</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">tt</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">ff</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ff</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">tt</span> <span class="bp">+</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">_</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">tt</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">tt</span>

<span class="kd">def</span> <span class="n">dp_popcount</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">_</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ff</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">tt</span> <span class="bp">+</span> <span class="o">(</span><span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">ff</span> <span class="bp">+</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">ff</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">_</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">tt</span> <span class="bp">+</span> <span class="o">(</span><span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">tt</span> <span class="bp">+</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">tt</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">to_binary</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list.reverse</span> <span class="o">((</span><span class="n">nat.to_digits</span> <span class="mi">2</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">ff</span> <span class="k">else</span> <span class="n">tt</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">dp</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">dp_popcount</span> <span class="o">(</span><span class="n">to_binary</span> <span class="n">n</span><span class="o">)</span> <span class="n">ff</span>

<span class="kd">lemma</span> <span class="n">equivalent</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">dp</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">popcount</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="223380622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223380622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223380622">(Jan 20 2021 at 14:40)</a>:</h4>
<p><code>slim_check</code> can't find any counterexamples so that's a good start :D</p>



<a name="223380697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223380697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223380697">(Jan 20 2021 at 14:41)</a>:</h4>
<p>So what's the proof sketch you have in mind? Lean won't do anything automatically, it needs to be guided.</p>



<a name="223380722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223380722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223380722">(Jan 20 2021 at 14:41)</a>:</h4>
<p>Why did you use <code>(range n).map (nat.to_digits 2)</code> instead of <code>selections</code>? You're going to need a bunch of theorems about digits that don't really matter here</p>



<a name="223380858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223380858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223380858">(Jan 20 2021 at 14:42)</a>:</h4>
<p><code>to_binary</code> also looks a little painful</p>



<a name="223386122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223386122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223386122">(Jan 20 2021 at 15:12)</a>:</h4>
<p>Here are some lemmas that should help you along the way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">eval_binary</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ff</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">eval_binary</span> <span class="n">l</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">eval_binary</span> <span class="n">l</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="kd">lemma</span> <span class="n">dp_cardinality_tt</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">dp_cardinality</span> <span class="n">l</span> <span class="n">tt</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">length</span> <span class="n">l</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">dp_cardinality_ff</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">dp_cardinality</span> <span class="n">l</span> <span class="n">ff</span> <span class="bp">=</span> <span class="n">eval_binary</span> <span class="n">l.reverse</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">dp_popcount_tt</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span><span class="o">,</span> <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">length</span> <span class="n">l</span> <span class="k">in</span>
  <span class="n">dp_popcount</span> <span class="n">l</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">eval_binary_to_binary</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">eval_binary</span> <span class="o">(</span><span class="n">to_binary</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">reverse</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="223386772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223386772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223386772">(Jan 20 2021 at 15:16)</a>:</h4>
<p>The algorithm that is being implemented is called <a href="https://www.geeksforgeeks.org/digit-dp-introduction/">"digit DP"</a>. The "digit DP" algorithm tries to construct every possible string that satisfies a given condition, for example in this case lexicographically less than the binary representation of n.</p>
<p>The first parameter of the two <code>dp</code> functions represents the current digit that is being probed. It's somewhat similar to the <code>selections</code> function: the first digit is probed first, then the second, then the third, then the nth. And the second parameter indicates whether or not the current number is already less than <code>n</code>. If every number with the already probed digits is less than <code>n</code> then the digits that are yet to be probed can be anything, otherwise the next digit must be &lt;= the corresponding digit of the number <code>n</code>.</p>
<p>The <code>dp_cardinality</code> function counts numbers that start with the already probed digits and are less than <code>n</code>. The <code>dp_popcount</code> function counts the number of set bits.</p>
<p>Let me dissect the two functions.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">dp_cardinality</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="c1">-- No more digits to probe. The final number is less than `n` so there is exactly 1 number that can be formed.</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">tt</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="c1">-- No more digits to probe. The final number is &gt;= `n`. No number can be formed.</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">ff</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="c1">-- If the corresponding digit of `n` is zero, the only possible value for the current digit is 0. Not every number with the already probed digits is less than `n`, therefore the second parameter is ff.</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ff</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">ff</span>
<span class="c1">-- The corresponding digit of `n` is one. The current digit can be either 0 or 1. If the current digit is 0 then every number with the already probed digits is less than `n`, therefore the second parameter is tt. Otherwise, the second parameter is ff.</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">tt</span> <span class="bp">+</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">ff</span>
<span class="c1">-- The second parameter indicates that the rest of the number can be anything and the number is still less than `n`.</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">_</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">tt</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">tt</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">dp_popcount</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="c1">-- No more digits, 1 number can be formed.</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">_</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="c1">-- The current digit is 0.</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ff</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">ff</span>

<span class="c1">-- The current digit can either be 0 or 1. When the current digit is 1, the total number of set bits increases by the # of numbers with the already probed digits that are less than `n`.</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">tt</span> <span class="bp">+</span> <span class="o">(</span><span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">ff</span> <span class="bp">+</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">ff</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">_</span><span class="o">::</span><span class="n">the_rest</span><span class="o">)</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">tt</span> <span class="bp">+</span> <span class="o">(</span><span class="n">dp_popcount</span> <span class="n">the_rest</span> <span class="n">tt</span> <span class="bp">+</span> <span class="n">dp_cardinality</span> <span class="n">the_rest</span> <span class="n">tt</span><span class="o">)</span>
</code></pre></div>
<p>As I don't have a math background, I don't really have a proof sketch. But I think the description of the algorithm somewhat serves as a justification for its correctness.</p>



<a name="223386897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223386897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223386897">(Jan 20 2021 at 15:17)</a>:</h4>
<p>Apologies if the explanation is confusing, I am not really good with words.</p>



<a name="223387446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223387446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223387446">(Jan 20 2021 at 15:21)</a>:</h4>
<blockquote>
<p>The dp_cardinality function counts numbers that start with the already probed digits and are less than n. The dp_popcount function counts the number of set bits.</p>
</blockquote>
<p>Those sound like excellent lemmas</p>



<a name="223388883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223388883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223388883">(Jan 20 2021 at 15:30)</a>:</h4>
<p>I had a very quick attempt by just throwing <code>simp</code> at the problem, and found a missing lemma about range, which I've PR'd as <a href="https://github.com/leanprover-community/mathlib/issues/5821">#5821</a></p>



<a name="223394424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223394424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223394424">(Jan 20 2021 at 16:07)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> You mean <a href="https://github.com/leanprover-community/mathlib/pull/5821">https://github.com/leanprover-community/mathlib/pull/5821</a> right?</p>



<a name="223394600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223394600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223394600">(Jan 20 2021 at 16:08)</a>:</h4>
<p>Whoops, my clipboard has been betraying me today</p>



<a name="223397096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223397096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223397096">(Jan 20 2021 at 16:24)</a>:</h4>
<p>Here's a more directed proof sketch:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">range_add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">range</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">range</span> <span class="n">a</span> <span class="bp">++</span> <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">range</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">set_bits</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat.digits</span> <span class="mi">2</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span>

<span class="kd">theorem</span> <span class="n">set_bits_succ</span> <span class="o">(</span><span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">set_bits</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">set_bits</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">eval_binary</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ff</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">eval_binary</span> <span class="n">l</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">eval_binary</span> <span class="n">l</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="kd">lemma</span> <span class="n">eval_binary_to_binary</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">eval_binary</span> <span class="o">(</span><span class="n">to_binary</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">reverse</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">theorem</span> <span class="n">eval_binary_lt</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">eval_binary</span> <span class="n">l</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">l.length</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">eval_binary'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ff</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">eval_binary</span> <span class="n">l</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">l.length</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">eval_binary</span> <span class="n">l</span>

<span class="kd">theorem</span> <span class="n">eval_binary_rev</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">eval_binary</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">eval_binary'</span> <span class="n">l</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">theorem</span> <span class="n">eval_binary_rev_lt</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">eval_binary'</span> <span class="n">l</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">l.length</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">eval_binary'_to_binary</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">eval_binary'</span> <span class="o">(</span><span class="n">to_binary</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">range_binary</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">tt</span> <span class="o">:=</span> <span class="o">[</span><span class="mi">0</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">ff</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">ff</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">range_binary</span> <span class="n">l</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">tt</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">range_binary</span> <span class="n">l</span> <span class="n">tt</span> <span class="bp">++</span> <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">length</span> <span class="n">l</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">range_binary</span> <span class="n">l</span> <span class="n">ff</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">_</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">range_binary</span> <span class="n">l</span> <span class="n">tt</span> <span class="bp">++</span> <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">length</span> <span class="n">l</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">range_binary</span> <span class="n">l</span> <span class="n">tt</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">range_binary_range_tt</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">range_binary</span> <span class="n">l</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">range</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">l.length</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">theorem</span> <span class="n">range_binary_range_ff</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">range_binary</span> <span class="n">l</span> <span class="n">ff</span> <span class="bp">=</span> <span class="n">range</span> <span class="o">(</span><span class="n">eval_binary'</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">theorem</span> <span class="n">range_binary_length</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">(</span><span class="n">range_binary</span> <span class="n">l</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">dp_cardinality</span> <span class="n">l</span> <span class="n">b</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">theorem</span> <span class="n">range_binary_set_bits</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">((</span><span class="n">range_binary</span> <span class="n">l</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">set_bits</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">=</span> <span class="n">dp_popcount</span> <span class="n">l</span> <span class="n">b</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">equivalent</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">dp</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">popcount</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">dp</span><span class="o">,</span> <span class="bp">←</span> <span class="n">range_binary_set_bits</span><span class="o">,</span> <span class="n">popcount</span><span class="o">,</span> <span class="n">map_map</span><span class="o">,</span>
    <span class="n">range_binary_range_ff</span><span class="o">,</span> <span class="n">eval_binary'_to_binary</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>
</code></pre></div>



<a name="223398451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223398451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223398451">(Jan 20 2021 at 16:33)</a>:</h4>
<p>also you should be using <code>nat.digits</code> (from <code>data.nat.digits</code>) instead of <code>nat.to_digits</code>. It's basically the same thing but it has a lot more lemmas</p>



<a name="223486491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223486491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223486491">(Jan 21 2021 at 09:42)</a>:</h4>
<p>Lightning quick question: how do I use <code>slim_check</code>?</p>



<a name="223486511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223486511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223486511">(Jan 21 2021 at 09:43)</a>:</h4>
<p>Is <code>import tactic.slim_check</code> the answer you're looking for?</p>



<a name="223486546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223486546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223486546">(Jan 21 2021 at 09:43)</a>:</h4>
<p>So deterministic timeout means that slim_check fails to find a counterexample right?</p>



<a name="223486695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223486695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223486695">(Jan 21 2021 at 09:45)</a>:</h4>
<p>Thanks for the quick response, <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <span aria-label="raised hands" class="emoji emoji-1f64c" role="img" title="raised hands">:raised_hands:</span></p>



<a name="223529673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223529673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223529673">(Jan 21 2021 at 16:05)</a>:</h4>
<p>How would you prove this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">coerce_bool</span> <span class="o">(</span><span class="n">digits</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list.reverse</span> <span class="o">(</span><span class="n">digits.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">ff</span> <span class="k">else</span> <span class="n">tt</span><span class="o">))</span>
<span class="kd">def</span> <span class="n">coerce_digits</span> <span class="o">(</span><span class="n">string</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list.reverse</span> <span class="o">(</span><span class="n">string.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">is_identity</span> <span class="o">{</span> <span class="n">string</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="o">}</span> <span class="o">{</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">string</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="o">}</span> <span class="o">:</span> <span class="n">coerce_digits</span> <span class="o">(</span><span class="n">coerce_bool</span> <span class="n">string</span><span class="o">)</span> <span class="bp">=</span> <span class="n">string</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>It is equivalent to the <code>eval_binary'_to_binary</code> lemma in the Lean proof sketch.</p>



<a name="223530121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223530121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223530121">(Jan 21 2021 at 16:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="270523">Huỳnh Trần Khanh</span> <a href="#narrow/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!/near/223486546">said</a>:</p>
<blockquote>
<p>So deterministic timeout means that slim_check fails to find a counterexample right?</p>
</blockquote>
<p>I think <code>slim_check</code> will tell you explicitly if it fails to find a counterexample after a certain number of tries; a deterministic timeout might mean that something else is failing before <code>slim_check</code> is able to run (e.g. <code>slim_check</code> does a search for a <code>testable</code> instance and this could time out). The documentation and some examples can be found <a href="https://leanprover-community.github.io/mathlib_docs/tactic/slim_check.html">here</a>; you can try those out to see what the normal behavior is.</p>



<a name="223533064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/I%20want%20to%20generate%20binary%20strings%20and%20reason%20about%20them%21/near/223533064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!.html#223533064">(Jan 21 2021 at 16:25)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.basic</span>

<span class="kd">def</span> <span class="n">coerce_bool</span> <span class="o">(</span><span class="n">digits</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list.reverse</span> <span class="o">(</span><span class="n">digits.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">ff</span> <span class="k">else</span> <span class="n">tt</span><span class="o">))</span>
<span class="kd">def</span> <span class="n">coerce_digits</span> <span class="o">(</span><span class="n">string</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list.reverse</span> <span class="o">(</span><span class="n">string.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">is_identity</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">coerce_digits</span> <span class="o">(</span><span class="n">coerce_bool</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">l</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">coerce_digits</span><span class="o">,</span> <span class="n">coerce_bool</span><span class="o">,</span> <span class="n">list.map_reverse</span><span class="o">,</span>
    <span class="n">list.reverse_reverse</span><span class="o">,</span> <span class="n">list.map_map</span><span class="o">,</span> <span class="n">list.map_congr</span><span class="o">,</span> <span class="n">list.map_id</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">H</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">dec_trivial</span>
<span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
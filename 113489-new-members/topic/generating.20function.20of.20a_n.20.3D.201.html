---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html">generating function of a_n = 1</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="218375410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218375410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218375410">(Dec 01 2020 at 02:58)</a>:</h4>
<p>Hi. Any advice for things I'm doing inefficiently or should know about in this proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">ring_theory.power_series</span>

<span class="kn">open</span> <span class="n">power_series</span>

<span class="kd">def</span> <span class="n">ones</span> <span class="o">:</span> <span class="n">power_series</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">power_series.mk</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">ones_coeff_one</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">coeff</span> <span class="n">ℚ</span> <span class="n">n</span> <span class="n">ones</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">mul_ones_X_coeff_one</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h_nonzero</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">coeff</span> <span class="n">ℚ</span> <span class="n">n</span> <span class="o">(</span><span class="n">X</span> <span class="bp">*</span> <span class="n">ones</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">tauto</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">finish</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">ones_inv</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">ones</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">-</span> <span class="n">X</span><span class="o">)</span> <span class="bp">*</span> <span class="n">ones</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">hc</span> <span class="o">:</span> <span class="n">constant_coeff</span> <span class="n">ℚ</span> <span class="n">ones</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="n">power_series.eq_inv_iff_mul_eq_one</span> <span class="n">hc</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">sub_mul</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">coeff_one</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">finish</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">add_monoid_hom.map_sub</span><span class="o">,</span> <span class="n">if_false</span><span class="o">],</span>
      <span class="k">suffices</span> <span class="n">h'</span> <span class="o">:</span> <span class="n">coeff</span> <span class="n">ℚ</span> <span class="n">n</span> <span class="o">(</span><span class="n">X</span> <span class="bp">*</span> <span class="n">ones</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h'</span><span class="o">,</span> <span class="n">ones_coeff_one</span><span class="o">,</span> <span class="n">sub_self</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">mul_ones_X_coeff_one</span> <span class="n">h</span> <span class="o">}}}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218382974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218382974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218382974">(Dec 01 2020 at 05:44)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">ring_theory.power_series</span>

<span class="kn">open</span> <span class="n">power_series</span>

<span class="kd">def</span> <span class="n">ones</span> <span class="o">:</span> <span class="n">power_series</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">power_series.mk</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coeff_ones</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">coeff</span> <span class="n">ℚ</span> <span class="n">n</span> <span class="n">ones</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">ones_inv</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">ones</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">eq_inv_iff_mul_eq_one</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">_</span><span class="o">,</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">one_ne_zero</span> <span class="o">},</span>
  <span class="n">ext1</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">sub_mul</span><span class="o">,</span> <span class="n">add_monoid_hom.map_sub</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">coeff_one</span><span class="o">],</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">coeff_zero_eq_constant_coeff_apply</span><span class="o">,</span> <span class="n">coeff_zero_eq_constant_coeff_apply</span><span class="o">,</span>
      <span class="n">ring_hom.map_mul</span><span class="o">,</span> <span class="n">constant_coeff_X</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">,</span> <span class="n">sub_zero</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">rfl</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">coeff_succ_mul_X</span><span class="o">,</span> <span class="n">if_neg</span> <span class="o">(</span><span class="n">n.succ_ne_zero</span><span class="o">)],</span> <span class="n">exact</span> <span class="n">sub_self</span> <span class="n">_</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218417769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218417769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218417769">(Dec 01 2020 at 12:56)</a>:</h4>
<p>Thanks!</p>



<a name="218775559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218775559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218775559">(Dec 04 2020 at 00:49)</a>:</h4>
<p>With the above I was trying to formalize a proof of a second recurrence with generating functions. I'm only partway through, but have 2 minor questions. Code is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">import</span> <span class="n">generating_functions</span>

<span class="kn">open</span> <span class="n">power_series</span>

<span class="kd">def</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℚ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">mk</span> <span class="n">a</span>

<span class="kd">lemma</span> <span class="n">A_def</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">mk</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c1">-- FIXME</span>
<span class="kd">lemma</span> <span class="n">two_lift</span> <span class="o">{</span><span class="n">φ</span> <span class="o">:</span> <span class="n">power_series</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">φ</span> <span class="bp">=</span> <span class="o">(</span><span class="n">C</span> <span class="n">ℚ</span><span class="o">)</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">φ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num</span>
<span class="kd">lemma</span> <span class="n">A_mul_two</span> <span class="o">:</span> <span class="n">power_series.mk</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">A</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">A</span><span class="o">,</span> <span class="n">two_lift</span><span class="o">],</span>
  <span class="n">rw</span> <span class="n">C_mul</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- FIXME: have h : ...</span>
<span class="k">#check</span> <span class="n">a.equations._eqn_2</span>

<span class="kd">lemma</span> <span class="n">A_recurrence</span> <span class="o">:</span> <span class="n">shift</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">+</span> <span class="n">ones</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">A_mul_two</span><span class="o">,</span>
  <span class="n">ext1</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">shift_def</span><span class="o">,</span> <span class="n">A_def</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">coeff_mk</span><span class="o">,</span> <span class="n">coeff_add</span><span class="o">,</span> <span class="n">coeff_ones</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">A_ogf</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">X</span> <span class="bp">/</span> <span class="o">((</span><span class="mi">1</span> <span class="bp">-</span> <span class="n">X</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">-</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">X</span><span class="o">))</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>where <code>generating_functions</code> contains:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.power_series</span>

<span class="kn">import</span> <span class="n">tactic.basic</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">power_series</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">div</span> <span class="o">(</span><span class="n">φ₁</span> <span class="n">φ₂</span> <span class="o">:</span> <span class="n">power_series</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span> <span class="n">φ₁</span> <span class="bp">*</span> <span class="n">φ₂</span><span class="bp">⁻¹</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_div</span> <span class="o">(</span><span class="n">power_series</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">div</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">div_def</span> <span class="o">(</span><span class="n">φ₁</span> <span class="n">φ₂</span> <span class="o">:</span> <span class="n">power_series</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">φ₁</span> <span class="bp">/</span> <span class="n">φ₂</span> <span class="bp">=</span> <span class="n">φ₁</span> <span class="bp">*</span> <span class="n">φ₂</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">one_div_eq_inv</span> <span class="o">(</span><span class="n">φ₁</span> <span class="n">φ₂</span> <span class="o">:</span> <span class="n">power_series</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">φ₁</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="n">φ₂</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">φ₁</span> <span class="bp">=</span> <span class="n">φ₂</span><span class="bp">⁻¹</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">div_def</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">ones</span> <span class="o">:=</span> <span class="n">power_series.mk</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">ones_def</span> <span class="o">:</span> <span class="n">ones</span> <span class="bp">=</span> <span class="n">power_series.mk</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">))</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coeff_ones</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">coeff</span> <span class="n">ℚ</span> <span class="n">n</span><span class="o">)</span> <span class="n">ones</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">ones_ogf</span> <span class="o">:</span> <span class="n">ones</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">/</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">-</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">one_div_eq_inv</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">eq_inv_iff_mul_eq_one</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ring_hom.map_sub</span><span class="o">,</span> <span class="n">constant_coeff_one</span><span class="o">,</span> <span class="n">constant_coeff_X</span><span class="o">,</span> <span class="n">sub_zero</span><span class="o">,</span>
               <span class="n">ne.def</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">one_ne_zero</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">ext1</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_sub</span><span class="o">,</span> <span class="n">add_monoid_hom.map_sub</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">,</span> <span class="n">coeff_one</span><span class="o">],</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">coeff_zero_eq_constant_coeff_apply</span><span class="o">,</span> <span class="n">coeff_zero_eq_constant_coeff_apply</span><span class="o">,</span>
        <span class="n">ring_hom.map_mul</span><span class="o">,</span> <span class="n">constant_coeff_X</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">sub_zero</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">rfl</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">coeff_succ_mul_X</span><span class="o">,</span> <span class="n">if_neg</span> <span class="o">(</span><span class="n">n.succ_ne_zero</span><span class="o">)],</span> <span class="n">exact</span> <span class="n">sub_self</span> <span class="n">_</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm">The shift operation on a power series takes `a₀ + a₁x + ...` to `a₁ + a₂x + ...`</span>
<span class="cm">-/</span>
<span class="kd">def</span> <span class="n">shift</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">power_series</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">power_series</span> <span class="n">k</span> <span class="o">:=</span>
<span class="n">power_series.mk</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">coeff</span> <span class="n">k</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">shift_def</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">power_series</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">shift</span> <span class="n">φ</span> <span class="bp">=</span> <span class="o">(</span><span class="n">power_series.mk</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">coeff</span> <span class="n">k</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">φ</span><span class="o">))</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm">Multiplying a `shift`ed power series by `x`, then adding its original</span>
<span class="cm">constant coefficient equals the original series.</span>
<span class="cm">-/</span>
<span class="kd">lemma</span> <span class="n">shift_mul_add_constant_is_inv</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">power_series</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">shift</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">*</span> <span class="n">X</span> <span class="bp">+</span> <span class="o">(</span><span class="n">C</span> <span class="n">k</span> <span class="o">(</span><span class="n">constant_coeff</span> <span class="n">k</span> <span class="n">φ</span><span class="o">))</span> <span class="bp">=</span> <span class="n">φ</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">shift_def</span><span class="o">],</span>
  <span class="n">ext1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ring_hom.map_add</span><span class="o">,</span> <span class="n">constant_coeff_C</span><span class="o">,</span> <span class="n">constant_coeff_X</span><span class="o">,</span> <span class="n">coeff_zero_eq_constant_coeff</span><span class="o">,</span>
               <span class="n">ring_hom.coe_add_monoid_hom</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">ring_hom.map_mul</span><span class="o">]</span> <span class="o">},</span>

  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat.succ_eq_add_one</span><span class="o">,</span> <span class="n">coeff_C</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">,</span> <span class="n">coeff_mk</span><span class="o">,</span> <span class="n">add_monoid_hom.map_add</span><span class="o">,</span>
               <span class="n">add_eq_zero_iff</span><span class="o">,</span> <span class="n">if_false</span><span class="o">,</span> <span class="n">one_ne_zero</span><span class="o">,</span> <span class="n">and_false</span><span class="o">,</span> <span class="n">coeff_succ_mul_X</span><span class="o">]</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coeff_add</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">φ₁</span> <span class="n">φ₂</span> <span class="o">:</span> <span class="n">power_series</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">coeff</span> <span class="n">k</span> <span class="n">n</span> <span class="o">(</span><span class="n">φ₁</span> <span class="bp">+</span> <span class="n">φ₂</span><span class="o">)</span> <span class="bp">=</span> <span class="n">coeff</span> <span class="n">k</span> <span class="n">n</span> <span class="n">φ₁</span> <span class="bp">+</span> <span class="n">coeff</span> <span class="n">k</span> <span class="n">n</span> <span class="n">φ₂</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">add_monoid_hom.map_add</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">C_mul</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">k</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">k</span><span class="o">}</span> <span class="o">:</span> <span class="n">C</span> <span class="n">k</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">mk</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">mk</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">coeff_mul_C</span><span class="o">,</span> <span class="n">coeff_mk</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>
<p>1) When I write <code>#check 2 * (power_series.mk id)</code>, the <code>2</code> is coerced into a <code>power_series.C</code> -- how can I write <code>C_mul</code> such that I don't need to manually <code>rw two_lift</code>and <code>A_mul_two</code>?<br>
2) Is <code>a.equations._eqn_2</code> the way I can refer to the recurrence from <code>a</code>'s definition? If I wanted to explicitly add that equation as a hypothesis in a local context how do I do that? <code>have h: a.equations._eqn_2</code> seems to complain that that isn't a type. The point of doing so was to calculate from that recurrence  in my proof of <code>A_recurrence</code>, which seems to just work if I put <code>simp [..., a, ...]</code> there instead of <code>a.equations._eqn_2</code>, but just curious on how to do so anyhow</p>
<p>Also, is e.g. <code>coeff_add</code> useful to add?</p>



<a name="218776177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776177">(Dec 04 2020 at 00:59)</a>:</h4>
<p><code> a.equations._eqn_2</code> isn't a type (a theorem statement), it's a term (a proof). If you want to add it to the local context then the syntax is <code>have h := a.equations._eqn_2</code> but <code>simp [..., a, ...]</code> is what you're supposed to be doing. <code>simp [a]</code> means "simp using the equation lemmas of the definition <code>a</code>". You can see them with <code>#print prefix a</code>.</p>



<a name="218776274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776274">(Dec 04 2020 at 01:00)</a>:</h4>
<p><code>coeff_add</code> looks fine to me. Note that you can prove it with <code>... := add_monoid_hom.map_add _ _ _</code> in term mode.</p>



<a name="218776386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776386">(Dec 04 2020 at 01:02)</a>:</h4>
<p>Oh wait, <code>coeff</code> is already an additive group hom, so <code>coeff_add</code> is already there. It's called <code>(coeff k n).map_add</code>.</p>



<a name="218776665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776665">(Dec 04 2020 at 01:06)</a>:</h4>
<p>How does one decided whether that should be marked <code>@[simp]</code> or not for this case?</p>



<a name="218776684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776684">(Dec 04 2020 at 01:07)</a>:</h4>
<p>(And thanks as usual, very helpful on the first thing -- I guess informally I was expecting to have a proof where I start with the equation from <code>a</code> and then manipulate it with the operations I did, but yeah that's not how the proof appears to turn out)</p>



<a name="218776782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776782">(Dec 04 2020 at 01:08)</a>:</h4>
<p>The <code>2</code> thing is a numeral issue. Any type which has a <code>zero</code> and a <code>one</code> and an <code>add</code> will have a <code>2</code>, defined to be <code>1 + 1</code>. In particular you won't see the same behaviour if you use <code>(c : \Q)</code>. I'm not quite sure what the question is. Do you want to prove theorems about numerals like 2 specifically?</p>



<a name="218776806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776806">(Dec 04 2020 at 01:09)</a>:</h4>
<p><code>(coeff k n).map_add</code> is already marked <code>simp</code>, because <code>#print add_monoid_hom.map_add</code> tells me it is. You can use <code>#print</code> to see all the tags attached to a term.</p>



<a name="218776874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776874">(Dec 04 2020 at 01:10)</a>:</h4>
<p>Oy, you're correct, though I could swear I added <code>coeff_add</code> after simp didn't finish solving something :(, must be my mistake.</p>



<a name="218776920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776920">(Dec 04 2020 at 01:11)</a>:</h4>
<p><code>lemma A_mul_two : power_series.mk (λ n, 2 * a n) = C _ 2 * A := C_mul.symm</code></p>



<a name="218776965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776965">(Dec 04 2020 at 01:12)</a>:</h4>
<p>On the number question -- I wanted to write <code>k * A</code> for multiplying a power series by an element of the field, and then be able to push <code>k</code> through <code>C_mul</code> without needing to manually prove a lemma for every different <code>k</code> (or without having to write <code>(C \Q k)</code> instead of <code>k</code>)</p>



<a name="218776979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776979">(Dec 04 2020 at 01:12)</a>:</h4>
<p>because if I have an equation with lots of multiplications I'll have to rewrite them all</p>



<a name="218776983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776983">(Dec 04 2020 at 01:12)</a>:</h4>
<p>You could add a coercion from <code>F</code> to <code>power series F</code> if you like.</p>



<a name="218776985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218776985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218776985">(Dec 04 2020 at 01:12)</a>:</h4>
<p>(Hopefully that makes more sense?)</p>



<a name="218777009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218777009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218777009">(Dec 04 2020 at 01:13)</a>:</h4>
<p>OK will try that, thanks.</p>



<a name="218777066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218777066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218777066">(Dec 04 2020 at 01:14)</a>:</h4>
<p>I mean, that's exactly what you're asking for, right? You want to have (x : F) being interpreted as (x : power_series F) and this is exactly a coercion.</p>



<a name="218777106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218777106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218777106">(Dec 04 2020 at 01:15)</a>:</h4>
<p>Yes, I think so, I guess I thought that was already existing for <code>2 * A</code> to work</p>



<a name="218777113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218777113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218777113">(Dec 04 2020 at 01:15)</a>:</h4>
<p>No because numerals are different -- they follow the rules I explained above.</p>



<a name="218777114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218777114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218777114">(Dec 04 2020 at 01:15)</a>:</h4>
<p>but it sounds like that's just because it's doing <code>2 = 1 + 1</code>.. yeah</p>



<a name="218777188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218777188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218777188">(Dec 04 2020 at 01:16)</a>:</h4>
<p>More precisely it's doing <code>2 = bit0 1</code>, but <code>bit0 x := x + x</code>.</p>



<a name="218777214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218777214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218777214">(Dec 04 2020 at 01:17)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">pp.numerals</span> <span class="n">false</span>

<span class="k">#check</span> <span class="o">(</span><span class="mi">37</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="c1">-- bit1 (bit0 (bit1 (bit0 (bit0 has_one.one)))) : ℚ</span>
</code></pre></div>



<a name="218777314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218777314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218777314">(Dec 04 2020 at 01:18)</a>:</h4>
<p>interesting thanks, I saw <code>bit0</code> show up somewhere in a ring homomorphism proof and wondered what it was -- why is it called <code>bit0</code>, I thought that'd refer to the <code>0th</code> bit of <code>x</code></p>



<a name="218777331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218777331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218777331">(Dec 04 2020 at 01:19)</a>:</h4>
<p>it means "add a 0 to the end of x" :-)</p>



<a name="218777342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218777342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218777342">(Dec 04 2020 at 01:19)</a>:</h4>
<p>ah.</p>



<a name="218937197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218937197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218937197">(Dec 05 2020 at 14:25)</a>:</h4>
<p>I haven't been able to get the coersion working, so hopefully it's OK to ask for another tip. Specifically... (Sorry, accidentally hit enter too soon)</p>



<a name="218955389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218955389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218955389">(Dec 05 2020 at 21:55)</a>:</h4>
<p>By the way you might like to look at <a href="https://github.com/leanprover-community/mathlib/pull/4259">https://github.com/leanprover-community/mathlib/pull/4259</a> in which Aaron and I used generating functions to show Euler's partition theorem</p>



<a name="218955660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218955660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218955660">(Dec 05 2020 at 22:02)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> oh awesome! I will, thanks for the pointer. I'm obviously playing with quite simple things (and getting stuck in quite simple places while doing so both because my math is crusty and my lean is worse) but having fun while doing so... I'm sure will pick up some tips from that.</p>



<a name="218955732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/218955732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#218955732">(Dec 05 2020 at 22:04)</a>:</h4>
<p>I think if I understand what I'm doing a little bit, that things would be easier if there was laurent series implemented</p>



<a name="222492321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/222492321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#222492321">(Jan 12 2021 at 20:49)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> I assume you're OK with me pushing a commit to bring that Euler Partition PR up to date with mathlib right? (There's like 2 or 3 small changes it looks like to get it re-passing)</p>



<a name="222492435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generating%20function%20of%20a_n%20%3D%201/near/222492435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generating.20function.20of.20a_n.20.3D.201.html#222492435">(Jan 12 2021 at 20:50)</a>:</h4>
<p>Go ahead!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
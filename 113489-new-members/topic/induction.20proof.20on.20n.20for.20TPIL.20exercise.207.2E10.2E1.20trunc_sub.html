---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html">induction proof on n for TPIL exercise 7.10.1 trunc_sub</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="199706026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706026">(Jun 04 2020 at 05:12)</a>:</h4>
<p>I'm trying to learn Lean via reading and doing exercises in TPIL. Right now, I'm stuck at proving the following theorem:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">my_sub_self</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">trunc_sub</span> <span class="n">n</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">k</span> <span class="n">hn</span><span class="o">,</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>The definition and a simple theorem I have are:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">trunc_sub</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="n">m</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">minus_m_n</span><span class="o">,</span> <span class="n">pred</span> <span class="n">minus_m_n</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">trunc_sub_zero_right</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">trunc_sub</span> <span class="n">n</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">trunc_sub</span><span class="o">,</span>
<span class="n">change</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">k</span><span class="o">,</span>
<span class="n">refl</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>I tried finishing off the theorem with some <code>rw trunc_sub at *</code> and <code>simp</code>, but I am not sure how to simplify the <code>nat.rec</code> or <code>nat.rec_on</code> in a way that recognizes that it is only in the <code>nat.succ k</code> case at that point in the proof. I think I'm just not understanding something about how to work with <code>rec</code> and <code>rec_on</code>.</p>
<p>I can include my definition of <code>pred</code> and associated theorems like <code>pred (succ n) = n</code> if that is helpful (or helps indicate that I have some grasp of Lean).</p>
<p>As a new-member introduction, I'm a computational chemist based in NYC. To learn Lean, I'm hoping to work through Benedict Gross's group theory class (which I've done before), but formalizing the notes and exercises.</p>



<a name="199706214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706214">(Jun 04 2020 at 05:17)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> Hi, welcome! Try <code>show pred _ = _</code>. Let us know if that hint gets you back on track.</p>



<a name="199706369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706369">(Jun 04 2020 at 05:21)</a>:</h4>
<p>In other words, lean realizes that it is in the <code>nat.succ</code> case of the proof, and using <code>show</code> you ask it to restate the goal in a way that is equal to the preceding goal <em>by definition</em>.</p>



<a name="199706473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706473">(Jun 04 2020 at 05:24)</a>:</h4>
<p>I'm trying to follow your hint here. After including that in the proof, my goal state is currently:</p>
<div class="codehilite"><pre><span></span><code><span class="mi">1</span> <span class="n">goal</span>
<span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">hn</span> <span class="o">:</span> <span class="n">trunc_sub</span> <span class="n">k</span> <span class="n">k</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="err">⊢</span> <span class="n">pred</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="n">minus_m_n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">pred</span> <span class="n">minus_m_n</span><span class="o">)</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span>
</code></pre></div>



<a name="199706499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706499">(Jun 04 2020 at 05:25)</a>:</h4>
<p>That state looks problematic, because the base case has also shifted</p>



<a name="199706510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706510">(Jun 04 2020 at 05:25)</a>:</h4>
<p>the <code>nat.rec</code> term is <code>trunc_sub (nat.succ k) k</code>, which your induction hypothesis will not help with</p>



<a name="199706555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706555">(Jun 04 2020 at 05:26)</a>:</h4>
<p>I'm just not sure how to get the <code>pred</code> to enter into the <code>nat.rec (*here* nat.succ k)</code></p>



<a name="199706567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706567">(Jun 04 2020 at 05:26)</a>:</h4>
<p>That's a lemma</p>



<a name="199706582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706582">(Jun 04 2020 at 05:27)</a>:</h4>
<p>more simply stated as <code>pred (trunc_sub m n) = trunc_sub (pred m) n</code></p>



<a name="199706586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706586">(Jun 04 2020 at 05:27)</a>:</h4>
<p>which you have to prove by induction</p>



<a name="199706593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706593">(Jun 04 2020 at 05:27)</a>:</h4>
<p>Aha! Yes, I was missing that.</p>



<a name="199706649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706649">(Jun 04 2020 at 05:28)</a>:</h4>
<p>I tried looking at the source for <code>add_right_neg</code> and learn from that. Thanks for the guidance, I'll try proving the lemma first.</p>



<a name="199706652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706652">(Jun 04 2020 at 05:28)</a>:</h4>
<p>it generalizes to <code>trunc_sub (trunc_sub m n) k = trunc_sub m (n + k)</code></p>



<a name="199706688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706688">(Jun 04 2020 at 05:29)</a>:</h4>
<p>(By the way, you presumably know that <code>trunc_sub</code> is also known as <code>-</code>)</p>



<a name="199706755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706755">(Jun 04 2020 at 05:31)</a>:</h4>
<p>Yeah, other than the nasty thing about it that <code>succ (pred n) = succ (pred m)</code> does not imply <code>n = m</code>, so <code>succ (trunc_sub m n)</code> doesn't have to equal <code>trunc_sub (succ m) n</code>.</p>



<a name="199706823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199706823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199706823">(Jun 04 2020 at 05:32)</a>:</h4>
<p>Because <code>pred 0 = 0</code> and <code>pred 1 = 0</code>.</p>



<a name="199707178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199707178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199707178">(Jun 04 2020 at 05:42)</a>:</h4>
<p>On this topic, why does using <code>unfold</code> work but <code>rw</code> does not work?</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">pred_trunc_sub</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">pred</span> <span class="o">(</span><span class="n">trunc_sub</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">trunc_sub</span> <span class="o">(</span><span class="n">pred</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">k</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">trunc_sub</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">hn</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="199708373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199708373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199708373">(Jun 04 2020 at 06:05)</a>:</h4>
<p>My current solution is below. Please let me know if there are better stylistic or semantic choices.</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">my_sub_self</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">trunc_sub</span> <span class="n">n</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">k</span> <span class="n">hn</span><span class="o">,</span>
<span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">pred_succ</span> <span class="n">k</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
<span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">pred_trunc_sub</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span> <span class="c1">--pred_trunc_sub (m n : nat) : pred (trunc_sub m n) = trunc_sub (pred m) n</span>
<span class="n">rw</span> <span class="n">pred_succ</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">trunc_sub</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">hn</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="199709601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199709601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199709601">(Jun 04 2020 at 06:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub/near/199706755">said</a>:</p>
<blockquote>
<p>Yeah, other than the nasty thing about it that <code>succ (pred n) = succ (pred m)</code> does not imply <code>n = m</code>, so <code>succ (trunc_sub m n)</code> doesn't have to equal <code>trunc_sub (succ m) n</code>.</p>
</blockquote>
<p>That's why the lemma is about <code>pred</code> and not <code>succ</code>. You can view <code>trunc_sub m n</code> as <code>pred^[n] m</code>, and so it has nice additivity properties with respect to <code>n</code>, irrespective of what <code>pred</code> does</p>



<a name="199709810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199709810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199709810">(Jun 04 2020 at 06:32)</a>:</h4>
<blockquote>
<p>On this topic, why does using unfold work but rw does not work?</p>
</blockquote>
<p>You can see that <code>unfold</code> does rather more than just unfold <code>trunc_sub</code>, because it is actually <code>simp</code> with special configuration options and it does some beta/iota reduction when it can</p>



<a name="199709824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199709824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199709824">(Jun 04 2020 at 06:33)</a>:</h4>
<p>notice that <code>unfold</code> turns the statement into something about <code>rec</code> instead of <code>rec_on</code></p>



<a name="199709835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199709835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199709835">(Jun 04 2020 at 06:33)</a>:</h4>
<p><code>rw</code> is just using the definition for <code>trunc_sub</code></p>



<a name="199709909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199709909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199709909">(Jun 04 2020 at 06:34)</a>:</h4>
<p>Stylistically, you could write the proof like so:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">pred_trunc_sub</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">pred</span> <span class="o">(</span><span class="n">trunc_sub</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">trunc_sub</span> <span class="o">(</span><span class="n">pred</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">k</span> <span class="n">hn</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">unfold</span> <span class="n">trunc_sub</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hn</span><span class="o">,</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">my_sub_self</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">trunc_sub</span> <span class="n">n</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">k</span> <span class="n">hn</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">pred_succ</span> <span class="n">k</span><span class="o">,</span> <span class="err">←</span> <span class="n">pred_trunc_sub</span><span class="o">,</span> <span class="n">pred_succ</span><span class="o">]</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">trunc_sub</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hn</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="199709997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199709997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199709997">(Jun 04 2020 at 06:36)</a>:</h4>
<p>If I want to avoid using simp for pedagogical purposes, what would be the way to invoke the beta and iota reduction after <code>rw</code>, like the transformation of <code>rec_on</code> to <code>rec</code> and the application of <code>pred</code> in the right place? Thanks for the style tips!</p>



<a name="199710110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199710110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199710110">(Jun 04 2020 at 06:39)</a>:</h4>
<p>But actually the use of <code>nat.rec_on</code> is itself non-idiomatic. You get better equations and better presentation by using the equation compiler:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">trunc_sub</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pred</span> <span class="o">(</span><span class="n">trunc_sub</span> <span class="n">n</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">pred_trunc_sub</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">pred</span> <span class="o">(</span><span class="n">trunc_sub</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">trunc_sub</span> <span class="o">(</span><span class="n">pred</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">k</span> <span class="n">hn</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">trunc_sub</span><span class="o">,</span> <span class="n">trunc_sub</span><span class="o">,</span> <span class="n">hn</span><span class="o">],</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">my_sub_self</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">trunc_sub</span> <span class="n">n</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">k</span> <span class="n">hn</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">trunc_sub</span><span class="o">,</span> <span class="n">pred_trunc_sub</span><span class="o">,</span> <span class="n">pred_succ</span><span class="o">,</span> <span class="n">hn</span><span class="o">],</span>
<span class="kn">end</span>
</code></pre></div>



<a name="199710208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199710208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199710208">(Jun 04 2020 at 06:41)</a>:</h4>
<p>and you can express the inductive proofs using the equation compiler as well, resulting in this mathlib-esque proof:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">pred_trunc_sub</span> <span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">pred</span> <span class="o">(</span><span class="n">trunc_sub</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">trunc_sub</span> <span class="o">(</span><span class="n">pred</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">trunc_sub</span><span class="o">,</span> <span class="n">trunc_sub</span><span class="o">,</span> <span class="n">pred_trunc_sub</span><span class="o">]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">my_sub_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">trunc_sub</span> <span class="n">n</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">trunc_sub</span><span class="o">,</span> <span class="n">pred_trunc_sub</span><span class="o">,</span> <span class="n">pred_succ</span><span class="o">,</span> <span class="n">my_sub_self</span><span class="o">]</span>
</code></pre></div>



<a name="199710239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199710239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199710239">(Jun 04 2020 at 06:42)</a>:</h4>
<p>Ah, cool! The TPIL document's <code>add</code> example is using <code>nat.rec_on</code>, so I stuck with it:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="n">m</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">add_m_n</span><span class="o">,</span> <span class="n">succ</span> <span class="n">add_m_n</span><span class="o">)</span>
</code></pre></div>



<a name="199710295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199710295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199710295">(Jun 04 2020 at 06:43)</a>:</h4>
<p>The problem with definitions using <code>nat.rec_on</code> directly is that the equation you get for it is <code>add m n = nat.rec_on n m (λ n add_m_n, succ add_m_n)</code>, when the equations you would like are <code>add m 0 = m</code> and <code>add m (succ n) = succ (add m n)</code></p>



<a name="199710373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199710373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199710373">(Jun 04 2020 at 06:44)</a>:</h4>
<p>You can prove these equations yourself of course (by <code>rfl</code>), and if you use them to rewrite instead of unfolding the <code>rec_on</code> definition everything goes more smoothly because you don't have that big recursor term appearing. If you use the equation compiler to write your definition this happens automatically</p>



<a name="199710612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199710612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199710612">(Jun 04 2020 at 06:48)</a>:</h4>
<p>When developing new definitions and theorems, is it an incremental improvement approach of first doing a tactic style <code>begin ... end</code> and then refactoring to an equation compiler, or just internalize using the eq compiler from the get-go?</p>



<a name="199710667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199710667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199710667">(Jun 04 2020 at 06:49)</a>:</h4>
<p>I would probably write a proof in tactic style first and then refactor if at the end of it I can see that I didn't really make much use of the flexibility of tactic mode</p>



<a name="199710724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199710724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199710724">(Jun 04 2020 at 06:50)</a>:</h4>
<p>but there is nothing wrong with a tactic proof by <code>induction</code>. Other methods are sometimes shorter and sometimes not</p>



<a name="199710780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20proof%20on%20n%20for%20TPIL%20exercise%207.10.1%20trunc_sub/near/199710780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20proof.20on.20n.20for.20TPIL.20exercise.207.2E10.2E1.20trunc_sub.html#199710780">(Jun 04 2020 at 06:51)</a>:</h4>
<p>Got it. Thanks for the walkthrough! I'll try these ideas with the <code>length</code> and <code>reverse</code> exercises.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
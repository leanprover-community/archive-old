---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html">filtering on a predicate with quantifiers</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="257405570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257405570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257405570">(Oct 13 2021 at 17:32)</a>:</h4>
<p>i'm still working on what i was yesterday, this is the first issue i'm stuck on.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">bitnode</span> <span class="o">:=</span>
  <span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
  <span class="o">(</span><span class="n">indices</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">))</span> <span class="c1">--these pointers indicate what it is connected to</span>
  <span class="o">(</span><span class="n">isconstant</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
  <span class="o">(</span><span class="n">considered</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">gatenode</span> <span class="o">:=</span>
  <span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">valence</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">possib</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span> <span class="n">vector</span> <span class="n">bool</span> <span class="n">valence</span><span class="o">))</span>
  <span class="o">(</span><span class="n">state</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">×</span> <span class="o">(</span><span class="n">vector</span> <span class="o">(</span><span class="n">bool</span><span class="o">)</span> <span class="n">valence</span><span class="o">))</span> <span class="c1">--the fst of this indicates that the front of consideration has passed the node</span>
  <span class="o">(</span><span class="n">indices</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">ℕ</span> <span class="n">valence</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">tables</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">)(</span><span class="n">g</span><span class="o">:</span> <span class="n">ℕ</span> <span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>  <span class="c1">--make a table listing all the ways that nextbits could be,</span>
                                                              <span class="c1">--given the last table in s.tablesequence and the gate at index g</span>
<span class="k">let</span> <span class="n">set</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span>  <span class="o">:=</span>
<span class="n">list.erase_dup</span> <span class="o">(</span><span class="n">list.append</span> <span class="n">s.nextbits</span> <span class="o">((([</span><span class="n">g</span><span class="o">]</span><span class="bp">.</span><span class="n">filter_map</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.gts</span><span class="o">))</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span><span class="n">true</span><span class="o">)</span> <span class="o">)</span><span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span><span class="n">x.indices.1</span><span class="o">))</span> <span class="o">)</span>
<span class="k">in</span>
  <span class="o">(</span><span class="n">set</span><span class="o">,(</span>
    <span class="k">let</span>
    <span class="n">subset</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">list.filter</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span> <span class="o">,(</span>        <span class="c1">--why does this fail?</span>
      <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s.bts</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">:</span> <span class="n">ℕ</span> <span class="o">,</span> <span class="n">d</span>  <span class="bp">∈</span>  <span class="o">([</span><span class="n">nat.sub</span> <span class="n">s.tablesequence.length</span> <span class="mi">1</span><span class="o">]</span><span class="bp">.</span><span class="n">filter_map</span><span class="o">(</span><span class="n">list.nth</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="o">)</span><span class="bp">.</span><span class="n">head.2</span><span class="o">,</span>
      <span class="n">list.nth</span> <span class="n">s.bts</span> <span class="o">(</span><span class="n">list.nth</span> <span class="o">(([</span><span class="n">g</span><span class="o">]</span><span class="bp">.</span><span class="n">filter_map</span><span class="o">(</span><span class="n">list.nth</span> <span class="n">s.gts</span><span class="o">))</span><span class="bp">.</span><span class="n">head.indices.1</span><span class="o">)</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>
      <span class="bp">→</span> <span class="n">list.nth</span> <span class="n">s.bts</span> <span class="o">(</span><span class="n">list.nth</span> <span class="o">(([</span><span class="n">nat.sub</span> <span class="n">s.tablesequence.length</span> <span class="mi">1</span><span class="o">]</span><span class="bp">.</span><span class="n">filter_map</span><span class="o">(</span><span class="n">list.nth</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="o">)</span><span class="bp">.</span><span class="n">head.1</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>
      <span class="bp">→</span> <span class="bp">¬</span> <span class="n">list.nth</span> <span class="n">d</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">x</span>
      <span class="o">)</span> <span class="o">)</span>
     <span class="o">(</span><span class="n">gatenode.possib</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.gts</span> <span class="n">g</span><span class="o">)),</span>
    <span class="n">expset</span> <span class="o">:</span> <span class="n">list</span> <span class="n">list</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">list.foldr</span> <span class="bp">λ</span><span class="n">z</span><span class="o">,(</span><span class="n">list.concat</span> <span class="n">z</span><span class="o">)</span> <span class="o">[]</span> <span class="o">(</span><span class="n">list.map</span> <span class="bp">λ</span><span class="n">x</span><span class="o">,(</span> <span class="n">list.map</span> <span class="bp">λ</span><span class="n">y</span><span class="o">,(</span><span class="n">list.append</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span>
    <span class="o">(</span><span class="n">prod.snd</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.tablesequence</span> <span class="o">(</span><span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">subset</span><span class="o">))</span>
    <span class="k">in</span>
    <span class="n">list.erase_dup</span> <span class="o">(</span><span class="n">list.transpose</span> <span class="o">(</span><span class="n">list.map</span> <span class="n">prod.snd</span> <span class="o">(</span><span class="n">list.erase_dup</span> <span class="o">(</span> <span class="n">list.filter</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span> <span class="o">(</span><span class="n">list.fst</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">set</span><span class="o">))))</span>
    <span class="n">list.zip</span> <span class="o">(</span> <span class="n">list.append</span> <span class="o">(</span><span class="n">prod.fst</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.tablesequence</span> <span class="o">(</span><span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="mi">1</span><span class="o">)))</span>
    <span class="o">(</span><span class="n">gatenode.indices</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.gts</span> <span class="n">g</span><span class="o">))</span> <span class="o">)</span> <span class="n">list.transpose</span> <span class="o">(</span><span class="n">list.erase_dup</span> <span class="n">expset</span><span class="o">)</span> <span class="o">)</span> <span class="o">)</span> <span class="o">)</span> <span class="o">)</span>
  <span class="o">))</span>
</code></pre></div>



<a name="257413064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257413064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257413064">(Oct 13 2021 at 18:21)</a>:</h4>
<p>you are missing some imports</p>



<a name="257415069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257415069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257415069">(Oct 13 2021 at 18:33)</a>:</h4>
<p>the imports are exactly the same as before. what am i missing?</p>



<a name="257415270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257415270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257415270">(Oct 13 2021 at 18:34)</a>:</h4>
<p>when making a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> it is good to put all the imports in, instead of making people follow along with the history, especially if you change topics/streams</p>



<a name="257415690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257415690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257415690">(Oct 13 2021 at 18:36)</a>:</h4>
<p>Here's some cleanup; the types aren't quite working yet. I don't know how you can write so much code with such a high density of syntax errors... You should address the syntax errors before you continue on to more stuff, or else you will just get uninformative errors from lean</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list</span>
<span class="kn">import</span> <span class="n">data.vector.basic</span>
<span class="kn">import</span> <span class="n">data.prod</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span><span class="o">:</span> <span class="kt">Type</span>

<span class="kd">@[derive inhabited]</span>
<span class="kd">structure</span> <span class="n">bitnode</span> <span class="o">:=</span>
  <span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
  <span class="o">(</span><span class="n">indices</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">))</span> <span class="c1">--these pointers indicate what it is connected to</span>
  <span class="o">(</span><span class="n">isconstant</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
  <span class="o">(</span><span class="n">considered</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>

<span class="kd">@[derive inhabited]</span>
<span class="kd">structure</span> <span class="n">gatenode</span> <span class="o">:=</span>
  <span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">valence</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">possib</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span> <span class="n">vector</span> <span class="n">bool</span> <span class="n">valence</span><span class="o">))</span>
  <span class="o">(</span><span class="n">state</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">×</span> <span class="o">(</span><span class="n">vector</span> <span class="o">(</span><span class="n">bool</span><span class="o">)</span> <span class="n">valence</span><span class="o">))</span> <span class="c1">--the fst of this indicates that the front of consideration has passed the node</span>
  <span class="o">(</span><span class="n">indices</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">ℕ</span> <span class="n">valence</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">satnet</span> <span class="o">:=</span>  <span class="c1">--i use an undirected graph representation of a sat instance,</span>
                     <span class="c1">--implemented as lists with indices as pointers</span>
<span class="n">mk</span><span class="o">::</span> <span class="o">(</span><span class="n">bts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">bitnode</span><span class="o">)(</span><span class="n">gts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">gatenode</span><span class="o">)</span>
<span class="o">(</span><span class="n">nextbits</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)(</span><span class="n">nextgates</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)(</span><span class="n">table</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">))</span>
<span class="o">(</span><span class="n">tablesequence</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)))</span>

<span class="kd">def</span> <span class="n">tables</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">satnet</span><span class="o">)(</span><span class="n">g</span><span class="o">:</span> <span class="n">ℕ</span> <span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>  <span class="c1">--make a table listing all the ways that nextbits could be,</span>
                                                              <span class="c1">--given the last table in s.tablesequence and the gate at index g</span>
<span class="k">let</span> <span class="n">set</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="o">:=</span>
  <span class="n">list.erase_dup</span> <span class="o">(</span><span class="n">s.nextbits</span> <span class="bp">++</span> <span class="o">(([</span><span class="n">g</span><span class="o">]</span><span class="bp">.</span><span class="n">filter_map</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.gts</span><span class="o">))</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span><span class="n">true</span><span class="o">)</span> <span class="o">)</span><span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span><span class="n">x.indices.1</span><span class="o">))</span>
<span class="k">in</span>
  <span class="o">(</span><span class="n">set</span><span class="o">,</span>
    <span class="k">let</span>
    <span class="n">subset</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
      <span class="o">(</span><span class="n">gatenode.possib</span> <span class="o">(</span><span class="n">list.inth</span> <span class="n">s.gts</span> <span class="n">g</span><span class="o">))</span><span class="bp">.</span><span class="n">filter</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
        <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">s.bts</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="n">c</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">s.tablesequence.inth</span> <span class="o">(</span><span class="n">s.tablesequence.length</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span>
         <span class="n">s.bts.inth</span> <span class="o">(</span><span class="n">list.inth</span> <span class="o">(([</span><span class="n">g</span><span class="o">]</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">list.inth</span> <span class="n">s.gts</span><span class="o">))</span><span class="bp">.</span><span class="n">head.indices.1</span><span class="o">)</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>
        <span class="bp">→</span>  <span class="n">s.bts.inth</span> <span class="o">(</span><span class="n">list.inth</span> <span class="o">(</span><span class="n">s.tablesequence.inth</span> <span class="o">(</span><span class="n">s.tablesequence.length</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>
        <span class="bp">→</span> <span class="bp">¬</span> <span class="n">list.inth</span> <span class="n">d</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">expset</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
      <span class="n">list.foldr</span> <span class="o">(</span><span class="bp">λ</span><span class="n">z</span><span class="o">,</span> <span class="n">list.concat</span> <span class="n">z</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">$</span>
        <span class="n">list.map</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="n">list.map</span> <span class="o">(</span><span class="bp">λ</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">++</span> <span class="n">y</span><span class="o">))</span>
          <span class="o">(</span><span class="n">s.tablesequence.inth</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.tablesequence</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span> <span class="n">subset</span>
    <span class="k">in</span>
    <span class="n">list.erase_dup</span> <span class="o">(</span><span class="n">list.transpose</span> <span class="o">(</span><span class="n">list.map</span> <span class="n">prod.snd</span> <span class="o">(</span><span class="n">list.erase_dup</span> <span class="o">(</span> <span class="n">list.filter</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,(</span> <span class="o">(</span><span class="n">list.fst</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">set</span><span class="o">))))</span>
    <span class="n">list.zip</span> <span class="o">(</span> <span class="n">list.append</span> <span class="o">(</span><span class="n">prod.fst</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.tablesequence</span> <span class="o">(</span><span class="n">nat.sub</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">s.tablesequence</span><span class="o">)</span> <span class="mi">1</span><span class="o">)))</span>
    <span class="o">(</span><span class="n">gatenode.indices</span> <span class="o">(</span><span class="n">list.nth</span> <span class="n">s.gts</span> <span class="n">g</span><span class="o">))</span> <span class="o">)</span> <span class="n">list.transpose</span> <span class="o">(</span><span class="n">list.erase_dup</span> <span class="n">expset</span><span class="o">)</span> <span class="o">)</span> <span class="o">)</span> <span class="o">)</span> <span class="o">)</span>
  <span class="o">))</span>
</code></pre></div>



<a name="257415799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257415799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257415799">(Oct 13 2021 at 18:37)</a>:</h4>
<p>By using <code>@[derive inhabited]</code> on all the types, it means we can use <code>list.inth</code> instead of struggling with <code>list.nth</code> all the time</p>



<a name="257418381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257418381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257418381">(Oct 13 2021 at 18:54)</a>:</h4>
<p>Okay, here's a version that works, except for a decidability requirement because you are filtering by a predicate that has an unbounded quantification <code>∀ (b c: ℕ),</code> in it</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- make a table listing all the ways that nextbits could be,</span>
<span class="c1">-- given the last table in s.tablesequence and the gate at index g</span>
<span class="kd">def</span> <span class="n">tables</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">satnet</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">set</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">s.nextbits</span> <span class="bp">++</span> <span class="o">(</span><span class="n">s.gts.inth</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">indices.1</span><span class="o">)</span><span class="bp">.</span><span class="n">erase_dup</span> <span class="k">in</span>
<span class="o">(</span><span class="n">set</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">subset</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">((</span><span class="n">s.gts.inth</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">possib.map</span> <span class="n">subtype.val</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
      <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">s.bts</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="n">c</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="bp">∈</span> <span class="n">s.tablesequence.last'.iget.2</span><span class="o">),</span>
      <span class="n">s.bts.inth</span> <span class="o">((</span><span class="n">s.gts.inth</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">indices.1.inth</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>
      <span class="bp">→</span>  <span class="n">s.bts.inth</span> <span class="o">(</span><span class="n">s.tablesequence.last'.iget.1.inth</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>
      <span class="bp">→</span> <span class="bp">¬</span> <span class="n">list.inth</span> <span class="o">(</span><span class="gr">sorry</span> <span class="c">/-</span><span class="cm">d-/</span><span class="o">)</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">x</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">expset</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">subset.bind</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">s.tablesequence.last'.iget.2.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">++</span> <span class="n">y</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">list.erase_dup</span> <span class="bp">$</span> <span class="n">list.transpose</span> <span class="bp">$</span> <span class="n">list.map</span> <span class="n">prod.snd</span> <span class="bp">$</span> <span class="n">list.erase_dup</span> <span class="bp">$</span>
  <span class="n">list.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x.1</span> <span class="bp">∈</span> <span class="n">set</span><span class="o">)</span> <span class="bp">$</span>
    <span class="o">(</span><span class="n">s.tablesequence.last'.iget.1</span> <span class="bp">++</span> <span class="o">(</span><span class="n">s.gts.inth</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">indices.1</span><span class="o">)</span><span class="bp">.</span><span class="n">zip</span> <span class="n">expset.erase_dup.transpose</span><span class="o">)</span>
</code></pre></div>



<a name="257418461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257418461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257418461">(Oct 13 2021 at 18:55)</a>:</h4>
<p>also the use of <code>d</code> at the <code>sorry</code> is a type error</p>



<a name="257419828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257419828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257419828">(Oct 13 2021 at 19:04)</a>:</h4>
<p>why isnt d being used directly there</p>



<a name="257419854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257419854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257419854">(Oct 13 2021 at 19:04)</a>:</h4>
<p>I commented it out since it's not the right type</p>



<a name="257419894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257419894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257419894">(Oct 13 2021 at 19:04)</a>:</h4>
<p>I don't understand the code well enough to suggest a fix</p>



<a name="257419985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257419985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257419985">(Oct 13 2021 at 19:05)</a>:</h4>
<p>but <code>d</code> has type <code>list bool</code> and the <code>sorry</code> has type <code>list (list bool)</code></p>



<a name="257420054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257420054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257420054">(Oct 13 2021 at 19:06)</a>:</h4>
<p>it could also be that <code>x</code> has the wrong type (it is <code>list bool</code>)</p>



<a name="257420152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257420152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257420152">(Oct 13 2021 at 19:06)</a>:</h4>
<p>both x and d should have type list bool</p>



<a name="257420196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257420196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257420196">(Oct 13 2021 at 19:06)</a>:</h4>
<p>then what does it mean to say <code>d.inth c = x</code>?</p>



<a name="257420380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257420380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257420380">(Oct 13 2021 at 19:08)</a>:</h4>
<p>with d being the row of the truth table, c picks out the column</p>



<a name="257420397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257420397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257420397">(Oct 13 2021 at 19:08)</a>:</h4>
<p>that's a bool</p>



<a name="257420437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257420437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257420437">(Oct 13 2021 at 19:08)</a>:</h4>
<p>whats a bool</p>



<a name="257420443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257420443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257420443">(Oct 13 2021 at 19:08)</a>:</h4>
<p>so why is it being equated to <code>x</code> which is a list bool</p>



<a name="257420465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257420465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257420465">(Oct 13 2021 at 19:08)</a>:</h4>
<p><code>d.inth c = x</code> is a type error</p>



<a name="257420738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257420738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257420738">(Oct 13 2021 at 19:10)</a>:</h4>
<p>i should have equated it to an element of x</p>



<a name="257420877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257420877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jared green <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257420877">(Oct 13 2021 at 19:11)</a>:</h4>
<p>that with the index b</p>



<a name="257421631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/filtering%20on%20a%20predicate%20with%20quantifiers/near/257421631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/filtering.20on.20a.20predicate.20with.20quantifiers.html#257421631">(Oct 13 2021 at 19:17)</a>:</h4>
<p>ok, this typechecks</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">tables</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">satnet</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">set</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">s.nextbits</span> <span class="bp">++</span> <span class="o">(</span><span class="n">s.gts.inth</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">indices.1</span><span class="o">)</span><span class="bp">.</span><span class="n">erase_dup</span> <span class="k">in</span>
<span class="o">(</span><span class="n">set</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">subset</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">((</span><span class="n">s.gts.inth</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">possib.map</span> <span class="n">subtype.val</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
      <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">s.bts</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&lt;</span> <span class="n">x.length</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="bp">∈</span> <span class="n">s.tablesequence.last'.iget.2</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="bp">&lt;</span> <span class="n">list.length</span> <span class="n">d</span><span class="o">),</span>
        <span class="n">s.bts.inth</span> <span class="o">((</span><span class="n">s.gts.inth</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">indices.1.inth</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">→</span>
        <span class="n">s.bts.inth</span> <span class="o">(</span><span class="n">s.tablesequence.last'.iget.1.inth</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">→</span>
        <span class="bp">¬</span> <span class="n">d.inth</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">x.inth</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">expset</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">subset.bind</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">s.tablesequence.last'.iget.2.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">++</span> <span class="n">y</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">list.erase_dup</span> <span class="bp">$</span> <span class="n">list.transpose</span> <span class="bp">$</span> <span class="n">list.map</span> <span class="n">prod.snd</span> <span class="bp">$</span> <span class="n">list.erase_dup</span> <span class="bp">$</span>
  <span class="n">list.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x.1</span> <span class="bp">∈</span> <span class="n">set</span><span class="o">)</span> <span class="bp">$</span>
    <span class="o">(</span><span class="n">s.tablesequence.last'.iget.1</span> <span class="bp">++</span> <span class="o">(</span><span class="n">s.gts.inth</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">indices.1</span><span class="o">)</span><span class="bp">.</span><span class="n">zip</span> <span class="n">expset.erase_dup.transpose</span><span class="o">)</span>
</code></pre></div>
<p>Double check the bounds on <code>b</code> and <code>c</code>. There are two equalities of <code>bitnode</code>s here (<code>a</code> is a <code>bitnode</code>), so you have to <code>derive decidable_eq</code> on bitnode to make it work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[derive [inhabited, decidable_eq]</span><span class="o">]</span>
<span class="kd">structure</span> <span class="n">bitnode</span> <span class="o">:=</span>
  <span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
  <span class="o">(</span><span class="n">indices</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">))</span> <span class="c1">--these pointers indicate what it is connected to</span>
  <span class="o">(</span><span class="n">isconstant</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
  <span class="o">(</span><span class="n">considered</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
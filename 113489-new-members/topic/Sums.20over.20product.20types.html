---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Sums.20over.20product.20types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html">Sums over product types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="201787474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201787474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201787474">(Jun 23 2020 at 21:42)</a>:</h4>
<p>Am I missing something that I can use from Pi lemmas? Or are there lemmas missing about pair types? I'm trying to prove lemmas about higher-dim dot products, and am hitting issues proving the following generalized lemma:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">u</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">v</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">×</span> <span class="n">v</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">u</span><span class="o">),</span> <span class="err">∑</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">v</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="err">∑</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">×</span> <span class="n">v</span><span class="o">),</span> <span class="n">f</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_product</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">},</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>It's getting into the morass of fintype.elems and finsets.</p>



<a name="201787938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201787938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201787938">(Jun 23 2020 at 21:46)</a>:</h4>
<p>This'll probably be <code>refl</code> after <code>rw &lt;- finset.sum_product</code>. I don't think it's in the library already and it should be added.</p>



<a name="201787992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201787992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201787992">(Jun 23 2020 at 21:46)</a>:</h4>
<p>It won't be <code>refl</code> actually.</p>



<a name="201788148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201788148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201788148">(Jun 23 2020 at 21:48)</a>:</h4>
<p>It is <code>refl</code></p>



<a name="201789470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201789470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201789470">(Jun 23 2020 at 22:01)</a>:</h4>
<p>Do you think it should be in mathlib in this forward, or in the backward direction?</p>



<a name="201789549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201789549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201789549">(Jun 23 2020 at 22:02)</a>:</h4>
<p>It's been my recent experience that there aren't a lot of lemmas that work directly on pair types, so perhaps expanding out the pair into the double sum is the better direction.</p>



<a name="201789689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201789689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201789689">(Jun 23 2020 at 22:03)</a>:</h4>
<p>It should be the same direction as <code>finset.sum_product</code></p>



<a name="201791709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201791709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201791709">(Jun 23 2020 at 22:24)</a>:</h4>
<p>And where would it go? <code>algebra.big_operators</code> has no lemmas that utilize <code>[fintype \a]</code>. Would it be alright to change the imports to introduce <code>fintype</code>?</p>



<a name="201795924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201795924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201795924">(Jun 23 2020 at 23:11)</a>:</h4>
<p>Those lemmas are in <code>data.fintype</code> I think</p>



<a name="201808628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201808628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201808628">(Jun 24 2020 at 03:29)</a>:</h4>
<p>Thanks for that guidance. Using that now-defined lemma, I'm trying to prove the equivalent of <code>fin.sum_univ_succ</code> for pair types, and am running into issues, culminating in getting fin to nat coercion to work. My computer has been crashing on memory with Lean and VSCode, so I've had to limit it's available memory. This prevents me from using library_search, so I'm relying a lot on <code>refine _</code> suggested by <code>suggest</code>. I'm sure this proof can be cleaned up a lot. But the current issue is the final coercion from nat to fin back to nat. It could also be that this has been proved in a more general way for some <code>\Pi u</code> type, I just don't know how to find it, or how to specialize it for pairs. I'd be happy to develop the more general <code>\Pi</code> version if I better understood how pi_finsets work.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="kn">notation</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">sum_prod</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">u</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">v</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">×</span> <span class="n">v</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">u</span><span class="o">),</span> <span class="err">∑</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">v</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="err">∑</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">×</span> <span class="n">v</span><span class="o">),</span> <span class="n">f</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_product</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">u</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">u</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
   <span class="err">∑</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">u</span><span class="o">),</span> <span class="n">v</span> <span class="n">p</span> <span class="bp">=</span>
   <span class="err">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">u</span><span class="o">),</span> <span class="n">v</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="bp">+</span> <span class="err">∑</span> <span class="o">(</span><span class="n">ki</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">u</span><span class="o">),</span> <span class="n">v</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">ki</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span> <span class="n">ki</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="bp">&lt;-@</span><span class="n">sum_prod</span> <span class="n">α</span> <span class="bp">_</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">u</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_add_distrib</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">sum_prod</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">fin</span><span class="bp">.</span><span class="n">sum_univ_succ</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="o">((</span><span class="bp">+</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">)))</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="n">v</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">prod</span><span class="bp">.</span><span class="n">eq_iff_fst_eq_snd_eq</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">fin</span><span class="bp">.</span><span class="n">coe_eq_val</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eq_iff_veq</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ_val</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_eq_add_one</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">fin</span><span class="bp">.</span><span class="n">coe_eq_val</span><span class="o">,</span>
    <span class="n">sorry</span> <span class="o">},</span> <span class="c1">-- j_val + 1 = ↑↑(j_val + 1)</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201808715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201808715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201808715">(Jun 24 2020 at 03:31)</a>:</h4>
<p>There might be some cleaner way to do this with <code>finset.prod_image, finset.prod_insert</code>, but I think it would have to be on the pi_finsets</p>



<a name="201814434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201814434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201814434">(Jun 24 2020 at 06:14)</a>:</h4>
<p>Currently there are a bunch of lemmas that need both <code>fintype</code> and <code>big_operators</code> in <code>data.finitype.card</code>. I think that's a reasonably bad name. Probably that file should be renamed to <code>data.fintype.big_operators</code></p>



<a name="201814447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201814447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201814447">(Jun 24 2020 at 06:15)</a>:</h4>
<p>Maybe even better: all those lemmas don't belong in <code>data.*</code></p>



<a name="201814511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201814511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201814511">(Jun 24 2020 at 06:16)</a>:</h4>
<p>I'm not sure if they belong in <code>algebra.*</code> either. I think initially the goal was to have <code>algebra.*</code> mean "algebraic hierarchy" and it should only contain the definitions (of groups, rings, what have you) and the most basic lemmas.<br>
So maybe the bigops stuff should all move to <code>group_theory.*</code></p>



<a name="201815349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201815349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201815349">(Jun 24 2020 at 06:37)</a>:</h4>
<p>Would it make more sense to PR in a couple of small lemmas still into <code>data.fintype.card</code>, and then rearrange later?</p>



<a name="201815361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201815361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201815361">(Jun 24 2020 at 06:37)</a>:</h4>
<p>It might be easier to do the rearrangement when a critical mass has formed</p>



<a name="201815420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201815420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201815420">(Jun 24 2020 at 06:38)</a>:</h4>
<p>Whatever you want. But a "rename a file PR" could also be done right now</p>



<a name="201815440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201815440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201815440">(Jun 24 2020 at 06:38)</a>:</h4>
<p>In any case, I'm still struggling on how to prove:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="err">↑</span><span class="o">((</span><span class="err">↑</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold_coes</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eq_iff_veq</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- x.succ.val = x.val.cast.succ.val.cast.val</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201815474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201815474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201815474">(Jun 24 2020 at 06:39)</a>:</h4>
<p>There's some weird diamond going on with <code>val</code>, <code>cast</code>, and <code>succ</code> where I can't eliminate any of them</p>



<a name="201815743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201815743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201815743">(Jun 24 2020 at 06:44)</a>:</h4>
<p>In which type is that equality taking place?</p>



<a name="201815825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201815825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201815825">(Jun 24 2020 at 06:46)</a>:</h4>
<p>As far as I understand, it should be taking place in <code>fin (n + 1)</code></p>



<a name="201815837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201815837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201815837">(Jun 24 2020 at 06:46)</a>:</h4>
<p><del>but since there is no arrow on the left, it's probably in <code>fin n</code></del></p>



<a name="201815991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201815991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201815991">(Jun 24 2020 at 06:50)</a>:</h4>
<p>So on the rhs you are casting <code>x</code> to <code>fin (n+1)</code>, then taking <code>succ</code>, which moves it to <code>fin (n+2)</code> and then casting back?</p>



<a name="201816004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201816004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201816004">(Jun 24 2020 at 06:51)</a>:</h4>
<p>(deleted)<br>
Whoops, had my cursor in the wrong place.</p>



<a name="201816076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201816076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201816076">(Jun 24 2020 at 06:52)</a>:</h4>
<p>I guess it is in nat after the <code>rw fin.eq_iff_veq</code>, but the statement at the top is in <code>fin (n + 1)</code></p>



<a name="201816166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201816166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201816166">(Jun 24 2020 at 06:55)</a>:</h4>
<p>I think the right hand side is going to <code>fin n --val--&gt; nat --cast--&gt; fin (n + 1) --succ--&gt; fin (n + 1) --val--&gt; nat --cast--&gt; fin (n + 1)</code></p>



<a name="201816452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201816452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201816452">(Jun 24 2020 at 07:00)</a>:</h4>
<p>Right... if possible, I would try to avoid that <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="201816453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201816453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201816453">(Jun 24 2020 at 07:00)</a>:</h4>
<p>Or is it <code>fin n --val--&gt; nat --cast--&gt; fin (n + 1) --succ--&gt; fin (n + 2) --val--&gt; nat --cast--&gt; fin (n + 2)</code></p>



<a name="201816465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201816465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201816465">(Jun 24 2020 at 07:01)</a>:</h4>
<p>It is</p>
<div class="codehilite"><pre><span></span><code>fin n --val--&gt; nat --cast--&gt; fin (n + 1) --succ--&gt; fin (n + 2) --val--&gt; nat --cast--&gt; fin (n + 1)
</code></pre></div>



<a name="201816483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201816483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201816483">(Jun 24 2020 at 07:01)</a>:</h4>
<p>And the cast from <code>nat</code> to <code>fin (? + 1)</code> is taking <code>i</code> to <code>i % (?+1)</code></p>



<a name="201816527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201816527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201816527">(Jun 24 2020 at 07:02)</a>:</h4>
<p>This proof will be a bit messy, because of all those casts</p>



<a name="201816542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201816542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201816542">(Jun 24 2020 at 07:02)</a>:</h4>
<p>Well it goes back to the proof I'm trying to show above, that sums broken up over pair types works out. The current sum lemmas are on plain <code>fin</code> types, and I don't understand how to employ the <code>pi_finset</code> to prove about pairs.</p>



<a name="201816546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201816546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201816546">(Jun 24 2020 at 07:02)</a>:</h4>
<p>hence, maybe it's easier to take a small step back, and see if you can avoid it all together</p>



<a name="201816564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201816564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201816564">(Jun 24 2020 at 07:03)</a>:</h4>
<p>Can you instead use sums over <code>finset.range n</code>?</p>



<a name="201816613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201816613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201816613">(Jun 24 2020 at 07:04)</a>:</h4>
<p>There is also <code>finset.product</code> to take the cartesian product of two finsets</p>



<a name="201819714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201819714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201819714">(Jun 24 2020 at 07:49)</a>:</h4>
<p>I would imagine that any proof which involves some funny map from fin(n+2) to fin(n+1) which is "the right thing for the input you have, but crazy in general" is going to have difficulties, for the same reason that theorems involving natural number subtraction are hard in general, even when the subtraction is "the right subtraction in this situation"</p>



<a name="201819803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201819803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201819803">(Jun 24 2020 at 07:50)</a>:</h4>
<p>Usually I try to refactor subtractions so instead of a-b which is "ok in this situation" I lose the a variable completely and instead use a new variable c such that a=c+b</p>



<a name="201820392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201820392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201820392">(Jun 24 2020 at 07:59)</a>:</h4>
<p>Looking at what you did, it seems very natural; I am surprised this has happened! Your original statement looks sensible, how did we end up with the casts?</p>



<a name="201821339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201821339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201821339">(Jun 24 2020 at 08:11)</a>:</h4>
<p>Aah, I think the statement <em>is</em> bad. It contains <code>example (m : ℕ) (i : fin m) : fin (m+1) := nat.succ i</code>. Maybe <code>i.succ</code> is better?</p>



<a name="201821578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201821578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201821578">(Jun 24 2020 at 08:14)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">u</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">u</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
   <span class="err">∑</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">u</span><span class="o">),</span> <span class="n">v</span> <span class="n">p</span> <span class="bp">=</span>
   <span class="err">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">u</span><span class="o">),</span> <span class="n">v</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="bp">+</span> <span class="err">∑</span> <span class="o">(</span><span class="n">ki</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">u</span><span class="o">),</span> <span class="n">v</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">ki</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span> <span class="n">ki</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="bp">&lt;-@</span><span class="n">sum_prod</span> <span class="n">α</span> <span class="bp">_</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">u</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_add_distrib</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">sum_prod</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">fin</span><span class="bp">.</span><span class="n">sum_univ_succ</span><span class="o">,</span>
  <span class="c1">-- it&#39;s all over</span>
<span class="kn">end</span>
</code></pre></div>


<p>Will this do for you? It's an initial segment of your proof, applied to a different statement.</p>



<a name="201822384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201822384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201822384">(Jun 24 2020 at 08:24)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold_coes</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>This is the glue which relates the proof above to your original statement.</p>



<a name="201822656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201822656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201822656">(Jun 24 2020 at 08:28)</a>:</h4>
<p>Here's a proof of your original statement. I am still a bit confused by all this. Note that it contains a non-terminal simp.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">helper</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold_coes</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>


<span class="kn">example</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">u</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">u</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
   <span class="err">∑</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">u</span><span class="o">),</span> <span class="n">v</span> <span class="n">p</span> <span class="bp">=</span>
   <span class="err">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">u</span><span class="o">),</span> <span class="n">v</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="bp">+</span> <span class="err">∑</span> <span class="o">(</span><span class="n">ki</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">u</span><span class="o">),</span> <span class="n">v</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">ki</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span> <span class="n">ki</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp_rw</span> <span class="n">helper</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">&lt;-@</span><span class="n">sum_prod</span> <span class="n">α</span> <span class="bp">_</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">u</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_add_distrib</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">sum_prod</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">fin</span><span class="bp">.</span><span class="n">sum_univ_succ</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201823578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201823578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201823578">(Jun 24 2020 at 08:40)</a>:</h4>
<p>There's a coercion from nat to <code>fin (nat.succ m)</code> and this is the poorly-behaved map which involves <code>%</code> in general. Avoiding this is the key.</p>



<a name="201826749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201826749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201826749">(Jun 24 2020 at 09:21)</a>:</h4>
<p>My actual problem is at the bottom of the mwe below. Thanks for all the insights. I'd love to hear more comments about how to incorporate this general sum result into the more specific <code>dot_product</code> proof. I think what is blocking that incorporation is that <code>simp_rw</code> which can't be moved further up.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">namespace</span> <span class="n">matrix</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="n">open_locale</span> <span class="n">matrix</span>

<span class="kn">section</span> <span class="n">matrix_notation</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span>

<span class="c">/-</span><span class="cm">- `vec_cons h t` prepends an entry `h` to a vector `t`.</span>

<span class="cm">The inverse functions are `vec_head` and `vec_tail`.</span>
<span class="cm">The notation `![a, b, ...]` expands to `vec_cons a (vec_cons b ...)`.</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">vec_cons</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="k">match</span> <span class="n">p</span> <span class="k">with</span>
<span class="bp">|</span> <span class="bp">⟨⟨</span><span class="mi">0</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="n">i</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">i</span>
<span class="bp">|</span> <span class="bp">⟨⟨</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">i</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">t</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_of_succ_lt_succ</span> <span class="n">hk</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm">- `vec_head v` gives the first entry of the vector `v` -/</span>
<span class="n">def</span> <span class="n">vec_head</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">v</span> <span class="o">(</span><span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_pos&#39;</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span>

<span class="c">/-</span><span class="cm">- `vec_tail v` gives a vector consisting of all entries of `v` except the first -/</span>
<span class="n">def</span> <span class="n">vec_tail</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">v</span> <span class="bp">⟨⟨</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_lt_succ</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">matrix_notation</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">n&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n&#39;</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n&#39;</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span>

<span class="kn">section</span> <span class="n">val</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">cons_val_succ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ix</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">vec_cons</span> <span class="n">x</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span> <span class="n">ix</span><span class="o">)</span> <span class="bp">=</span> <span class="n">u</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">ix</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">vec_cons</span><span class="o">],</span> <span class="n">cases</span> <span class="n">i</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">val</span>

<span class="c">/-</span><span class="cm">- A product over the `univ` of a pair type equals to</span>
<span class="cm">the double product over the `univ`s of the `fst` and `snd` types. -/</span>
<span class="bp">@</span><span class="o">[</span><span class="n">to_additive</span> <span class="s2">&quot;A sum over the `univ` of a pair type equals to</span>
<span class="s2">the double sum over the `univ`s of the `fst` and `snd` types.&quot;</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">prod_product_fintype</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span>
  <span class="err">∏</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="err">∏</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="err">∏</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">prod_product</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kn">section</span> <span class="n">dot_product</span>

<span class="kn">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">cons_dot_product</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dot_product</span> <span class="o">(</span><span class="n">vec_cons</span> <span class="n">x</span> <span class="n">v</span><span class="o">)</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">dot_product</span> <span class="n">x</span> <span class="o">(</span><span class="n">vec_head</span> <span class="n">w</span><span class="o">)</span> <span class="bp">+</span> <span class="n">dot_product</span> <span class="n">v</span> <span class="o">(</span><span class="n">vec_tail</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">dot_product</span><span class="o">,</span> <span class="n">vec_head</span><span class="o">,</span> <span class="n">vec_tail</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fintype</span><span class="bp">.</span><span class="n">sum_product_fintype</span><span class="o">,</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span> <span class="n">ι</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
      <span class="n">fintype</span><span class="bp">.</span><span class="n">sum_product_fintype</span><span class="o">,</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span> <span class="n">ι</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
      <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_add_distrib</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">fin</span><span class="bp">.</span><span class="n">sum_univ_succ</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">cons_val_succ</span><span class="o">],</span>  <span class="c1">-- I wish I could move this further up, but simp_rw doesn&#39;t work higher</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="o">((</span><span class="bp">+</span><span class="o">)</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="o">)))</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="n">w</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">unfold_coes</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">eq_iff_veq</span><span class="o">,</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ_val</span><span class="o">],</span>
  <span class="n">assumption</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="c1">-- this line isn&#39;t needed in my actual file because sum_product_fintype is properly imported</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">dot_product</span>

<span class="kn">end</span> <span class="n">matrix</span>
</code></pre></div>



<a name="201829591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201829591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201829591">(Jun 24 2020 at 09:55)</a>:</h4>
<p>I don't really understand this question -- the code compiles. You don't need all those <code>_</code>s in the rewrite in the last proof; <code>rw</code> will put them in for you.</p>



<a name="201829701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201829701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201829701">(Jun 24 2020 at 09:56)</a>:</h4>
<p>I don't know anything about big operators, I was just intrigued by the puzzle about succ :-)</p>



<a name="201830224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201830224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201830224">(Jun 24 2020 at 10:03)</a>:</h4>
<p>Why is <code>fintype.prod_product_fintype</code> not a valid <code>simp</code> lemma? This looks like the sort of proof <code>simp</code> would be really good at.</p>



<a name="201830651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201830651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201830651">(Jun 24 2020 at 10:09)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">vec_cons</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">⟨⟨</span><span class="mi">0</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="n">i</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">i</span>
<span class="bp">|</span> <span class="bp">⟨⟨</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">i</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">t</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_of_succ_lt_succ</span> <span class="n">hk</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>



<a name="201830685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201830685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201830685">(Jun 24 2020 at 10:09)</a>:</h4>
<p>I think it's better -- better definitional equalities maybe?</p>



<a name="201830692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201830692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201830692">(Jun 24 2020 at 10:09)</a>:</h4>
<p>e.g.</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">cons_val_succ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ix</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">vec_cons</span> <span class="n">x</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span> <span class="n">ix</span><span class="o">)</span> <span class="bp">=</span> <span class="n">u</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">ix</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">i</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>
</code></pre></div>



<a name="201830755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201830755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201830755">(Jun 24 2020 at 10:10)</a>:</h4>
<p>Does this help you?</p>



<a name="201830809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201830809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201830809">(Jun 24 2020 at 10:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> why isn't <code>fintype.prod_product_fintype</code> a valid <code>simp</code> lemma? I want <code>simp</code> to be doing the donkey work here, don't I?</p>



<a name="201830832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201830832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201830832">(Jun 24 2020 at 10:11)</a>:</h4>
<p>what's the statement?</p>



<a name="201830843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201830843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201830843">(Jun 24 2020 at 10:12)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> that change to the definition of <code>vec_cons</code> lets me move the <code>simp_rw</code> up. Have I solved your problem?</p>



<a name="201830890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201830890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201830890">(Jun 24 2020 at 10:12)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm">- A product over the `univ` of a pair type equals to</span>
<span class="cm">the double product over the `univ`s of the `fst` and `snd` types. -/</span>
<span class="bp">@</span><span class="o">[</span><span class="n">to_additive</span> <span class="s2">&quot;A sum over the `univ` of a pair type equals to</span>
<span class="s2">the double sum over the `univ`s of the `fst` and `snd` types.&quot;</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">prod_product_fintype</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span>
  <span class="err">∏</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="err">∏</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="err">∏</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">prod_product</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>
</code></pre></div>



<a name="201830908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201830908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201830908">(Jun 24 2020 at 10:12)</a>:</h4>
<p>Those pis are products not Pi types</p>



<a name="201830946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201830946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201830946">(Jun 24 2020 at 10:13)</a>:</h4>
<p>I don't know about this always being a simp lemma, but you should be able to simp with it</p>



<a name="201830984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201830984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201830984">(Jun 24 2020 at 10:13)</a>:</h4>
<p><code>simp [fintype.sum_product_fintype],</code> -&gt; <code>invalid simplification lemma 'matrix.fintype.sum_product_fintype' (use command 'set_option trace.simp_lemmas true' for more details)</code></p>



<a name="201831037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201831037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201831037">(Jun 24 2020 at 10:14)</a>:</h4>
<div class="codehilite"><pre><span></span><code>[simp_lemmas.invalid] rule derived from &#39;matrix.fintype.sum_product_fintype&#39; contains argument that is (a) not a Prop, (b) not an instance, and (c) not in the LHS of the rule
</code></pre></div>



<a name="201831069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201831069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201831069">(Jun 24 2020 at 10:15)</a>:</h4>
<div class="codehilite"><pre><span></span><code>fintype.sum_product_fintype :
  ∀ {α : Type u_1} {a : Type u_2} {β : Type u_3} {M : Type u_4} [_inst_5 : fintype α] [_inst_6 : add_comm_monoid M]
  [_inst_7 : fintype β] {f : α × β → M}, ∑ (x : α × β), f x = ∑ (x : α) (y : β), f (x, y)
</code></pre></div>



<a name="201831115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201831115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201831115">(Jun 24 2020 at 10:15)</a>:</h4>
<p>oh!</p>



<a name="201831119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201831119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201831119">(Jun 24 2020 at 10:15)</a>:</h4>
<p>what's <code>a</code> doing there</p>



<a name="201831211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201831211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201831211">(Jun 24 2020 at 10:16)</a>:</h4>
<p>I'm surprised the unused arguments linter didn't catch this</p>



<a name="201831376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201831376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201831376">(Jun 24 2020 at 10:19)</a>:</h4>
<p>This is not in mathlib</p>



<a name="201831386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201831386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201831386">(Jun 24 2020 at 10:19)</a>:</h4>
<p>Thanks! I should have linted!</p>



<a name="201834472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201834472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201834472">(Jun 24 2020 at 11:02)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> there's a typo in your definition of <code>fintype.prod_product_fintype</code> -- an <code>{a : Type*}</code> should be <code>{α : Type*}</code>. This explains the random <code>Type</code> goals you get after the rewrite (the <code>assumption, assumption</code> thing). It can now be made into a <code>simp</code> lemma.</p>



<a name="201835191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201835191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201835191">(Jun 24 2020 at 11:12)</a>:</h4>
<p>The linter also points out that you have two <code>has_mul</code> instances for <code>cons_dot_product</code>. Put <code>#lint</code> at the bottom of your file and take a look at the output.</p>



<a name="201886724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201886724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201886724">(Jun 24 2020 at 18:39)</a>:</h4>
<p>Thanks for all the insight! Your suggestions made me think of writing another simp lemma, which now makes these higher-dim dot product proofs pretty nice:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">namespace</span> <span class="n">matrix</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="n">open_locale</span> <span class="n">matrix</span>

<span class="kn">section</span> <span class="n">matrix_notation</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span>

<span class="c">/-</span><span class="cm">- `![]` is the vector with no entries. -/</span>
<span class="n">def</span> <span class="n">vec_empty</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">k</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">fin_zero_elim</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">α</span><span class="o">)</span> <span class="n">k</span>

<span class="c">/-</span><span class="cm">- `vec_cons h t` prepends an entry `h` to a vector `t`.</span>

<span class="cm">The inverse functions are `vec_head` and `vec_tail`.</span>
<span class="cm">The notation `![a, b, ...]` expands to `vec_cons a (vec_cons b ...)`.</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">vec_cons</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">⟨⟨</span><span class="mi">0</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="n">i</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">i</span>
<span class="bp">|</span> <span class="bp">⟨⟨</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">i</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">t</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_of_succ_lt_succ</span> <span class="n">hk</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`!</span><span class="o">[</span><span class="bp">`</span> <span class="n">l</span><span class="o">:(</span><span class="n">foldr</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">vec_cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">vec_empty</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="o">)</span> <span class="o">:=</span> <span class="n">l</span>

<span class="c">/-</span><span class="cm">- `vec_head v` gives the first entry of the vector `v` -/</span>
<span class="n">def</span> <span class="n">vec_head</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">-&gt;</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">v</span> <span class="o">(</span><span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_pos&#39;</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span>

<span class="c">/-</span><span class="cm">- `vec_tail v` gives a vector consisting of all entries of `v` except the first -/</span>
<span class="n">def</span> <span class="n">vec_tail</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">⟨⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">i</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">v</span> <span class="bp">⟨⟨</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">k</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_lt_succ</span> <span class="n">hk</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">i</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">matrix_notation</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">n&#39;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n&#39;</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n&#39;</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span>

<span class="kn">section</span> <span class="n">val</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">cons_val_succ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ix</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">vec_cons</span> <span class="n">x</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span> <span class="n">ix</span><span class="o">)</span> <span class="bp">=</span> <span class="n">u</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">ix</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">i</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">tail_cons&#39;</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ix</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">vec_tail</span> <span class="n">u</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">ix</span><span class="o">)</span> <span class="bp">=</span> <span class="n">u</span> <span class="o">(</span><span class="n">k</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span> <span class="n">ix</span><span class="o">)</span> <span class="o">:=</span>
<span class="c1">-- by { ext i, simp [vec_tail], cases i, cases i_fst, { simp [fin.cases], }, rw cons_val_succ&#39;&#39;,  }</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">k</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">val</span>

<span class="kn">section</span> <span class="n">dot_product</span>

<span class="c">/-</span><span class="cm">- A product over the `univ` of a pair type equals to</span>
<span class="cm">the double product over the `univ`s of the `fst` and `snd` types. -/</span>
<span class="bp">@</span><span class="o">[</span><span class="n">to_additive</span> <span class="s2">&quot;A sum over the `univ` of a pair type equals to</span>
<span class="s2">the double sum over the `univ`s of the `fst` and `snd` types.&quot;</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">prod_product_fintype</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span>
  <span class="err">∏</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="err">∏</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="err">∏</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">prod_product</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kn">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">cons_dot_product</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dot_product</span> <span class="o">(</span><span class="n">vec_cons</span> <span class="n">x</span> <span class="n">v</span><span class="o">)</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">dot_product</span> <span class="n">x</span> <span class="o">(</span><span class="n">vec_head</span> <span class="n">w</span><span class="o">)</span> <span class="bp">+</span> <span class="n">dot_product</span> <span class="n">v</span> <span class="o">(</span><span class="n">vec_tail</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">dot_product</span><span class="o">,</span> <span class="n">vec_head</span><span class="o">,</span> <span class="n">vec_tail</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fintype</span><span class="bp">.</span><span class="n">sum_product_fintype</span><span class="o">,</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span> <span class="n">ι</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
      <span class="n">fintype</span><span class="bp">.</span><span class="n">sum_product_fintype</span><span class="o">,</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span> <span class="n">ι</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
      <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_add_distrib</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">sum_univ_succ</span><span class="o">],</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">dot_product_cons</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dot_product</span> <span class="n">v</span> <span class="o">(</span><span class="n">vec_cons</span> <span class="n">x</span> <span class="n">w</span><span class="o">)</span> <span class="bp">=</span> <span class="n">dot_product</span> <span class="o">(</span><span class="n">vec_head</span> <span class="n">v</span><span class="o">)</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">dot_product</span> <span class="o">(</span><span class="n">vec_tail</span> <span class="n">v</span><span class="o">)</span> <span class="n">w</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">dot_product</span><span class="o">,</span> <span class="n">vec_head</span><span class="o">,</span> <span class="n">vec_tail</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fintype</span><span class="bp">.</span><span class="n">sum_product_fintype</span><span class="o">,</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span> <span class="n">ι</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
      <span class="n">fintype</span><span class="bp">.</span><span class="n">sum_product_fintype</span><span class="o">,</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span> <span class="n">ι</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
      <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_add_distrib</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">congr_arg</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">sum_univ_succ</span><span class="o">],</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">dot_product</span>

<span class="kn">end</span> <span class="n">matrix</span>
</code></pre></div>



<a name="201888195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201888195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201888195">(Jun 24 2020 at 18:49)</a>:</h4>
<p>Even further golfed:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">cons_dot_product</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dot_product</span> <span class="o">(</span><span class="n">vec_cons</span> <span class="n">x</span> <span class="n">v</span><span class="o">)</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">dot_product</span> <span class="n">x</span> <span class="o">(</span><span class="n">vec_head</span> <span class="n">w</span><span class="o">)</span> <span class="bp">+</span> <span class="n">dot_product</span> <span class="n">v</span> <span class="o">(</span><span class="n">vec_tail</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">dot_product</span><span class="o">,</span> <span class="n">vec_head</span><span class="o">,</span> <span class="n">vec_tail</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fintype</span><span class="bp">.</span><span class="n">sum_product_fintype</span><span class="o">,</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span> <span class="n">ι</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
      <span class="n">fintype</span><span class="bp">.</span><span class="n">sum_product_fintype</span><span class="o">,</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span> <span class="n">ι</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
      <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_add_distrib</span><span class="o">],</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">sum_univ_succ</span><span class="o">,</span> <span class="n">tail_cons&#39;</span><span class="o">,</span> <span class="n">cons_val_succ</span><span class="o">]</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">dot_product_cons</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">-&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dot_product</span> <span class="n">v</span> <span class="o">(</span><span class="n">vec_cons</span> <span class="n">x</span> <span class="n">w</span><span class="o">)</span> <span class="bp">=</span> <span class="n">dot_product</span> <span class="o">(</span><span class="n">vec_head</span> <span class="n">v</span><span class="o">)</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">dot_product</span> <span class="o">(</span><span class="n">vec_tail</span> <span class="n">v</span><span class="o">)</span> <span class="n">w</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">dot_product</span><span class="o">,</span> <span class="n">vec_head</span><span class="o">,</span> <span class="n">vec_tail</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fintype</span><span class="bp">.</span><span class="n">sum_product_fintype</span><span class="o">,</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span> <span class="n">ι</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
      <span class="n">fintype</span><span class="bp">.</span><span class="n">sum_product_fintype</span><span class="o">,</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_comm</span> <span class="n">ι</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
      <span class="bp">&lt;-</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_add_distrib</span><span class="o">],</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">sum_univ_succ</span><span class="o">,</span> <span class="n">tail_cons&#39;</span><span class="o">,</span> <span class="n">cons_val_succ</span><span class="o">]</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201888492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201888492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201888492">(Jun 24 2020 at 18:52)</a>:</h4>
<p>I'd been banging my head against the wall for like 4-5 days on these lemmas. And turns out just defining the <code>fintype.prod_product_fintype</code> and <code>tail_cons'</code> was all I needed. Is that a normal proof workflow? I feel like I went down too many wrong paths.</p>



<a name="201888759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201888759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201888759">(Jun 24 2020 at 18:54)</a>:</h4>
<p>I haven't been following the discussion but the last message sounds like you're learning.</p>



<a name="201888883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201888883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201888883">(Jun 24 2020 at 18:55)</a>:</h4>
<p>Without having any idea about the topic of the discussion, I can see uncurried functions and lots of underscores. This doesn't smell good.</p>



<a name="201889076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201889076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201889076">(Jun 24 2020 at 18:57)</a>:</h4>
<p>The uncurried functions are due to my trying to make lemmas about higher-dim "matrices" without having to rewrite them for <code>b -&gt; a</code>, <code>c -&gt; b -&gt; a</code>, <code>d -&gt; c -&gt; b -&gt; a</code>.</p>



<a name="201889196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201889196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201889196">(Jun 24 2020 at 18:58)</a>:</h4>
<p>where the head of those arguments is always a <code>fin n</code>. So my proving over the product type, I can stuff the rest of the arrows all into the <code>\io</code> index type.</p>



<a name="201889340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201889340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201889340">(Jun 24 2020 at 18:59)</a>:</h4>
<p>This is fishy.</p>



<a name="201889430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201889430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201889430">(Jun 24 2020 at 19:00)</a>:</h4>
<p>What do you call higher-dim matrices? Tensors?</p>



<a name="201889730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201889730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201889730">(Jun 24 2020 at 19:02)</a>:</h4>
<p>Yakov yes, this is exactly the workflow for learning Lean. You get interested in something, you work on it, you come up with some <em>concrete Lean code</em> which works, or doesn't quite work, you post it, others look at it and suggest fixes or changes, and proofs just get neater and neater. It doesn't matter how much you understand the material "informally", there is some kind of a knack for getting it into Lean which you learn by doing (writing code) and getting others to look at it. The vast majority of us learnt this way. The power of this chat is that there are a whole bunch of experts on it -- your situation was sufficiently basic that an intermediate user like me could help, but as you get better and maybe more specialised then you ask more challenging questions with your code and experts who know the system inside out give you more subtle answers (e.g. there are very subtle questions which can come up regarding e.g. the type class inference system).</p>



<a name="201890961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201890961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201890961">(Jun 24 2020 at 19:12)</a>:</h4>
<p>I'm a fan of that sort of learning style. The hope is that everyone remains eager to teach each other</p>



<a name="201890985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201890985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201890985">(Jun 24 2020 at 19:12)</a>:</h4>
<p>What do you find fishy about that sort of construction, Patrick?</p>



<a name="201891093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201891093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201891093">(Jun 24 2020 at 19:13)</a>:</h4>
<p>Once could call them tensors, although in a mathlib that seems inappropriate. Higher dim matrices is a numpy style moniker.</p>



<a name="201891163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201891163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201891163">(Jun 24 2020 at 19:14)</a>:</h4>
<p>I thought they were called holors :-)</p>



<a name="201891234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201891234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201891234">(Jun 24 2020 at 19:15)</a>:</h4>
<p>Holors, from what I looked at in the lib, don't have good support for cons, they seemed to me to be more about construct-once at desired shape</p>



<a name="201891443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201891443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201891443">(Jun 24 2020 at 19:17)</a>:</h4>
<p>I'm editing the matrix notation file, and didn't want to write repetitive lemmas about matrices for the ones that were already written about vectors. Seemed to me that they were general statements about cons, head, tail, etc that did not rely on 1- or 2- dimensionality</p>



<a name="201891670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sums%20over%20product%20types/near/201891670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sums.20over.20product.20types.html#201891670">(Jun 24 2020 at 19:19)</a>:</h4>
<p>And also a good way to flex/train my lean programming skills</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Projecting.20Class.20Members.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html">Projecting Class Members</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="214636790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214636790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214636790">(Oct 26 2020 at 21:40)</a>:</h4>
<p>Hello, I defined a class with two members, a binary operation and a unit. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">PMClass</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>
 <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span><span class="o">)</span>
</code></pre></div>

<p>Now, when defining the homomorphism between two instances of the class, I find that a difference in accessing <code>e</code> versus <code>op</code> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">pclasshom</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">p1.e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2.e</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">hom</span> <span class="o">(</span><span class="n">PMClass.op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">PMClass.op</span> <span class="o">(</span><span class="n">hom</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hom</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div>

<p>where qualifying <code>e</code> with the class name does not type check, and qualifying <code>op</code> with the instance name does not type check. <br>
Worth saying, that when changing <code>class</code> into <code>structure</code>, they can both be qualified by the instance name. <br>
So why do they behave differently?</p>



<a name="214637062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214637062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214637062">(Oct 26 2020 at 21:43)</a>:</h4>
<p>Can you give an example of some statement that doesn't type check with the definitions as you have them?</p>



<a name="214637413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214637413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214637413">(Oct 26 2020 at 21:47)</a>:</h4>
<p>Since <code>e</code> does not have any explicit arguments:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">PMClass.e</span>
<span class="c1">-- @[reducible] def PMClass.e : Π {m : Type} [c : PMClass m], m := ...</span>
</code></pre></div>

<p><code>p1.e</code> does not typecheck</p>



<a name="214637547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214637547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214637547">(Oct 26 2020 at 21:48)</a>:</h4>
<p>One of the main points of using classes is so that you don't need to manually write things like <code>p1.e</code>.  E.g.:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">PMClass</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>
 <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">PMClass</span>

<span class="kd">structure</span> <span class="n">pclasshom</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">PMClass</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="n">PMClass</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">hom</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">hom</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hom</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div>



<a name="214638168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214638168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214638168">(Oct 26 2020 at 21:54)</a>:</h4>
<p>Sure.. the following definition is not accepted</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">pclasshom</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">p1.e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2.e</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">hom</span> <span class="o">(</span><span class="n">p1.op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2.op</span> <span class="o">(</span><span class="n">hom</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hom</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div>

<p>And the following one too </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">pclasshom</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">PMClass.e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">PMClass.e</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">hom</span> <span class="o">(</span><span class="n">PMClass.op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">PMClass.op</span> <span class="o">(</span><span class="n">hom</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hom</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div>



<a name="214638418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214638418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214638418">(Oct 26 2020 at 21:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Projecting.20Class.20Members/near/214637413">said</a>:</p>
<blockquote>
<p>Since <code>e</code> does not have any explicit arguments:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">PMClass.e</span>
<span class="c1">-- @[reducible] def PMClass.e : Π {m : Type} [c : PMClass m], m := ...</span>
</code></pre></div>

<p><code>p1.e</code> does not typecheck</p>
</blockquote>
<p>But <code>p1.e</code> actually typechecks, as in the <code>pres</code> axiom. <code>p1.op</code> is the one that doesn't.</p>



<a name="214638480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214638480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214638480">(Oct 26 2020 at 21:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Projecting.20Class.20Members/near/214637547">said</a>:</p>
<blockquote>
<p>One of the main points of using classes is so that you don't need to manually write things like <code>p1.e</code>.  E.g.:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">PMClass</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>
 <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">PMClass</span>

<span class="kd">structure</span> <span class="n">pclasshom</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">PMClass</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="n">PMClass</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">hom</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">hom</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hom</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div>

</blockquote>
<p>Are there any more strong reasons to use one of them over the other?</p>



<a name="214638562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214638562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214638562">(Oct 26 2020 at 21:58)</a>:</h4>
<p>If you don't use <code>[PMClass a]</code> you will always need to manually feed in the <code>PMClass</code> instance whenever you want to use <code>pclasshom</code>.</p>



<a name="214638975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214638975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214638975">(Oct 26 2020 at 22:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Projecting.20Class.20Members/near/214638562">said</a>:</p>
<blockquote>
<p>If you don't use <code>[PMClass a]</code> you will always need to manually feed in the <code>PMClass</code> instance whenever you want to use <code>pclasshom</code>.</p>
</blockquote>
<p>like you would normally do with other theorem provers? I am just asking as my scope is more of uniformity across different systems.</p>



<a name="214639014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214639014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214639014">(Oct 26 2020 at 22:03)</a>:</h4>
<p>Actually, I'm a little surprised that this is okay:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">PMClass</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>
 <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span><span class="o">)</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="kd">class</span><span class="o">]</span> <span class="n">PMClass</span>

<span class="kd">structure</span> <span class="n">pclasshom'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">p1.e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2.e</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">hom</span> <span class="o">(</span><span class="n">p1.op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2.op</span> <span class="o">(</span><span class="n">hom</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hom</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div>

<p>But this is not:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">PMClass</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>
 <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">pclasshom'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">p1.e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2.e</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">hom</span> <span class="o">(</span><span class="n">p1.op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2.op</span> <span class="o">(</span><span class="n">hom</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hom</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div>



<a name="214639072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214639072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214639072">(Oct 26 2020 at 22:03)</a>:</h4>
<p>I always thought that <code>class foo ...</code> was equivalent to <code>structure foo ....</code> + <code>attribute [class] foo</code>, but I guess there are some subtle differences.</p>



<a name="214639182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214639182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214639182">(Oct 26 2020 at 22:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Projecting.20Class.20Members/near/214639014">said</a>:</p>
<blockquote>
<p>Actually, I'm a little surprised that this is okay:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">PMClass</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>
 <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span><span class="o">)</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="kd">class</span><span class="o">]</span> <span class="n">PMClass</span>

<span class="kd">structure</span> <span class="n">pclasshom'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">p1.e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2.e</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">hom</span> <span class="o">(</span><span class="n">p1.op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2.op</span> <span class="o">(</span><span class="n">hom</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hom</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div>

<p>But this is not:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">PMClass</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>
 <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">pclasshom'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">p1.e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2.e</span><span class="o">)</span>
 <span class="o">(</span><span class="n">pres2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">hom</span> <span class="o">(</span><span class="n">p1.op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2.op</span> <span class="o">(</span><span class="n">hom</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hom</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div>

</blockquote>
<p>Absolutely, there is something that needs investigation here.</p>



<a name="214645134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214645134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214645134">(Oct 26 2020 at 23:22)</a>:</h4>
<blockquote>
<p>I always thought that class foo ... was equivalent to structure foo .... + attribute [class] foo, but I guess there are some subtle differences.</p>
</blockquote>
<p><code>class foo</code> is equivalent to <code>@[class] structure foo</code>, not <code>structure foo ... attribute [class] foo</code>. The difference is that the former has the opportunity to change the definitions of the fields</p>



<a name="214645178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214645178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214645178">(Oct 26 2020 at 23:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="358884">Yasmine Sharoda</span> <a href="#narrow/stream/113489-new-members/topic/Projecting.20Class.20Members/near/214638418">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Projecting.20Class.20Members/near/214637413">said</a>:</p>
<blockquote>
<p>Since <code>e</code> does not have any explicit arguments:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">PMClass.e</span>
<span class="c1">-- @[reducible] def PMClass.e : Π {m : Type} [c : PMClass m], m := ...</span>
</code></pre></div>

<p><code>p1.e</code> does not typecheck</p>
</blockquote>
<p>But <code>p1.e</code> actually typechecks, as in the <code>pres</code> axiom. <code>p1.op</code> is the one that doesn't.</p>
</blockquote>
<p>It's not supposed to</p>



<a name="214645261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214645261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214645261">(Oct 26 2020 at 23:24)</a>:</h4>
<p>but there are some funny behaviors when projection notation is used on structure fields, I think lean gets confused and supplies it even though it makes no sense to</p>



<a name="214645426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214645426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214645426">(Oct 26 2020 at 23:27)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">PMClass</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">PMClass.e'</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">m</span><span class="o">]</span> <span class="o">:</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">PMClass.e</span>

<span class="k">#print</span> <span class="n">PMClass.e</span>  <span class="c1">-- def PMClass.e : Π {m : Type} [c : PMClass m], m</span>
<span class="k">#print</span> <span class="n">PMClass.e'</span> <span class="c1">-- def PMClass.e' : Π {m : Type} [c : PMClass m], m</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">m</span><span class="o">]</span>
<span class="k">#check</span> <span class="n">c.e</span>  <span class="c1">-- ok</span>
<span class="k">#check</span> <span class="n">c.e'</span> <span class="c1">-- fail</span>
</code></pre></div>



<a name="214645651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214645651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214645651">(Oct 26 2020 at 23:30)</a>:</h4>
<p>The square brackets means that you are not supposed to supply the value. If you want to supply the value, mark it as a <code>structure</code>, and then the projections will have <code>c</code> as an explicit argument</p>



<a name="214645682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214645682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214645682">(Oct 26 2020 at 23:31)</a>:</h4>
<p>or to supply the value at a particular application, use <code>@</code>, as in <code>@PMClass.e _ c</code></p>



<a name="214654360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214654360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214654360">(Oct 27 2020 at 02:05)</a>:</h4>
<p>Context: <span class="user-mention" data-user-id="358884">@Yasmine Sharoda</span> and I work together - she's looking to have our theory generator produce Lean as well as Agda. The underlying question is "class or structure or both?"  In a generative context, it's just as cheap to generate both than choosing (unlike in a human context, where such redundancy is quite painful).  But to generate these, we need to know exactly what we should be generating!</p>
<p>So <code>PMClass</code> is really a short-hand for "the class version of Pointed Magma", whose homomorphisms are the same as monoid homomorphisms, and so a good test case for questions.  Especially when oddities such as the ones documented above arise, making a proper exporter harder to write.</p>
<p>It might be worth starting a separate thread (where?) to discuss the general design, i.e what should (for example)</p>
<ul>
<li>a Monoid</li>
<li>a Monoid homomorphism</li>
<li>the 'term language' induced by a Monoid? [There are a host of variants of this]</li>
<li>a product Monoid</li>
</ul>
<p>all look like?</p>



<a name="214656089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214656089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214656089">(Oct 27 2020 at 02:45)</a>:</h4>
<p>a monoid should be a class, a monoid hom a structure, and a product monoid should be an instance</p>



<a name="214656108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214656108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214656108">(Oct 27 2020 at 02:45)</a>:</h4>
<p>the term language is probably an inductive</p>



<a name="214728586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214728586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214728586">(Oct 27 2020 at 16:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Projecting.20Class.20Members/near/214645426">said</a>:</p>
<blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">PMClass</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">PMClass.e'</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">m</span><span class="o">]</span> <span class="o">:</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">PMClass.e</span>

<span class="k">#print</span> <span class="n">PMClass.e</span>  <span class="c1">-- def PMClass.e : Π {m : Type} [c : PMClass m], m</span>
<span class="k">#print</span> <span class="n">PMClass.e'</span> <span class="c1">-- def PMClass.e' : Π {m : Type} [c : PMClass m], m</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">m</span><span class="o">]</span>
<span class="k">#check</span> <span class="n">c.e</span>  <span class="c1">-- ok</span>
<span class="k">#check</span> <span class="n">c.e'</span> <span class="c1">-- fail</span>
</code></pre></div>

</blockquote>
<p>Actually I tried this code on the web interface and it did not accept it. It was accepted when the body of <code>PMClass.e'</code> became <code>c.e</code>.  <br>
There really is something different about instance resolution of constants versus unary and binary operations.. As I am looking to automatically generate code, I want to have a better understanding on how this work. <br>
Maybe referring me to material on classes versus structures would be helpful.</p>



<a name="214729040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214729040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214729040">(Oct 27 2020 at 16:51)</a>:</h4>
<p>Note that <code>PMClass.e</code> and <code>c.e</code> are using the dot in two different ways. The first one is a namespaced name, and the second one is projection notation (once upon a time this was written <code>c^.e</code> and I think that still works, but <code>.</code> is overloaded for both meanings now).</p>



<a name="214729249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214729249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214729249">(Oct 27 2020 at 16:52)</a>:</h4>
<p>The difference is not about unary vs binary, it's about whether the field takes an argument of type <code>m</code></p>



<a name="214729310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214729310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214729310">(Oct 27 2020 at 16:53)</a>:</h4>
<p>Do you have a link for the failed test? You might be running an old version of lean</p>



<a name="214729401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214729401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214729401">(Oct 27 2020 at 16:53)</a>:</h4>
<p><a href="https://leanprover-community.github.io/lean-web-editor/#code=class%20PMClass%20%28m%20%3A%20Type%29%20%3A%20Type%20%3A%3D%20%28e%20%3A%20m%29%0A%0A%40%5Breducible%5D%0Adef%20PMClass.e'%20%7Bm%20%3A%20Type%7D%20%5Bc%20%3A%20PMClass%20m%5D%20%3A%20m%20%3A%3D%20PMClass.e%0A%0A%23print%20PMClass.e%20%20--%20def%20PMClass.e%20%3A%20%CE%A0%20%7Bm%20%3A%20Type%7D%20%5Bc%20%3A%20PMClass%20m%5D%2C%20m%0A%23print%20PMClass.e'%20--%20def%20PMClass.e'%20%3A%20%CE%A0%20%7Bm%20%3A%20Type%7D%20%5Bc%20%3A%20PMClass%20m%5D%2C%20m%0A%0Avariables%20%7Bm%20%3A%20Type%7D%20%5Bc%20%3A%20PMClass%20m%5D%0A%23check%20c.e%20%20--%20ok%0A%23check%20c.e'%20--%20fail">test</a></p>



<a name="214729638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214729638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214729638">(Oct 27 2020 at 16:55)</a>:</h4>
<p>Oh right, thanks to zulip you can also click "View in Lean community playground" in the top right of the code block</p>



<a name="214730566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214730566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214730566">(Oct 27 2020 at 17:01)</a>:</h4>
<p>With the original lean playground (the link scheme doesn't mix with markdown, but copy paste the below), which runs</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">lean.version</span> <span class="c1">-- (3,4,1)</span>
</code></pre></div>

<p>you get a <em>different</em> bug relating to how lean treats elaborates structure fields differently. Here's a better test showing the difference on lean 3.4.1:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">PMClass</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">PMClass.e'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">m</span><span class="o">],</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">PMClass.e</span>

<span class="k">#print</span> <span class="n">PMClass.e</span>  <span class="c1">-- def PMClass.e : Π {m : Type} [c : PMClass m], m</span>
<span class="k">#print</span> <span class="n">PMClass.e'</span> <span class="c1">-- def PMClass.e' : Π {m : Type} [c : PMClass m], m</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">m</span><span class="o">]</span>
<span class="k">#check</span> <span class="n">c.e</span>  <span class="c1">-- ok</span>
<span class="k">#check</span> <span class="n">c.e'</span> <span class="c1">-- fail</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">PMClass.e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>  <span class="c1">-- fail</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">PMClass.e</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">PMClass</span> <span class="n">m</span><span class="o">],</span> <span class="n">m</span><span class="o">)</span>  <span class="c1">-- ok</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">PMClass.e'</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span> <span class="c1">-- ok</span>
</code></pre></div>



<a name="214730750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214730750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214730750">(Oct 27 2020 at 17:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Projecting.20Class.20Members/near/214729310">said</a>:</p>
<blockquote>
<p>Do you have a link for the failed test? You might be running an old version of lean</p>
</blockquote>
<p>Here is the <a href="https://leanprover.github.io/live/latest/#code=--%20Live%20javascript%20version%20of%20Lean%0A%0Aclass%20PMClass%20(m%20:%20Type)%20:%20Type%20:=%20(e%20:%20m)%0A%0A@%5Breducible%5D%0Adef%20PMClass.e'%20%7Bm%20:%20Type%7D%20%5Bc%20:%20PMClass%20m%5D%20:%20m%20:=%20PMClass.e%0A%0A#print%20PMClass.e%20%20--%20def%20PMClass.e%20:%20%CE%A0%20%7Bm%20:%20Type%7D%20%5Bc%20:%20PMClass%20m%5D,%20m%0A#print%20PMClass.e'%20--%20def%20PMClass.e'%20:%20%CE%A0%20%7Bm%20:%20Type%7D%20%5Bc%20:%20PMClass%20m%5D,%20m%0A%0Avariables%20%7Bm%20:%20Type%7D%20%5Bc%20:%20PMClass%20m%5D%0A#check%20c.e%20%20--%20ok%0A#check%20c.e'%20--%20fail">code that fails</a>. Indeed it is version 3.4.1.. thanks for noticing that</p>



<a name="214731114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214731114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214731114">(Oct 27 2020 at 17:04)</a>:</h4>
<p>The lean community editor runs</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">lean.version</span> <span class="c1">-- (3,21,0)</span>
</code></pre></div>

<p>btw</p>



<a name="214731195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214731195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214731195">(Oct 27 2020 at 17:05)</a>:</h4>
<p>3.4.1 is about 2 years old now</p>



<a name="214731528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214731528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214731528">(Oct 27 2020 at 17:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Projecting.20Class.20Members/near/214731195">said</a>:</p>
<blockquote>
<p>3.4.1 is about 2 years old now</p>
</blockquote>
<p>Thanks for this clue.. as google takes one to the older interface.</p>



<a name="214731633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214731633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214731633">(Oct 27 2020 at 17:08)</a>:</h4>
<p>Just to be clear, what you are witnessing are (long-standing) bugs in lean, this isn't how implicit arguments are supposed to work</p>



<a name="214731715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214731715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214731715">(Oct 27 2020 at 17:08)</a>:</h4>
<p>One simple fix we often do is to restate axioms outside a structure, just like <code>PMClass.e'</code> here</p>



<a name="214731831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214731831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214731831">(Oct 27 2020 at 17:09)</a>:</h4>
<p>because the bug only occurs when you are referring to one of the fields themselves, not a wrapper definition around it</p>



<a name="214732065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214732065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214732065">(Oct 27 2020 at 17:11)</a>:</h4>
<p>But with the modern version, you only hit the bug if you do something you shouldn't be doing in the first place, which is to use projection notation on a variable of class type</p>



<a name="214732114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214732114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214732114">(Oct 27 2020 at 17:11)</a>:</h4>
<p>so it shouldn't cause problems for your code generation</p>



<a name="214733276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214733276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214733276">(Oct 27 2020 at 17:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Projecting.20Class.20Members/near/214732065">said</a>:</p>
<blockquote>
<p>But with the modern version, you only hit the bug if you do something you shouldn't be doing in the first place, which is to use projection notation on a variable of class type</p>
</blockquote>
<p>Yes, now that I shifted to the right version, things make more sense.. projecting from a class uses namespace, while from a structure uses the instance name.. <br>
Are there any references comparing classes and structures that I can read to get more depth on that?</p>



<a name="214856146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Projecting%20Class%20Members/near/214856146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Projecting.20Class.20Members.html#214856146">(Oct 28 2020 at 15:51)</a>:</h4>
<p>Related to the same topic.. I get an error when projecting a class member in a function definition. I tried having a definition for <code>op</code> as suggested above but didn't help. Here is the <a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20init.data.nat.basic%0Aimport%20init.data.fin.basic%0Aimport%20data.vector%0A%0Aclass%20monoidTh%20%28m%20%3A%20Type%29%20%3A%20Type%20%3A%3D%20%0A%20%20%28e%20%3A%20m%29%20%0A%20%20%28op%20%3A%20m%20-%3E%20m%20-%3E%20m%29%20%0A%20%20%28assoc%3A%20%E2%88%80%20%20x%20y%20z%20%3A%20m%2C%20op%20x%20%28op%20y%20z%29%20%3D%20op%20%28op%20x%20y%29%20z%29%20%0A%20%20%28lunit%20%3A%20%E2%88%80%20x%20%3A%20m%2C%20op%20e%20x%20%3D%20x%29%20%0A%20%20%28runit%20%3A%20%E2%88%80%20x%20%3A%20m%2C%20op%20x%20e%20%3D%20x%29%20%0A%0Aopen%20monoidTh%20%0A%0Ainductive%20OpenTermLang%20%28n%20%3A%20nat%29%20%28A%20%3A%20Type%29%20%3A%20Type%0A%7C%20var%20%3A%20fin%20n%20-%3E%20OpenTermLang%0A%7C%20singleton%20%3A%20A%20-%3E%20OpenTermLang%0A%7C%20e'%20%20%3A%20OpenTermLang%20%0A%7C%20op'%20%3A%20OpenTermLang%20-%3E%20OpenTermLang%20-%3E%20OpenTermLang%20%20%0A%0Aopen%20vector%20%28nth%29%0Aopen%20OpenTermLang%0A%0Adef%20monoidTh.opp%20%7Ba%20%3A%20Type%7D%20%7Bx%20%3A%20a%7D%20%7By%20%3A%20a%7D%20%5BmonoidTh%20a%5D%20%3A%20a%20%3A%3D%20monoidTh.op%20x%20y%0A%0Adef%20eval%20%7Bn%20%3A%20nat%7D%20%7Ba%20%3A%20Type%7D%20%3A%20monoidTh%20a%20-%3E%20vector%20a%20n%20-%3E%20OpenTermLang%20n%20a%20-%3E%20a%20%0A%7C%20_%20_%20%28singleton%20x%29%20%3A%3D%20x%20%0A%7C%20m%20_%20e'%20%3A%3D%20m.e%0A%7C%20m%20v%20%28op'%20x%20y%29%20%3A%3D%20m.op%20%28eval%20m%20v%20x%29%20%28eval%20m%20v%20y%29%20%0A%7C%20m%20v%20%28var%20x%29%20%3A%3D%20nth%20v%20x%20%0A%0A%20">code</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
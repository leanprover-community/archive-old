---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html">define a function by iterating</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="274263133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274263133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274263133">(Mar 05 2022 at 20:24)</a>:</h4>
<p>I have a function that either maps <code>α → α</code> or <code>α → β</code> depending on whether a "termination" predicate <code>p : α → Prop</code> holds. I know that the function terminates after finitely many steps, so I'd like to define <code>f_total : α → β</code> by repeating the function until it finishes. What's the best way to do this?</p>
<p>I'm not sure how to express the "terminates in finitely many steps" thing (as in <code>∀ (a : α), ∃ (n : ℕ), ... something p n a</code>), but conveniently there is a decreasing natural number associated to each <code>a</code> and the function must stop if the number is 0 (but may finish sooner), so I managed to use that instead.</p>
<p>Still my formalization feels messy. In particular I have a tactic-based definition of <code>f_total</code>. Here it is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">f_go</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">f_stop</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">p_rank</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">p_rank_decr</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">p_rank</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">hp</span><span class="o">))</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">p_stop0</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hpr</span> <span class="o">:</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">totalf_0</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">}</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">f_stop</span> <span class="o">(</span><span class="n">p_stop0</span> <span class="n">a.prop</span><span class="o">)</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">totalf_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">fn</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">n.succ</span><span class="o">}</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a.val</span><span class="o">,</span>
  <span class="c1">-- fn ∘ f_go</span>
  <span class="n">apply</span> <span class="n">fn</span> <span class="o">⟨</span><span class="n">f_go</span> <span class="n">hp</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">nat.succ_inj'</span><span class="o">,</span> <span class="n">p_rank_decr</span> <span class="n">hp</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">a.prop</span><span class="o">,</span>
  <span class="c1">-- f_stop</span>
  <span class="n">exact</span> <span class="n">f_stop</span> <span class="n">hp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">totalf'</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">nat.rec</span> <span class="n">totalf_0</span> <span class="n">totalf_succ</span> <span class="n">n</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">totalf</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">totalf'</span> <span class="o">(</span><span class="n">p_rank</span> <span class="n">a</span><span class="o">)</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
</code></pre></div>
<p>So this basically works for this toy case, but the tactic-based definition of <code>totalf_succ</code> makes me worry it would be hard to work with.<br>
The function I'm trying to work with is quite a bit more complicated, so I also wonder if I'm missing an easier way to use <code>nat.rec</code> or something.</p>
<p>Thanks for any help!</p>



<a name="274263881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274263881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274263881">(Mar 05 2022 at 20:39)</a>:</h4>
<p>Maybe this is better, using <code>dite</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">totalf_0</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">}</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">f_stop</span> <span class="o">(</span><span class="n">p_stop0</span> <span class="n">a.prop</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">totalf_aux</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">n.succ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p_rank</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">h</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">nat.succ_inj'</span><span class="o">,</span> <span class="n">p_rank_decr</span> <span class="n">h</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">h'</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">totalf_succ</span> <span class="o">[</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">p</span> <span class="n">a</span><span class="o">)]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fn</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">n.succ</span><span class="o">}</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">dite</span> <span class="o">(</span><span class="n">p</span> <span class="n">a.val</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">fn</span> <span class="o">⟨</span><span class="n">f_go</span> <span class="n">h</span><span class="o">,</span> <span class="n">totalf_aux</span> <span class="n">h</span> <span class="n">a.prop</span><span class="o">⟩)</span> <span class="n">f_stop</span>

<span class="kd">def</span> <span class="n">totalf'</span> <span class="o">[</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">p</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">nat.rec</span> <span class="n">totalf_0</span> <span class="n">totalf_succ</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">totalf</span> <span class="o">[</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">p</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">totalf'</span> <span class="o">(</span><span class="n">p_rank</span> <span class="n">a</span><span class="o">)</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
</code></pre></div>



<a name="274266181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274266181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274266181">(Mar 05 2022 at 21:33)</a>:</h4>
<p>That sounds pretty similar to <a href="https://leanprover-community.github.io/mathlib_docs/find/pfun.fix">docs#pfun.fix</a></p>



<a name="274266231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274266231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274266231">(Mar 05 2022 at 21:34)</a>:</h4>
<p>It produces a partial function, but you can prove it terminates separately and thus get a regular function out</p>



<a name="274266538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274266538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274266538">(Mar 05 2022 at 21:43)</a>:</h4>
<p>The usual way we would write this is using well founded recursion like so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">f_go</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">f_stop</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">@</span><span class="n">p</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">p_rank</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">p_rank_decr</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p_rank</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">a</span> <span class="n">hp</span><span class="o">))</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">totalf</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span> <span class="k">then</span>
    <span class="k">have</span> <span class="n">p_rank</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">a</span> <span class="n">h</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p_rank</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">p_rank_decr</span> <span class="n">h</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">nat.lt_succ_self</span><span class="o">,</span>
    <span class="n">totalf</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">a</span> <span class="n">h</span><span class="o">)</span>
  <span class="k">else</span> <span class="n">f_stop</span> <span class="n">a</span> <span class="n">h</span>
<span class="n">using_well_founded</span> <span class="o">{</span> <span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">measure_wf</span> <span class="n">p_rank</span><span class="o">⟩]</span> <span class="o">}</span>
</code></pre></div>



<a name="274290890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274290890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274290890">(Mar 06 2022 at 07:25)</a>:</h4>
<p>Interesting, yes this looks very much like what I wanted. Thank you very much!</p>



<a name="274291117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274291117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274291117">(Mar 06 2022 at 07:31)</a>:</h4>
<p>What does the notation</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">`</span><span class="o">[</span><span class="bp">...</span><span class="o">]</span>
</code></pre></div>
<p>mean?</p>



<a name="274349417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274349417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274349417">(Mar 07 2022 at 04:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Further question, is there a way to do this without having to write down the output type?</p>



<a name="274354825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274354825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274354825">(Mar 07 2022 at 06:37)</a>:</h4>
<p>The <code> `[...]</code> syntax constructs a <code>tactic unit</code> using the interactive parser. It is just like <code>begin ... end</code>, but instead of running the tactic on the current goal it just constructs the tactic and returns it. The <code>using_well_founded</code> syntax is a bit arcane and 99% of the time it's just <code>exact</code> of some term like here, but in principle you can use a tactic to generate the well founded relation.</p>



<a name="274355295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274355295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274355295">(Mar 07 2022 at 06:47)</a>:</h4>
<p>I'm not sure which output type you are referring to. If you mean the <code>T</code> in <code>have T, from ...</code> in the example, you don't really need it but the decreasing tactic is using <code>assumption</code> to find a proof that the call is decreasing so you need something defeq to that in the context one way or another. Also the <code>rw</code> proof doesn't really work if the type is not known.</p>



<a name="274355300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274355300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274355300">(Mar 07 2022 at 06:47)</a>:</h4>
<p>All of the <code>sorry</code>'d definitions can be inlined, there is no need to have them separate</p>



<a name="274358575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274358575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274358575">(Mar 07 2022 at 07:47)</a>:</h4>
<p>Actually I just meant <code>α</code> and <code>β</code>. My function is actually of the form <code>Π (a : α), α_aux a → Σ' (b : β), β_aux b</code> and it's a bit involved to write down the full type of the output. (Some intermediate steps in what I have were just defined as <code>foo x := ...</code> without explicitly writing down the type of <code>foo x</code>.)</p>
<p>I actually managed to get the function working based on the skeleton you provided!</p>
<p>I also just tried to add some more stuff to it and encountered this error: <code>rec_fn_macro only allowed in meta definitions</code>. Any idea what this means? It would be a little tricky to extract a mwe for this.</p>



<a name="274358660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274358660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274358660">(Mar 07 2022 at 07:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/define.20a.20function.20by.20iterating/near/274355295">said</a>:</p>
<blockquote>
<p>I'm not sure which output type you are referring to. If you mean the <code>T</code> in <code>have T, from ...</code> in the example, you don't really need it but the decreasing tactic is using <code>assumption</code> to find a proof that the call is decreasing so you need something defeq to that in the context one way or another. Also the <code>rw</code> proof doesn't really work if the type is not known.</p>
</blockquote>
<p>Ah, that's quite enlightening. Thanks.</p>



<a name="274360083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274360083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274360083">(Mar 07 2022 at 08:10)</a>:</h4>
<p>The <code>rec_fn_macro</code> error seems to arise when I try to replace <code>β</code> by a dependent type of the form <code>Σ' (b : β) (h1 : p1 b) (h2 : p2 b), β_aux b</code> where <code>p1 b</code> and <code>p2 b</code> are some extra <code>Prop</code>s about the function output type.</p>
<p>The problem seems to occur with only one of the extra <code>Prop</code>s, namely one that involves <code>set.finite.to_finset.card</code>... roughly it's like <code>h2 : b.size = a.size + 1</code> where <code>b.size</code> and <code>a.size</code> are two <code>finset.card</code>'s associated to the input and output.</p>



<a name="274360115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274360115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274360115">(Mar 07 2022 at 08:10)</a>:</h4>
<p>(I realize this is vague, I'll try to extract a mwe... but whatever it is is something subtle)</p>



<a name="274361078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274361078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274361078">(Mar 07 2022 at 08:25)</a>:</h4>
<p>Maybe it would be simpler to leave the output type as just <code>Σ' (b : β), β_aux b</code> since I had that one working. In that case I have one more question, which is how do I inductively prove facts about the output of the <code>totalf</code> function, given appropriate facts about <code>f_go</code> and <code>f_stop</code>?</p>



<a name="274511431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274511431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274511431">(Mar 08 2022 at 08:50)</a>:</h4>
<p>I'm not sure how to prove things about a function defined with <code>using_well_founded</code>. Continuing with the <code>totalf</code> function defined above, given a property preserved by <code>f_go</code> and <code>f_stop</code>, how can I prove it holds for outputs of <code>totalf</code>? This is the lemma <code>r_totalf</code> below (I have an attempt at a proof, which doesn't seem to work). Complete mwe, sorry it's getting a bit long:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="kd">def</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="n">p</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">f_go</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">f_stop</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">p_rank</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">p_rank_decr</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p_rank</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">hp</span><span class="o">))</span> <span class="bp">&lt;</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">totalf</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span> <span class="k">then</span>
    <span class="k">have</span> <span class="n">p_rank</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">h</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">p_rank_decr</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">totalf</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">h</span><span class="o">)</span>
  <span class="k">else</span> <span class="n">f_stop</span> <span class="n">h</span>
<span class="n">using_well_founded</span> <span class="o">{</span> <span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">measure_wf</span> <span class="n">p_rank</span><span class="o">⟩]}</span>

<span class="c1">-- A property preserved by f:</span>
<span class="kd">def</span> <span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">rβ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">rf_go</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">hp</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">rf_stop</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">rβ</span> <span class="o">(</span><span class="n">f_stop</span> <span class="n">hnp</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">r_totalf</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">r</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">rβ</span> <span class="o">(</span><span class="n">totalf</span> <span class="n">a</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">a</span> <span class="n">h</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">totalf</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hp</span><span class="o">],</span> <span class="n">rotate</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">rf_stop</span> <span class="n">hp</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">wf</span> <span class="o">:</span> <span class="n">p_rank</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">hp</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">p_rank_decr</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">r_totalf</span> <span class="o">(</span><span class="n">rf_go</span> <span class="n">hp</span> <span class="n">h</span><span class="o">),</span> <span class="c1">-- *** this line is not accepted</span>
<span class="kd">end</span>
<span class="n">using_well_founded</span> <span class="o">{</span> <span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">measure_wf</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span> <span class="n">p_rank</span> <span class="n">a</span><span class="o">)⟩]}</span>
</code></pre></div>
<p>I get the following error message:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">1</span> <span class="n">goal</span>
<span class="n">r_totalf</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">r</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">rβ</span> <span class="o">(</span><span class="n">totalf</span> <span class="n">a</span><span class="o">)</span>
<span class="n">a</span><span class="o">:</span> <span class="n">α</span>
<span class="n">h</span><span class="o">:</span> <span class="n">r</span> <span class="n">a</span>
<span class="n">hp</span><span class="o">:</span> <span class="n">p</span> <span class="n">a</span>
<span class="n">wf</span><span class="o">:</span> <span class="n">p_rank</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">hp</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p_rank</span> <span class="n">a</span>
<span class="bp">⊢</span> <span class="n">rβ</span> <span class="o">(</span><span class="n">totalf</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">_</span><span class="o">))</span>
<span class="n">Messages</span> <span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">failed</span> <span class="n">to</span> <span class="n">prove</span> <span class="n">recursive</span> <span class="n">application</span> <span class="n">is</span> <span class="n">decreasing</span><span class="o">,</span> <span class="n">well</span> <span class="n">founded</span> <span class="n">relation</span>
  <span class="bp">@</span><span class="n">has_well_founded.r</span> <span class="o">(</span><span class="bp">Σ'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">r</span> <span class="n">a</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">has_well_founded.mk</span> <span class="o">(</span><span class="bp">Σ'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">r</span> <span class="n">a</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">measure</span> <span class="o">(</span><span class="bp">Σ'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">r</span> <span class="n">a</span><span class="o">)</span>
          <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="bp">Σ'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">r</span> <span class="n">a</span><span class="o">),</span>
             <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_a</span> <span class="o">:</span> <span class="bp">Σ'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">r</span> <span class="n">a</span><span class="o">),</span> <span class="n">_a.cases_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">fst</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">snd</span> <span class="o">:</span> <span class="n">r</span> <span class="n">fst</span><span class="o">),</span> <span class="n">id_rhs</span> <span class="n">ℕ</span> <span class="o">(</span><span class="n">p_rank</span> <span class="n">fst</span><span class="o">)))</span> <span class="n">_x</span><span class="o">))</span>
       <span class="n">_</span><span class="o">)</span>
<span class="n">The</span> <span class="n">nested</span> <span class="n">exception</span> <span class="n">contains</span> <span class="n">the</span> <span class="n">failure</span> <span class="n">state</span> <span class="n">for</span> <span class="n">the</span> <span class="n">decreasing</span> <span class="n">tactic.</span>
<span class="n">nested</span> <span class="n">exception</span> <span class="n">message</span><span class="o">:</span>
<span class="n">default_dec_tac</span> <span class="n">failed</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">r_totalf</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">_p</span> <span class="o">:</span> <span class="bp">Σ'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">r</span> <span class="n">a</span><span class="o">),</span> <span class="n">rβ</span> <span class="o">(</span><span class="n">totalf</span> <span class="n">_p.fst</span><span class="o">),</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">r</span> <span class="n">a</span><span class="o">,</span>
<span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span>
<span class="bp">⊢</span> <span class="n">id_rhs</span> <span class="n">ℕ</span> <span class="o">(</span><span class="n">p_rank</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">hp</span><span class="o">))</span> <span class="bp">&lt;</span> <span class="n">id_rhs</span> <span class="n">ℕ</span> <span class="o">(</span><span class="n">p_rank</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>
<p>It looks like the desired well-foundedness inequality <code>id_rhs ℕ (p_rank (f_go hp)) &lt; id_rhs ℕ (p_rank a)</code>  is pretty close to the hypothesis <code>wf: p_rank (f_go hp) &lt; p_rank a</code>, I'm not sure what's wrong.</p>



<a name="274593842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/define%20a%20function%20by%20iterating/near/274593842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/define.20a.20function.20by.20iterating.html#274593842">(Mar 08 2022 at 19:31)</a>:</h4>
<p>Figured it out, and I might as well include the answer for posterity (in case anyone else encounters the same error message):</p>
<p><a href="https://leanprover-community.github.io/extras/well_founded_recursion.html">https://leanprover-community.github.io/extras/well_founded_recursion.html</a></p>
<p>"Note that the <code>have</code> must not be in tactics mode, i.e. inside any <code>begin end</code>. If you are in tactics mode, there is the option of putting the <code>have</code> statement inside the <code>exact</code> statement."</p>
<p>So for the example above, it's enough to change</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="n">wf</span> <span class="o">:</span> <span class="n">p_rank</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">hp</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">p_rank_decr</span> <span class="n">hp</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">r_totalf</span> <span class="o">(</span><span class="n">rf_go</span> <span class="n">hp</span> <span class="n">h</span><span class="o">),</span>  <span class="c1">-- *** this line is not accepted</span>
</code></pre></div>
<p>to this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">exact</span> <span class="k">have</span> <span class="n">p_rank</span> <span class="o">(</span><span class="n">f_go</span> <span class="n">hp</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p_rank</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">p_rank_decr</span> <span class="n">hp</span><span class="o">,</span>
      <span class="n">r_totalf</span> <span class="o">(</span><span class="n">rf_go</span> <span class="n">hp</span> <span class="n">h</span><span class="o">),</span> <span class="c1">-- works!</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
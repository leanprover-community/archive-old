---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/What.20does.20.60.3FM_1.20xyz.60.20mean.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20does.20.60.3FM_1.20xyz.60.20mean.3F.html">What does `?M_1 xyz` mean?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="218839643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20does%20%60%3FM_1%20xyz%60%20mean%3F/near/218839643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rajiv <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20does.20.60.3FM_1.20xyz.60.20mean.3F.html#218839643">(Dec 04 2020 at 14:34)</a>:</h4>
<p>I am new to lean and when working on this section, <a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#enumerated-types">https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#enumerated-types</a> and  in the following snippet, when I do <code>#check weekday.rec</code> and <code>#check weekday.rec_on</code>, I see something like <code>?M_1 weekday.sunday</code> and <code>?M_1 n</code>.</p>
<p>What does the form <code>?M_1 xyz</code> mean in a type signature?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">weekday</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">sunday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">monday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">tuessday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">wednesday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">thursday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">friday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">saturday</span> <span class="o">:</span> <span class="n">weekday</span>

<span class="k">#check</span> <span class="n">weekday.rec</span>

<span class="k">#check</span> <span class="n">weekday.rec_on</span>
</code></pre></div>



<a name="218839694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20does%20%60%3FM_1%20xyz%60%20mean%3F/near/218839694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20does.20.60.3FM_1.20xyz.60.20mean.3F.html#218839694">(Dec 04 2020 at 14:35)</a>:</h4>
<p>I agree this is confusing. Try <code>#check @weekday.rec</code></p>



<a name="218839924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20does%20%60%3FM_1%20xyz%60%20mean%3F/near/218839924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rajiv <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20does.20.60.3FM_1.20xyz.60.20mean.3F.html#218839924">(Dec 04 2020 at 14:37)</a>:</h4>
<p>Thanks a lot. That helps! :-)</p>



<a name="218839940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20does%20%60%3FM_1%20xyz%60%20mean%3F/near/218839940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20does.20.60.3FM_1.20xyz.60.20mean.3F.html#218839940">(Dec 04 2020 at 14:37)</a>:</h4>
<p>"For all functions C from <code>weekday</code> to types, if you have a term of type <code>C sunday</code> and a term of type <code>C monday</code> and ... and a term of type <code>C saturday</code>, then I can give you a function which takes any weekday <code>n</code>, and returns a term of type <code>C n</code>"</p>



<a name="218921308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20does%20%60%3FM_1%20xyz%60%20mean%3F/near/218921308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rajiv <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20does.20.60.3FM_1.20xyz.60.20mean.3F.html#218921308">(Dec 05 2020 at 06:21)</a>:</h4>
<p>Are there more examples of how to read <code>Π</code> type signatures somewhere? I am finding this way of reading type signatures quite useful.</p>



<a name="218936811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20does%20%60%3FM_1%20xyz%60%20mean%3F/near/218936811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20does.20.60.3FM_1.20xyz.60.20mean.3F.html#218936811">(Dec 05 2020 at 14:13)</a>:</h4>
<p>I tried to read recursors when I was getting the hang of this stuff. For me when I was learning, I found it helpful to just focus on the idea that there were only two universes, <code>Prop</code> (the universe of types which represent true/false statements like 2+2=4 and 2+2+5) and <code>Type</code> (the universe of types which represent collections of stuff, like the real numbers). (This idea isn't actually true, there are infinitely many type universes because Type has to have a type, but this is just a quirk of the theory). When I see <code>Sort u</code> I would interpret it as meaning "Either <code>Prop</code> or <code>Type</code>". With that in mind, here is <code>nat.rec</code> (which is quite a difficult one):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">nat.rec</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">C</span> <span class="mi">0</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="n">d</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">d.succ</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="n">n</span>
</code></pre></div>
<p>If we interpret <code>Sort u</code> as <code>Prop</code>, this says the principle of mathematical induction, namely that for all families <code>C 0, C 1, C 2, ...</code> of true-false statements, if we know <code>C 0</code> is true and if we know that for all d, <code>C d</code> implies <code>C (d + 1)</code> (note that <code>d.succ</code> just means <code>d + 1</code>), then we can conclude that for all n, <code>C n</code> is true.</p>
<p>If on the other hand we interpret <code>Sort u</code> as <code>Type</code>, then this says the principle of mathematical recursion, namely that for all families <code>C 0</code>, <code>C 1</code>, ... <code>C n</code>, ... of types or sets or however you want to think of them, if we have an element of <code>C 0</code>, and if we also have a method which given <code>d</code> and an element of <code>C d</code> produces an element of <code>C (d + 1)</code>, then we have a method to produce an element of <code>C n</code> for all <code>n</code>.</p>



<a name="218938714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20does%20%60%3FM_1%20xyz%60%20mean%3F/near/218938714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rajiv <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20does.20.60.3FM_1.20xyz.60.20mean.3F.html#218938714">(Dec 05 2020 at 15:06)</a>:</h4>
<p>Thanks again Prof. Kevin. I really appreciate your reply and pointers.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
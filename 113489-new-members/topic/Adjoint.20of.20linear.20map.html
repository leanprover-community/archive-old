---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html">Adjoint of linear map</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="268465876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268465876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268465876">(Jan 18 2022 at 22:34)</a>:</h4>
<p>I've been working with <span class="user-mention" data-user-id="459656">@Hans Parshall</span> on singular value stuff, and we both haven't been able to troubleshoot the error message from the following code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">is_R_or_C</span> <span class="n">F</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">F</span> <span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module.finite</span> <span class="n">F</span> <span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">F</span><span class="o">}</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">matrix.to_lin'</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">adjoint</span>
</code></pre></div>
<p>Which yields the error message:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="bp">⇑</span><span class="n">linear_map.adjoint</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">matrix.to_lin'</span> <span class="n">A</span><span class="o">)</span>
<span class="n">term</span>
  <span class="bp">⇑</span><span class="n">matrix.to_lin'</span> <span class="n">A</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">F</span><span class="o">]</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u_1</span> <span class="n">u_2</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_3</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="bp">?</span><span class="n">m_1</span><span class="o">]</span> <span class="bp">?</span><span class="n">m_4</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="bp">?</span> <span class="bp">?</span><span class="o">)</span>
</code></pre></div>
<p>It seems like the types line up, so the error message is quite confusing.<br>
If anyone has any insight on this error, let me know!</p>



<a name="268466287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268466287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268466287">(Jan 18 2022 at 22:38)</a>:</h4>
<p>Maybe you need to remove the <code>inner_product_space F (n → F)</code> and/or <code>module.finite F (n → F)</code> variables?</p>



<a name="268466377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268466377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268466377">(Jan 18 2022 at 22:39)</a>:</h4>
<p>Can you add imports? I can't get your code working.</p>



<a name="268466592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268466592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268466592">(Jan 18 2022 at 22:41)</a>:</h4>
<p>Presumably:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.inner_product_space.adjoint</span>
<span class="kn">import</span> <span class="n">linear_algebra.matrix.to_lin</span>
</code></pre></div>



<a name="268466598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268466598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268466598">(Jan 18 2022 at 22:41)</a>:</h4>
<p>I think this import should be sufficient:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.inner_product_space.adjoint</span>
</code></pre></div>



<a name="268466633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268466633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268466633">(Jan 18 2022 at 22:41)</a>:</h4>
<p>Removing the variables in any combination didn't work either</p>



<a name="268466697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268466697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268466697">(Jan 18 2022 at 22:42)</a>:</h4>
<p>Oh, you're right about the other import</p>



<a name="268466759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268466759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268466759">(Jan 18 2022 at 22:43)</a>:</h4>
<p>A perhaps simpler example (without the matrix part):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.inner_product_space.adjoint</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">m</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">p</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">m</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">p</span><span class="o">]</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)]</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)]</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)]</span>

<span class="kd">variable</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℂ</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">f.adjoint</span>
</code></pre></div>



<a name="268466800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268466800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268466800">(Jan 18 2022 at 22:43)</a>:</h4>
<p>(deleted)</p>



<a name="268466819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268466819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268466819">(Jan 18 2022 at 22:43)</a>:</h4>
<p>Woops, edited now for that</p>



<a name="268467024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268467024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268467024">(Jan 18 2022 at 22:45)</a>:</h4>
<p>I usually debug this sort of thing by rewriting as <code>#check @linear_map.adjoint _ _ _ _ _ _ _ _ f</code> and then I start filling in the holes.</p>



<a name="268467153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268467153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268467153">(Jan 18 2022 at 22:47)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">linear_map.adjoint</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">f</span>
</code></pre></div>
<p>-&gt;</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">,</span>
<span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span><span class="o">,</span>
<span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_4</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_5</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">m</span><span class="o">,</span>
<span class="n">_inst_2</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">n</span><span class="o">,</span>
<span class="n">_inst_3</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">p</span><span class="o">,</span>
<span class="n">_inst_4</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">m</span><span class="o">,</span>
<span class="n">_inst_5</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">n</span><span class="o">,</span>
<span class="n">_inst_6</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">p</span><span class="o">,</span>
<span class="n">_inst_7</span> <span class="o">:</span> <span class="n">inner_product_space</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">),</span>
<span class="n">_inst_8</span> <span class="o">:</span> <span class="n">inner_product_space</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">),</span>
<span class="n">_inst_9</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">),</span>
<span class="n">_inst_10</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">),</span>
<span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℂ</span><span class="o">]</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℂ</span>
<span class="bp">⊢</span> <span class="n">finite_dimensional</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span>
</code></pre></div>



<a name="268467255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268467255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268467255">(Jan 18 2022 at 22:48)</a>:</h4>
<p>That should not fail (even without <code>_inst_9</code>), since <code>n</code> is a fintype...</p>



<a name="268467340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268467340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268467340">(Jan 18 2022 at 22:49)</a>:</h4>
<p>Aha, I see the likely issue: adding the variable <code>[inner_product_space ℂ (m → ℂ)]</code> gives an incompatible instance with the standard vector space on <code>m → ℂ</code>.</p>



<a name="268467508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268467508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268467508">(Jan 18 2022 at 22:51)</a>:</h4>
<p>So filling in the <code>_</code>s with instances you get</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">linear_map.adjoint</span>
<span class="n">term</span>
  <span class="n">_inst_9</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">finite_dimensional</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring</span> <span class="n">ℂ</span> <span class="n">complex.field</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">pi.add_comm_group</span> <span class="n">m</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ᾰ</span> <span class="o">:</span> <span class="n">m</span><span class="o">),</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">m</span><span class="o">),</span> <span class="bp">@</span><span class="n">normed_group.to_add_comm_group</span> <span class="n">ℂ</span> <span class="n">complex.normed_group</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">pi.module</span> <span class="n">m</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ᾰ</span> <span class="o">:</span> <span class="n">m</span><span class="o">),</span> <span class="n">ℂ</span><span class="o">)</span> <span class="n">ℂ</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">ℂ</span> <span class="o">(</span><span class="bp">@</span><span class="n">division_ring.to_ring</span> <span class="n">ℂ</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring</span> <span class="n">ℂ</span> <span class="n">complex.field</span><span class="o">)))</span>
       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">m</span><span class="o">),</span> <span class="bp">@</span><span class="n">add_comm_group.to_add_comm_monoid</span> <span class="n">ℂ</span> <span class="o">(</span><span class="bp">@</span><span class="n">normed_group.to_add_comm_group</span> <span class="n">ℂ</span> <span class="n">complex.normed_group</span><span class="o">))</span>
       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">m</span><span class="o">),</span>
          <span class="bp">@</span><span class="n">semiring.to_module</span> <span class="n">ℂ</span>
            <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">ℂ</span> <span class="o">(</span><span class="bp">@</span><span class="n">division_ring.to_ring</span> <span class="n">ℂ</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring</span> <span class="n">ℂ</span> <span class="n">complex.field</span><span class="o">)))))</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">finite_dimensional</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring</span> <span class="n">ℂ</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">normed_field.to_field</span> <span class="n">ℂ</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">nondiscrete_normed_field.to_normed_field</span> <span class="n">ℂ</span>
             <span class="o">(</span><span class="bp">@</span><span class="n">is_R_or_C.to_nondiscrete_normed_field</span> <span class="n">ℂ</span> <span class="n">complex.is_R_or_C</span><span class="o">))))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">normed_group.to_add_comm_group</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space.to_normed_group</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span> <span class="n">complex.is_R_or_C</span> <span class="n">_inst_7</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">normed_space.to_module</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">nondiscrete_normed_field.to_normed_field</span> <span class="n">ℂ</span> <span class="o">(</span><span class="bp">@</span><span class="n">is_R_or_C.to_nondiscrete_normed_field</span> <span class="n">ℂ</span> <span class="n">complex.is_R_or_C</span><span class="o">))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space.to_normed_group</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span> <span class="n">complex.is_R_or_C</span> <span class="n">_inst_7</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space.to_normed_space</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span> <span class="n">complex.is_R_or_C</span> <span class="n">_inst_7</span><span class="o">))</span>
</code></pre></div>



<a name="268467558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268467558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hans Parshall <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268467558">(Jan 18 2022 at 22:52)</a>:</h4>
<p>this looks familiar :)</p>



<a name="268467637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268467637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268467637">(Jan 18 2022 at 22:52)</a>:</h4>
<p>This is not a corner of the library I'm familiar with, but it looks like the solution is to use <a href="https://leanprover-community.github.io/mathlib_docs/find/euclidean_space">docs#euclidean_space</a> instead of <code>n → ℂ</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.inner_product_space.pi_L2</span>
<span class="kn">import</span> <span class="n">analysis.inner_product_space.adjoint</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">m</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">p</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">m</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">p</span><span class="o">]</span>

<span class="kd">variable</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℂ</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span>

<span class="c1">-- Works:</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">linear_map.adjoint</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="n">ℂ</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="n">ℂ</span> <span class="n">n</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">f</span>
</code></pre></div>



<a name="268467839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268467839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268467839">(Jan 18 2022 at 22:54)</a>:</h4>
<p>Ah, but <code>euclidean_space</code> isn't a <code>ℂ</code>-vector space...</p>



<a name="268468094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268468094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268468094">(Jan 18 2022 at 22:56)</a>:</h4>
<p>Will this still work for the old problem? Since the linear map generated from the matrix is automatically of type </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℂ</span><span class="o">]</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span>
</code></pre></div>



<a name="268477095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268477095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268477095">(Jan 19 2022 at 00:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113489-new-members/topic/Adjoint.20of.20linear.20map/near/268467839">said</a>:</p>
<blockquote>
<p>Ah, but <code>euclidean_space</code> isn't a <code>ℂ</code>-vector space...</p>
</blockquote>
<p>It really should be! For some weird reason it finds the module instance for an <code>is_R_or_C</code> field but not for <code>ℂ</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.inner_product_space.pi_L2</span>
<span class="kn">import</span> <span class="n">analysis.inner_product_space.adjoint</span>

<span class="kd">noncomputable theory</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">is_R_or_C</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">m</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">m</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">module</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>    <span class="c1">-- works</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">module</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">m</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>    <span class="c1">-- works</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">module</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="n">ℂ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>     <span class="c1">-- fails</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">module</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="bp">𝕜</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>     <span class="c1">-- works</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">module</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">pi_Lp</span> <span class="mi">2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">m</span><span class="o">,</span> <span class="n">ℂ</span><span class="o">))</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>   <span class="c1">-- fails</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">module</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">pi_Lp</span> <span class="mi">2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">m</span><span class="o">,</span> <span class="bp">𝕜</span><span class="o">))</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>    <span class="c1">-- works</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">inner_product_space</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="n">ℂ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>   <span class="c1">-- works</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">inner_product_space</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="bp">𝕜</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>    <span class="c1">-- works</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">normed_space</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="n">ℂ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>          <span class="c1">-- works</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="bp">𝕜</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>          <span class="c1">-- works</span>
</code></pre></div>
<p>Does anyone know what's going on?</p>



<a name="268479524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268479524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268479524">(Jan 19 2022 at 01:08)</a>:</h4>
<p>Still looking into this, but the type class trace looks very suspicious, and <code>local attribute [-instance] pi_Lp.normed_group</code> makes it work</p>



<a name="268495176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268495176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268495176">(Jan 19 2022 at 05:54)</a>:</h4>
<p><span class="user-mention" data-user-id="467358">@Daniel Packer</span>, if you're dealing with the adjoints of linear maps defined by matrices, you'll probably want to know that you can get them concretely by transposing the matrix.  I had some code lying around for this which you have inspired me to clean up and PR: <a href="https://github.com/leanprover-community/mathlib/pull/11551">#11551</a></p>



<a name="268612122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268612122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268612122">(Jan 19 2022 at 22:20)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> Oh nice! Looking at the PR, it looks like you used some trick with id to get the type to work out--what purpose is the id filling in? Does it tell Lean what type to coerce (n \to \C) to be?</p>



<a name="268613617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268613617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268613617">(Jan 19 2022 at 22:35)</a>:</h4>
<p><span class="user-mention" data-user-id="467358">@Daniel Packer</span> Yes, this is because <code>euclidean_space 𝕜 n</code> is a "type synonym" for <code>n → 𝕜</code> so one sometimes has to engage in trickery to get Lean to recognize something of the one type as being of the other type.</p>
<p>But it's clearly unsatisfactory (and just hasn't been a big obstacle before because not many people have done explicit calculations on <code>euclidean_space 𝕜 n</code>).  See <a href="https://github.com/leanprover-community/mathlib/pull/11551#discussion_r787677895">this discussion</a>, probably to be continued on Zulip at some point, for some points of view.</p>



<a name="268613658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268613658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268613658">(Jan 19 2022 at 22:35)</a>:</h4>
<p>(The issue is that by default <code>n → 𝕜</code> has the l-infinity norm, not the l-2 norm.)</p>



<a name="268617057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268617057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268617057">(Jan 19 2022 at 23:05)</a>:</h4>
<p>Similar issue is that while <code>matrix n n R</code> is just <code>n -&gt; n -&gt; R</code>, <code>(1 : matrix n n R)</code> is supposed to be the diagonal matrix with 1 on the diagonal, while <code>(1 : n -&gt; n -&gt; R)</code> is the constant function giving <code>1 : R</code> for all inputs <code>1 x y</code> (<a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.has_one">docs#matrix.has_one</a> vs <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.has_one">docs#pi.has_one</a>). And sometimes, the wrong <code>1</code> is inferred for matrix, somehow falling back to the <code>pi</code> one.</p>



<a name="268617272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268617272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268617272">(Jan 19 2022 at 23:06)</a>:</h4>
<p>Do you have an example of when that happens, Yakov?</p>



<a name="268617415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268617415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268617415">(Jan 19 2022 at 23:07)</a>:</h4>
<p>I've had this issue when working with explicit matrices and trying to prove something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">]]</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>



<a name="268618126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268618126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268618126">(Jan 19 2022 at 23:14)</a>:</h4>
<p>Ah right; the problem there being that <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.vec_cons">docs#matrix.vec_cons</a> has the wrong type, just as <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.to_lin'">docs#matrix.to_lin'</a> has the wrong type for <span class="user-mention" data-user-id="260507">@Heather Macbeth</span>.</p>



<a name="268618340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Adjoint%20of%20linear%20map/near/268618340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Adjoint.20of.20linear.20map.html#268618340">(Jan 19 2022 at 23:16)</a>:</h4>
<p>That's a little easier to solve though, we could just have a <code>matrix_of</code> constructor like <code>set_of</code>. The to_lin case is harder because we want to change only subterms of the type, not the head term</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html">Defining a list type with a no duplicates constraint</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="249002084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249002084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249002084">(Aug 10 2021 at 16:28)</a>:</h4>
<p>I'm a programmer without a strong mathematical background having fun playing around in Lean, but I'm a complete beginner at this. I've completed up to proposition world in the natural numbers game and read through most of the documentation but it's not all intuitive for me yet.</p>
<p>I'm interested in proving some simple theorems on a type I'll call <code>unique_array</code>. This is a fixed length ordered list in which duplicates are not allowed. I'm particularly interested in using lemmas surrounding rotation of elements, as well as swaps.</p>
<p>The <code>list</code> type exists and has <a href="https://leanprover-community.github.io/mathlib_docs/data/list/rotate.html">rotation defined</a>, but does not have the fixed length or uniqueness constraints. The <code>array</code> type has the fixed length constraint but not uniqueness, and does not have rotation defined. The <code>set</code> type has uniqueness but nothing else that I need.</p>
<p>Is there a way to create a <code>unique_array</code> type that combines the features of the above? For example, create an alias of the <code>list</code> type with the additional no duplicates and fixed length constraints? I'd like to make use of the many lemmas already defined for <code>list</code>. I should then be able to define additional lemmas like "for all <code>unique_array</code> a with length &gt; 1, (a.rotate 1) != a" which relies on uniqueness.</p>
<p>I don't know how to go about defining an alias or derivation with additional constraints, nor how to go about constraining uniqueness. Perhaps there's something that I can do with <a href="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#inheritance">structure inheritance</a>, but I've not got my head around it well enough to work this out yet.</p>
<p>Some pointers would be welcome please! Thanks.</p>



<a name="249002533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249002533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249002533">(Aug 10 2021 at 16:32)</a>:</h4>
<p>You should look at the definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/finset/src">src#finset</a>, which does basically this, but with <code>multiset</code> as the base instead of <code>list</code> or <code>array</code></p>



<a name="249002666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249002666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249002666">(Aug 10 2021 at 16:33)</a>:</h4>
<p>That's interesting. I'll take a look, thanks!</p>



<a name="249002759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249002759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249002759">(Aug 10 2021 at 16:34)</a>:</h4>
<p>That is, I think you are describing a type like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">unique_array</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">nodup</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">val</span><span class="o">)</span>
<span class="o">(</span><span class="n">len</span> <span class="o">:</span> <span class="n">val.length</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="249002863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249002863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249002863">(Aug 10 2021 at 16:35)</a>:</h4>
<p>Note that you will still have to reprove all the theorems, because they don't all carry over, although most of them are just redirecting to the corresponding lemma on the representing type. See the rest of that finset file for examples</p>



<a name="249003010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249003010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249003010">(Aug 10 2021 at 16:36)</a>:</h4>
<p>Can one subtype on <code>vector</code>?</p>



<a name="249003110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249003110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249003110">(Aug 10 2021 at 16:37)</a>:</h4>
<p>that's also an option, although <code>vector</code> doesn't have <code>nodup</code> so you would have to write <code>val.1.nodup</code> for the other field</p>



<a name="249003138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249003138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249003138">(Aug 10 2021 at 16:37)</a>:</h4>
<p>But if you're thinking about swaps and rotation of elements over a type with a fixed number of elements, just work on functions over <code>fin n</code>. That way you can use <code>equiv.perm (fin n)</code>, <code>function.injective</code>, etc</p>



<a name="249003295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249003295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249003295">(Aug 10 2021 at 16:38)</a>:</h4>
<p>If the base type has size n, you can just use permutations instead of defining a new type</p>



<a name="249003539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249003539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249003539">(Aug 10 2021 at 16:40)</a>:</h4>
<p>Ah. I had considered a composition approach like this but had dismissed it because it doesn't inherit all of the theorems already proved on <code>list</code>. There's a lot of stuff already defined on <code>list</code> that looks useful to me. Intuitively, a fixed length list with a constraint on the elements is a subtype of <code>list</code> and I hoped to exploit that without the busywork of re-implementing the theorems.</p>



<a name="249003591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249003591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249003591">(Aug 10 2021 at 16:40)</a>:</h4>
<p>it depends on what you want. <code>perm</code> and <code>equiv</code> also have a lot of theorems</p>



<a name="249003668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249003668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249003668">(Aug 10 2021 at 16:41)</a>:</h4>
<p>but indexing is a little annoying on lists</p>



<a name="249004028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249004028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249004028">(Aug 10 2021 at 16:44)</a>:</h4>
<p>I'm looking at those now. I am actually dealing with permutations quite a bit so that sounds useful. I'd only come across <a href="https://leanprover-community.github.io/mathlib_docs/data/list/perm.html">list.perm</a> and hadn't realised that <a href="https://leanprover-community.github.io/mathlib_docs/group_theory/perm/basic.html">perm</a> is defined as its own type in the group theory namespace.</p>



<a name="249004267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249004267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249004267">(Aug 10 2021 at 16:45)</a>:</h4>
<p>The catch is that when I said that I don't have a strong mathematical background I meant it. I'm not actually familiar with group theory yet, so I'll have to see if that's an obstacle or just an opportunity to learn.</p>



<a name="249008054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249008054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249008054">(Aug 10 2021 at 17:13)</a>:</h4>
<p>Is there a way to accomplish something like this using <code>subtype</code>?  The <a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions">Inductive Types documentation</a> mentions it briefly but I've not fully got my head around it yet. Does this represent the type of a list of naturals with no duplicates?</p>
<p><code>#check { x : list nat // list.nodup x}</code></p>



<a name="249008327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249008327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249008327">(Aug 10 2021 at 17:16)</a>:</h4>
<p>yes, that's right</p>



<a name="249008468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249008468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249008468">(Aug 10 2021 at 17:17)</a>:</h4>
<p>Another way to write the type from above is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">unique_array</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">val</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">nodup</span> <span class="n">val</span> <span class="bp">∧</span> <span class="n">val.length</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">}</span>
</code></pre></div>



<a name="249009972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249009972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249009972">(Aug 10 2021 at 17:30)</a>:</h4>
<p>Ah, that looks very promising, thanks!</p>
<p>I'm a little surprised that that still seems to be creating a new type with a constrained list as a field. <code>unique_array</code> itself is not a list here, right? I'm a little confused by why this is called <code>subtype</code>, because I would think of this result as being a composed type rather than a subtype.</p>



<a name="249012297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249012297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249012297">(Aug 10 2021 at 17:49)</a>:</h4>
<p>It's a subtype because it's the elements of <code>list α</code> which satisfy <code>nodup val ∧ val.length = n</code> - that makes it a "smaller" type with fewer elements (unless the condition is just <code>true</code>!)</p>



<a name="249012605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249012605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249012605">(Aug 10 2021 at 17:51)</a>:</h4>
<p>But from a syntactic point of view, it's true that an element of <code>unique_array</code> is not a list, it is a tuple of a list and two proofs. The proofs are erased, so in the VM it is represented as just a list</p>



<a name="249012639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249012639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249012639">(Aug 10 2021 at 17:51)</a>:</h4>
<p>My confusion stems from the fact that it looks like a structure with a field called <code>val</code> of that subtype, rather than the subtype itself.</p>



<a name="249012711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249012711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249012711">(Aug 10 2021 at 17:52)</a>:</h4>
<p>what is "it"?</p>



<a name="249012737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249012737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249012737">(Aug 10 2021 at 17:52)</a>:</h4>
<p>the <code>def</code> or the <code>structure</code> example?</p>



<a name="249012772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249012772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249012772">(Aug 10 2021 at 17:53)</a>:</h4>
<p>The <code>unique_array</code> type def. You're right, I shouldn't have called it a "structure" I think.</p>



<a name="249012950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249012950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249012950">(Aug 10 2021 at 17:54)</a>:</h4>
<p>That is a typedef for a certain instantiation of the <code>subtype</code> type, which is defined as a <code>structure</code> with two fields (the first of which is actually called <code>val</code>, unrelated to the fact that I also called it <code>val</code> in the binder syntax)</p>



<a name="249013026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249013026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249013026">(Aug 10 2021 at 17:55)</a>:</h4>
<p>so your "confusion" is actually the correct interpretation of the situation, this is a structure with two things</p>



<a name="249013097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249013097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249013097">(Aug 10 2021 at 17:55)</a>:</h4>
<p>the reason it is "smaller" is because the second thing is sometimes only a singleton and sometimes impossible</p>



<a name="249013113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249013113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249013113">(Aug 10 2021 at 17:55)</a>:</h4>
<p>Oh! I thought that <code>val</code> was the field name you defined in the def.</p>



<a name="249013268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249013268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249013268">(Aug 10 2021 at 17:56)</a>:</h4>
<p>If I wrote</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">unique_array</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">nodup</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">a.length</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">}</span>
</code></pre></div>
<p>it would still define the same type and the field projection to get the list would still be called <code>subtype.val</code></p>



<a name="249013326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249013326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249013326">(Aug 10 2021 at 17:57)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/subtype/src">src#subtype</a> might clear things up. There's nothing magic going on other than perhaps the notation</p>



<a name="249013355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249013355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249013355">(Aug 10 2021 at 17:57)</a>:</h4>
<p>I've got the following very simple test that I'm playing with to understand this. I've just found that same thing about using a different name.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">unique_array</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">list.nodup</span> <span class="n">bar</span> <span class="bp">∧</span> <span class="n">bar.length</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">unique_array</span> <span class="n">nat</span> <span class="mi">10</span><span class="o">)</span> <span class="o">:</span> <span class="n">a.val.length</span> <span class="bp">=</span> <span class="mi">10</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">tauto</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="249013422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249013422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249013422">(Aug 10 2021 at 17:57)</a>:</h4>
<p>The shorter proof is <code>a.prop.2</code> (<a href="https://leanprover-community.github.io/mathlib_docs/find/subtype.prop">docs#subtype.prop</a>)</p>



<a name="249013514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249013514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249013514">(Aug 10 2021 at 17:58)</a>:</h4>
<p>or <code>a.2.2</code> since you can refer to structure fields either by name or index</p>



<a name="249013515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249013515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249013515">(Aug 10 2021 at 17:58)</a>:</h4>
<p>Oh very cool!</p>



<a name="249013619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249013619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249013619">(Aug 10 2021 at 17:59)</a>:</h4>
<p>with the <a href="#narrow/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint/near/249002759">structure def</a> it would be either <code>a.3</code> or <code>a.len</code></p>



<a name="249014563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249014563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249014563">(Aug 10 2021 at 18:06)</a>:</h4>
<p>To clarify, what <code>subtype</code> and the <code>def</code> actually create is a tuple, containing a value and a constraint upon that value?</p>
<p>What I intuitively expected was for the result of <code>subtype</code> to itself actually <em>be</em> a constrained<code>list</code>, rather than a grouping of a plain list and a constraint upon it. This is fine, it's just not what I expected from the name of the feature.</p>



<a name="249014978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249014978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249014978">(Aug 10 2021 at 18:10)</a>:</h4>
<p>In lean, a value can only have one type up to definitional equality. So if <code>val : list A</code> is a list with no duplicates, it still has type <code>list A</code>, it is not possible to prove that it has a different, more constrained type. This is important for type inference, among other things. If you want to show that it has a more constrained type, what you actually do is construct a <em>new</em> value that bundles <code>val</code> with its proof, and that's what <code>subtype</code> does. There are coercions to make this process fairly transparent in most cases</p>



<a name="249015131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249015131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249015131">(Aug 10 2021 at 18:11)</a>:</h4>
<p>I see, thanks! I think I'm getting the hang of this now.</p>



<a name="249015799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249015799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249015799">(Aug 10 2021 at 18:17)</a>:</h4>
<p>One thing that seems a little inconvenient about this is the lack of dot calls. Is there a way to make <code>a.length</code> etc automatically forward to <code>a.val.length</code>?</p>



<a name="249017420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249017420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249017420">(Aug 10 2021 at 18:28)</a>:</h4>
<p>On the subtype? Not automatically. Dot notation <code>l.length</code> is just shorthand for <code>list.length l</code>. Since the subtype isn't of the type <code>list</code> but of <code>subtype ...</code>, there isn't a way to infer that a function <code>subtype.length {x : list _ / ...}</code> ...</p>



<a name="249018016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249018016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249018016">(Aug 10 2021 at 18:33)</a>:</h4>
<p>I see. I obviously don't know what I'm talking about yet, but I wonder whether that would make sense to add in the future. It seems like it might be convenient if it could forward to <code>val</code> when unambiguous, but maybe there's a good reason for not doing that.</p>



<a name="249020587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249020587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249020587">(Aug 10 2021 at 18:57)</a>:</h4>
<p>Note that you can still write <code>list.length a</code> and the coercion will kick in</p>



<a name="249022563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249022563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249022563">(Aug 10 2021 at 19:11)</a>:</h4>
<p>Also, this forwarding does happen for structure <code>extends</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">foo</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">bar</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">foo</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">stuff</span> <span class="o">:</span> <span class="n">true</span><span class="o">)</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">bar</span> <span class="n">nat</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">x.val</span> <span class="c1">-- x.to_foo.val</span>
</code></pre></div>
<p>You can't make a structure extend a non-structure though, so it doesn't work for <code>list</code></p>



<a name="249023565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249023565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249023565">(Aug 10 2021 at 19:20)</a>:</h4>
<p>Ah yes I see. I think that difference between structure <code>extends</code> and <code>subtype</code> was part of where my original confusion came from.</p>



<a name="249023936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249023936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249023936">(Aug 10 2021 at 19:22)</a>:</h4>
<p>Extended structures feel like my intuitive notion of subtyping more than <code>subtype</code> actually does, but that's only a matter of naming and probably stems from me thinking in more typical programming terms rather than type theory terms.</p>



<a name="249023937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249023937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249023937">(Aug 10 2021 at 19:22)</a>:</h4>
<p>Extended structures feel like my intuitive notion of subtyping more than <code>subtype</code> actually does, but that's only a matter of naming and probably stems from me thinking in more typical programming terms rather than type theory terms.</p>



<a name="249025070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249025070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249025070">(Aug 10 2021 at 19:31)</a>:</h4>
<p>Keep in mind that <code>extends</code> is also just sugar for an extra field like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">bar</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_foo</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">stuff</span> <span class="o">:</span> <span class="n">true</span><span class="o">)</span>
</code></pre></div>



<a name="249025222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249025222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249025222">(Aug 10 2021 at 19:32)</a>:</h4>
<p>combined with a bit of added magic like the dot forwarding</p>



<a name="249174977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249174977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249174977">(Aug 11 2021 at 22:00)</a>:</h4>
<p>Thanks for all of the help yesterday guys! I said in my post that</p>
<blockquote>
<p>I should then be able to define additional lemmas like "for all unique_array a with length &gt; 1, (a.rotate 1) != a"</p>
</blockquote>
<p>Formally (and slightly more generally for all rotation distances) that's</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">nodup_rotate</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hl₁</span> <span class="o">:</span> <span class="n">l.length</span> <span class="bp">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hl₂</span> <span class="o">:</span> <span class="n">l.nodup</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="o">:</span> <span class="o">((</span><span class="n">n</span> <span class="bp">%</span> <span class="n">l.length</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">l</span> <span class="bp">=</span> <span class="o">(</span><span class="n">l.rotate</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>
<p>I've now proved that theorem, which is my first Lean proof at a difficulty level higher than the Natural Numbers Game. It was quite a slog and it took longer than it should have with lots of things to learn along the way, but I got there. In the end I proved this on plain list not the <code>unique_array</code> type - I can use this proof to trivially prove it for <code>unique_array</code> later if I want that.</p>
<p>The proof ended up being quite long and complicated, and I expect that I've done lots of things very inefficiently. Any feedback on how I could improve it would be very welcome! I've tried to name things well but in some places readability is quite poor. I have a fear that somebody may come along and do it in one line...</p>
<p>One thing that I've found is that it's actually quite annoyingly slow to evaluate in VSCode - like 10 seconds. Are there some tricks to make compilation faster?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.basic</span>
<span class="kn">import</span> <span class="n">data.list.rotate</span>
<span class="kn">import</span> <span class="n">data.list.nodup</span>
<span class="kn">import</span> <span class="n">tactic.linarith</span>


<span class="kd">theorem</span> <span class="n">nodup_rotate</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hl₁</span> <span class="o">:</span> <span class="n">l.length</span> <span class="bp">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hl₂</span> <span class="o">:</span> <span class="n">l.nodup</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
  <span class="o">:</span> <span class="o">((</span><span class="n">n</span> <span class="bp">%</span> <span class="n">l.length</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">l</span> <span class="bp">=</span> <span class="o">(</span><span class="n">l.rotate</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">norm_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>

  <span class="c1">-- Break up the iff into parts</span>
  <span class="n">fconstructor</span><span class="o">,</span>

  <span class="c1">-- Show that n % l.length = 0 → l = l.rotate n</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">l.rotate</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">l.rotate</span> <span class="o">(</span><span class="n">n</span> <span class="bp">%</span> <span class="n">l.length</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">list.rotate_mod</span> <span class="n">l</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">list.rotate_zero</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="o">},</span>

  <span class="c1">-- Show that l = l.rotate n → n % l.length = 0</span>
  <span class="c1">-- Prove by contradiction, showing that n % l.length ≠ 0 → l ≠ l.rotate n</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">by_contradiction</span> <span class="n">h₂</span><span class="o">,</span>

    <span class="c1">-- We have two different indices</span>
    <span class="k">let</span> <span class="n">k₁</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">k₂</span> <span class="o">:=</span> <span class="o">(</span><span class="n">k₁</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="bp">%</span> <span class="n">l.length</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h_k₁_ne_k₂</span> <span class="o">:</span> <span class="n">k₁</span> <span class="bp">≠</span> <span class="n">k₂</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">finish</span><span class="o">,</span>

    <span class="c1">-- Utility hypothesese required for list indexing - indices must be in range</span>
    <span class="k">have</span> <span class="n">h_k₁_le_len</span> <span class="o">:</span> <span class="n">k₁</span> <span class="bp">&lt;</span> <span class="n">l.length</span> <span class="o">:=</span> <span class="n">pos_of_gt</span> <span class="n">hl₁</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h_k₂_le_len</span> <span class="o">:</span> <span class="n">k₂</span> <span class="bp">&lt;</span> <span class="n">l.length</span> <span class="o">:=</span> <span class="o">(</span><span class="n">k₁</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">mod_lt</span> <span class="n">h_k₁_le_len</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h_k₁_le_rlen</span> <span class="o">:</span> <span class="n">k₁</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">l.rotate</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">finish</span><span class="o">,</span>

    <span class="c1">-- Show that the two different indices have the same value</span>
    <span class="k">have</span> <span class="n">h_vk₁_eq_vk₂</span><span class="o">:</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">k₁</span> <span class="n">h_k₁_le_len</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">k₂</span> <span class="n">h_k₂_le_len</span><span class="o">)</span> <span class="o">:=</span>
    <span class="kd">begin</span>
      <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">l.rotate</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">k₁</span> <span class="n">h_k₁_le_rlen</span> <span class="bp">=</span> <span class="n">l.nth_le</span> <span class="n">k₂</span> <span class="n">h_k₂_le_len</span> <span class="o">:=</span> <span class="n">list.nth_le_rotate</span> <span class="n">l</span> <span class="n">n</span> <span class="n">k₁</span> <span class="n">h_k₁_le_rlen</span><span class="o">,</span>
      <span class="n">finish</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>

    <span class="c1">-- Different indices having the same value implies that the list is not nodup</span>
    <span class="c1">-- Our list is nodup by definition</span>
    <span class="c1">-- This is our contradiction</span>
    <span class="k">have</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">l.nodup</span> <span class="o">:=</span> <span class="n">list.nth_le_eq_of_ne_imp_not_nodup</span> <span class="n">l</span> <span class="n">k₁</span> <span class="n">k₂</span> <span class="n">h_k₁_le_len</span> <span class="n">h_k₂_le_len</span> <span class="n">h_vk₁_eq_vk₂</span> <span class="n">h_k₁_ne_k₂</span><span class="o">,</span>
    <span class="n">finish</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>Thanks again for all of the help!</p>



<a name="249176136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249176136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249176136">(Aug 11 2021 at 22:10)</a>:</h4>
<p>Regarding the speed, <code>finish</code> is often a slow tactic</p>



<a name="249176163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249176163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249176163">(Aug 11 2021 at 22:11)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.rotate_eq_iff/src">src#list.rotate_eq_iff</a></p>



<a name="249176226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249176226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249176226">(Aug 11 2021 at 22:11)</a>:</h4>
<p>That's how that lemma is proven in more generality in mathlib (by yours truly)</p>



<a name="249176380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249176380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249176380">(Aug 11 2021 at 22:13)</a>:</h4>
<p>That doesn't look like a comparable statement to me</p>



<a name="249176402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249176402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249176402">(Aug 11 2021 at 22:13)</a>:</h4>
<p>Your <code>norm_cast</code> isn't doing much. Instead of <code>fconstructor</code>, which is a very low-level tactic, it is more customary to use <code>split</code>.</p>



<a name="249176509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249176509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249176509">(Aug 11 2021 at 22:14)</a>:</h4>
<p>Ah I must have misread it. I see.</p>



<a name="249176587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249176587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249176587">(Aug 11 2021 at 22:15)</a>:</h4>
<p>I don't think the <code>l.length &gt; 1</code> hypothesis is needed for it to be true?</p>



<a name="249178984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249178984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249178984">(Aug 11 2021 at 22:41)</a>:</h4>
<p>Oh I think that you're right about <code>l.length &gt; 1</code> not being needed! That's a holdover from a previous version of a slightly different lemma. I do use it in the proof to verify that the indices are in range, but I suppose I should just special case length 0 and length 1.</p>



<a name="249179089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249179089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249179089">(Aug 11 2021 at 22:42)</a>:</h4>
<p><code>finish</code> being slow is interesting. Those mostly appeared out of me lazily doing <code>hint</code> so I'll try to replace those with something faster.</p>



<a name="249179315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249179315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249179315">(Aug 11 2021 at 22:45)</a>:</h4>
<p>I'm quite surprised that nobody said that anything more drastic was wrong! Would this be considered a reasonably proof? If hypothetically this theorem were being put into mathlib, what would need to change to bring it up to standard?</p>



<a name="249179411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249179411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249179411">(Aug 11 2021 at 22:46)</a>:</h4>
<p>I don't know much about the policy for what gets added to mathlib. I just did this for fun and learning, but is it something that it might be worth turning into a PR or would mathlib not want it?</p>



<a name="249179573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249179573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249179573">(Aug 11 2021 at 22:48)</a>:</h4>
<p>I'll look at that <code>fconstructor</code> / <code>split</code> thing now! Thanks! I got <code>fconstructor</code> from <code>hint</code>, which didn't offer me <code>split</code>. Is there a reason for that?</p>



<a name="249183218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249183218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249183218">(Aug 11 2021 at 23:34)</a>:</h4>
<p>I've been able to turn the final <code>finish</code> into a nice <code>exact h₂ (false.rec (n % list.length l = 0) (this hl₂)),</code> by first using <code>solve_by_elim</code> instead, then using <code>show_term</code> and inlining it.</p>
<p>The other three <code>finish</code>s are giving me a bit more trouble, and <code>show_term</code> on them gives me some 20 line monstrosity. I'm leaving them as <code>finish</code> for now, but if anyone has any tips on how to tidy them up into something that runs faster without being verbose or ugly I'd appreciate it!</p>



<a name="249195849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249195849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249195849">(Aug 12 2021 at 04:07)</a>:</h4>
<p>Here's how I would phrase this lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.rotate</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="kd">theorem</span> <span class="n">nodup.rotate_eq_self_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hl</span> <span class="o">:</span> <span class="n">l.nodup</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l.rotate</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">l</span> <span class="bp">↔</span> <span class="n">n</span> <span class="bp">%</span> <span class="n">l.length</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">l</span> <span class="bp">=</span> <span class="o">[]</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">l.length.zero_le.eq_or_lt</span> <span class="k">with</span> <span class="n">hl'</span> <span class="n">hl'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span><span class="n">length_eq_zero</span><span class="o">,</span> <span class="bp">←</span><span class="n">hl'</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">left</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">nodup_iff_nth_le_inj</span> <span class="n">at</span> <span class="n">hl</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">hl</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">nat.mod_lt</span> <span class="n">_</span> <span class="n">hl'</span><span class="o">)</span> <span class="n">hl'</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">nth_le_rotate'</span> <span class="n">_</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">nat.sub_add_cancel</span> <span class="o">(</span><span class="n">nat.mod_lt</span> <span class="n">_</span> <span class="n">hl'</span><span class="o">)</span><span class="bp">.</span><span class="n">le</span><span class="o">,</span> <span class="n">nat.mod_self</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">(</span><span class="n">h</span><span class="bp">|</span><span class="n">h</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">rotate_mod</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">rotate_zero</span> <span class="n">l</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">list</span>
</code></pre></div>



<a name="249202890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249202890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249202890">(Aug 12 2021 at 06:54)</a>:</h4>
<p>Wow thank you <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span>! That is so much cleaner than mine! I won't be able to properly study what you've done until later, but this is an incredibly valuable learning resource.</p>



<a name="249203004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Defining%20a%20list%20type%20with%20a%20no%20duplicates%20constraint/near/249203004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint.html#249203004">(Aug 12 2021 at 06:56)</a>:</h4>
<p>In runs in a fraction of a second compared to 10 seconds for mine, too. I guess those tactics really were doing me in!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
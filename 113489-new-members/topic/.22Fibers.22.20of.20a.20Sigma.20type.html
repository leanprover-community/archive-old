---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html">"Fibers" of a Sigma type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="260264958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260264958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260264958">(Nov 04 2021 at 12:55)</a>:</h4>
<p>Hey, what would be the "right" way to define the "fiber" of some sigma type? I can do the following </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kd">constant</span> <span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kd">def</span> <span class="n">B</span> <span class="o">:=</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">×</span> <span class="n">A</span><span class="o">),</span> <span class="n">h</span> <span class="n">t.fst</span> <span class="n">t.snd</span>
<span class="kd">constants</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span>
<span class="kd">def</span> <span class="n">C</span> <span class="o">:=</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">//</span> <span class="n">t.fst.fst</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">t.fst.snd</span> <span class="bp">=</span> <span class="n">y</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">u</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="k">have</span> <span class="n">u1</span> <span class="o">:=</span> <span class="n">t.val.snd</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">subtype.val_eq_coe</span> <span class="n">at</span> <span class="n">u1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">t.prop.left</span> <span class="n">at</span> <span class="n">u1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">t.prop.right</span> <span class="n">at</span> <span class="n">u1</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">u1</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>but this feels so wrong to have to invoque rewrites and stuff in a definition. Is there a more "canonical" way to define the type <code>C</code> so that the <code>u</code> might have a better definition that does not involve clumsy rewrites like this?</p>



<a name="260265148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260265148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260265148">(Nov 04 2021 at 12:57)</a>:</h4>
<p>The issue is that the equalities in C are propositional rather than definitional but I don't know if there is a way around this.</p>



<a name="260267431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260267431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260267431">(Nov 04 2021 at 13:15)</a>:</h4>
<p>I guess <code>h x y</code>is already the type I'm looking for in a way, though, this is probably not exactly the question I wanted to ask.</p>



<a name="260283812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260283812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260283812">(Nov 04 2021 at 15:11)</a>:</h4>
<p>(note that using <code>constant</code> like that is atypical, usually you'd use <code>variable</code>)</p>



<a name="260285772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260285772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260285772">(Nov 04 2021 at 15:24)</a>:</h4>
<p>First, this is a more typical way this might be written (<code>constant</code> is atypical because it introduces things as axioms; <code>variables</code> introduces them as arguments for the definitions instead):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">B</span> <span class="o">:=</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">×</span> <span class="n">A</span><span class="o">),</span> <span class="n">h</span> <span class="n">t.fst</span> <span class="n">t.snd</span>
<span class="kd">def</span> <span class="n">C</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">B</span> <span class="n">h</span> <span class="bp">//</span> <span class="n">t.fst.fst</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">t.fst.snd</span> <span class="bp">=</span> <span class="n">y</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">u</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">C</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="k">have</span> <span class="n">u1</span> <span class="o">:=</span> <span class="n">t.val.snd</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">subtype.val_eq_coe</span> <span class="n">at</span> <span class="n">u1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">t.prop.left</span> <span class="n">at</span> <span class="n">u1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">t.prop.right</span> <span class="n">at</span> <span class="n">u1</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">u1</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I'm not sure there's a way around needing to rewrite for fibers of a sigma type.  There's a trick, though, using the fancier decomposition tactics like <code>rintro</code>, <code>rcases</code>, and <code>obtain</code> which is to use the fact you can have constructors appear in the pattern.  The effect of the <code>rfl</code> constructor is <code>subst</code>, so you can do the rewrites in one fell swoop:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">u</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">C</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h'</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260286326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260286326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260286326">(Nov 04 2021 at 15:27)</a>:</h4>
<p>Second, I would probably use nested sigma types rather than use a product.  It doesn't really change much, but it's worth knowing that you can do it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">B</span> <span class="o">:=</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span>   <span class="c1">-- short for Σ (x : A), Σ (y : A), h x y</span>
<span class="kd">def</span> <span class="n">C</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">B</span> <span class="n">h</span> <span class="bp">//</span> <span class="n">t.fst</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">t.snd.fst</span> <span class="bp">=</span> <span class="n">y</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">u</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">C</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h'</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260287393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260287393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260287393">(Nov 04 2021 at 15:34)</a>:</h4>
<p>One more comment: rather than <code>.fst</code> and <code>.snd</code>, for these simple types it's common to use <code>.1</code> and <code>.2</code> like so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">C</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">B</span> <span class="n">h</span> <span class="bp">//</span> <span class="n">t.1</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">t.2.1</span> <span class="bp">=</span> <span class="n">y</span><span class="o">}</span>
</code></pre></div>
<p>This numerical notation works universally for structures, no matter what the names of the fields actually are.</p>



<a name="260297131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260297131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260297131">(Nov 04 2021 at 16:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="286014">Robin Carlier</span> <a href="#narrow/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type/near/260267431">said</a>:</p>
<blockquote>
<p>I guess <code>h x y</code>is already the type I'm looking for in a way, though, this is probably not exactly the question I wanted to ask.</p>
</blockquote>
<p>Here's sort of a proof that <code>h x y</code> is the type you're looking for, but also a sort of proof that all the rewrites don't really get in the way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">u</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">C</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">≃</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">C</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span><span class="o">),</span> <span class="kd">begin</span>
    <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">t</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h'</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span><span class="o">),</span> <span class="o">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">t</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="260344347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260344347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260344347">(Nov 04 2021 at 22:38)</a>:</h4>
<p>IMO It's a little strange to try to define the fibres of a sigma type... The point of a sigma type is to define a type if you're given the fibres. What are you actually trying to do?</p>



<a name="260377968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260377968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260377968">(Nov 05 2021 at 08:42)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> The thing I'm trying to do is related to the colimit of quivers and category thing I mentionned in an other thread: quivers in lean are defined as a structure of a type <code>V</code> of 'vertices' and a hom <code>V → V → Type u</code>.<br>
A common way to describe quivers in category theory is as a presheaf on the walking parallel pair (two objects V and E, two morphisms from V to E): the functor from quivers a la lean to a quiver as presheaves sends a quiver to the functor that sends <code>V</code>to its type,  and that sends  <code>E</code> to the sigma type I defined above, and the two maps to the two projections.<br>
Now the inverse functor sends a presheaf <code>F</code> to the type <code>F.obj V</code>, and the <code>hom</code>between two elements <code>x</code>and <code>y</code> in that type should be defined as the fiber at <code>x, y</code> of the map <code>F.obj E → F.obj V × F.obj V </code>. To see this gives an equivalence of categories, you have to go through the fact this fiber thing gives back the type you want, which is what Kyle proved above. <br>
The presheaf description of quivers is nice in that it gives existence of limits and colimits for free, since they are functors from a small category to <code>Type u</code>.</p>



<a name="260378261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260378261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260378261">(Nov 05 2021 at 08:46)</a>:</h4>
<p>when trying to implement that the rewrites got a bit in the way, so <span class="user-mention" data-user-id="306601">@Kyle Miller</span> 's answer is very helpful!</p>



<a name="260413090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260413090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260413090">(Nov 05 2021 at 14:35)</a>:</h4>
<p>The rewritings are still a bit of a pain... I put my stuff in <a href="https://gist.github.com/robin-carlier/9e833c13031e80083a38eb3640bb31dc">https://gist.github.com/robin-carlier/9e833c13031e80083a38eb3640bb31dc</a> if someone wants to have a look, the goal in the first sorry is a complete mess because of those rewrites.<br>
I think I'm not taking the right approach to this.</p>



<a name="260413800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260413800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260413800">(Nov 05 2021 at 14:41)</a>:</h4>
<p><span class="user-mention" data-user-id="286014">@Robin Carlier</span> this old discussion is related: <br>
<a href="#narrow/stream/252551-graph-theory/topic/spans/near/214898332">https://leanprover.zulipchat.com/#narrow/stream/252551-graph-theory/topic/spans/near/214898332</a></p>



<a name="260414949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260414949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260414949">(Nov 05 2021 at 14:49)</a>:</h4>
<p>Very relevant indeed, thanks a lot for this link! <br>
What I get out of this is that "working with sigma types for this sort of thing leads to a huge amount of pain very quickly", which is also my experience this far :D <br>
I see that in the end <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> seems to have part of the desired equivalence, the remaining part being an equivalence between <code>dgraph</code> and an actual category of functor.</p>



<a name="260422103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260422103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260422103">(Nov 05 2021 at 15:41)</a>:</h4>
<p>In another discussion, Reid said something about the theoretical relationship when I asked a couple message up: <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/214905554">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/214905554</a></p>



<a name="260422263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260422263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260422263">(Nov 05 2021 at 15:42)</a>:</h4>
<p>Yes, that stuff is in the end an instance of the grothendieck construction but I think this would be a huge rabbit hole to formalize in itself.</p>



<a name="260424704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260424704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260424704">(Nov 05 2021 at 15:59)</a>:</h4>
<p>Right so in ordinary math, an S-indexed family of sets is "the same as" a set with a map to S, but as you've discovered, in type theory the former has a preferred status.</p>



<a name="260433780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260433780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260433780">(Nov 05 2021 at 17:00)</a>:</h4>
<p>Even though one has a preferred status, the equivalence between the two should still be expected, despite being perhaps a bit more convoluted to prove right?</p>



<a name="260434079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260434079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260434079">(Nov 05 2021 at 17:02)</a>:</h4>
<p>Passing information along equivalences however might not be so easy.</p>



<a name="260434627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260434627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260434627">(Nov 05 2021 at 17:06)</a>:</h4>
<p>Yes, this I'm ok to believe.<br>
In the case of "quivers as families" vs. "quiver as presheaves", the fact that they are equivalent as categories is enough to prove the former has limits and colimits anyway, which was the goal here.</p>



<a name="260434810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260434810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260434810">(Nov 05 2021 at 17:07)</a>:</h4>
<p>Trying to extract actual construction of limits or colimits via this equivalence will be rather hard</p>



<a name="260436328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260436328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260436328">(Nov 05 2021 at 17:18)</a>:</h4>
<p>Here's some category theory without the <code>category_theory</code>, showing (most of the argument) that spans are equivalent to indexed families:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">dgraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">dgraph'</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">edge</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">dgraph.hom</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="n">G'</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="n">G.E</span> <span class="bp">→</span> <span class="n">G'.E</span><span class="o">)</span>
<span class="o">(</span><span class="n">s_map</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.E</span><span class="o">),</span> <span class="n">G'.s</span> <span class="o">(</span><span class="n">map</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G.s</span> <span class="n">e</span><span class="o">)</span>
<span class="o">(</span><span class="n">t_map</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.E</span><span class="o">),</span> <span class="n">G'.t</span> <span class="o">(</span><span class="n">map</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G.t</span> <span class="n">e</span><span class="o">)</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">dgraph.hom.comp</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="n">G'</span> <span class="n">G''</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G.hom</span> <span class="n">G'</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:</span> <span class="n">G'.hom</span> <span class="n">G''</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.hom</span> <span class="n">G''</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="n">f'.map</span> <span class="bp">∘</span> <span class="n">f.map</span><span class="o">,</span>
  <span class="n">s_map</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">dgraph.hom.s_map</span><span class="o">],</span>
  <span class="n">t_map</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">dgraph.hom.t_map</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">dgraph.hom.id</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">G.hom</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">s_map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">t_map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">dgraph'.hom</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="n">G'</span> <span class="o">:</span> <span class="n">dgraph'</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="n">G.edge</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">G'.edge</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">dgraph'.hom.comp</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="n">G'</span> <span class="n">G''</span> <span class="o">:</span> <span class="n">dgraph'</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G.hom</span> <span class="n">G'</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:</span> <span class="n">G'.hom</span> <span class="n">G''</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.hom</span> <span class="n">G''</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span> <span class="n">e</span><span class="o">,</span> <span class="n">f'.map</span> <span class="o">(</span><span class="n">f.map</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">dgraph'.hom.id</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">dgraph'</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">G.hom</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">id</span> <span class="o">}</span>

<span class="sd">/-- A functor from the dgraph category to the dgraph' category -/</span>
<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">dgraph.to_dgraph'</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">dgraph'</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">edge</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.E</span> <span class="bp">//</span> <span class="n">G.s</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">v</span> <span class="bp">∧</span> <span class="n">G.t</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">w</span><span class="o">}</span> <span class="o">}</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">dgraph.to_dgraph'_hom</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="n">G'</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">dgraph.hom</span> <span class="n">G</span> <span class="n">G'</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dgraph'.hom</span> <span class="n">G.to_dgraph'</span> <span class="n">G'.to_dgraph'</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span> <span class="n">e</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">f.map</span> <span class="n">e</span><span class="o">,</span> <span class="n">f.s_map</span> <span class="n">_</span><span class="o">,</span> <span class="n">f.t_map</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="sd">/-- A functor from the dgraph' category to the dgraph category -/</span>
<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">dgraph'.to_dgraph</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">dgraph'</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">E</span> <span class="o">:=</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G'.edge</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">s</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.1</span><span class="o">,</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.2.1</span> <span class="o">}</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">dgraph'.to_dgraph_hom</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="n">G'</span> <span class="o">:</span> <span class="n">dgraph'</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">dgraph'.hom</span> <span class="n">G</span> <span class="n">G'</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dgraph.hom</span> <span class="n">G.to_dgraph</span> <span class="n">G'.to_dgraph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="o">⟨</span><span class="n">e.1</span><span class="o">,</span> <span class="n">e.2.1</span><span class="o">,</span> <span class="n">f.map</span> <span class="n">e.2.2</span><span class="o">⟩,</span>
  <span class="n">s_map</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">t_map</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">}</span>

<span class="c1">-- The composition of these functors is an equivalence:</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">dgraph.to_dgraph_to_dgraph'</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dgraph.hom</span> <span class="n">G</span> <span class="n">G.to_dgraph'.to_dgraph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="o">⟨</span><span class="n">G.s</span> <span class="n">e</span><span class="o">,</span> <span class="n">G.t</span> <span class="n">e</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">s_map</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">t_map</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">dgraph.to_dgraph_to_dgraph'_symm</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dgraph.hom</span> <span class="n">G.to_dgraph'.to_dgraph</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.2.2.1</span><span class="o">,</span>
  <span class="n">s_map</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span><span class="n">w</span><span class="o">,</span><span class="n">e</span><span class="o">,</span><span class="n">rfl</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">t_map</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span><span class="n">w</span><span class="o">,</span><span class="n">e</span><span class="o">,</span><span class="n">rfl</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">dgraph.to_dgraph_equiv1</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.to_dgraph_to_dgraph'.comp</span> <span class="n">G.to_dgraph_to_dgraph'_symm</span> <span class="bp">=</span> <span class="n">dgraph.hom.id</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">dgraph.to_dgraph_equiv2</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.to_dgraph_to_dgraph'_symm.comp</span> <span class="n">G.to_dgraph_to_dgraph'</span> <span class="bp">=</span> <span class="n">dgraph.hom.id</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">e</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="c1">-- The composition of these functors in the other direction is an equivalence:</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">dgraph'.to_dgraph'_to_dgraph</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">dgraph'</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dgraph'.hom</span> <span class="n">G</span> <span class="n">G.to_dgraph.to_dgraph'</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span> <span class="n">e</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">e</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">}</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">dgraph'.to_dgraph'_to_dgraph_symm</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">dgraph'</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dgraph'.hom</span> <span class="n">G.to_dgraph.to_dgraph'</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span> <span class="n">e</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">convert</span> <span class="n">e.1.2.2</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">e.2.1.symm</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">e.2.2.symm</span> <span class="o">},</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">dgraph'.to_dgraph'_equiv1</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">dgraph'</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.to_dgraph'_to_dgraph.comp</span> <span class="n">G.to_dgraph'_to_dgraph_symm</span> <span class="bp">=</span> <span class="n">dgraph'.hom.id</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">dgraph'.to_dgraph'_equiv2</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">dgraph'</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.to_dgraph'_to_dgraph_symm.comp</span> <span class="n">G.to_dgraph'_to_dgraph</span> <span class="bp">=</span> <span class="n">dgraph'.hom.id</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">v</span> <span class="n">w</span> <span class="n">e</span><span class="bp">;</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">e</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">e</span><span class="bp">;</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260437145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260437145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260437145">(Nov 05 2021 at 17:24)</a>:</h4>
<p>Wow, great!</p>



<a name="260437551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260437551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260437551">(Nov 05 2021 at 17:27)</a>:</h4>
<p>(It'd be a good <code>category_theory</code> exercise to put it in that language -- I'm not really sure why I didn't start that way.)</p>



<a name="260437745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260437745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260437745">(Nov 05 2021 at 17:29)</a>:</h4>
<p>Yup, that's what I intend to do at some point :D</p>



<a name="260437942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260437942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260437942">(Nov 05 2021 at 17:30)</a>:</h4>
<p><code>dgraph'.to_dgraph'_equiv1</code> by the way was the most horrific proof to get working, and luck seemed to be on my side to be able to find this.  You should take a look at the term a plain <code>simp</code> gives right after <code>ext v w e</code>...</p>



<a name="260438149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260438149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260438149">(Nov 05 2021 at 17:32)</a>:</h4>
<p>It might be because the <code>@[simps]</code> aren't generating good simp lemmas, but I'd expect something like that anyway because of how many rewrites &amp; destructurings are needed in these definitions.</p>



<a name="260438286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260438286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260438286">(Nov 05 2021 at 17:33)</a>:</h4>
<p>Which version of lean is your code in? vscode is complaining that <code>@[ext]</code> is an unknown attribute.</p>



<a name="260438417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260438417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260438417">(Nov 05 2021 at 17:34)</a>:</h4>
<p>Same for <code>@[simps]</code></p>



<a name="260438625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260438625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260438625">(Nov 05 2021 at 17:36)</a>:</h4>
<p>Are you using an up to date mathlib master Robin?</p>



<a name="260438676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260438676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260438676">(Nov 05 2021 at 17:37)</a>:</h4>
<p>oh ! Kyle didn't put any imports! <code>import tactic</code> at the top fixes everything.</p>



<a name="260438732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260438732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260438732">(Nov 05 2021 at 17:37)</a>:</h4>
<p>Oops, it's just <code>import tactic</code></p>



<a name="260439413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260439413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260439413">(Nov 05 2021 at 17:42)</a>:</h4>
<p>Putting <code>import tactic</code>at the top makes lean gives me an "excessive memory consumption", I'll figure something. I think my mathlib is up-to-date yes.</p>



<a name="260439440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260439440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260439440">(Nov 05 2021 at 17:43)</a>:</h4>
<p>Exit VS Code and restart it.</p>



<a name="260439486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260439486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260439486">(Nov 05 2021 at 17:43)</a>:</h4>
<p>Or ctrl-shift-P -&gt; Restart Lean</p>



<a name="260439628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260439628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260439628">(Nov 05 2021 at 17:44)</a>:</h4>
<p>Unrelated to memory consumption, I made a more "surgical" definition for <code>dgraph'.to_dgraph'_to_dgraph_symm</code> and the proof is much less horrific: now it's <code>rfl</code>!  (The code block above is updated.)</p>



<a name="260441317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Fibers%22%20of%20a%20Sigma%20type/near/260441317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Carlier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type.html#260441317">(Nov 05 2021 at 17:56)</a>:</h4>
<p>The kind of goal it was giving before the update was the kind of goal I was stuck on in the gist I posted a few posts above</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
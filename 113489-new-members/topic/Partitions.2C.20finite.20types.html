---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Partitions.2C.20finite.20types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html">Partitions, finite types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="273894834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273894834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273894834">(Mar 02 2022 at 23:23)</a>:</h4>
<p>It is not clear to me how one should work with <code>finset</code>s. <br>
I was willing to formulate a variant of <a href="https://leanprover-community.github.io/mathlib_docs/find/finpartition.sum_card_parts">docs#finpartition.sum_card_parts</a> where the partition is not finite a priori,<br>
but just finite because the ambient set is finite.<br>
In the course of it, I was needed to prove that for a <code>fintype X</code>,  any <code>c : set(set X)</code>is itself finite.<br>
That worked out (see the mwe below), at the price of noncomputability — which I don't understand.<br>
On the other hand, it is not clear to me neither why Lean couldn't find the instance itself.<br>
Any explanation will be welcome !</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.basic</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">data.setoid.partition</span>
<span class="kn">import</span> <span class="n">data.set.finite</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">noncomputable</span>
<span class="kd">lemma</span> <span class="n">fintype_of_set</span> <span class="o">[</span><span class="n">hfX</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span> <span class="o">:</span> <span class="n">fintype</span> <span class="bp">↥</span><span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">fin_ssX</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">set</span><span class="o">(</span><span class="n">set</span><span class="o">(</span><span class="n">X</span><span class="o">)))</span> <span class="o">:=</span> <span class="n">set.fintype</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">set.finite.fintype</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">set.finite.of_fintype</span> <span class="n">c</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">card_of_partition_eq</span> <span class="o">[</span><span class="n">hfX</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)}</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">setoid.is_partition</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="bp">↥</span><span class="n">c</span><span class="o">]</span> <span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">),</span> <span class="n">fintype</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">b</span> <span class="k">in</span> <span class="n">c.to_finset</span><span class="o">,</span> <span class="n">fintype.card</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="273896018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273896018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273896018">(Mar 02 2022 at 23:33)</a>:</h4>
<p>Your first instance is <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype.fintype">docs#subtype.fintype</a> combined with <a href="https://leanprover-community.github.io/mathlib_docs/find/set.fintype">docs#set.fintype</a> and a decidability instance that you didn't have.</p>



<a name="273896187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273896187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273896187">(Mar 02 2022 at 23:35)</a>:</h4>
<p>Long story short for decidability, a <code>finset</code> can be enumerated, so when constructing one you must ensure you do not add twice the same element.</p>



<a name="273896314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273896314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273896314">(Mar 02 2022 at 23:37)</a>:</h4>
<p>In another world I believe we could get rid of those decidability conditions by defining <code>finset</code> directly as the quotient of <code>list</code> under the extensionality relation, rather than as the subtype of nodup <code>multiset</code>s. This seems to be the gist of the difference between <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp">docs#finsupp</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/dfinsupp">docs#dfinsupp</a>.</p>



<a name="273896342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273896342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273896342">(Mar 02 2022 at 23:37)</a>:</h4>
<p>Maybe <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> has a better explanation?</p>



<a name="273898800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273898800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273898800">(Mar 03 2022 at 00:00)</a>:</h4>
<p>Maybe we should make some instances for <code>set.finite</code> in the presence of <code>nonempty (fintype X)</code>?</p>



<a name="273899137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273899137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273899137">(Mar 03 2022 at 00:01)</a>:</h4>
<p>We should mostly have a <code>finite</code> typeclass, as Yury wanted.</p>



<a name="273899231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273899231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273899231">(Mar 03 2022 at 00:02)</a>:</h4>
<p>I'm afraid however that this will only bring confusion around the finiteness conundrum.</p>



<a name="273899242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273899242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273899242">(Mar 03 2022 at 00:02)</a>:</h4>
<p>There's already a profusion of options.</p>



<a name="273899289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273899289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273899289">(Mar 03 2022 at 00:03)</a>:</h4>
<p>But we do have a <code>finite</code> typeclass -- it's <code>nonempty (fintype X)</code></p>



<a name="273899449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273899449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273899449">(Mar 03 2022 at 00:04)</a>:</h4>
<p>Basically finsets are hard to use if you're a beginner or are coming to things with a mathematical viewpoint and have no interest in decidability, and I wonder whether it's worth exploring more the nonconstructive versions of these things. With polynomials we liked it so much that we switched</p>



<a name="273958728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273958728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273958728">(Mar 03 2022 at 11:28)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> To get rid of the decidability assumption in subtype.fintype requires more than just quotienting lists by extensionality; this eliminates the need for the elements of the list to be distinct, but not for them to be elements of the base type <code>A</code> in the first place. If you have a <code>list X</code> covering all the elements of <code>X</code> and want a list of elements of <code>{x : X // p x}</code> covering <code>{x : X // p x}</code>, you have to decide for each original element whether to keep it (if <code>p x</code> is true) or discard it (if <code>p x</code> is false). If you discard an element you needed to keep then it might not cover all the elements of <code>{x : X // p x}</code>, and if you keep an element you need to discard then you can't fit it in the type <code>{x : X // p x}</code>. So you need to decide <code>p x</code> to determine the list.</p>



<a name="273971615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273971615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273971615">(Mar 03 2022 at 13:27)</a>:</h4>
<p>I am ready to try to understand the decidability issues, they quite interest me. But what I need above all is some directions for how we use those (fin)sets and (fin)types.<br>
An explanation.<br>
I formalized some results from Wielandt's <em>Finite permutation groups</em>. A lot of it is about group actions an arbitrary sets, but part of it requires that the sets be finite.  <br>
Should the general stuff be duplicated (eliminating decidability issues in the finset case) ? <br>
Otherwise, should the relevant hypothesis be a <code>fintype</code> instance? or add a <code>set.finite</code> assumption?<br>
This is here that I need directions/advices.</p>



<a name="273992558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273992558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273992558">(Mar 03 2022 at 15:53)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> If you can figure out how to effectively work with finiteness in lean, please do let us all know! (It's been a huge pain for a lot of us for quite some time.)</p>
<p>More seriously, I think it's a matter of getting to know the API, which is perhaps not so intuitive. Here are a few examples to get started. If you want to know how to do something else, let me know!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.finite</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span> <span class="n">infer_instance</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">S.finite</span> <span class="o">:=</span> <span class="n">set.finite.of_fintype</span> <span class="n">S</span> <span class="c1">-- found using library search</span>

<span class="kd">noncomputable</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">(</span><span class="n">set.finite.of_fintype</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">S.finite</span> <span class="o">:=</span> <span class="n">set.finite.of_fintype</span> <span class="n">S</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)]</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">infer_instance</span>

<span class="n">open_locale</span> <span class="n">classical</span>
<span class="kd">noncomputable theory</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">infer_instance</span>
</code></pre></div>



<a name="273993658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Partitions%2C%20finite%20types/near/273993658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Partitions.2C.20finite.20types.html#273993658">(Mar 03 2022 at 15:59)</a>:</h4>
<p>(Note that lean does indeed find that last instance, but as Yaël mentioned, one has to deal with decidability, hence the <code>open_locale classical</code> line, or the <code>decidable_pred</code> parameter)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
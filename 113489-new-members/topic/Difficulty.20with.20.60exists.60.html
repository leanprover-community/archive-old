---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html">Difficulty with `exists`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="234800833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234800833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234800833">(Apr 16 2021 at 06:28)</a>:</h4>
<p>Hi,</p>
<p>This is a long <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>; I've shorten as much of it as possible while trying to keep all the important things, although please ask if something seems to be missing. I'm trying to prove the Zassenhaus butterfly lemma, and I've run into some problems while trying to work with the construction of the isomorphisms. Here we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo>⊴</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A' \trianglelefteq A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8885620000000001em;vertical-align:-0.13667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo>⊴</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">B' \trianglelefteq B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8885620000000001em;vertical-align:-0.13667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> as subgroups of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>. The first step is to construct a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>A</mi><mo>⊓</mo><mi>B</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>A</mi><mo>⊓</mo><mi>B</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msup><mi>A</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo>⊓</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>A</mi><mo>⊓</mo><msup><mi>B</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A' (A \sqcap B) \to (A \sqcap B) / (A' \sqcap B)(A \sqcap B')</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. This is <code>Zassenhaus_fun </code>. Normally the definition goes something like: "Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>∈</mo><msup><mi>A</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>A</mi><mo>⊓</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax \in A' (A \sqcap B)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><msup><mi>A</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">a \in A'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>A</mi><mo>⊓</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">x \in A \sqcap B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. Map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">ax</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">xD</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mi>A</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo>⊓</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>A</mi><mo>⊓</mo><msup><mi>B</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D = (A' \sqcap B)(A \sqcap B')</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. This is well-defined because blah blah..."</p>
<p>This is done as <code>λ x, quotient.mk' ⟨_, ((mem_mul (Zassenhaus_aux B hA)).mp x.2).some_spec.some_spec.2.1⟩</code>. (This is very ugly and I would be happy to know if there was a better way to do it.) But I settled on it and tried to move on with the next part of the proof, which is showing that the kernel of the map is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>A</mi><mo>⊓</mo><msup><mi>B</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A' (A \sqcap B')</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.  The inclusion <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>A</mi><mo>⊓</mo><msup><mi>B</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>⊆</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">A' (A \sqcap B') \subseteq \ker f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">ker</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is supposed to be obvious: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">ax</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span> is mapped to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>D</mi><mo>=</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">xD = D</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>, since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> is annihilated.  </p>
<p>Now the problem: To invoke the factorization of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">ax</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span> from a generic term of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>A</mi><mo>⊓</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A'(A \sqcap B)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>, I have to use <code>mem_mul </code>. However, this only gives me <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>A</mi><mo>⊓</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">x \in A \sqcap B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and loses the information that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>A</mi><mo>⊓</mo><msup><mi>B</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">x \in A \sqcap B'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>. In my code, this happens exactly as I define <code>X : ↥(A ⊓ B)</code>. How should I retain the membership information? I want to use the <code>h</code> hypothesis, but it turns out that doing so yields an error where the type of my proofs don't match, and I can't convert my goal. (I can also post the code for my other attempts.)</p>
<p>Also, I'm wondering if this is an <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> problem. Is my entire way of approaching this wrong? How should I think to proceed? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.subgroup</span>
<span class="kn">import</span> <span class="n">group_theory.quotient_group</span>
<span class="kn">import</span> <span class="n">data.setoid.basic</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>
<span class="kn">namespace</span> <span class="n">subgroup</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span>

<span class="c">/-</span><span class="cm"> View `H` as a subgroup of `K`. -/</span>
<span class="kd">def</span> <span class="n">of</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">K</span> <span class="o">:=</span> <span class="n">H.comap</span> <span class="n">K.subtype</span>

<span class="kd">lemma</span> <span class="n">mem_of</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="n">h</span> <span class="bp">∈</span> <span class="n">H.of</span> <span class="n">K</span> <span class="bp">↔</span> <span class="n">K.subtype</span> <span class="n">h</span> <span class="bp">∈</span> <span class="n">H</span> <span class="bp">⊓</span> <span class="n">K</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">mem_of_subset</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hK</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">≤</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">K</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">mem_mul</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">{</span><span class="n">H</span> <span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">↑</span><span class="o">(</span><span class="n">H</span> <span class="bp">⊔</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="bp">*</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g</span> <span class="bp">∈</span> <span class="n">H</span> <span class="bp">⊔</span> <span class="n">K</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">H</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">K</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">Zassenhaus_subgroup</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">:</span> <span class="o">((</span><span class="n">A'</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B'</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sup_le</span> <span class="o">(</span><span class="n">inf_le_inf</span> <span class="n">hA</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="n">inf_le_inf</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">)</span> <span class="n">hB</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">Zassenhaus1</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span> <span class="o">(((</span><span class="n">A'</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B'</span><span class="o">))</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">))</span><span class="bp">.</span><span class="n">normal</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">Zassenhaus_quot</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:=</span>
<span class="n">quotient_group.quotient</span> <span class="bp">$</span> <span class="o">((</span><span class="n">A'</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B'</span><span class="o">))</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">Zassenhaus_group</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span> <span class="n">group</span> <span class="o">(</span><span class="n">Zassenhaus_quot</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">Zassenhaus_quot</span><span class="o">],</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">subgroup.Zassenhaus1</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">,</span> <span class="n">apply_instance</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">Zassenhaus_aux</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">↑</span><span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">A'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">Zassenhaus_fun</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→*</span> <span class="o">(</span><span class="n">Zassenhaus_quot</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">quotient.mk'</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">((</span><span class="n">mem_mul</span> <span class="o">(</span><span class="n">Zassenhaus_aux</span> <span class="n">B</span> <span class="n">hA</span><span class="o">))</span><span class="bp">.</span><span class="n">mp</span> <span class="n">x.2</span><span class="o">)</span><span class="bp">.</span><span class="n">some_spec.some_spec.2.1</span><span class="o">⟩,</span>
  <span class="n">map_one'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">Zassenhaus_fun_ker</span> <span class="o">(</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">Zassenhaus_fun</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">)</span><span class="bp">.</span><span class="n">ker</span> <span class="bp">=</span> <span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B'</span><span class="o">)</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">ax</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">monoid_hom.mem_ker</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">Zassenhaus_fun</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">quot.sound</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mem_of</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">split_ax</span> <span class="o">:=</span> <span class="o">((</span><span class="n">mem_mul</span> <span class="o">(</span><span class="n">Zassenhaus_aux</span> <span class="n">B</span> <span class="n">hA</span><span class="o">))</span><span class="bp">.</span><span class="n">mp</span> <span class="n">ax.2</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">X</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">split_ax.some_spec.some</span><span class="o">,</span> <span class="n">split_ax.some_spec.some_spec.2.1</span><span class="o">⟩,</span>
  <span class="k">suffices</span> <span class="n">hm</span> <span class="o">:</span> <span class="n">X</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">∈</span> <span class="o">((</span><span class="n">A'</span> <span class="bp">⊓</span> <span class="n">B</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B'</span><span class="o">)</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)),</span>
  <span class="n">exact</span> <span class="n">hm</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">subgroup</span>
</code></pre></div>



<a name="234801626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234801626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234801626">(Apr 16 2021 at 06:38)</a>:</h4>
<p>Here is the version where I do use <code>h</code>, for more context.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">Zassenhaus_fun_ker</span> <span class="o">(</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">Zassenhaus_fun</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">)</span><span class="bp">.</span><span class="n">ker</span> <span class="bp">=</span> <span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B'</span><span class="o">)</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">ax</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">monoid_hom.mem_ker</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">Zassenhaus_fun</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">quot.sound</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mem_of</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="o">((</span><span class="n">mem_mul</span> <span class="o">(</span><span class="n">Zassenhaus_aux</span> <span class="n">B'</span> <span class="n">hA</span><span class="o">))</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hax</span><span class="o">⟩,</span>
  <span class="c1">-- Here `hx` is the correct membership proof that `x ∈ A ⊓ B'`.</span>
  <span class="k">have</span> <span class="n">hx'</span> <span class="o">:=</span> <span class="n">mem_of_subset</span> <span class="o">(</span><span class="n">inf_le_inf</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">A</span><span class="o">)</span> <span class="n">hB</span><span class="o">)</span> <span class="n">hx</span><span class="o">,</span> <span class="c1">-- I can upgrade it to `x ∈ A ⊓ B`,</span>
  <span class="k">have</span> <span class="n">X</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx'</span><span class="o">⟩,</span> <span class="c1">-- And use it to construct `X`,</span>
  <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="n">X</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">∈</span> <span class="o">((</span><span class="n">A'</span> <span class="bp">⊓</span> <span class="n">B</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B'</span><span class="o">)</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)),</span> <span class="c1">-- But now it fails :(</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="234802348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234802348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234802348">(Apr 16 2021 at 06:47)</a>:</h4>
<p>Given your definitions, one thing that might be useful to prove is <code>H.of K = (H ⊓ K).of K</code>. Then, given <code>x \in H.of K</code>, you can manufacture a bit of extra information about it before the quotient</p>



<a name="234802661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234802661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234802661">(Apr 16 2021 at 06:50)</a>:</h4>
<p>How is <code>Zassenhaus_aux</code> proven?</p>



<a name="234803341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234803341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234803341">(Apr 16 2021 at 06:58)</a>:</h4>
<p>Like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">Zassenhaus_aux</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">↑</span><span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">A'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">normal_subgroup_mul</span> <span class="n">A'</span> <span class="n">A</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="n">hA</span> <span class="o">(</span><span class="n">inf_le_left_of_le</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">A</span><span class="o">))</span>
</code></pre></div>
<p>The statement of <code>normal_subgroup_mul</code> is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">normal_subgroup_mul</span> <span class="o">(</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">hN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">A'</span> <span class="bp">*</span> <span class="n">B</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="234803678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234803678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234803678">(Apr 16 2021 at 07:00)</a>:</h4>
<p>And <code>normal_subgroup_mul</code>?</p>



<a name="234803715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234803715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234803715">(Apr 16 2021 at 07:00)</a>:</h4>
<p>I'm wondering where the existential came from</p>



<a name="234803831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234803831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234803831">(Apr 16 2021 at 07:01)</a>:</h4>
<p>Sorry, like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">normal_subgroup_mul</span> <span class="o">(</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">hN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">A'</span> <span class="bp">*</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="o">((</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">of</span> <span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="n">A'.of</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B.of</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">of</span><span class="o">,</span> <span class="n">coe_comap</span><span class="o">,</span> <span class="n">coe_subtype</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply_fun</span> <span class="n">set.image</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">nth_rewrite</span> <span class="mi">3</span> <span class="bp">←</span> <span class="n">coe_subtype</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">nth_rewrite</span> <span class="mi">3</span> <span class="bp">←</span> <span class="n">coe_subtype</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">preimage_mul_of_injective</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.image_preimage_coe</span><span class="o">,</span> <span class="n">set_like.mem_coe</span><span class="o">,</span> <span class="n">coe_subtype</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">change</span> <span class="o">((</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">∩</span> <span class="n">A</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">A'</span> <span class="bp">*</span> <span class="bp">↑</span><span class="n">B</span> <span class="bp">∩</span> <span class="n">A</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">set.inter_eq_self_of_subset_left</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="n">set.inter_eq_self_of_subset_left</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">set.le_eq_subset</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">A'</span> <span class="bp">*</span> <span class="bp">↑</span><span class="n">B</span> <span class="bp">⊆</span> <span class="bp">↑</span><span class="n">A</span> <span class="bp">*</span> <span class="bp">↑</span><span class="n">A</span> <span class="o">:=</span> <span class="n">set.mul_subset_mul</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">coe_mul_self_eq</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">sup_le</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">subtype_injective</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">monoid_hom.coe_range</span><span class="o">,</span> <span class="n">subtype_range</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">hA</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">monoid_hom.coe_range</span><span class="o">,</span> <span class="n">subtype_range</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">hB</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">sup_of</span> <span class="n">A'</span> <span class="n">B</span> <span class="n">A</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">,</span> <span class="n">normal_mul</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="234803959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234803959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234803959">(Apr 16 2021 at 07:01)</a>:</h4>
<p>Hold on, I should probably commit my branch to git.</p>



<a name="234804154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234804154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234804154">(Apr 16 2021 at 07:02)</a>:</h4>
<p>BTW you can make the Zassenhaus function a bit less obtuse with an auxiliary definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">set.snd</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">B</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">x.2</span><span class="o">)</span><span class="bp">.</span><span class="n">some_spec.some_spec.2.1</span><span class="o">⟩</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">Zassenhaus_fun</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→*</span> <span class="o">(</span><span class="n">Zassenhaus_quot</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">quotient.mk'</span> <span class="o">(</span><span class="n">set.snd</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">mem_mul</span> <span class="o">(</span><span class="n">Zassenhaus_aux</span> <span class="n">B</span> <span class="n">hA</span><span class="o">))</span><span class="bp">.</span><span class="n">mp</span> <span class="n">x.2</span><span class="o">⟩),</span>
  <span class="n">map_one'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>



<a name="234804514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234804514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234804514">(Apr 16 2021 at 07:04)</a>:</h4>
<p>Looking at that proof, it seems like this is not just any set product, it's one you know is injective, so perhaps you should retain that information somehow</p>



<a name="234804573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234804573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234804573">(Apr 16 2021 at 07:04)</a>:</h4>
<p>The <code>set.snd</code> function is nonsense if it's not</p>



<a name="234806636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234806636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234806636">(Apr 16 2021 at 07:18)</a>:</h4>
<p>Pushed here: <a href="https://github.com/leanprover-community/mathlib/tree/acxxa/composition-series">branch#acxxa/composition-series</a></p>



<a name="234808470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234808470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234808470">(Apr 16 2021 at 07:35)</a>:</h4>
<p>Your "no abel/ring" in <code>normal_sup_normal</code> is <code>simp</code></p>



<a name="234809331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234809331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234809331">(Apr 16 2021 at 07:44)</a>:</h4>
<p>One thing I'm wondering is what exactly is the difference between <code>rcases</code> and <code>exists.some/spec</code>? It seems <code>rcases</code> forgets the data, which is forcing me to constantly use <code>some/some_spec</code> in the <code>Zassenhaus_fun</code> proof. It's feels a bit strange that the proofs are so bulky. IRL one would say "let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>∈</mo><msup><mi>A</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>A</mi><mo>⊓</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax \in A' (A \sqcap B)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>", immediately unwrapping the data while adding the assumptions that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><msup><mi>A</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">a \in A'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>A</mi><mo>⊓</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">x \in A \sqcap B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. But it seems I can't convince lean to do it for me with <code>rcases</code>.</p>



<a name="234809695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234809695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234809695">(Apr 16 2021 at 07:47)</a>:</h4>
<p>You can't use <code>cases</code>/<code>rcases</code> to destruct an existential if you are constructing a function. You need AC for that, which is why classical.some gets involved</p>



<a name="234809840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234809840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234809840">(Apr 16 2021 at 07:48)</a>:</h4>
<p>You can use the <code>choose</code> tactic to construct a function from a forall exists statement, but that's only helpful if you have some limited scope within which you need the construction, i.e. it's not good for constructing defs like <code>Zassenhaus_fun</code></p>



<a name="234809911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234809911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234809911">(Apr 16 2021 at 07:49)</a>:</h4>
<p>But when you do use <code>some</code> directly in a definition, you are encouraged to immediately state the corresponding <code>some_spec</code> lemma and henceforth forget about the actual definition</p>



<a name="234811108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234811108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234811108">(Apr 16 2021 at 08:00)</a>:</h4>
<p>I think this is the lemma you are missing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">Zassenhaus_fun_aux</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">Zassenhaus_quot</span> <span class="n">hA</span> <span class="n">hB</span> <span class="o">:=</span>
<span class="n">quotient.mk'</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">((</span><span class="n">mem_mul</span> <span class="o">(</span><span class="n">Zassenhaus_aux</span> <span class="n">B</span> <span class="n">hA</span><span class="o">))</span><span class="bp">.</span><span class="n">mp</span> <span class="n">x.2</span><span class="o">)</span><span class="bp">.</span><span class="n">some_spec.some_spec.2.1</span><span class="o">⟩</span>

<span class="c1">-- "This is well-defined because blah blah..."</span>
<span class="kd">theorem</span> <span class="n">Zassenhaus_fun_aux_app</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A'</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Zassenhaus_fun_aux</span> <span class="n">hA</span> <span class="n">hB</span> <span class="o">⟨</span><span class="n">a</span> <span class="bp">*</span> <span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">=</span> <span class="n">quotient.mk'</span> <span class="n">x</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="234811210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234811210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234811210">(Apr 16 2021 at 08:00)</a>:</h4>
<p>Using this function, you can make the proof of <code> Zassenhaus_fun</code> a lot shorter</p>



<a name="234814887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234814887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234814887">(Apr 16 2021 at 08:29)</a>:</h4>
<p>Indeed, this vastly shrinks the size of <code>Zassenhaus_fun</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mem_mul'</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">{</span><span class="n">H</span> <span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">↑</span><span class="o">(</span><span class="n">H</span> <span class="bp">⊔</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="bp">*</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g</span> <span class="bp">∈</span> <span class="n">H</span> <span class="bp">⊔</span> <span class="n">K</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span><span class="o">:</span><span class="n">K</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mem_mul</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">⟨</span>
  <span class="bp">λ</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span> <span class="o">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩,</span> <span class="n">h</span><span class="o">⟩,</span>
  <span class="bp">λ</span> <span class="o">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩,</span> <span class="n">h</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩⟩</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">Zassenhaus_fun_aux</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">Zassenhaus_quot</span> <span class="n">hA</span> <span class="n">hB</span> <span class="o">:=</span>
<span class="n">quotient.mk'</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">((</span><span class="n">mem_mul</span> <span class="o">(</span><span class="n">Zassenhaus_aux</span> <span class="n">B</span> <span class="n">hA</span><span class="o">))</span><span class="bp">.</span><span class="n">mp</span> <span class="n">x.2</span><span class="o">)</span><span class="bp">.</span><span class="n">some_spec.some_spec.2.1</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">Zassenhaus_fun_aux_app</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A'</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Zassenhaus_fun_aux</span> <span class="n">hA</span> <span class="n">hB</span> <span class="o">⟨</span><span class="n">a</span> <span class="bp">*</span> <span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">=</span> <span class="n">quotient.mk'</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">quotient.sound'</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:=</span> <span class="o">(</span><span class="n">mem_mul</span> <span class="o">(</span><span class="n">Zassenhaus_aux</span> <span class="n">B</span> <span class="n">hA</span><span class="o">))</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">H.some</span><span class="o">,</span> <span class="k">let</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">H.some_spec.some</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">a</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">cases</span> <span class="n">x</span> <span class="k">with</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">h1</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">∈</span> <span class="n">A'</span><span class="o">,</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">,</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">*</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">x</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">H.some_spec.some_spec</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">mem_of</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">v</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">A'</span> <span class="bp">⊓</span> <span class="n">B</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B'</span><span class="o">)</span> <span class="bp">⊓</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)),</span>
  <span class="n">rw</span> <span class="n">inf_eq_left.2</span> <span class="o">(</span><span class="n">sup_le</span> <span class="o">(</span><span class="n">inf_le_inf_right</span> <span class="n">_</span> <span class="n">hA</span><span class="o">)</span> <span class="o">(</span><span class="n">inf_le_inf_left</span> <span class="n">_</span> <span class="n">hB</span><span class="o">)),</span>
  <span class="gr">sorry</span> <span class="c1">-- your turn</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">Zassenhaus_fun_aux_app'</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A'</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b.1</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Zassenhaus_fun_aux</span> <span class="n">hA</span> <span class="n">hB</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">quotient.mk'</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">,</span> <span class="o">{</span><span class="n">rw</span> <span class="n">e</span><span class="o">,</span> <span class="n">exact</span> <span class="n">b.2</span><span class="o">},</span>
  <span class="n">convert</span> <span class="bp">←</span> <span class="n">Zassenhaus_fun_aux_app</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">exact</span> <span class="n">e</span>
<span class="kd">end</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">Zassenhaus_fun</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">↥</span><span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→*</span> <span class="n">Zassenhaus_quot</span> <span class="n">hA</span> <span class="n">hB</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">Zassenhaus_fun_aux</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">Zassenhaus_fun_aux_app'</span> <span class="n">_</span> <span class="n">_</span> <span class="mi">1</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">refl</span><span class="o">),</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩,</span>
  <span class="kd">begin</span>
    <span class="n">clear_</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a₁</span><span class="o">,</span> <span class="n">a₂</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">mem_mul'</span> <span class="o">(</span><span class="n">Zassenhaus_aux</span> <span class="n">B</span> <span class="n">hA</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">b₁</span><span class="o">,</span> <span class="n">b₂</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">mem_mul'</span> <span class="o">(</span><span class="n">Zassenhaus_aux</span> <span class="n">B</span> <span class="n">hA</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Zassenhaus_fun_aux_app</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">Zassenhaus_fun_aux_app'</span> <span class="n">_</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">a₁</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a₂</span> <span class="bp">*</span> <span class="n">b₁</span> <span class="bp">*</span> <span class="n">a₂</span><span class="bp">⁻¹</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">],</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
<p>The sorry is something about normal subgroups that I'm sure you already have</p>



<a name="234909612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234909612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234909612">(Apr 16 2021 at 19:40)</a>:</h4>
<p>Thanks, I was able to finish much more of the proof with this!</p>



<a name="234909931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234909931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234909931">(Apr 16 2021 at 19:43)</a>:</h4>
<p>I've run into another problem though. In the final lemma, it seems like Lean is unable to infer the fact that the quotients have a group structure.  I've tried to force it by explicitly writing out the instances with <code>Zassenhaus_normal </code> and <code>finally</code>, but Lean is doesn't know how to use them. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">Zassenhaus_fun_ker</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">Zassenhaus_fun</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">)</span><span class="bp">.</span><span class="n">ker</span> <span class="bp">=</span> <span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B'</span><span class="o">)</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kn">open</span> <span class="n">quotient_group</span>

<span class="kd">instance</span> <span class="n">Zassenhaus_normal</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B'</span><span class="o">)</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">))</span><span class="bp">.</span><span class="n">normal</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">Zassenhaus_fun_ker</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">,</span> <span class="n">exact</span> <span class="n">monoid_hom.normal_ker</span> <span class="n">_</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">@[instance]</span> <span class="kd">lemma</span> <span class="n">finally</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">group</span> <span class="bp">$</span> <span class="n">quotient_group.quotient</span> <span class="o">((</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B'</span><span class="o">)</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:=</span> <span class="n">subgroup.Zassenhaus_normal</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">Zassenhaus_fun_surjective</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">function.surjective</span> <span class="o">(</span><span class="n">Zassenhaus_fun</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x.induction_on'</span> <span class="bp">$</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">∈</span> <span class="bp">↑</span><span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">))⟩,</span>
  <span class="k">have</span> <span class="n">hy'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">mem_mul'</span> <span class="o">(</span><span class="n">Zassenhaus_aux</span> <span class="n">B</span> <span class="n">hA</span><span class="o">))</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩,</span> <span class="n">one_mul</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">use</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy'</span><span class="o">⟩,</span>
  <span class="n">rw</span> <span class="n">subtype.coe_mk</span> <span class="n">at</span> <span class="n">hy'</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">one_mul</span> <span class="n">y</span> <span class="n">at</span> <span class="n">hy'</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">subtype.coe_mk</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">at</span> <span class="n">hy'</span><span class="o">,</span>
  <span class="n">conv_lhs</span> <span class="o">{</span> <span class="n">find</span> <span class="n">y</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">one_mul</span> <span class="n">y</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">subtype.coe_mk</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Zassenhaus_fun</span><span class="o">,</span> <span class="n">monoid_hom.coe_mk</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">Zassenhaus_fun_aux_app</span> <span class="n">hA</span> <span class="n">hB</span> <span class="mi">1</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩</span> <span class="n">hy'</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">butterfly</span> <span class="o">{</span><span class="n">A'</span> <span class="n">A</span> <span class="n">B'</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A'</span> <span class="bp">≤</span> <span class="n">A</span><span class="o">}</span> <span class="o">{</span><span class="n">hB</span> <span class="o">:</span> <span class="n">B'</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">}</span>
  <span class="o">[</span><span class="n">hAN</span> <span class="o">:</span> <span class="o">(</span><span class="n">A'.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">[</span><span class="n">hBN</span> <span class="o">:</span> <span class="o">(</span><span class="n">B'.of</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">normal</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">quotient</span> <span class="o">((</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B'</span><span class="o">)</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">A'</span> <span class="bp">⊔</span> <span class="n">A</span> <span class="bp">⊓</span> <span class="n">B</span><span class="o">))</span> <span class="bp">≃*</span> <span class="n">quotient</span> <span class="o">((</span><span class="n">B'</span> <span class="bp">⊔</span> <span class="n">B</span> <span class="bp">⊓</span> <span class="n">A'</span><span class="o">)</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">B'</span> <span class="bp">⊔</span> <span class="n">B</span> <span class="bp">⊓</span> <span class="n">A</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="234910157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234910157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234910157">(Apr 16 2021 at 19:45)</a>:</h4>
<p>A <code>mul_equiv</code> isn't a lemma, it's a <code>def</code> because you have to supply not just the proof that the multiplication is respected, but also the data of the function that is bijective</p>



<a name="234910694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234910694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234910694">(Apr 16 2021 at 19:49)</a>:</h4>
<p>Ah, my bad. That's one mistake fixed, but it seems changing to <code>def</code> still doesn't help Lean infer the group instance.</p>



<a name="234911480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234911480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234911480">(Apr 16 2021 at 19:55)</a>:</h4>
<p>It can't automatically infer it because it hasn't been supplied the <code>(hA : A' ≤ A) (hB : B' ≤ B)</code></p>



<a name="234911554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234911554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234911554">(Apr 16 2021 at 19:56)</a>:</h4>
<p>It can't find from the instance cache, it's not automatically available to the TC search, if I understand correctly</p>



<a name="234911705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234911705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234911705">(Apr 16 2021 at 19:57)</a>:</h4>
<p>Hmm, should I be using <code>[hA : A' ≤ A]</code> then? Or maybe <code>[fact (A' ≤ A)]</code>?</p>



<a name="234912151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Difficulty%20with%20%60exists%60/near/234912151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Difficulty.20with.20.60exists.60.html#234912151">(Apr 16 2021 at 20:00)</a>:</h4>
<p>Making them implicit arguments isn't working either, which is weird because Lean is able to infer <code>{A' A B' B : subgroup \a}</code> on its own.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html">How are universe levels defined</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="207745556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207745556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207745556">(Aug 22 2020 at 22:53)</a>:</h4>
<p>Universe levels are indexed by natural numbers. Does it imply that a structure of "natural numbers" is defined in advance without use of Types? How are these numbers defined?</p>



<a name="207746351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207746351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207746351">(Aug 22 2020 at 23:18)</a>:</h4>
<p>The arithmetic of levels is a simple axiomatic system, weaker than peano, where you can prove things by case analysis on natural numbers. The language is quite impoverished, containing only <code>0, succ, max, imax</code> and variables, but the axiomatic system is complete for that language.</p>



<a name="207746370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207746370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207746370">(Aug 22 2020 at 23:19)</a>:</h4>
<p>the rules are described in section 2.2 of <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">https://github.com/digama0/lean-type-theory/releases/tag/v1.0</a></p>



<a name="207746432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207746432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207746432">(Aug 22 2020 at 23:21)</a>:</h4>
<p>Technically lean doesn't actually implement this entire axiomatic system, so there are some level inequalities that it cannot verify, but can be verified by external typecheckers like trepplein that implement the full decision procedure</p>



<a name="207746496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207746496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207746496">(Aug 22 2020 at 23:23)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>
<span class="c1">-- fails even though it is true for all u,v,w</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">Sort</span><span class="bp">.</span><span class="o">{</span><span class="n">imax</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="n">w</span><span class="o">}</span> <span class="bp">=</span> <span class="n">Sort</span><span class="bp">.</span><span class="o">{</span><span class="n">imax</span> <span class="n">u</span> <span class="o">(</span><span class="n">imax</span> <span class="n">v</span> <span class="n">w</span><span class="o">)}</span>
</code></pre></div>



<a name="207746865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207746865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207746865">(Aug 22 2020 at 23:35)</a>:</h4>
<p>Thank you very much! I will study that thesis. <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="207779931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207779931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207779931">(Aug 23 2020 at 16:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined/near/207746351">said</a>:</p>
<blockquote>
<p>The arithmetic of levels is a simple axiomatic system, weaker than peano, where you can prove things by case analysis on natural numbers. The language is quite impoverished, containing only <code>0, succ, max, imax</code> and variables, but the axiomatic system is complete for that language.</p>
</blockquote>
<p><a href="/user_uploads/3121/iCL0j7zFQuZGO2gWO3R4LCrR/screenshot-2020-08-23-17.12.30.png">screenshot-2020-08-23-17.12.30.png</a><br>
I'm wondering if I understand correctly:  α and β here are expression variables. I can replace Γ by Γ, e : α in a judgement only if I have derived e : α from a judgement. And the judgements of  ⊢ Γ ok provides an easy way to form Γ, a well-formed sequence of type assignments but this is not necessary in our axiom.</p>
<div class="message_inline_image"><a href="/user_uploads/3121/iCL0j7zFQuZGO2gWO3R4LCrR/screenshot-2020-08-23-17.12.30.png" title="screenshot-2020-08-23-17.12.30.png"><img src="/user_uploads/3121/iCL0j7zFQuZGO2gWO3R4LCrR/screenshot-2020-08-23-17.12.30.png"></a></div>



<a name="207789529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207789529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207789529">(Aug 23 2020 at 20:18)</a>:</h4>
<p><span class="user-mention" data-user-id="258319">@Xiang Li</span></p>
<blockquote>
<p>I'm wondering if I understand correctly: α and β here are expression variables.</p>
</blockquote>
<p>Yes. (I use α and β to denote expressions that represent types, but this is no additional syntactic restriction.)</p>
<blockquote>
<p>The expression e : α always makes sense even if α is not a Type -- it appears in the judgements.</p>
</blockquote>
<p>e : α itself isn't an expression, it is a fragment of the judgment Γ ⊢ e : α, which is well formed but false if α is not a type.</p>
<blockquote>
<p>judgements of ⊢ Γ ok provide an easy way to form a well-formed sequence of type assignments, but this is not necessary in the axiom.<br>
Also, I cannot figure out the way to prove "If Γ ⊢ e : α, then ⊢ Γ ok", what does that mean by by induction on the judgments?</p>
</blockquote>
<p>Right, ⊢ Γ ok is not needed in the definition of Γ ⊢ e : α, but due to the setup of the rules the latter implies the former.</p>
<p>The proof of this is by induction on the typing judgment Γ ⊢ e : α. Most rules keep Γ the same so you have the inductive hypothesis already; the universe typing rule has no context so it is ok; and rules that extend the context like the typing rule for lambda and pi have a side condition  Γ ⊢ α : U_l that is the requirement to show that the extended context is still ok.</p>



<a name="207789764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207789764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207789764">(Aug 23 2020 at 20:25)</a>:</h4>
<p>Oh, actually I've got it backward. Since we are proving by induction on the typing judgment the interesting rules are the ones that extend the context reading top down; there are only two such rules, the weakening rule and the hypothesis rule, and in both cases the final context  Γ, x : α is ok because we have an explicit hypothesis  Γ ⊢ α : U_l in the rule and Γ ok from the induction hypothesis.</p>



<a name="207792682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207792682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207792682">(Aug 23 2020 at 21:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <br>
Thank you very much for your detailed explanation <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span><br>
I think there is a problem with typing rule for lambda, because the only induction hypothesis is  ⊢ Γ, x : α ok but the goal is ⊢ Γ ok.</p>



<a name="207795209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207795209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207795209">(Aug 23 2020 at 22:57)</a>:</h4>
<blockquote>
<p>induction hypothesis is ⊢ Γ, x : α ok but the goal is ⊢ Γ ok.</p>
</blockquote>
<p>You can use inversion on that hypothesis to prove ⊢ Γ ok</p>



<a name="207795249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207795249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207795249">(Aug 23 2020 at 22:58)</a>:</h4>
<p>that is, <code>cases</code> in lean</p>



<a name="207795386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207795386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207795386">(Aug 23 2020 at 23:00)</a>:</h4>
<p>To prove e : α ⊢ e : α, you need to use the hypothesis rule, which requires ⊢ α : U_l</p>



<a name="207795480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207795480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207795480">(Aug 23 2020 at 23:03)</a>:</h4>
<blockquote>
<p>My comprehension is that Γ, x : e can only be formed if Γ ⊢ x : e is deduced, so Γ cannot be e : α, is that right?</p>
</blockquote>
<p>No, there are no syntactic restrictions on the formation of contexts, but Γ ⊢ x : α implies that all parts of it are well formed (Γ is ok, and α is a type in context Γ)</p>



<a name="207795488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207795488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207795488">(Aug 23 2020 at 23:03)</a>:</h4>
<p>In practice we want to restrict attention to only the well formed contexts, types and expressions</p>



<a name="207797171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207797171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207797171">(Aug 23 2020 at 23:49)</a>:</h4>
<blockquote>
<p>that is, cases in lean</p>
</blockquote>
<p><code>cases</code> tactic sometimes does many things at once that needs to be longly proved using rec_on, cases_on and dcases_on. Is there a specific example using inversion in lean?</p>



<a name="207797237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207797237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207797237">(Aug 23 2020 at 23:50)</a>:</h4>
<p>It is an application of <code>cases_on</code></p>



<a name="207797316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207797316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207797316">(Aug 23 2020 at 23:53)</a>:</h4>
<p>Thank you! I'm much clear now.</p>



<a name="207797608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207797608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207797608">(Aug 24 2020 at 00:02)</a>:</h4>
<p>Here's a fragment of the definition sufficient to show how the proof goes:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">lev</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">inductive</span> <span class="n">exp</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">sort</span> <span class="o">:</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">lam</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">pi</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>

<span class="n">def</span> <span class="n">lft</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">exp</span>

<span class="kn">inductive</span> <span class="n">has_type</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">α</span> <span class="n">l</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_type</span> <span class="err">Γ</span> <span class="n">α</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">sort</span> <span class="n">l</span><span class="o">)</span> <span class="bp">→</span> <span class="n">has_type</span> <span class="o">(</span><span class="n">α</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">lft</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">lam</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">e</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_type</span> <span class="o">(</span><span class="n">α</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">e</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">has_type</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">lam</span> <span class="n">α</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">pi</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>

<span class="kn">inductive</span> <span class="n">is_type</span> <span class="o">(</span><span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span><span class="o">)</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">α</span> <span class="n">l</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_type</span> <span class="err">Γ</span> <span class="n">α</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">sort</span> <span class="n">l</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_type</span> <span class="n">α</span>

<span class="kn">inductive</span> <span class="kn">context</span><span class="bp">.</span><span class="n">ok</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="kn">context</span><span class="bp">.</span><span class="n">ok</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="kn">context</span><span class="bp">.</span><span class="n">ok</span> <span class="err">Γ</span> <span class="bp">→</span> <span class="n">is_type</span> <span class="err">Γ</span> <span class="n">α</span> <span class="bp">→</span> <span class="kn">context</span><span class="bp">.</span><span class="n">ok</span> <span class="o">(</span><span class="n">α</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">e</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">has_type</span> <span class="err">Γ</span> <span class="n">e</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kn">context</span><span class="bp">.</span><span class="n">ok</span> <span class="err">Γ</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">constructor</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">constructor</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">h_ih</span><span class="o">,</span>
    <span class="n">assumption</span> <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="207797662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207797662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207797662">(Aug 24 2020 at 00:02)</a>:</h4>
<p>the real thing is of course more complicated, in particular because <code>has_type</code> is mutually recursive with defeq</p>



<a name="207798112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207798112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207798112">(Aug 24 2020 at 00:14)</a>:</h4>
<p>Ok! I'm considering to formalise "The Type Theory of Lean" in lean. Thank you again!</p>



<a name="207798286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207798286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207798286">(Aug 24 2020 at 00:18)</a>:</h4>
<p>I would like that very much :)</p>



<a name="207831278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207831278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207831278">(Aug 24 2020 at 11:17)</a>:</h4>
<p>when reading mario's msc thesis i found the recursor to be the hardest definition to parse. the natural language description in the lean reference manual helps: <a href="https://leanprover.github.io/reference/declarations.html#inductive-families">https://leanprover.github.io/reference/declarations.html#inductive-families</a><br>
some things are also implicitly defined in an equation, e.g. p[b] and pi_i[b, x] in 2.6.3 (this took me a while to understand <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> ).<br>
i'd also love to see a formalization of it.</p>



<a name="207836920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207836920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207836920">(Aug 24 2020 at 12:29)</a>:</h4>
<p>By the way, there's a stream <a class="stream" data-stream-id="236446" href="/#narrow/stream/236446-Type-theory">#Type theory</a> which would be a good place to discuss such a formalization.</p>



<a name="207889204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207889204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207889204">(Aug 24 2020 at 19:57)</a>:</h4>
<p><span class="user-mention" data-user-id="221921">@Marc Huisinga</span> The definition of the recursor in my thesis is based very closely on Dybjer's <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.37.74&amp;rep=rep1&amp;type=pdf">Inductive families</a>, which uses a lot of :: in order to deal with the many "telescopes" that appear in the definition, which might be a little easier to read. I rewrote it as a series of inductive rules specifically to ease formalization efforts like an encoding in lean, or <a href="https://github.com/digama0/mm0/blob/master/examples/lean.mm1">an encoding in MM0</a>.</p>



<a name="207901520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207901520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207901520">(Aug 24 2020 at 21:48)</a>:</h4>
<p>once i understood all the nuances of your notation it was honestly pretty good to read and straight to the point.</p>



<a name="207909130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207909130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207909130">(Aug 24 2020 at 23:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Did you default alpha equivalent in the thesis? I didn't see it in defeq. <br>
When you write </p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>x</mi><mo>:</mo><mi>α</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>β</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>α</mi><mi mathvariant="normal">.</mi><mi>e</mi><mo>:</mo><mi mathvariant="normal">∀</mi><mi>x</mi><mo>:</mo><mi>α</mi><mi mathvariant="normal">.</mi><mi>β</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\dfrac {Γ , x : α ⊢ e : β} {Γ⊢λx:α.e:∀x:α.β}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>do you mean the x's are the same symbol (sorry this question is not important). <br>
Since I need to define β[e/x], I have to include the bounded variable in the definitions of lam and pi:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">exp</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">sort</span> <span class="o">:</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">lam</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">pi</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>

<span class="kn">open</span> <span class="n">exp</span>
<span class="n">def</span> <span class="n">subst</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">sort</span> <span class="n">l</span><span class="o">)</span> <span class="n">x</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">sort</span> <span class="n">l</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">e</span> <span class="k">else</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="n">x</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">app</span> <span class="o">(</span><span class="n">subst</span> <span class="n">e1</span> <span class="n">x</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">subst</span> <span class="n">e2</span> <span class="n">x</span> <span class="n">e</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">lam</span> <span class="n">x</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="n">y</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">lam</span> <span class="n">x</span> <span class="n">e1</span> <span class="n">e2</span> <span class="k">else</span> <span class="n">lam</span> <span class="n">x</span> <span class="o">(</span><span class="n">subst</span> <span class="n">e1</span> <span class="n">y</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">subst</span> <span class="n">e2</span> <span class="n">y</span> <span class="n">e</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pi</span> <span class="n">x</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="n">y</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">pi</span> <span class="n">x</span> <span class="n">e1</span> <span class="n">e2</span> <span class="k">else</span> <span class="n">pi</span> <span class="n">x</span> <span class="o">(</span><span class="n">subst</span> <span class="n">e1</span> <span class="n">y</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">subst</span> <span class="n">e2</span> <span class="n">y</span> <span class="n">e</span><span class="o">)</span>
</code></pre></div>



<a name="207909207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207909207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207909207">(Aug 24 2020 at 23:28)</a>:</h4>
<p>Formally, the terms are all in de bruijn representation, so alpha equality is just actual equality</p>



<a name="207909239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207909239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207909239">(Aug 24 2020 at 23:28)</a>:</h4>
<p>the sketch I gave above indicates some of this</p>



<a name="207909381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207909381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207909381">(Aug 24 2020 at 23:30)</a>:</h4>
<p>the <code>lft</code> function in the sketch is the lift operator, which increases the indexes of all variables that are not bound by 1</p>



<a name="207910269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207910269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207910269">(Aug 24 2020 at 23:42)</a>:</h4>
<p>Here's a basic implementation of <code>lift</code> and <code>subst</code> for de bruijn terms:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">lev</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">inductive</span> <span class="n">exp</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">sort</span> <span class="o">:</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">lam</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">pi</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>

<span class="n">def</span> <span class="n">exp</span><span class="bp">.</span><span class="n">liftn</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">e</span><span class="bp">@</span><span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">sort</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">e</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">e</span><span class="bp">@</span><span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">e</span> <span class="k">else</span> <span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">lam</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">liftn</span> <span class="n">n</span> <span class="n">e₁</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">liftn</span> <span class="n">n</span> <span class="n">e₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">lam</span> <span class="n">A</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">lam</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">liftn</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">liftn</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">pi</span> <span class="n">A</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">pi</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">liftn</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">liftn</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">A</span><span class="o">)</span>

<span class="n">def</span> <span class="n">exp</span><span class="bp">.</span><span class="n">lift</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="o">:=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">liftn</span> <span class="mi">0</span>

<span class="n">def</span> <span class="n">exp</span><span class="bp">.</span><span class="n">substn</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">e</span><span class="bp">@</span><span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">sort</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">e</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">e</span><span class="bp">@</span><span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">e</span> <span class="k">else</span> <span class="k">if</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span> <span class="k">then</span> <span class="n">exp</span><span class="bp">.</span><span class="n">lift</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="n">a</span> <span class="k">else</span> <span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="o">(</span><span class="n">m</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">lam</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">substn</span> <span class="n">n</span> <span class="n">e₁</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">substn</span> <span class="n">n</span> <span class="n">e₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">lam</span> <span class="n">A</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">lam</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">substn</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">substn</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">pi</span> <span class="n">A</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">pi</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">substn</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">substn</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">A</span><span class="o">)</span>

<span class="c1">-- e[a / #0]</span>
<span class="n">def</span> <span class="n">exp</span><span class="bp">.</span><span class="n">subst</span> <span class="o">(</span><span class="n">e</span> <span class="n">a</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">:</span> <span class="n">exp</span> <span class="o">:=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">substn</span> <span class="n">a</span> <span class="mi">0</span> <span class="n">e</span>
</code></pre></div>



<a name="207910810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/207910810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#207910810">(Aug 24 2020 at 23:51)</a>:</h4>
<p>Thank you! That helps me a lot. I studied de bruijn representation just now.</p>



<a name="208034597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208034597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208034597">(Aug 25 2020 at 22:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  I am defining the admissible definition of constants in 2.5.</p>
<blockquote>
<p>For a constant definition <code>constant</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mover accent="true"><mi>u</mi><mo>ˉ</mo></mover></msub><mo>:</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">c_{\bar u} : \alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.24744599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight">u</span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord mtight">ˉ</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> to be admissible, we require that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊢</mo><mi>α</mi><mo>:</mo><msub><mi>U</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">⊢ α : U_l</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, where the<br>
universe variables in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> are contained in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>u</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar u</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span> ̄.</p>
</blockquote>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">lev</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">univ_var</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">lev</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">lev</span>
<span class="bp">|</span> <span class="n">S</span> <span class="o">:</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">lev</span>
<span class="bp">|</span> <span class="n">max</span> <span class="o">:</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">lev</span>
<span class="bp">|</span> <span class="n">imax</span> <span class="o">:</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">lev</span>

<span class="n">def</span> <span class="n">univ_vars</span> <span class="o">:=</span> <span class="o">{</span><span class="n">u</span> <span class="bp">//</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">lev</span><span class="bp">.</span><span class="n">univ_var</span> <span class="n">n</span><span class="o">}</span>

<span class="kn">inductive</span> <span class="n">exp</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">sort</span> <span class="o">:</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">lam</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">pi</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">Let</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">univ_vars</span> <span class="bp">→</span> <span class="n">exp</span>

<span class="n">def</span> <span class="n">consts</span> <span class="o">:=</span> <span class="o">{</span><span class="n">C</span> <span class="bp">//</span> <span class="bp">∃</span> <span class="n">n</span> <span class="n">l</span><span class="o">,</span> <span class="n">C</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">c</span> <span class="n">n</span> <span class="n">l</span><span class="o">}</span>
</code></pre></div>


<p>The only way of taking the list <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>u</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar u</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span> from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mover accent="true"><mi>u</mi><mo>ˉ</mo></mover></msub></mrow><annotation encoding="application/x-tex">c_{\bar u}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.24744599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight">u</span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord mtight">ˉ</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> I can think of is to use <code>classical.some</code>.  Is there any way to avoid it?</p>



<a name="208034738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208034738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208034738">(Aug 25 2020 at 22:59)</a>:</h4>
<p>the way it is implemented in lean is more like the regular variables. You have a context of variables that are legal and then the term typechecks in that context</p>



<a name="208034761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208034761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208034761">(Aug 25 2020 at 23:00)</a>:</h4>
<p>Since all universe variables have the same "type" you really only need to keep track of their number</p>



<a name="208034959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208034959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208034959">(Aug 25 2020 at 23:01)</a>:</h4>
<p>That is, you can define a function <code>lvl.ubound : lvl -&gt; nat</code>, <code>exp.ubound : exp -&gt; nat</code> which calculates the smallest <code>n</code> such that every universe variable in the level or expression is less than <code>n</code></p>



<a name="208035037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208035037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208035037">(Aug 25 2020 at 23:02)</a>:</h4>
<p>and then the admissibility criterion says <code>A.ubound &lt;= k</code> where <code>k</code> is the number of universe variables in the constant declaration</p>



<a name="208035369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208035369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208035369">(Aug 25 2020 at 23:06)</a>:</h4>
<p>I assume the nat in <code>exp.c</code> is the "name" of the constant? I think you want it to have type <code>| c : nat -&gt; list lvl -&gt; exp</code>, where the list represents the substitutions to universe variables in the constant definition</p>



<a name="208035583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208035583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208035583">(Aug 25 2020 at 23:08)</a>:</h4>
<p>You might also want to consider giving it the type <code>c : nat -&gt; list lvl -&gt; exp -&gt; exp</code> where the final <code>exp</code> is the type of the constant; this is not strictly speaking correct, but allows you to define typechecking without a global environment</p>



<a name="208035967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208035967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208035967">(Aug 25 2020 at 23:12)</a>:</h4>
<p>Thank you <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> . I will try it.</p>



<a name="208083077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208083077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208083077">(Aug 26 2020 at 12:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <br>
This is part of the code I have written -- maybe my understanding is not right :</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">lev</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">univ_var</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">lev</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">lev</span>
<span class="bp">|</span> <span class="n">S</span> <span class="o">:</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">lev</span>
<span class="bp">|</span> <span class="n">max</span> <span class="o">:</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">lev</span>
<span class="bp">|</span> <span class="n">imax</span> <span class="o">:</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">lev</span>

<span class="kn">inductive</span> <span class="n">exp</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">sort</span> <span class="o">:</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">lam</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">pi</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">Let</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">exp</span>

<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">exp</span>

<span class="kn">open</span> <span class="n">lev</span> <span class="n">exp</span>

<span class="n">def</span> <span class="n">lev</span><span class="bp">.</span><span class="n">ubound</span> <span class="o">:</span> <span class="n">lev</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">univ_var</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">S</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">lev</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">l</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">max</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">lev</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">l1</span><span class="o">)</span> <span class="o">(</span><span class="n">lev</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">l2</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">imax</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">lev</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">l1</span><span class="o">)</span> <span class="o">(</span><span class="n">lev</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">l2</span><span class="o">)</span>

<span class="n">def</span> <span class="n">list_lev</span><span class="bp">.</span><span class="n">ubound</span> <span class="o">:</span> <span class="n">list</span> <span class="n">lev</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span> <span class="bp">::</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">lev</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">list_lev</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">t</span><span class="o">)</span>

<span class="n">def</span> <span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">sort</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">lev</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">l</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">e1</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">e2</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">lam</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">e1</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">e2</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pi</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">e1</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">e2</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Let</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">e1</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">e2</span><span class="o">))</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">e3</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">c</span> <span class="bp">_</span> <span class="n">lst</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list_lev</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">lst</span>

<span class="n">mutual</span> <span class="kn">inductive</span> <span class="n">has_type</span><span class="o">,</span> <span class="n">admis_const</span><span class="o">,</span> <span class="n">admis_def</span>
<span class="k">with</span> <span class="n">has_type</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">c1</span> <span class="o">{</span><span class="n">α</span> <span class="n">lst</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">admis_const</span> <span class="o">(</span><span class="n">c</span> <span class="n">n</span> <span class="n">lst</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">has_type</span> <span class="o">[]</span> <span class="o">(</span><span class="n">c</span> <span class="n">n</span> <span class="n">lst</span><span class="o">)</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">c2</span> <span class="o">{</span><span class="n">α</span> <span class="n">e</span> <span class="n">lst</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">admis_def</span> <span class="o">(</span><span class="n">c</span> <span class="n">n</span> <span class="n">lst</span><span class="o">)</span> <span class="n">α</span> <span class="n">e</span> <span class="bp">→</span> <span class="n">has_type</span> <span class="o">[]</span> <span class="o">(</span><span class="n">c</span> <span class="n">n</span> <span class="n">lst</span><span class="o">)</span> <span class="n">α</span>
<span class="k">with</span> <span class="n">admis_const</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">{</span><span class="n">α</span> <span class="n">l</span> <span class="n">lst</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_type</span> <span class="o">[]</span> <span class="n">α</span> <span class="o">(</span><span class="n">sort</span> <span class="n">l</span><span class="o">)</span> <span class="bp">→</span> <span class="n">lev</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">l</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="n">list</span> <span class="n">lev</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">→</span>
  <span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">α</span> <span class="bp">≤</span> <span class="n">lst</span><span class="bp">.</span><span class="n">length</span> <span class="bp">→</span> <span class="n">admis_const</span> <span class="o">(</span><span class="n">c</span> <span class="n">n</span> <span class="n">lst</span><span class="o">)</span> <span class="n">α</span>
<span class="k">with</span> <span class="n">admis_def</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">{</span><span class="n">α</span> <span class="n">e</span> <span class="n">lst</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_type</span> <span class="o">[]</span> <span class="n">e</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">e</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="n">list</span> <span class="n">lev</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">→</span> <span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">α</span> <span class="bp">≤</span> <span class="n">lst</span><span class="bp">.</span><span class="n">length</span>
  <span class="bp">→</span> <span class="n">admis_def</span> <span class="o">(</span><span class="n">c</span> <span class="n">n</span> <span class="n">lst</span><span class="o">)</span> <span class="n">α</span> <span class="n">e</span>
</code></pre></div>


<p>Is the criteria <code>has_type [] α (sort l)</code> of  <code>admis_const</code>  free of context, or it should be <code>has_type  Γ α (sort l)</code>?</p>



<a name="208113708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208113708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208113708">(Aug 26 2020 at 16:18)</a>:</h4>
<p><span class="user-mention" data-user-id="258319">@Xiang Li</span> In lean, constants must be valid in the empty context, but they can contain free universe variables, up to the universe number in the constant definition</p>



<a name="208114832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208114832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208114832">(Aug 26 2020 at 16:27)</a>:</h4>
<p>I don't think <code>admis_const</code> needs to be mutual with <code>has_type</code>. In order to make sure that all constants are interpreted consistently, I think you need a global context, which for now can just be a list of constant definitions. Then <code>has_type</code> can just assume that these constants are all well typed, and you can use typing to define what it means for the constants to be admissible</p>



<a name="208117644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208117644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208117644">(Aug 26 2020 at 16:51)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">cdef</span>
<span class="bp">|</span> <span class="n">cnst</span> <span class="o">(</span><span class="n">uvars</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">ty</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">:</span> <span class="n">cdef</span>
<span class="bp">|</span> <span class="n">defn</span> <span class="o">(</span><span class="n">uvars</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">ty</span> <span class="n">val</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">:</span> <span class="n">cdef</span>

<span class="kn">inductive</span> <span class="n">cdef</span><span class="bp">.</span><span class="n">as_const</span> <span class="o">:</span> <span class="n">cdef</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">cnst</span> <span class="o">(</span><span class="n">uvars</span> <span class="n">ty</span><span class="o">)</span> <span class="o">:</span> <span class="n">cdef</span><span class="bp">.</span><span class="n">as_const</span> <span class="o">(</span><span class="n">cdef</span><span class="bp">.</span><span class="n">cnst</span> <span class="n">uvars</span> <span class="n">ty</span><span class="o">)</span> <span class="n">uvars</span> <span class="n">ty</span>
<span class="bp">|</span> <span class="n">defn</span> <span class="o">(</span><span class="n">uvars</span> <span class="n">ty</span> <span class="n">val</span><span class="o">)</span> <span class="o">:</span> <span class="n">cdef</span><span class="bp">.</span><span class="n">as_const</span> <span class="o">(</span><span class="n">cdef</span><span class="bp">.</span><span class="n">defn</span> <span class="n">uvars</span> <span class="n">ty</span> <span class="n">val</span><span class="o">)</span> <span class="n">uvars</span> <span class="n">ty</span>

<span class="n">def</span> <span class="n">exp</span><span class="bp">.</span><span class="n">usubst</span> <span class="o">:</span> <span class="n">list</span> <span class="n">lev</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="n">def</span> <span class="n">exp</span><span class="bp">.</span><span class="n">subst</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">consts</span> <span class="o">:</span> <span class="n">list</span> <span class="n">cdef</span><span class="o">)</span>

<span class="kn">inductive</span> <span class="n">has_type</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">{</span><span class="n">lst</span> <span class="n">n</span> <span class="n">cd</span> <span class="n">uvars</span> <span class="n">ty</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">consts</span><span class="bp">.</span><span class="n">nth</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">cd</span> <span class="bp">→</span>
  <span class="n">cdef</span><span class="bp">.</span><span class="n">as_const</span> <span class="n">cd</span> <span class="n">uvars</span> <span class="n">ty</span> <span class="bp">→</span>
  <span class="n">has_type</span> <span class="o">[]</span> <span class="o">(</span><span class="n">c</span> <span class="n">n</span> <span class="n">lst</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">usubst</span> <span class="n">lst</span> <span class="n">ty</span><span class="o">)</span>
<span class="c1">-- ...</span>

<span class="n">def</span> <span class="n">is_type</span> <span class="o">(</span><span class="err">Γ</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">l</span><span class="o">,</span> <span class="n">has_type</span> <span class="n">consts</span> <span class="err">Γ</span> <span class="n">α</span> <span class="o">(</span><span class="n">sort</span> <span class="n">l</span><span class="o">)</span>

<span class="kn">inductive</span> <span class="n">cdef</span><span class="bp">.</span><span class="n">admis</span> <span class="o">:</span> <span class="n">cdef</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">cnst</span> <span class="o">{</span><span class="n">us</span> <span class="n">ty</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_type</span> <span class="n">consts</span> <span class="o">[]</span> <span class="n">ty</span> <span class="bp">→</span> <span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">ty</span> <span class="bp">≤</span> <span class="n">us</span> <span class="bp">→</span>
  <span class="n">cdef</span><span class="bp">.</span><span class="n">admis</span> <span class="o">(</span><span class="n">cdef</span><span class="bp">.</span><span class="n">cnst</span> <span class="n">us</span> <span class="n">ty</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">defn</span> <span class="o">{</span><span class="n">us</span> <span class="n">ty</span> <span class="n">val</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_type</span> <span class="n">consts</span> <span class="o">[]</span> <span class="n">ty</span> <span class="n">val</span> <span class="bp">→</span> <span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">ty</span> <span class="bp">≤</span> <span class="n">us</span> <span class="bp">→</span> <span class="n">exp</span><span class="bp">.</span><span class="n">ubound</span> <span class="n">val</span> <span class="bp">≤</span> <span class="n">us</span> <span class="bp">→</span>
  <span class="n">cdef</span><span class="bp">.</span><span class="n">admis</span> <span class="o">(</span><span class="n">cdef</span><span class="bp">.</span><span class="n">defn</span> <span class="n">us</span> <span class="n">ty</span> <span class="n">val</span><span class="o">)</span>

<span class="kn">inductive</span> <span class="n">consts</span><span class="bp">.</span><span class="n">admis</span> <span class="o">:</span> <span class="n">list</span> <span class="n">cdef</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">consts</span><span class="bp">.</span><span class="n">admis</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">C</span> <span class="n">cd</span><span class="o">}</span> <span class="o">:</span> <span class="n">consts</span><span class="bp">.</span><span class="n">admis</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">cdef</span><span class="bp">.</span><span class="n">admis</span> <span class="n">C</span> <span class="n">cd</span> <span class="bp">→</span> <span class="n">consts</span><span class="bp">.</span><span class="n">admis</span> <span class="o">(</span><span class="n">C</span> <span class="bp">++</span> <span class="o">[</span><span class="n">cd</span><span class="o">])</span>
</code></pre></div>



<a name="208140562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208140562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208140562">(Aug 26 2020 at 19:58)</a>:</h4>
<p>Thank you for your help again!</p>



<a name="208145006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208145006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208145006">(Aug 26 2020 at 20:35)</a>:</h4>
<p>Oh, I forgot to add the constraint in <code>has_type.c</code> that <code>lst.length = uvars</code></p>



<a name="208165189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208165189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xiang Li <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208165189">(Aug 27 2020 at 00:09)</a>:</h4>
<p>And also lev.ubound l ≤ us in <code>cdef.admis.cnst</code>.<br>
<code>exp.usubst</code> just means changing univ_var u  by the uth element in the list, right?</p>



<a name="208173731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208173731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208173731">(Aug 27 2020 at 02:54)</a>:</h4>
<blockquote>
<p>And also lev.ubound l ≤ us in cdef.admis.cnst.</p>
</blockquote>
<p>Actually that's implied from the first bound, although the proof is only easily obtainable as a corollary of the main theorem in the paper</p>



<a name="208173755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20are%20universe%20levels%20defined/near/208173755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20are.20universe.20levels.20defined.html#208173755">(Aug 27 2020 at 02:55)</a>:</h4>
<blockquote>
<p>exp.usubst just means changing univ_var u by the uth element in the list, right?</p>
</blockquote>
<p>Yes</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
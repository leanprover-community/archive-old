---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html">Getting a hypothesis that agrees with the match branch</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="219760278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219760278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219760278">(Dec 13 2020 at 12:49)</a>:</h4>
<p>I'm stuck o n the first sorry here - my goal is exactly the description of the match branch I'm in, but I don't appear to have a proof to hand:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.perm.subgroup</span>

<span class="kd">def</span> <span class="n">inv_sum_congr</span> <span class="o">{</span><span class="n">ιa</span> <span class="n">ιb</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm.sum_congr_subgroup</span> <span class="n">ιa</span> <span class="n">ιb</span><span class="o">)</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="n">ιa</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">match</span> <span class="n">σ</span> <span class="o">(</span><span class="n">sum.inl</span> <span class="n">i</span><span class="o">)</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">sum.inl</span> <span class="n">il</span><span class="o">)</span> <span class="o">:=</span> <span class="n">il</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">sum.inr</span> <span class="n">ir</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false.elim</span> <span class="kd">begin</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">σ</span><span class="o">,</span> <span class="n">sl</span><span class="o">,</span> <span class="n">sr</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">σ</span><span class="o">,</span>
      <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">_root_.congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="n">_</span><span class="o">,</span> <span class="n">σ</span> <span class="o">(</span><span class="n">sum.inl</span> <span class="n">i</span><span class="o">))</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">sum.inl</span> <span class="o">(</span><span class="n">sl</span> <span class="n">i</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">sum.inr</span> <span class="n">ir</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ne.def</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">],</span>
      <span class="n">apply</span> <span class="n">h2</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span><span class="n">h</span><span class="o">,</span>
      <span class="c1">--`⊢ ⇑σ (sum.inl i) = sum.inr ir` ir is exactly our match condition!</span>
      <span class="n">sorry</span>
    <span class="kd">end</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">}</span>
</code></pre></div>



<a name="219760634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219760634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219760634">(Dec 13 2020 at 13:00)</a>:</h4>
<p>I can get there with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">with_proof</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span><span class="n">a'</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span><span class="o">}</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
</code></pre></div>
<p>and thenusing <code>match with_proof (σ (sum.inl i)) with ...</code>. Does <code>with_proof</code> exist as a syntax feature already?</p>



<a name="219761205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219761205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219761205">(Dec 13 2020 at 13:17)</a>:</h4>
<p>Every once in a while something like this gets asked and Mario usually pops up with some solution that uses <code>match _, rfl : \forall</code>, e.g. <a href="#narrow/stream/113488-general/topic/match.20hypothesis/near/133919298">1</a> <a href="#narrow/stream/113489-new-members/topic/Equation.20for.20match-case/near/147353504">2</a> <a href="#narrow/stream/113489-new-members/topic/Getting.20equation.20from.20match/near/188421210">3</a></p>



<a name="219761704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219761704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219761704">(Dec 13 2020 at 13:32)</a>:</h4>
<p>Thanks, that solves my need for <code>with_proof</code>, but I still get stuck trying to unfold the matches</p>



<a name="219761863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219761863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219761863">(Dec 13 2020 at 13:36)</a>:</h4>
<p>I get stuck here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">inv_sum_congr</span> <span class="o">{</span><span class="n">ιa</span> <span class="n">ιb</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm.sum_congr_subgroup</span> <span class="n">ιa</span> <span class="n">ιb</span><span class="o">)</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="n">ιa</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">match</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">σ.1</span> <span class="o">(</span><span class="n">sum.inl</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="n">_</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">sum.inl</span> <span class="n">il</span><span class="o">),</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">il</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">sum.inr</span> <span class="n">ir</span><span class="o">),</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">false.elim</span> <span class="bp">$</span> <span class="k">let</span> <span class="o">⟨</span><span class="n">sl</span><span class="o">,</span> <span class="n">sr</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">σ.2</span> <span class="k">in</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h2</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">match</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">σ</span><span class="bp">⁻¹.</span><span class="mi">1</span> <span class="o">(</span><span class="n">sum.inl</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="n">_</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">sum.inl</span> <span class="n">il</span><span class="o">),</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">il</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">sum.inr</span> <span class="n">ir</span><span class="o">),</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">false.elim</span> <span class="bp">$</span> <span class="k">let</span> <span class="o">⟨</span><span class="n">sl</span><span class="o">,</span> <span class="n">sr</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">σ</span><span class="bp">⁻¹.</span><span class="mi">2</span> <span class="k">in</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h2</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">match</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">σ.1</span> <span class="o">(</span><span class="n">sum.inl</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="n">_</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">sum.inl</span> <span class="n">il</span><span class="o">),</span> <span class="n">h</span> <span class="o">:=</span> <span class="kd">begin</span>
      <span class="n">simp</span> <span class="n">only</span><span class="o">,</span>
      <span class="n">simp_rw</span> <span class="bp">←</span><span class="n">h</span><span class="o">,</span>
      <span class="n">sorry</span>
    <span class="kd">end</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">sum.inr</span> <span class="n">ir</span><span class="o">),</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">false.elim</span> <span class="bp">$</span> <span class="k">let</span> <span class="o">⟨</span><span class="n">sl</span><span class="o">,</span> <span class="n">sr</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">σ.2</span> <span class="k">in</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h2</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">sorry</span><span class="o">}</span>
</code></pre></div>



<a name="219763372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763372">(Dec 13 2020 at 14:17)</a>:</h4>
<p>I think the better solution is just to go to tactic mode and use <code>cases e : x</code> which handles this</p>



<a name="219763379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763379">(Dec 13 2020 at 14:17)</a>:</h4>
<p>I haven't needed to write <code>match x, rfl : ...</code> since that was added</p>



<a name="219763460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763460">(Dec 13 2020 at 14:19)</a>:</h4>
<p>Oh true, tactic mode would be fine in the two proof fields</p>



<a name="219763517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763517">(Dec 13 2020 at 14:20)</a>:</h4>
<p>Would tactic mode be a bad idea for the data fields?</p>



<a name="219763536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763536">(Dec 13 2020 at 14:21)</a>:</h4>
<p>It's fine as long as you are aware what all the tactics you use desugar to</p>



<a name="219763544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763544">(Dec 13 2020 at 14:21)</a>:</h4>
<p>This kind of construction is difficult to work with regardless of how you write it</p>



<a name="219763606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763606">(Dec 13 2020 at 14:22)</a>:</h4>
<p>because you have to induct over the x and rfl simultaneously in order to unfold the match, and this involves some messy dependent inductive hypothesis</p>



<a name="219763790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763790">(Dec 13 2020 at 14:26)</a>:</h4>
<p>I think those matches should actually be a function on their own, like <code>sum.resolve_left : \all x: A + B, (\ex y, x = sum.inl y) -&gt; A</code></p>



<a name="219763806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763806">(Dec 13 2020 at 14:27)</a>:</h4>
<p>I was thinking about that too</p>



<a name="219763825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763825">(Dec 13 2020 at 14:28)</a>:</h4>
<p>Is there a more generic version of that to non-classically unpack an exists of an inductive type?</p>



<a name="219763875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763875">(Dec 13 2020 at 14:28)</a>:</h4>
<p>it would be even better if such functions were generated automatically because they work for all inductive types</p>



<a name="219763885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763885">(Dec 13 2020 at 14:28)</a>:</h4>
<p>Or is a type like <code>sum.elim (fun _, true) (fun _, false)</code> a better thing to use as an argument than <code>exists</code>?</p>



<a name="219763974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763974">(Dec 13 2020 at 14:30)</a>:</h4>
<p>I have considered the following scheme: <code>T.discr : T -&gt; nat</code> returns the discriminant, i.e. 0 for the first case, 1 for the second, etc, and <code>T.extract_c : \all x : T, x.discr = n -&gt; A x B</code> gets case <code>| c : A -&gt; B -&gt; T</code> with discriminant <code>n</code></p>



<a name="219763997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219763997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219763997">(Dec 13 2020 at 14:31)</a>:</h4>
<p>Alternatively, <code>extract_c</code> can return <code>option (A x B)</code> and there are theorems about what its <code>is_some</code> looks like so you can use <code>option.get</code></p>



<a name="219764042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219764042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219764042">(Dec 13 2020 at 14:32)</a>:</h4>
<p>The cool thing is that this represents the primitive operations of the VM, so they have efficient implementations even better than match</p>



<a name="219764121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219764121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219764121">(Dec 13 2020 at 14:34)</a>:</h4>
<p>extract_c could go with <code>-&gt; \sigma a b, x = c a b</code> right?</p>



<a name="219764123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219764123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219764123">(Dec 13 2020 at 14:34)</a>:</h4>
<p>Also, for very large inductive types, this scheme is asymptotically better than the standard O(n^2) decidable_eq implementation</p>



<a name="219764141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219764141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219764141">(Dec 13 2020 at 14:35)</a>:</h4>
<p>It could also be broken into a bunch of functions instead of a pair- or sigma- returning function</p>



<a name="219764173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219764173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219764173">(Dec 13 2020 at 14:36)</a>:</h4>
<p>the equality would be a theorem, there's no need to pack it in the return value</p>



<a name="219768308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219768308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219768308">(Dec 13 2020 at 16:24)</a>:</h4>
<p>I've been having similar issues with casing on inductive types. What would be the main expected challenge in generating such functions for all inductive types?</p>



<a name="219769466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219769466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219769466">(Dec 13 2020 at 16:53)</a>:</h4>
<p>Packing it in the return value seems like an easy way to generalize over arbitrary telescopes</p>



<a name="219769472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Getting%20a%20hypothesis%20that%20agrees%20with%20the%20match%20branch/near/219769472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Getting.20a.20hypothesis.20that.20agrees.20with.20the.20match.20branch.html#219769472">(Dec 13 2020 at 16:53)</a>:</h4>
<p>Rather that having a special case for the last argument which doesn't get a binder</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
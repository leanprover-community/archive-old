---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/easy.20questions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html">easy questions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="169009150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169009150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adrian Chu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169009150">(Jun 26 2019 at 08:23)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">test</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">2</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="mi">4</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">test2</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="bp">∃</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">3</span><span class="bp">*</span><span class="n">b</span> <span class="bp">=</span> <span class="mi">6</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">fapply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
  <span class="n">exact</span> <span class="mi">3</span><span class="o">,</span> <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>in this stupid theorem, i want to replace <code>3</code> with the <code>a</code> given by <code>test</code>, how should i write?</p>



<a name="169009211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169009211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169009211">(Jun 26 2019 at 08:25)</a>:</h4>
<p>you can't take out what you put in the proof of an existential statement</p>



<a name="169009349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169009349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adrian Chu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169009349">(Jun 26 2019 at 08:27)</a>:</h4>
<p>huh? but then how should we define a number x+1, in which the existence of x is guaranteed by some previous theorem A?</p>



<a name="169009421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169009421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169009421">(Jun 26 2019 at 08:28)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">choice</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">C</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">spec</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">C</span> <span class="n">n</span><span class="o">),</span> <span class="n">choice</span> <span class="n">C</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">false</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">zero_ne_one</span> <span class="err">$</span> <span class="k">show</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="k">from</span>
<span class="k">calc</span>  <span class="mi">0</span>
    <span class="bp">=</span> <span class="n">choice</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">:</span> <span class="o">(</span><span class="n">spec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="mi">0</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">choice</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">rfl</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="mi">1</span>                           <span class="o">:</span> <span class="n">spec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="mi">1</span> <span class="n">rfl</span>
</pre></div>



<a name="169009433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169009433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169009433">(Jun 26 2019 at 08:28)</a>:</h4>
<p>this is because of proof irrelevance, where two proofs of the same theorem are definitionally equal</p>



<a name="169009452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169009452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169009452">(Jun 26 2019 at 08:29)</a>:</h4>
<p>so in particular two witnesses result in the same proof of the existential.</p>



<a name="169009640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169009640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169009640">(Jun 26 2019 at 08:32)</a>:</h4>
<p>but you can use a <code>subtype</code> to retain the witness:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">test</span> <span class="o">:</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="mi">2</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">}</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">2</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">test2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">3</span><span class="bp">*</span><span class="n">b</span> <span class="bp">=</span> <span class="mi">6</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">test</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>
</pre></div>



<a name="169009773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169009773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169009773">(Jun 26 2019 at 08:35)</a>:</h4>
<p>But if you want only want to use the witness a in a proof of something else then you can say <code>cases test with a ha,</code></p>



<a name="169009842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169009842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169009842">(Jun 26 2019 at 08:36)</a>:</h4>
<p>oh right</p>



<a name="169009995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169009995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169009995">(Jun 26 2019 at 08:38)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">test</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">2</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="mi">4</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">2</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">test2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">3</span><span class="bp">*</span><span class="n">b</span> <span class="bp">=</span> <span class="mi">6</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">test</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">refine</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">two_mul</span> <span class="n">at</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">bit0_inj</span> <span class="n">ha</span> <span class="o">},</span>
  <span class="n">subst</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kn">end</span>
</pre></div>



<a name="169010235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169010235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adrian Chu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169010235">(Jun 26 2019 at 08:42)</a>:</h4>
<p>i see, thanks!!</p>



<a name="169017943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169017943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169017943">(Jun 26 2019 at 10:56)</a>:</h4>
<blockquote>
<p>you can't take out what you put in the proof of an existential statement</p>
</blockquote>
<p>Don't listen to the constructivist!</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">theorem</span> <span class="n">test</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">2</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="mi">4</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">test2</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="bp">∃</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">3</span><span class="bp">*</span><span class="n">b</span> <span class="bp">=</span> <span class="mi">6</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">choose</span> <span class="n">a</span> <span class="n">ha</span> <span class="kn">using</span> <span class="n">test</span> <span class="mi">37</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  1 goal</span>
<span class="cm">  x a : ℕ,</span>
<span class="cm">  ha : 2 * a = 4</span>
<span class="cm">  ⊢ ∃ (b : ℕ), 3 * b = 6</span>
<span class="cm">  -/</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>[why does test take an input which is never used?]</p>



<a name="169018082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169018082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169018082">(Jun 26 2019 at 10:59)</a>:</h4>
<p>You don't need <code>choose</code> here, just <code>cases</code> which was mentioned earlier</p>



<a name="169018211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169018211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169018211">(Jun 26 2019 at 11:01)</a>:</h4>
<p>Sure, but this is a refutation of Kenny's claim "you can't take out what you put in the proof of an existential statement". The issue with <code>choose</code> is that it is noncomputable (Lean actually forgot <code>a</code> once it had checked your proof, so there is no algorithm for getting it back).</p>



<a name="169024194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169024194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169024194">(Jun 26 2019 at 12:31)</a>:</h4>
<p>but my point was that you can't take out what you <strong>put in</strong>, i.e. the explicit witness you constructed</p>



<a name="169024208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169024208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169024208">(Jun 26 2019 at 12:31)</a>:</h4>
<p>contrary to maths where you can always destruct an existential to get data</p>



<a name="169024328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169024328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169024328">(Jun 26 2019 at 12:33)</a>:</h4>
<p>I don't know that in maths the behavior is much different from <code>choose</code></p>



<a name="169024390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169024390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169024390">(Jun 26 2019 at 12:34)</a>:</h4>
<p>Except possibly that you can prove additional properties to put in the existential after the fact</p>



<a name="169024400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169024400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169024400">(Jun 26 2019 at 12:34)</a>:</h4>
<p>but this is more of a proof structuring thing</p>



<a name="169024920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169024920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169024920">(Jun 26 2019 at 12:41)</a>:</h4>
<p>I think the situation in real maths is just that if you constructed an existential by directly producing a term, then if you ever need it later you're allowed to remember your proof and the element</p>



<a name="169025554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169025554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169025554">(Jun 26 2019 at 12:49)</a>:</h4>
<p>It's even better than that, we're even allowed to say "By the proof of Theorem 3.2, ..."</p>



<a name="169126576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169126576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adrian Chu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169126576">(Jun 27 2019 at 11:46)</a>:</h4>
<p>how to prove that </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="n">def</span> <span class="n">y</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="mi">1</span><span class="bp">+</span><span class="n">i</span><span class="o">)</span>
<span class="kn">theorem</span> <span class="n">test</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>  <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>
</pre></div>


<p>? library search gives nothing</p>



<a name="169126707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169126707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169126707">(Jun 27 2019 at 11:48)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="k">begin</span>
  <span class="n">funext</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>



<a name="169126736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169126736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169126736">(Jun 27 2019 at 11:49)</a>:</h4>
<p>Or in term mode: <code>funext $ _</code></p>



<a name="169126860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169126860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adrian Chu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169126860">(Jun 27 2019 at 11:51)</a>:</h4>
<p>i see</p>



<a name="169128301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169128301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169128301">(Jun 27 2019 at 12:10)</a>:</h4>
<p>Why does <code>rfl</code> fail?</p>



<a name="169128318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169128318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169128318">(Jun 27 2019 at 12:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="n">def</span> <span class="n">y</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="mi">1</span><span class="bp">+</span><span class="n">i</span><span class="o">)</span>
<span class="kn">theorem</span> <span class="n">test</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>  <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- type mismatch</span>
</pre></div>



<a name="169128834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169128834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169128834">(Jun 27 2019 at 12:18)</a>:</h4>
<p>the first one is <code>i+1</code> and the second one is <code>1+i</code></p>



<a name="169129325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169129325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169129325">(Jun 27 2019 at 12:26)</a>:</h4>
<p>oh thanks. Duh.</p>



<a name="169129343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169129343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169129343">(Jun 27 2019 at 12:26)</a>:</h4>
<p>The colours played a trick on my brain somehow</p>



<a name="169129922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169129922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169129922">(Jun 27 2019 at 12:35)</a>:</h4>
<p>Whoever made the courier new typeface has caused at least billions of dollars of damage with how close <code>i</code> and <code>1</code> look</p>



<a name="169137953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169137953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adrian Chu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169137953">(Jun 27 2019 at 14:08)</a>:</h4>
<p>wouldn't <code>1</code> and <code>l</code> be deadlier?</p>



<a name="169140519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169140519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169140519">(Jun 27 2019 at 14:36)</a>:</h4>
<p>1ucki1y l is 1ess common in programming</p>



<a name="169284881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169284881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169284881">(Jun 29 2019 at 06:34)</a>:</h4>
<p>is it illegal to delcare a long literal in Java with a lower case <code>l</code>?</p>



<a name="169284883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169284883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169284883">(Jun 29 2019 at 06:34)</a>:</h4>
<p>If no, that's a good one</p>



<a name="169285287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169285287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169285287">(Jun 29 2019 at 06:49)</a>:</h4>
<p>that's legal</p>



<a name="169285741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/169285741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#169285741">(Jun 29 2019 at 07:05)</a>:</h4>
<p>There's an entire class of "off-by-<code>l</code>" errors</p>



<a name="171379559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171379559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171379559">(Jul 21 2019 at 16:53)</a>:</h4>
<p>Hi guys, I want to use the heterogeneous equality but cannot derive it to homogeneous equality. i.e. can we define the following?</p>
<div class="codehilite"><pre><span></span>    <span class="n">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
              <span class="n">x</span> <span class="bp">==</span> <span class="n">y</span> <span class="bp">→</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>



<a name="171379702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171379702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171379702">(Jul 21 2019 at 16:57)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
              <span class="n">x</span> <span class="bp">==</span> <span class="n">y</span> <span class="bp">→</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">h</span><span class="bp">;</span> <span class="n">refl</span>
</pre></div>



<a name="171379869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171379869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171379869">(Jul 21 2019 at 17:01)</a>:</h4>
<p>You don't need the assumption <code>α = β</code>, it's implied by <code>x == y</code></p>



<a name="171379885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171379885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171379885">(Jul 21 2019 at 17:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> ah, thanks. but how about another way?</p>



<a name="171380013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171380013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171380013">(Jul 21 2019 at 17:04)</a>:</h4>
<p>wait, if we don't need <code>p : α = β</code>, then how can we express <code>(eq.rec_on p x : β) = y</code>?</p>



<a name="171380034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171380034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171380034">(Jul 21 2019 at 17:05)</a>:</h4>
<p>You could write <code>eq.rec_on (type_eq_of_heq (h : x == y)) x</code></p>



<a name="171419680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171419680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171419680">(Jul 22 2019 at 10:34)</a>:</h4>
<p>Hi, there. Can anyone tell me why the following example doesn't work?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="k">begin</span> <span class="n">rw</span> <span class="n">p</span><span class="o">,</span> <span class="n">reflexivity</span> <span class="kn">end</span>
</pre></div>


<p>after <code>rw p</code> the goal is <code>unit → β = unit → β</code> but <code>reflexivity</code> doesn't work.</p>



<a name="171419725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171419725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171419725">(Jul 22 2019 at 10:35)</a>:</h4>
<p>Brackets</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">unit</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">unit</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span> <span class="n">rw</span> <span class="n">p</span> <span class="kn">end</span>
</pre></div>



<a name="171419787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171419787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171419787">(Jul 22 2019 at 10:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> wow, such a silly mistake. Thank you</p>



<a name="171420094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171420094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171420094">(Jul 22 2019 at 10:43)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="k">begin</span> <span class="n">intros</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">p</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span> <span class="n">exact</span> <span class="o">()</span> <span class="kn">end</span>
</pre></div>



<a name="171453375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171453375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171453375">(Jul 22 2019 at 18:06)</a>:</h4>
<p>Does lean have something like the following in standard library or mathlib?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">uip</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>if not, how can we prove this?</p>



<a name="171453408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171453408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171453408">(Jul 22 2019 at 18:07)</a>:</h4>
<p><code>rfl</code></p>



<a name="171453437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171453437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171453437">(Jul 22 2019 at 18:07)</a>:</h4>
<p>this is called proof irrelevance and is built into Lean</p>



<a name="171453453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171453453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171453453">(Jul 22 2019 at 18:07)</a>:</h4>
<p>it says that two proofs of the same proposition are definitionally equal</p>



<a name="171453510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171453510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171453510">(Jul 22 2019 at 18:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> , thank you :)</p>



<a name="171680724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171680724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171680724">(Jul 25 2019 at 10:52)</a>:</h4>
<p>I have a problem with unfolding tactic. Considering the following code</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">graph</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">nodes</span>  <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">edges</span>  <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">srctrg</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">edges</span> <span class="bp">→</span> <span class="n">nodes</span><span class="o">)</span>

<span class="n">def</span> <span class="n">prism_graph</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">nodes</span>  <span class="o">:=</span> <span class="n">bool</span> <span class="bp">×</span> <span class="n">G</span><span class="bp">.</span><span class="n">nodes</span>
  <span class="o">,</span> <span class="n">edges</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">×</span> <span class="n">G</span><span class="bp">.</span><span class="n">edges</span><span class="o">)</span> <span class="err">⊕</span> <span class="n">G</span><span class="bp">.</span><span class="n">nodes</span>
  <span class="o">,</span> <span class="n">srctrg</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">e</span><span class="o">,</span> <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
                     <span class="bp">|</span> <span class="o">(</span><span class="n">sum</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">b&#39;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="o">:=</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">G</span><span class="bp">.</span><span class="n">srctrg</span> <span class="n">b&#39;</span> <span class="n">e</span><span class="o">)</span>
                     <span class="bp">|</span> <span class="o">(</span><span class="n">sum</span><span class="bp">.</span><span class="n">inr</span> <span class="n">v</span><span class="o">)</span>       <span class="o">:=</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>
                     <span class="kn">end</span>
  <span class="o">}</span>

<span class="n">def</span> <span class="n">cube_graph</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">graph</span>
<span class="bp">|</span> <span class="mi">0</span>      <span class="o">:=</span> <span class="bp">⟨</span><span class="n">unit</span><span class="o">,</span> <span class="n">unit</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="o">())</span><span class="bp">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">prism_graph</span> <span class="o">(</span><span class="n">cube_graph</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="o">(</span><span class="n">cube_graph</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">nodes</span><span class="o">)</span> <span class="o">:</span>
      <span class="o">(</span><span class="n">graph</span><span class="bp">.</span><span class="n">srctrg</span> <span class="o">(</span><span class="n">cube_graph</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="n">b</span> <span class="o">(</span><span class="n">sum</span><span class="bp">.</span><span class="n">inr</span> <span class="n">v</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">unfold</span> <span class="n">cube_graph</span><span class="o">,</span>
  <span class="kn">end</span>
</pre></div>


<p>I don't understand why <code>unfold cube_graph</code> fails. Clearly, it should succeed with the goal become <code>(graph.srctrg (prism_graph (cube_graph n)) b (sum.inr v)) = (b, v)</code>.</p>
<p>Ps. You might argue that I can close this tactic by <code>refl</code> but my point is to use <code>unfold</code>. The reason is that this is the simplified version of the actual problem that I am working and I can't just use <code>refl</code>.<br>
Ps2. This is another question. If <code>refl</code> works, why <code>simp</code> doesn't. Isn't <code>simp</code> use <code>refl</code> at the end anyway?</p>



<a name="171681264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171681264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171681264">(Jul 25 2019 at 11:02)</a>:</h4>
<p>You're expecting too much from unfold. What you want here is <code>dsimp [cube_graph]</code>.</p>



<a name="171681280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171681280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171681280">(Jul 25 2019 at 11:03)</a>:</h4>
<p>About your second question, maybe <code>simp</code> is actually doing some thing which turns your goal into a non-refl goal.</p>



<a name="171681287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171681287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171681287">(Jul 25 2019 at 11:03)</a>:</h4>
<p>You can use <code>dunfold</code>. The reason <code>simp</code> doesn't work, is because <code>graph.srctrg</code> is a dependent function, so the expression after rewriting only typechecks because <code>cube_graph (n + 1) = prism_graph (cube_graph n)</code> is s definitional equality.</p>



<a name="171690621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171690621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171690621">(Jul 25 2019 at 13:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span>  <span class="user-mention" data-user-id="110044">@Chris Hughes</span>  Thank you for introducing <code>dsimp</code> and <code>dunfold</code> to me.</p>
<p>Another question, if I have two occurrences of the same<br>
definition in a goal. <code>(d)unfold</code> once will affect the first<br>
occurrence an not the second, if I want another way (i.e. affect the second<br>
one and not the first one) what should I do?</p>



<a name="171690749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171690749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171690749">(Jul 25 2019 at 13:25)</a>:</h4>
<p>Definitional unfolding is all defeq, so if your goal does not look like what you want it to look like, you can just write <code>change &lt;what you want the goal to look like&gt;</code> and if what you write is definitionally equal to what the goal is, the goal will change to what you write. Note that <code>show</code> is synonymous with <code>change</code>, although you can use <code>change</code> on hypotheses as well.</p>



<a name="171690838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171690838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171690838">(Jul 25 2019 at 13:26)</a>:</h4>
<p>The other approach for zooming in on terms in goals is <code>conv</code> mode:  <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md</a></p>



<a name="171690925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171690925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171690925">(Jul 25 2019 at 13:27)</a>:</h4>
<p>I don't know how much you know about definitional equality v all the other equalities, but here's something I wrote about definitional equality: <a href="https://xenaproject.wordpress.com/2019/05/21/equality-part-1-definitional-equality/" target="_blank" title="https://xenaproject.wordpress.com/2019/05/21/equality-part-1-definitional-equality/">https://xenaproject.wordpress.com/2019/05/21/equality-part-1-definitional-equality/</a></p>



<a name="171691021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171691021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171691021">(Jul 25 2019 at 13:28)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span>  <span class="user-mention silent" data-user-id="110044">Chris Hughes</span>  Thank you for introducing <code>dsimp</code> and <code>dunfold</code> to me.</p>
<p>Another question, if I have two occurrences of the same<br>
definition in a goal. <code>(d)unfold</code> once will affect the first<br>
occurrence an not the second, if I want another way (i.e. affect the second<br>
one and not the first one) what should I do?</p>
</blockquote>
<p>Do you have an example of this. Usually I think it unfolds all occurrences, so it might be not unfolding the second one for some other reason.</p>



<a name="171691194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171691194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171691194">(Jul 25 2019 at 13:31)</a>:</h4>
<p>Another thing you might want to know is that if you type <code>#print prefix cube_graph</code> then you can see all the stuff that Lean generated for you when you made <code>cube_graph</code>. Things called <code>cube_graph._equation.1</code> or something (I forget what they're exactly called) are the things which Lean tries to use when you run <code>unfold</code> -- that's what the tactic actually does.  Similarly <code>dsimp [cube_graph]</code> tries to simplify using those "hidden" equation lemmas.</p>



<a name="171691501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171691501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171691501">(Jul 25 2019 at 13:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Thank you for introducing <code>change</code> and <code>conv</code>. These what tactics that I have been looking for many days. It is also interesting to know that we can even unfold anonymous functions as well. </p>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span>  I have but it is in a long file and it can be the case that the second occurrence is not unfoldable at the moment so I miss understood the behaviour of <code>(d)unfold</code> .</p>



<a name="171700078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171700078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171700078">(Jul 25 2019 at 15:13)</a>:</h4>
<p><span class="user-mention" data-user-id="144193">@Gun Pinyo</span> you should definitely read through the general <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md">mathlib tactic documentation</a></p>



<a name="171840194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171840194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171840194">(Jul 27 2019 at 10:48)</a>:</h4>
<p>If I am in the tactic mode with 2 goals. Is there any tactic that lets me prove the second goal before the first one?<br>
The motivation behind this is when the second goal is a lot easier than the first one.</p>
<p>Ps. I have read through <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md">https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md</a> but didn't find any.</p>



<a name="171840196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171840196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171840196">(Jul 27 2019 at 10:48)</a>:</h4>
<p><code>swap</code></p>



<a name="171840209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171840209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171840209">(Jul 27 2019 at 10:48)</a>:</h4>
<p>Once you've got it working, hover over the tactic to see the docstring.</p>



<a name="171840339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171840339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171840339">(Jul 27 2019 at 10:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  Thank you.<br>
So there are more tactics that are not in mathlib. Where can I find the documentation of these built-in tactics?<br>
At first, I thought every built-in tactic should be in <a href="https://leanprover.github.io/reference/tactics.html" target="_blank" title="https://leanprover.github.io/reference/tactics.html">https://leanprover.github.io/reference/tactics.html#</a> but it is not the case for <code>swap</code>.</p>



<a name="171840390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171840390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171840390">(Jul 27 2019 at 10:54)</a>:</h4>
<p>Maybe <code>swap</code> is in core Lean? You can just right click on it to check.</p>



<a name="171840394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171840394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171840394">(Jul 27 2019 at 10:54)</a>:</h4>
<p>A great place for learning about core tactics is the book Theorem Proving In Lean.</p>



<a name="171840539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171840539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171840539">(Jul 27 2019 at 10:59)</a>:</h4>
<p>It would be good to add <code>swap</code> and any other missing core tactics to that doc page. Maybe for now we should just add a comment to this issue <a href="https://github.com/leanprover-community/mathlib/issues/450" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/450">https://github.com/leanprover-community/mathlib/issues/450</a></p>



<a name="171840543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171840543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171840543">(Jul 27 2019 at 10:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I agree, that was what I did before starting my current project.<br>
But again, it doesn't mention <code>swap</code>.</p>



<a name="171840747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171840747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171840747">(Jul 27 2019 at 11:04)</a>:</h4>
<p>Oh, btw, <code>swap</code> is defined in mathlib and not the builtin one. <a href="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/interactive.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/interactive.lean">https://github.com/leanprover-community/mathlib/blob/master/src/tactic/interactive.lean</a></p>



<a name="171846042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/171846042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#171846042">(Jul 27 2019 at 13:48)</a>:</h4>
<p>If I recall, core defines <code>tactic.swap</code> but does not expose to interactive?</p>



<a name="172680308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172680308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172680308">(Aug 07 2019 at 14:01)</a>:</h4>
<p>This might be a very stupid question but why can't we add univalence axiom to lean3? i.e. why axiom K of lean3 doesn't play well with the univalence axiom?</p>



<a name="172680357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172680357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172680357">(Aug 07 2019 at 14:01)</a>:</h4>
<p>(deleted)</p>



<a name="172680391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172680391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172680391">(Aug 07 2019 at 14:02)</a>:</h4>
<p>(deleted)</p>



<a name="172680490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172680490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172680490">(Aug 07 2019 at 14:02)</a>:</h4>
<p>This has been talked about before and I know it's inconsistent but I don't know why. It's something to do with impredicativity of Prop</p>



<a name="172681053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172681053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172681053">(Aug 07 2019 at 14:10)</a>:</h4>
<p>Because equality is a subsingleton, and univalence says it is isomorphic to something which is not a subsingleton. Even if you define a equality to return a type, rather than a Prop, this is still provably a subsingleton (the proof uses the proof irrelevant version of eq).</p>



<a name="172681138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172681138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172681138">(Aug 07 2019 at 14:11)</a>:</h4>
<p>I think <code>α ≃ β → α = β</code> is consistent though, but not very useful.</p>



<a name="172681498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172681498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172681498">(Aug 07 2019 at 14:15)</a>:</h4>
<p>So is even my undeleted post incorrect?</p>



<a name="172681580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172681580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172681580">(Aug 07 2019 at 14:16)</a>:</h4>
<p>Because <code>α = β → α ≃ β</code> is a theorem</p>



<a name="172681735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172681735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172681735">(Aug 07 2019 at 14:18)</a>:</h4>
<p>Those two function aren't inverses of each other in Lean, but univalence says they are.</p>



<a name="172681847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172681847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172681847">(Aug 07 2019 at 14:19)</a>:</h4>
<p>Surely <code>α ≃ β → α = β</code> would be useful in Lean, because it would enable me to show that if R and S are isomorphic rings and R is Noetherian local then S is Noetherian local?</p>



<a name="172681963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172681963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172681963">(Aug 07 2019 at 14:21)</a>:</h4>
<p>You also need the ring structures to be <code>heq</code> for that. Which won't be provable.</p>



<a name="172682115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172682115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172682115">(Aug 07 2019 at 14:23)</a>:</h4>
<p>So you can't get from the bare <code>α ≃ β → α = β</code> statement about types to statements about isomorphic groups being equal groups by using some kind of trickery?</p>



<a name="172682140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172682140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172682140">(Aug 07 2019 at 14:23)</a>:</h4>
<p>I would imagine that in HoTT they can do this somehow</p>



<a name="172682305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172682305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172682305">(Aug 07 2019 at 14:25)</a>:</h4>
<p>I don't think so. In Lean, you have no idea what <code>eq.mp</code> gives you. In HoTT, you know from the <code>right_inv</code> part of the univalence equivalence, that <code>eq.mpr</code> is <code>to_fun</code> of your bijection. Then you can prove that <code>eq.rec one_ring_strcuture = the_other_ring_structure</code></p>



<a name="172682587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172682587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172682587">(Aug 07 2019 at 14:29)</a>:</h4>
<p>In the univalence equivalence <code>inv_fun := eq.mp</code>. The axiom says that <code>eq.mp</code> has a two sided inverse.</p>



<a name="172692268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172692268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172692268">(Aug 07 2019 at 16:19)</a>:</h4>
<p>In answer to the original question: from univalence you can show that <code>bool = bool</code>  has two unequal elements (one corresponding to the identity function, and one corresponding to the function that swaps the elements), which contradicts axiom K.</p>



<a name="172692548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172692548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172692548">(Aug 07 2019 at 16:23)</a>:</h4>
<p>And I'm quite sure that Chris is right that weak univalence (<code>α ≃ β → α = β</code>) doesn't give you that isomorphic groups are equal.</p>



<a name="172929865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172929865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172929865">(Aug 10 2019 at 15:57)</a>:</h4>
<p>Hi, there. Regarding defined class in stdlib, many of them have one field. I try to understand why don't you just use <code>def</code> with <code>@[class]</code>? For example, </p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">default</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">def</span> <span class="n">inhabited&#39;</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="n">α</span>
</pre></div>


<p><code>inhabited'</code> should be as usable as <code>inhabited</code> but we also don't need to write the constructor. </p>
<p>There are some classes that way such as in <code>library/init/relator.lean</code>. I can see the advantage of using the letter way but haven't seen the advantage of the former way. Could you please explain to me please?</p>



<a name="172953836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172953836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172953836">(Aug 11 2019 at 05:05)</a>:</h4>
<p>&lt;deleted&gt;</p>



<a name="172953987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172953987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172953987">(Aug 11 2019 at 05:10)</a>:</h4>
<p>&lt;deleted&gt;</p>



<a name="172954210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172954210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172954210">(Aug 11 2019 at 05:18)</a>:</h4>
<p>&lt;deleted&gt;</p>



<a name="172954397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172954397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172954397">(Aug 11 2019 at 05:25)</a>:</h4>
<p>One difference is that <code>inhabited' α</code> is definitionally equal to <code>α</code>, while <code>inhabited α</code> is not (it is equivalent to <code>α</code>, in the sense that <code>equiv (inhabited α) α</code> can be proven). <br>
Sometimes extra definitional equalities are convenient, but sometimes they have downsides. It is possible that the elaborator of Lean will unfold <code>inhabited'</code> in places where you didn't want to, and then you are not talking about the type <code>inhabited' α</code> anymore, but about <code>α</code>. The latter is not a class, which might cause issues with type class inference not firing.<br>
Since <code>inhabited</code> is not a definition, it can never be unfolded.</p>



<a name="172954454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172954454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172954454">(Aug 11 2019 at 05:27)</a>:</h4>
<p>This is a much better explanation of why, haha.</p>



<a name="172971447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172971447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172971447">(Aug 11 2019 at 14:43)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> , how about we add <code>@[irreducible]</code> to <code>inhabited' α</code>, would it solved the problem with unwanted unfolding?</p>



<a name="172973230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172973230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172973230">(Aug 11 2019 at 15:42)</a>:</h4>
<p>In that case there won't be much advantage of the <code>def</code> over the single-field <code>class</code></p>



<a name="172976066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172976066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172976066">(Aug 11 2019 at 17:12)</a>:</h4>
<p>That would also be fine. But as Reid said: if you don't want to unfold it, you can just as well make it a structure.</p>



<a name="172976425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172976425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172976425">(Aug 11 2019 at 17:23)</a>:</h4>
<p>Well, my point is that I don't want to keep writing <code>.intro</code> or something like that.</p>



<a name="172976915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172976915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172976915">(Aug 11 2019 at 17:39)</a>:</h4>
<p>Angle bracket notation doesn't work for you?</p>



<a name="172977345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/172977345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#172977345">(Aug 11 2019 at 17:52)</a>:</h4>
<p>If you marked it irreducible you'd have to define an<code>intro</code> and use that.</p>



<a name="173217032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/173217032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#173217032">(Aug 14 2019 at 16:06)</a>:</h4>
<p>I just discover that we can write numerals as elements of <code>fin</code><br>
type. So I want to refactor the following code:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">fin</span><span class="bp">.</span><span class="n">zero</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero_lt_succ</span> <span class="n">n</span><span class="bp">⟩</span>
<span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">insert_nth_zero</span> <span class="o">:</span> <span class="n">v</span><span class="bp">.</span><span class="n">insert_nth</span> <span class="n">a</span> <span class="n">fin</span><span class="bp">.</span><span class="n">zero</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">v</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">l</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">zero</span><span class="o">,</span> <span class="n">vector</span><span class="bp">.</span><span class="n">insert_nth</span><span class="o">,</span> <span class="n">vector</span><span class="bp">.</span><span class="n">cons</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">insert_nth</span><span class="o">],</span>
  <span class="kn">end</span>

<span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">insert_nth_zero&#39;</span> <span class="o">:</span> <span class="n">v</span><span class="bp">.</span><span class="n">insert_nth</span> <span class="n">a</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">v</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">l</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[{</span><span class="bp">!</span><span class="n">what</span> <span class="n">should</span> <span class="n">be</span> <span class="n">here</span><span class="err">?</span><span class="bp">!</span><span class="o">},</span> <span class="n">vector</span><span class="bp">.</span><span class="n">insert_nth</span><span class="o">,</span> <span class="n">vector</span><span class="bp">.</span><span class="n">cons</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">insert_nth</span><span class="o">],</span>
  <span class="kn">end</span>
</pre></div>


<p><code>vector.insert_nth_zero'</code> is the same as <code>vector.insert_nth_zero</code><br>
except that <code>fin.zero</code> is changed to <code>0</code>. Everything should be fine, however, I don't know there to replace <code>fin.zero</code> in <code>simp</code> tactic now. Does anyone know how to fix this?</p>



<a name="173221599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/173221599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#173221599">(Aug 14 2019 at 17:01)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">insert_nth_zero&#39;</span> <span class="o">:</span> <span class="n">v</span><span class="bp">.</span><span class="n">insert_nth</span> <span class="n">a</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">v</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">l</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">vector</span><span class="bp">.</span><span class="n">insert_nth</span><span class="o">],</span> <span class="n">norm_cast</span>
  <span class="kn">end</span>
</pre></div>



<a name="173221946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/173221946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#173221946">(Aug 14 2019 at 17:05)</a>:</h4>
<p>or maybe this</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">insert_nth_zero&#39;</span> <span class="o">:</span> <span class="n">v</span><span class="bp">.</span><span class="n">insert_nth</span> <span class="n">a</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">v</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">l</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">vector</span><span class="bp">.</span><span class="n">insert_nth</span><span class="o">,</span> <span class="n">vector</span><span class="bp">.</span><span class="n">cons</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">mk_eq_mk</span><span class="o">],</span>
    <span class="k">show</span> <span class="n">list</span><span class="bp">.</span><span class="n">insert_nth</span> <span class="mi">0</span> <span class="n">a</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">l</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">insert_nth</span><span class="o">]</span>
  <span class="kn">end</span>
</pre></div>



<a name="173292870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/173292870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#173292870">(Aug 15 2019 at 14:02)</a>:</h4>
<p>I still have another question regarding <code>fin</code>.  Sometimes, I want to use pattern matching on <code>i : fin n</code> in the same way as one will do in <code>ℕ</code> but since the inductive part is in <code>i.val</code> so I need to do as follows:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">fin_is_even</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="mi">0</span>      <span class="n">i</span>                        <span class="o">:=</span> <span class="n">i</span><span class="bp">.</span><span class="n">elim0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span>    <span class="bp">_⟩</span>                <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">i_val</span> <span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">succ_i_is_lt</span><span class="bp">⟩</span> <span class="o">:=</span>
     <span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">i_val</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pred_le_pred</span> <span class="n">succ_i_is_lt</span><span class="bp">⟩</span>
      <span class="k">in</span> <span class="n">bnot</span> <span class="o">(</span><span class="n">fin_is_even</span> <span class="n">n</span> <span class="n">i</span><span class="o">)</span>
</pre></div>


<p>Ok it works, but in practice, I find it quite annoying to write <code>let i : fin n := ⟨i_val, nat.pred_le_pred succ_i_is_lt⟩</code> every time whereas <code>i</code> should be obtained directly from something like <code>fin.succ i</code>. Therefore, I try to use <code>@[pattern]</code> to help me with this as follows:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">pattern</span><span class="o">]</span>
<span class="n">def</span> <span class="n">fin</span><span class="bp">.</span><span class="n">zero</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero_lt_succ</span> <span class="n">n</span><span class="bp">⟩</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ</span>

<span class="n">def</span> <span class="n">fin_is_even&#39;</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="mi">0</span>      <span class="n">i</span>            <span class="o">:=</span> <span class="n">i</span><span class="bp">.</span><span class="n">elim0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">fin</span><span class="bp">.</span><span class="n">zero</span>     <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bnot</span> <span class="o">(</span><span class="n">fin_is_even&#39;</span> <span class="n">n</span> <span class="n">i</span><span class="o">)</span>
</pre></div>


<p>However I get an error, what is wrong with my code?  Did I misunderstand anything about <code>@[pattern]</code>?</p>
<p>err msg1:<br>
<code>invalid function application in pattern, it cannot be reduced to a constructor (possible solution, mark term as inaccessible using '.( )')</code><br>
err msg2:<br>
<code>don't know how to synthesize placeholder
context:
fin_is_even' : Π (n : ℕ), fin n → bool
⊢ fin n</code></p>



<a name="173297330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/173297330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#173297330">(Aug 15 2019 at 15:03)</a>:</h4>
<p>You're basically expecting the equation compiler to determine whether an element of <code>fin n</code> is in the image of <code>fin.succ</code> or not, and if it is what the element that maps to it is. This is very hard in general. I think the <code>pattern</code> attribute only works for things that are definitionally equal to a constructor. for example <code>λ x, x + 2 = λ x, nat.succ (nat.succ x)</code>, by definition, so marking add with the pattern attribute works. Incidentall changing your definition of <code>fin.zero</code> also works - it also wanted to reduce the proof to a constructor, but it's probably not a desirable change.</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">pattern</span><span class="o">]</span>
<span class="n">def</span> <span class="n">fin</span><span class="bp">.</span><span class="n">zero</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span><span class="o">):</span> <span class="n">fin</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ</span>

<span class="n">def</span> <span class="n">fin_is_even&#39;</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="mi">0</span>      <span class="n">i</span>            <span class="o">:=</span> <span class="n">i</span><span class="bp">.</span><span class="n">elim0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">zero</span> <span class="n">h</span><span class="o">)</span>     <span class="o">:=</span> <span class="n">true</span>
<span class="c1">--| (n +1) x := bnot (fin_is_even&#39; n i)</span>
</pre></div>



<a name="173308047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/173308047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gun Pinyo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#173308047">(Aug 15 2019 at 17:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> , thank you, now I can see why fin.succ doesn't work. Anyway, is there any other that allow us use something like fin.zero and fin.succ in pattern matching? I really miss the following alternative definition of <code>fin</code></p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">fin&#39;</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">fin&#39;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">fin&#39;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin&#39;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
</pre></div>


<p>But I use this definition, it is incompatible with the standard library.</p>
<blockquote>
<p>I think the <code>pattern</code> attribute only works for things that are definitionally equal to a constructor</p>
</blockquote>
<p>How about this following code in <code>data.vector</code>? Is this definitionally equal to any constructor? I fact, I haven't seen any code using pattern matching on <code>vector</code></p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">def</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="o">[],</span>  <span class="n">rfl</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">def</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">a</span> <span class="bp">⟨</span> <span class="n">v</span><span class="o">,</span> <span class="n">h</span> <span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨</span> <span class="n">a</span><span class="bp">::</span><span class="n">v</span><span class="o">,</span> <span class="n">congr_arg</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">h</span> <span class="bp">⟩</span>
</pre></div>



<a name="173309108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/173309108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#173309108">(Aug 15 2019 at 17:46)</a>:</h4>
<p><code>nil</code> definitely is. <code>cons</code> definitely isn't.</p>
<p>Actually it depends on the vector you're trying to match with. If your vector is a variable then it won't work. If you do</p>
<div class="codehilite"><pre><span></span><span class="k">match</span> <span class="n">vector</span><span class="bp">.</span><span class="n">mk</span> <span class="n">l</span> <span class="n">rfl</span> <span class="k">with</span><span class="bp">...</span>
</pre></div>


<p>Then it has a better chance of working, but I think the prood of equality would have to be rfl.</p>



<a name="173353499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/easy%20questions/near/173353499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/easy.20questions.html#173353499">(Aug 16 2019 at 07:17)</a>:</h4>
<p>I thought this variant of fin was in mathlib somewhere</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/sets.20with.20two.20elements.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html">sets with two elements</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="208698356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208698356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208698356">(Sep 01 2020 at 14:53)</a>:</h4>
<p>Dear All,</p>
<p>I have managed to find a very convoluted proof of what I think of as a very simple fact.  Can anyone suggest a proof of the lemma below?</p>
<p>I am happy to be embarrassed by showing my proof, although I am not doing it right away, in order not to lead anyone astray...  I will post it, if you ask, though!</p>
<p>Thank you very much!</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">lemma</span> <span class="n">card_two</span> <span class="o">{</span><span class="n">sup</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="n">sup</span> <span class="bp">≠</span> <span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208698573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208698573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208698573">(Sep 01 2020 at 14:54)</a>:</h4>
<p>(The reason that I would like a shorter proof is that at the moment, Lean times out every time I try to continue with my proofs...)</p>



<a name="208699314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208699314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208699314">(Sep 01 2020 at 14:59)</a>:</h4>
<p>I was going to say your lemma doesn't look like it would type check but I guess it actually does.</p>



<a name="208699342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208699342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208699342">(Sep 01 2020 at 14:59)</a>:</h4>
<p>Did you really prove it as a top-level lemma in this form?</p>



<a name="208699387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208699387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208699387">(Sep 01 2020 at 15:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/208699342">said</a>:</p>
<blockquote>
<p>Did you really prove it as a top-level lemma in this form?</p>
</blockquote>
<p>I did prove it, but I am not really proud of my proof:</p>



<a name="208699497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208699497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208699497">(Sep 01 2020 at 15:00)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">card_two</span> <span class="o">{</span><span class="n">sup</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="n">sup</span> <span class="bp">≠</span> <span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intro</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">sne</span> <span class="o">:</span> <span class="n">sup</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="n">refine</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_pos</span><span class="bp">.</span><span class="n">mp</span> <span class="bp">_</span><span class="o">,</span>
            <span class="n">refine</span> <span class="n">lt_of_lt_of_le</span> <span class="bp">_</span> <span class="n">H</span><span class="o">,</span>
            <span class="n">exact</span> <span class="n">two_pos</span><span class="o">,</span>
        <span class="o">},</span>
    <span class="k">have</span> <span class="n">ineq</span> <span class="o">:</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">d</span> <span class="err">∈</span> <span class="n">sup</span> <span class="o">,</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">c</span><span class="o">}</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="n">sup</span> <span class="n">sne</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="n">sne</span><span class="o">)},</span>
        <span class="o">{</span>
            <span class="n">intros</span> <span class="n">c</span> <span class="n">chip</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">cinsup</span> <span class="o">:</span> <span class="n">c</span> <span class="err">∈</span> <span class="n">sup</span><span class="o">,</span>
                <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">exists_eq_right</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">set_of_mem</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_coe</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">clemax</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="n">sne</span><span class="o">,</span>
                <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">le_max&#39;</span> <span class="n">sup</span> <span class="n">sne</span> <span class="n">c</span> <span class="n">cinsup</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">minlec</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="n">sup</span> <span class="n">sne</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">,</span>
                <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;_le</span> <span class="n">sup</span> <span class="n">sne</span> <span class="n">c</span> <span class="n">cinsup</span><span class="o">,</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">and_self</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_set_of_eq</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="o">},</span>
    <span class="n">rw</span> <span class="n">a</span> <span class="n">at</span> <span class="n">ineq</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="n">sne</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="n">sne</span><span class="o">)}</span> <span class="bp">=</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="n">sne</span><span class="o">)},</span>
        <span class="o">{</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">set_of_eq_eq_singleton</span><span class="o">,</span> <span class="n">exists_eq_right</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">set_of_mem</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
            <span class="n">ext</span><span class="o">,</span>
            <span class="n">split</span><span class="bp">;</span><span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_imp</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_singleton_iff</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_set_of_eq</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span><span class="n">omega</span><span class="o">},</span>
        <span class="o">},</span>
    <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">ineq</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">set_of_eq_eq_singleton</span><span class="o">,</span> <span class="n">exists_eq_right</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">set_of_mem</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">consingle</span> <span class="o">:</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">d</span> <span class="err">∈</span> <span class="n">sup</span> <span class="o">,</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">c</span><span class="o">}</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="n">sne</span><span class="o">},</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">exists_eq_right</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">set_of_mem</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">supfintype</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">d</span> <span class="err">∈</span> <span class="n">sup</span> <span class="o">,</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">c</span><span class="o">},</span>
        <span class="o">{</span>
            <span class="n">refine</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span><span class="bp">.</span><span class="n">fintype</span> <span class="bp">_</span><span class="o">,</span>
            <span class="n">refine</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span><span class="bp">.</span><span class="n">subset</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
            <span class="n">exact</span> <span class="o">{</span><span class="n">dd</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">d</span> <span class="err">∈</span> <span class="n">sup</span> <span class="o">,</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">dd</span><span class="o">},</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">exists_eq_right</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">set_of_mem</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
            <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">finite_to_set</span> <span class="n">sup</span><span class="o">,</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="o">},</span>
    <span class="k">have</span> <span class="n">supfinite</span> <span class="o">:</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">d</span> <span class="err">∈</span> <span class="n">sup</span> <span class="o">,</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">c</span><span class="o">}</span><span class="bp">.</span><span class="n">finite</span><span class="o">,</span>
        <span class="n">refine</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span><span class="bp">.</span><span class="n">subset</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
        <span class="n">exact</span> <span class="o">{</span><span class="n">dd</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">d</span> <span class="err">∈</span> <span class="n">sup</span> <span class="o">,</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">dd</span><span class="o">},</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">exists_eq_right</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">set_of_mem</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">finite_to_set</span> <span class="n">sup</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">supins</span> <span class="o">:</span> <span class="n">sup</span> <span class="bp">=</span> <span class="n">supfinite</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">finite_to_set_to_finset</span><span class="o">,</span> <span class="n">exists_eq_right</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">set_of_mem</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">singlefinite</span><span class="o">:</span> <span class="o">{</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">sup</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sne</span><span class="o">}</span><span class="bp">.</span><span class="n">finite</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite_pure</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="n">sne</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">le</span> <span class="o">:</span> <span class="n">supfinite</span><span class="bp">.</span><span class="n">to_finset</span><span class="bp">.</span><span class="n">card</span> <span class="bp">≤</span> <span class="n">singlefinite</span><span class="bp">.</span><span class="n">to_finset</span><span class="bp">.</span><span class="n">card</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_le_of_subset</span><span class="o">,</span>
            <span class="n">intros</span> <span class="n">a</span> <span class="n">ah</span><span class="o">,</span>
            <span class="n">refine</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_def</span><span class="bp">.</span><span class="n">mpr</span> <span class="bp">_</span><span class="o">,</span>
            <span class="n">refine</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_map</span><span class="bp">.</span><span class="n">mpr</span> <span class="bp">_</span><span class="o">,</span>
            <span class="n">tidy</span><span class="o">,</span>
        <span class="o">},</span>
    <span class="k">let</span> <span class="n">singsing</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="n">sne</span><span class="o">},</span>
    <span class="k">have</span> <span class="n">singsingfinite</span> <span class="o">:</span> <span class="n">singsing</span><span class="bp">.</span><span class="n">finite</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite_singleton</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="n">sne</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">eq1</span> <span class="o">:</span> <span class="n">singlefinite</span><span class="bp">.</span><span class="n">to_finset</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_eq_one</span><span class="bp">.</span><span class="n">mpr</span><span class="o">,</span>
            <span class="n">use</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="n">sne</span><span class="o">),</span>
            <span class="n">ext1</span><span class="o">,</span>
            <span class="n">split</span><span class="bp">;</span>
                <span class="o">{</span><span class="n">intros</span> <span class="n">xx</span><span class="o">,</span><span class="n">finish</span><span class="o">,},</span>
        <span class="o">},</span>
    <span class="n">rw</span> <span class="n">eq1</span> <span class="n">at</span> <span class="n">le</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">careq</span> <span class="o">:</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="n">supfinite</span><span class="bp">.</span><span class="n">to_finset</span><span class="bp">.</span><span class="n">card</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">congr_arg</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card</span> <span class="n">supins</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span> <span class="n">careq</span> <span class="n">at</span> <span class="n">le</span><span class="o">,</span>
    <span class="n">linarith</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208699657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208699657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208699657">(Sep 01 2020 at 15:01)</a>:</h4>
<p><del>(I am not sure whether I need more <code>imports</code> for the proof to go through: I produced the <code>mwe</code> with only the statement)</del><br>
I just checked that there is the need for no other <code>import</code>s.</p>



<a name="208699925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208699925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208699925">(Sep 01 2020 at 15:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/208699342">said</a>:</p>
<blockquote>
<p>Did you really prove it as a top-level lemma in this form?</p>
</blockquote>
<p>Btw, what does "top-level lemma" means?</p>



<a name="208700083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208700083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208700083">(Sep 01 2020 at 15:04)</a>:</h4>
<p>Not part of another proof</p>



<a name="208700169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208700169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208700169">(Sep 01 2020 at 15:04)</a>:</h4>
<p>well, this lemma is supposed to be part of another proof...  ahahah!  so I guess that it is a "bottom-level lemma"!</p>



<a name="208701208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208701208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208701208">(Sep 01 2020 at 15:11)</a>:</h4>
<p>Here's a more efficient proof</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">card_two</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">s</span><span class="bp">.</span><span class="n">card</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">sne</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="err">←</span><span class="n">finset</span><span class="bp">.</span><span class="n">card_pos</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">min</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="n">s</span> <span class="n">sne</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">max</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">s</span> <span class="n">sne</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">min</span> <span class="bp">=</span> <span class="n">max</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">],</span> <span class="n">rw</span> <span class="n">h</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">min</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">le_max&#39;</span> <span class="n">s</span> <span class="n">sne</span> <span class="n">x</span> <span class="n">hx</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;_le</span> <span class="n">s</span> <span class="n">sne</span> <span class="n">x</span> <span class="n">hx</span> <span class="o">}</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">card</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_le_one_iff</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">this</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">this</span> <span class="n">y</span> <span class="n">hy</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">linarith</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208701363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208701363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208701363">(Sep 01 2020 at 15:12)</a>:</h4>
<p><code>finset.le_max'</code> seems to have spurious assumptions.</p>



<a name="208701416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208701416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208701416">(Sep 01 2020 at 15:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/208701208">said</a>:</p>
<blockquote>
<p>Here's a more efficient proof</p>
</blockquote>
<p>Thank you so much!!!</p>



<a name="208701452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208701452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208701452">(Sep 01 2020 at 15:12)</a>:</h4>
<p>I will try to understand why your proof works, but for the moment, I will continue with what I was doing!</p>



<a name="208701545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208701545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208701545">(Sep 01 2020 at 15:13)</a>:</h4>
<p>The main step is to guess that something like <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_le_one_iff">docs#finset.card_le_one_iff</a> already exists</p>



<a name="208701679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208701679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208701679">(Sep 01 2020 at 15:14)</a>:</h4>
<p>Here is my proof, without looking at the one by Reid. I haven't made golfing attempts yet.</p>
<div class="codehilite"><pre><span></span><code><span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">lemma</span> <span class="n">card_two</span> <span class="o">(</span><span class="n">sup</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="n">sup</span> <span class="bp">≠</span> <span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">contrapose</span><span class="bp">!</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">this</span> <span class="k">with</span> <span class="n">h</span> <span class="n">h</span><span class="bp">;</span> <span class="n">rw</span> <span class="n">h</span><span class="bp">;</span> <span class="n">linarith</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">or_iff_not_imp_left</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_eq_one</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">ne</span><span class="bp">.</span><span class="n">def</span><span class="o">,</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pos_iff_ne_zero</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_pos</span><span class="o">]</span> <span class="n">at</span> <span class="n">h0</span><span class="o">,</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h0</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">eq_singleton_iff_unique_mem</span><span class="o">,</span>
  <span class="n">refine</span> <span class="bp">⟨</span><span class="n">hx</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">sup</span> <span class="bp">→</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">sup</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">le_antisymm</span><span class="bp">;</span> <span class="n">solve_by_elim</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">sup</span><span class="bp">.</span><span class="n">le_max&#39;</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span> <span class="n">a</span> <span class="n">ha</span><span class="o">),</span>
  <span class="n">rw</span> <span class="err">←</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">sup</span><span class="bp">.</span><span class="n">min&#39;_le</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208701803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208701803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208701803">(Sep 01 2020 at 15:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/208701545">said</a>:</p>
<blockquote>
<p>The main step is to guess that something like <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_le_one_iff">docs#finset.card_le_one_iff</a> already exists</p>
</blockquote>
<p>It always seems to simple, when someone else points it out to me...</p>



<a name="208701827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208701827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208701827">(Sep 01 2020 at 15:15)</a>:</h4>
<p>The assumption is calling to be formulated in terms of <code>nontrivial</code> (which is equivalent to your assumption thanks to <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.one_lt_card_iff_nontrivial">docs#fintype.one_lt_card_iff_nontrivial</a> )</p>



<a name="208701858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208701858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208701858">(Sep 01 2020 at 15:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/208701545">said</a>:</p>
<blockquote>
<p>The main step is to guess that something like <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_le_one_iff">docs#finset.card_le_one_iff</a> already exists</p>
</blockquote>
<p>What does <code>Type*</code> mean?</p>



<a name="208701893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208701893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208701893">(Sep 01 2020 at 15:15)</a>:</h4>
<p>Golfed</p>
<div class="codehilite"><pre><span></span><code><span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">lemma</span> <span class="n">card_two</span> <span class="o">(</span><span class="n">sup</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="n">sup</span> <span class="bp">≠</span> <span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">contrapose</span><span class="bp">!</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_le_one_iff</span><span class="o">,</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">sup</span> <span class="bp">→</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">sup</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">apply</span> <span class="n">le_antisymm</span><span class="bp">;</span> <span class="n">solve_by_elim</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">sup</span><span class="bp">.</span><span class="n">le_max&#39;</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="bp">⟩</span> <span class="n">a</span> <span class="n">ha</span><span class="o">),</span>
  <span class="n">rw</span> <span class="err">←</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">sup</span><span class="bp">.</span><span class="n">min&#39;_le</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="bp">⟩</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208702190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208702190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208702190">(Sep 01 2020 at 15:16)</a>:</h4>
<p>Oh, now I understand what you mean about extraneous assumptions</p>



<a name="208702217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208702217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208702217">(Sep 01 2020 at 15:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/208701858">said</a>:</p>
<blockquote>
<p>What does <code>Type*</code> mean?</p>
</blockquote>
<p><code>Type _</code>, in other words: "Hey lean, figure out the universe yourself"</p>



<a name="208702258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208702258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208702258">(Sep 01 2020 at 15:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/208701893">said</a>:</p>
<blockquote>
<p>Golfed</p>
</blockquote>
<p>Wow!  This proof is also very short!</p>



<a name="208702429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208702429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208702429">(Sep 01 2020 at 15:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/208702217">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/208701858">said</a>:</p>
<blockquote>
<p>What does <code>Type*</code> mean?</p>
</blockquote>
<p><code>Type _</code>, in other words: "Hey lean, figure out the universe yourself"</p>
</blockquote>
<p>Ah, so I can skip introducing universes and go directly to never think about them anymore!</p>



<a name="208702472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208702472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208702472">(Sep 01 2020 at 15:17)</a>:</h4>
<p>No, sorry, nontrivial is for (fin)types, but you're working with a finset.</p>



<a name="208702529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208702529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208702529">(Sep 01 2020 at 15:18)</a>:</h4>
<p>Yup... until you start doing fpqc cohomology (-;</p>



<a name="208702772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208702772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208702772">(Sep 01 2020 at 15:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Are you PRing a fix? Otherwise I will do it</p>



<a name="208702968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208702968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208702968">(Sep 01 2020 at 15:21)</a>:</h4>
<p>Go ahead</p>



<a name="208703436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208703436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208703436">(Sep 01 2020 at 15:24)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/4020">#4020</a></p>



<a name="208703763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208703763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208703763">(Sep 01 2020 at 15:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> I also finally understand why you were so surprised that this lemma typechecked <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="208703865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208703865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208703865">(Sep 01 2020 at 15:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/208701208">said</a>:</p>
<blockquote>
<p>Here's a more efficient proof</p>
</blockquote>
<p>I really like your proof!  I see that you went for the minimum, rather than the maximum!  Anyway, it was very instructive for me, thanks!</p>



<a name="208704516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208704516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208704516">(Sep 01 2020 at 15:31)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> Here is an evil proof that might satisfy Reid:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">card_two</span> <span class="o">(</span><span class="n">sup</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="n">sup</span> <span class="bp">≠</span> <span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_pos</span> <span class="n">at</span> <span class="n">h0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">ne</span><span class="bp">.</span><span class="n">def</span><span class="o">,</span> <span class="n">function</span><span class="bp">.</span><span class="n">funext_iff</span><span class="o">,</span> <span class="n">not_forall</span><span class="o">],</span>
  <span class="n">use</span> <span class="n">h0</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">ne_of_lt</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;_lt_max&#39;_of_card</span><span class="o">,</span>
  <span class="n">linarith</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208704705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208704705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208704705">(Sep 01 2020 at 15:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/208704516">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> Here is an evil proof that might satisfy Reid:</p>
</blockquote>
<p>Ahaha an  evil proof!</p>
<p>I was going over your previous one and I find it very clean!</p>



<a name="208704844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208704844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208704844">(Sep 01 2020 at 15:33)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">card_two</span> <span class="o">(</span><span class="n">sup</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="n">sup</span> <span class="bp">≠</span> <span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">sup</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_pos</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">ne</span><span class="bp">.</span><span class="n">def</span><span class="o">,</span> <span class="n">function</span><span class="bp">.</span><span class="n">funext_iff</span><span class="o">,</span> <span class="n">not_forall</span><span class="o">],</span>
  <span class="n">use</span> <span class="n">h0</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">ne_of_lt</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;_lt_max&#39;_of_card</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">H</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208705013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208705013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208705013">(Sep 01 2020 at 15:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/208704516">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> Here is an evil proof that might satisfy Reid:</p>
<div class="codehilite"><pre><span></span><code>  <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;_lt_max&#39;_of_card</span><span class="o">,</span>
</code></pre></div>


</blockquote>
<p>Oh nice</p>



<a name="208705088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208705088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208705088">(Sep 01 2020 at 15:34)</a>:</h4>
<p>Presumably this is the statement one actually wants anyways (the inequality of functions is not very convenient)</p>



<a name="208708560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208708560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208708560">(Sep 01 2020 at 15:58)</a>:</h4>
<p>If you look at the definition of <code>finset.min'_lt_max'_of_card</code>, you'll see the closely related <code>finset.min'_lt_max'</code>, which might be more convenient. Not sure how you showed that the cardinality is 2 or more. Could be that if you're still proving things about disjoint elements, the <code>card</code>-free lemma is simpler to utilize, instead of generating a hypothesis about <code>card</code> that is just for this lemma.</p>



<a name="208711697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/208711697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#208711697">(Sep 01 2020 at 16:19)</a>:</h4>
<p>Thank you all for the useful lemmas that you found!</p>



<a name="210691903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/210691903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#210691903">(Sep 21 2020 at 00:08)</a>:</h4>
<p>Perhaps I'm missing something, but to me the obvious thing to do here would be:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">card_two</span> <span class="o">{</span><span class="n">sup</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="n">sup</span> <span class="bp">≠</span> <span class="n">finset</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="n">sup</span> <span class="o">:=</span>
<span class="n">mt</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">congr_fun</span> <span class="n">h</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">ne_of_lt</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">min&#39;_lt_max&#39;_of_card</span> <span class="n">sup</span> <span class="n">H</span><span class="o">))</span>
</code></pre></div>



<a name="210710128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/210710128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#210710128">(Sep 21 2020 at 07:49)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> I would like this to be easy, but using your approach, I get the following error:</p>
<div class="codehilite"><pre><span></span><code><span class="n">expected</span> <span class="n">type</span><span class="o">:</span>
<span class="n">sup</span><span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span>
<span class="n">H</span><span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span>
<span class="err">⊢</span> <span class="n">sup</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="bp">≠</span> <span class="n">sup</span><span class="bp">.</span><span class="n">max&#39;</span>
<span class="n">Messages</span> <span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">mwe</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="mi">4</span><span class="o">:</span><span class="mi">21</span>
<span class="n">don&#39;t</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="kn">context</span><span class="o">:</span>
<span class="n">sup</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">H</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span>
<span class="err">⊢</span> <span class="n">sup</span><span class="bp">.</span><span class="n">nonempty</span>
<span class="n">mwe</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="mi">4</span><span class="o">:</span><span class="mi">35</span>
<span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">sup</span><span class="bp">.</span><span class="n">min&#39;_lt_max&#39;_of_card</span> <span class="n">H</span>
<span class="n">term</span>
  <span class="n">H</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="mi">2</span> <span class="bp">≤</span> <span class="n">sup</span><span class="bp">.</span><span class="n">card</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">sup</span><span class="bp">.</span><span class="n">nonempty</span>
<span class="n">Additional</span> <span class="n">information</span><span class="o">:</span>
<span class="bp">/</span><span class="n">home</span><span class="bp">/</span><span class="n">damiano</span><span class="bp">/</span><span class="n">Matematica</span><span class="bp">/</span><span class="n">Lean</span><span class="bp">/</span><span class="n">Chevalley01</span><span class="bp">/</span><span class="n">mwe</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="mi">4</span><span class="o">:</span><span class="mi">35</span><span class="o">:</span> <span class="kn">context</span><span class="o">:</span> <span class="n">switched</span> <span class="n">to</span> <span class="n">simple</span> <span class="n">application</span> <span class="n">elaboration</span> <span class="n">procedure</span> <span class="n">because</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">use</span> <span class="n">expected</span> <span class="n">type</span> <span class="n">to</span> <span class="n">elaborate</span> <span class="n">it</span><span class="o">,</span> <span class="n">error</span> <span class="n">message</span>
  <span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
    <span class="err">?</span><span class="n">m_3</span><span class="bp">.</span><span class="n">min&#39;_lt_max&#39;_of_card</span> <span class="err">?</span><span class="n">m_4</span>
  <span class="n">has</span> <span class="n">type</span>
    <span class="mi">1</span> <span class="bp">&lt;</span> <span class="err">?</span><span class="n">m_2</span><span class="bp">.</span><span class="n">card</span> <span class="bp">→</span> <span class="err">?</span><span class="n">m_2</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="err">?</span><span class="n">m_4</span> <span class="bp">&lt;</span> <span class="err">?</span><span class="n">m_2</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="err">?</span><span class="n">m_4</span>
  <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
    <span class="n">sup</span><span class="bp">.</span><span class="n">min&#39;</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">&lt;</span> <span class="n">sup</span><span class="bp">.</span><span class="n">max&#39;</span> <span class="err">?</span><span class="n">m_1</span>
</code></pre></div>


<p>(the underlined bits are the underscore in <code>congr_fun h _</code>and <code>finset</code>)</p>



<a name="210710708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/210710708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#210710708">(Sep 21 2020 at 07:56)</a>:</h4>
<p>(deleted)</p>



<a name="210710746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/210710746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#210710746">(Sep 21 2020 at 07:57)</a>:</h4>
<p>(deleted)</p>



<a name="210710989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/210710989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#210710989">(Sep 21 2020 at 08:00)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> What Bhavik posted works for me. <code>finset.min'_lt_max'_of_card</code> was changed 15 days ago (<a href="https://github.com/leanprover-community/mathlib/issues/4020">#4020</a>), so maybe you need to update mathlib?</p>



<a name="210711120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/210711120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#210711120">(Sep 21 2020 at 08:03)</a>:</h4>
<p>(Scratch what I said.  I wasn't paying attention to what was going on.)</p>



<a name="210722491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/sets%20with%20two%20elements/near/210722491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/sets.20with.20two.20elements.html#210722491">(Sep 21 2020 at 10:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="266440">Shing Tak Lam</span> <a href="#narrow/stream/113489-new-members/topic/sets.20with.20two.20elements/near/210710989">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> What Bhavik posted works for me. <code>finset.min'_lt_max'_of_card</code> was changed 15 days ago (<a href="https://github.com/leanprover-community/mathlib/issues/4020">#4020</a>), so maybe you need to update mathlib?</p>
</blockquote>
<p>Thanks: after downloading the new version of mathlib, it works!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
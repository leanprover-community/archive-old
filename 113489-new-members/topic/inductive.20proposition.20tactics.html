---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/inductive.20proposition.20tactics.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html">inductive proposition tactics</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="200186449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200186449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200186449">(Jun 09 2020 at 06:40)</a>:</h4>
<p>Is there a tactic for proving inductively defined propositions, where the right constructor to apply is always obvious because they're all mutually exclusive in their conclusions? I find myself having to apply many constructors of the inductive proposition, all of which terminate to some atomic constructor, or can be solved with <code>assumption</code>.</p>



<a name="200186533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200186533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200186533">(Jun 09 2020 at 06:42)</a>:</h4>
<p>Is <code>tauto</code> of any use?</p>



<a name="200186536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200186536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200186536">(Jun 09 2020 at 06:42)</a>:</h4>
<p>It uses <code>solve_by_elim</code></p>



<a name="200186811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200186811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200186811">(Jun 09 2020 at 06:48)</a>:</h4>
<p>That sounds like <code>constructor</code></p>



<a name="200186832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200186832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200186832">(Jun 09 2020 at 06:49)</a>:</h4>
<p>which is basically the same as <code>apply T.constr1 &lt;|&gt; apply T.constr2 &lt;|&gt;  ...</code></p>



<a name="200188035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200188035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200188035">(Jun 09 2020 at 07:10)</a>:</h4>
<p><code>tauto</code> didn't work, and <code>constructor</code> works as expected for 1 step, so I did <code>repeat {constructor}</code> and that solved it - but this will only work if the proposition reduces to atomic constructors, not if one of the goals produced is part of the context (for which <code>assumption</code> would work). I'm guessing I could do something like <code>repeat {constructor &lt;|&gt; assumption}</code> - but is that the cleanest way to proceed?</p>
<p>Here's a contrived example to illustrate this</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">Unit</span> <span class="err">⁎</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊥</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">n</span><span class="o">}</span>     <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">[]</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">[]</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">[]</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
  <span class="n">assumption</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200188422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200188422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200188422">(Jun 09 2020 at 07:15)</a>:</h4>
<p>Does <code>tidy</code> do it for you?</p>



<a name="200188698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200188698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200188698">(Jun 09 2020 at 07:19)</a>:</h4>
<p>Nope, no progress</p>



<a name="200189837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200189837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200189837">(Jun 09 2020 at 07:34)</a>:</h4>
<p>it seems you have a proof already. Do you have a better example?</p>



<a name="200190069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200190069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200190069">(Jun 09 2020 at 07:37)</a>:</h4>
<p>also that's not an <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="200190138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200190138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200190138">(Jun 09 2020 at 07:38)</a>:</h4>
<p>probably <code>constructor; assumption</code> will work on this and similar goals</p>



<a name="200190169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200190169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200190169">(Jun 09 2020 at 07:39)</a>:</h4>
<p>so something like <code>induction h; constructor; assumption</code> will take care of most of your theorem</p>



<a name="200190183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200190183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200190183">(Jun 09 2020 at 07:39)</a>:</h4>
<p><span class="user-mention" data-user-id="255481">@Billy Price</span></p>



<a name="200198768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200198768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200198768">(Jun 09 2020 at 09:14)</a>:</h4>
<p>Here's an example of how this problem blows up, which is only half done because of the definition of <code>biimp</code>. Essentially I want a tactic which will do as much of this as it can by itself, and then leave me with the non-trivial goals (in this case those can be solved by <code>assumption</code> - but I can imagine more general usage where I'd need to do more work).</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">tidy</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">tauto</span>

<span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Unit</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="n">def</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Unit</span>
<span class="kn">infix</span> <span class="bp">`××`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">𝒫</span><span class="bp">`</span><span class="n">A</span> <span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span> <span class="n">A</span>

<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="c1">-- Notation and derived operators</span>
<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟘</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">0</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">1</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟚</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">2</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟛</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">3</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟜</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">4</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟝</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="mi">5</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⁎</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">star</span>    <span class="c1">-- input \asterisk</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊤</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span>     <span class="c1">--       \top</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊥</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span>     <span class="c1">-- input \bot</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">imp</span> <span class="c1">-- input \==&gt;</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋀</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">and</span> <span class="c1">-- input \And or \bigwedge</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⋁</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">59</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">or</span>  <span class="c1">-- input \Or or \bigvee</span>


<span class="n">def</span> <span class="n">biimp</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span><span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">⋀</span> <span class="o">(</span><span class="n">q</span> <span class="err">⟹</span> <span class="n">p</span><span class="o">)</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⇔</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">biimp</span> <span class="c1">-- input \&lt;=&gt;</span>

<span class="kn">infix</span> <span class="err">∈</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">elem</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟦</span><span class="bp">`</span> <span class="n">φ</span> <span class="bp">`</span><span class="err">⟧</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">comp</span> <span class="n">φ</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">⟪</span><span class="bp">`</span> <span class="n">a</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span><span class="err">⟫</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">pair</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">prefix</span> <span class="bp">`∀</span><span class="err">&#39;</span><span class="bp">`</span><span class="o">:</span><span class="mi">1</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">all</span>
<span class="kn">prefix</span> <span class="bp">`∃</span><span class="err">&#39;</span><span class="bp">`</span><span class="o">:</span><span class="mi">2</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">.</span><span class="n">ex</span>

<span class="n">def</span> <span class="n">lib_eq</span> <span class="o">(</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span> <span class="bp">∀</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">a₁</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">(</span><span class="n">a₂</span> <span class="err">∈</span> <span class="mi">𝟘</span><span class="o">)</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">≃</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">lib_eq</span>


<span class="c1">-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="kn">open</span> <span class="n">term</span>



<span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">Unit</span> <span class="err">⁎</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊤</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span>         <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="err">⊥</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⋁</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pair</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">B</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span> <span class="err">⟪</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="err">⟫</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">n</span><span class="o">}</span>     <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth</span> <span class="err">Γ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="err">⟦</span><span class="n">φ</span><span class="err">⟧</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">φ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">φ</span><span class="o">)</span>

<span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="n">term</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">[</span><span class="n">Unit</span><span class="o">,</span><span class="err">Ω</span><span class="o">]</span> <span class="err">Ω</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">WF</span> <span class="o">[</span><span class="n">Unit</span><span class="o">,</span><span class="err">Ω</span><span class="o">]</span> <span class="err">Ω</span> <span class="n">q</span>  <span class="bp">→</span> <span class="n">WF</span> <span class="o">[</span><span class="n">Unit</span><span class="o">,</span><span class="err">Ω</span><span class="o">]</span> <span class="err">Ω</span> <span class="n">r</span>  <span class="bp">→</span> <span class="n">WF</span> <span class="o">[</span><span class="n">Unit</span><span class="o">,</span><span class="err">Ω</span><span class="o">]</span> <span class="err">Ω</span> <span class="o">((</span><span class="n">p</span> <span class="err">⋀</span> <span class="mi">𝟙</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">((</span><span class="n">q</span> <span class="err">⋀</span> <span class="n">r</span> <span class="err">⋀</span> <span class="mi">𝟙</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">((</span><span class="err">⁎</span> <span class="err">≃</span> <span class="mi">𝟙</span><span class="o">)</span> <span class="err">⋀</span> <span class="n">p</span><span class="o">)))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200199029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200199029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200199029">(Jun 09 2020 at 09:17)</a>:</h4>
<p>Btw some of my Unicode notation is non-obvious. I'm using <code>\And, \Or, \==&gt;, \&lt;=&gt;,  \asterisk</code> to name a few relevant ones. Also the numbers are <code>\b0, \b1, \b2,</code> etc.</p>



<a name="200199533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200199533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200199533">(Jun 09 2020 at 09:22)</a>:</h4>
<p>Off topic, but your <code>WF.all</code> rule looks wrong. The argument <code>A</code> is not fixed by application, so you are allowed to assume any type for it</p>



<a name="200199698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200199698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200199698">(Jun 09 2020 at 09:25)</a>:</h4>
<p>Your definition of <code>lib_eq</code> is also wrong, you have to lift <code>a1</code> and <code>a2</code></p>



<a name="200199881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200199881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200199881">(Jun 09 2020 at 09:27)</a>:</h4>
<p>the theorem itself is false, because <code>⁎ ≃ 𝟙</code> isn't well typed</p>



<a name="200199996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200199996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200199996">(Jun 09 2020 at 09:28)</a>:</h4>
<p>Modulo those things, this proof works:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">WF</span><span class="bp">.</span><span class="n">biimp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">p</span> <span class="n">q</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">p</span> <span class="err">⇔</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">WF</span><span class="bp">.</span><span class="n">and</span> <span class="o">(</span><span class="n">WF</span><span class="bp">.</span><span class="n">imp</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)</span> <span class="o">(</span><span class="n">WF</span><span class="bp">.</span><span class="n">imp</span> <span class="n">h2</span> <span class="n">h1</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">WF</span><span class="bp">.</span><span class="n">lib_eq</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">A</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="o">(</span><span class="n">a</span> <span class="err">≃</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">[</span><span class="n">Unit</span><span class="o">,</span><span class="err">Ω</span><span class="o">]</span> <span class="err">Ω</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">[</span><span class="n">Unit</span><span class="o">,</span><span class="err">Ω</span><span class="o">]</span> <span class="err">Ω</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">[</span><span class="n">Unit</span><span class="o">,</span><span class="err">Ω</span><span class="o">]</span> <span class="err">Ω</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">WF</span> <span class="o">[</span><span class="n">Unit</span><span class="o">,</span><span class="err">Ω</span><span class="o">]</span> <span class="err">Ω</span> <span class="o">((</span><span class="n">p</span> <span class="err">⋀</span> <span class="mi">𝟙</span><span class="o">)</span> <span class="err">⇔</span> <span class="o">((</span><span class="n">q</span> <span class="err">⋀</span> <span class="n">r</span> <span class="err">⋀</span> <span class="mi">𝟙</span><span class="o">)</span> <span class="err">⟹</span> <span class="o">((</span><span class="err">⁎</span> <span class="err">≃</span> <span class="mi">𝟘</span><span class="o">)</span> <span class="err">⋀</span> <span class="n">p</span><span class="o">)))</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">apply_rules</span> <span class="o">[</span><span class="n">WF</span><span class="bp">.</span><span class="n">biimp</span><span class="o">,</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span><span class="o">,</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span><span class="o">,</span> <span class="n">WF</span><span class="bp">.</span><span class="n">lib_eq</span><span class="o">,</span> <span class="n">WF</span><span class="bp">.</span><span class="n">star</span><span class="o">,</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>
</code></pre></div>



<a name="200200450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200200450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200200450">(Jun 09 2020 at 09:33)</a>:</h4>
<p>Hm, the proof works without <code>WF.biimp</code> in the list, but it is twice as long. I think there should be a reducibility setting in <code>apply_rules</code> so that it doesn't go unfold-happy</p>



<a name="200200472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200200472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200200472">(Jun 09 2020 at 09:33)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">irreducible</span><span class="o">]</span> <span class="n">biimp</span>
</code></pre></div>


<p>works, of course</p>



<a name="200200493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200200493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200200493">(Jun 09 2020 at 09:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/inductive.20proposition.20tactics/near/200199533">said</a>:</p>
<blockquote>
<p>Off topic, but your <code>WF.all</code> rule looks wrong. The argument <code>A</code> is not fixed by application, so you are allowed to assume any type for it</p>
</blockquote>
<p>Isn't it fixed by the hypothesis that <code>\phi</code> is well-formed in the context with <code>A</code> put at the start?</p>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/inductive.20proposition.20tactics/near/200199698">said</a>:</p>
<blockquote>
<p>Your definition of <code>lib_eq</code> is also wrong, you have to lift <code>a1</code> and <code>a2</code></p>
</blockquote>
<p>Good point, didn't think about lifting it here, I was just making do by manually lifting the variables, which is why I wrote <code>⁎ ≃ 𝟙</code>, instead of <code>⁎ ≃ 𝟘</code> - isn't that well formed?</p>



<a name="200200762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200200762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200200762">(Jun 09 2020 at 09:36)</a>:</h4>
<blockquote>
<p>Isn't it fixed by the hypothesis that \phi is well-formed in the context with A put at the start?</p>
</blockquote>
<p>The problem is that the term doesn't record what <code>A</code> is, so you can have multiple types for one term. It's not exactly broken, I think they call this "implicit typing" and it was used by Curry I think for lambda terms, but in the modern tradition the terms carry enough typing information so that the context uniquely determines the type of the expression</p>



<a name="200200851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200200851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200200851">(Jun 09 2020 at 09:37)</a>:</h4>
<blockquote>
<p>Good point, didn't think about lifting it here, I was just making do by manually lifting the variables, which is why I wrote ⁎ ≃ 𝟙, instead of ⁎ ≃ 𝟘 - isn't that well formed?</p>
</blockquote>
<p>Oh I see, you made = a binder. Well that's one way to solve the problem <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="200201298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200201298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200201298">(Jun 09 2020 at 09:42)</a>:</h4>
<p>Can you explain the role of the semicolon? I was under the impression it's just a new-line-separator, but it seems that there's a lot of cleanup done after apply_rules, whereas if I do this in tactic mode, I have 20 goals to apply <code>refl</code> to.</p>



<a name="200201319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200201319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200201319">(Jun 09 2020 at 09:42)</a>:</h4>
<p>semicolon means "apply next tactic to all goals generated by this tactic"</p>



<a name="200201329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200201329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200201329">(Jun 09 2020 at 09:42)</a>:</h4>
<p>As an example of the bad behavior of implicit typing here, <code>∃' ∀' (𝟘 ≃ 𝟙)</code> (or with your binding equals operator, <code>∃' ∀' (𝟙 ≃ 𝟚)</code>) is well typed of type <code>Ω</code> but assuming that you can prove that <code>Unit</code> is a singleton and <code>𝒫 Unit</code> is not, this term is both provably true and provably false and hence the system is inconsistent</p>



<a name="200201457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200201457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200201457">(Jun 09 2020 at 09:44)</a>:</h4>
<p>The problem is that the term is vague about what type is being asserted to be a singleton</p>



<a name="200201508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200201508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200201508">(Jun 09 2020 at 09:45)</a>:</h4>
<p>There are only 3 goals produced by <code>apply_rules</code> in my test, which are kicked back from the <code>var</code> rule</p>



<a name="200201572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200201572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200201572">(Jun 09 2020 at 09:46)</a>:</h4>
<p>a less golfed version is</p>
<div class="codehilite"><pre><span></span><code><span class="k">begin</span>
  <span class="n">apply_rules</span> <span class="o">[</span><span class="n">WF</span><span class="bp">.</span><span class="n">biimp</span><span class="o">,</span> <span class="n">WF</span><span class="bp">.</span><span class="n">and</span><span class="o">,</span> <span class="n">WF</span><span class="bp">.</span><span class="n">imp</span><span class="o">,</span> <span class="n">WF</span><span class="bp">.</span><span class="n">lib_eq</span><span class="o">,</span> <span class="n">WF</span><span class="bp">.</span><span class="n">star</span><span class="o">,</span> <span class="n">WF</span><span class="bp">.</span><span class="n">var</span><span class="o">],</span>
  <span class="n">all_goals</span> <span class="o">{</span><span class="n">refl</span><span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200201780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200201780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200201780">(Jun 09 2020 at 09:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/inductive.20proposition.20tactics/near/200201329">said</a>:</p>
<blockquote>
<p>As an example of the bad behavior of implicit typing here, <code>∃' ∀' (𝟘 ≃ 𝟙)</code> (or with your binding equals operator, <code>∃' ∀' (𝟙 ≃ 𝟚)</code>) is well typed of type <code>Ω</code> but assuming that you can prove that <code>Unit</code> is a singleton and <code>𝒫 Unit</code> is not, this term is both provably true and provably false and hence the system is inconsistent</p>
</blockquote>
<p>Thanks for that explanation, I forget when or why I dropped the type parameter from term.all and term.ex. Thanks for pointing that out</p>



<a name="200201852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200201852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200201852">(Jun 09 2020 at 09:49)</a>:</h4>
<p>I recall you had a lot more types before (on things like application) and I think I pointed out that they were not necessary</p>



<a name="200201913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200201913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200201913">(Jun 09 2020 at 09:49)</a>:</h4>
<p>The place where you need types are when you are introducing a new type variable that can't be inferred from the arguments</p>



<a name="200201918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200201918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200201918">(Jun 09 2020 at 09:50)</a>:</h4>
<p>Yeah I must have taken that too far haha</p>



<a name="200202090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200202090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200202090">(Jun 09 2020 at 09:51)</a>:</h4>
<p>R.e. apply_rules, can I be lazy with it and tell it to try all of the rules? Like everything starting with <code>WF.</code>?</p>



<a name="200202272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200202272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200202272">(Jun 09 2020 at 09:53)</a>:</h4>
<p>I think there is a way to make sets of rules for it</p>



<a name="200202352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200202352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200202352">(Jun 09 2020 at 09:54)</a>:</h4>
<p>the <code>apply_rules</code> documentation has an example</p>



<a name="200202473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200202473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200202473">(Jun 09 2020 at 09:55)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#apply_rules">tactic#apply_rules</a></p>



<a name="200202481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200202481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200202481">(Jun 09 2020 at 09:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/inductive.20proposition.20tactics/near/200201913">said</a>:</p>
<blockquote>
<p>The place where you need types are when you are introducing a new type variable that can't be inferred from the arguments</p>
</blockquote>
<p>Does this mean that <code>term.comp</code> doesn't need an explicit type parameter, because the WF constructor<code> | comp {Γ A φ}     : WF (A::Γ) Ω φ → WF Γ (𝒫 A) term.comp φ</code> tells you the type of the variable free in phi?</p>



<a name="200202768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200202768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200202768">(Jun 09 2020 at 09:58)</a>:</h4>
<p>To be honest I don't quite understand what exact kind of situation you are referring to in "when you are introducing a new type variable". Is this strictly just when defining WF?</p>



<a name="200202900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200202900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200202900">(Jun 09 2020 at 09:59)</a>:</h4>
<p>No, I think <code>comp</code> needs a type</p>



<a name="200203032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200203032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200203032">(Jun 09 2020 at 10:00)</a>:</h4>
<p>An easy rule is anything with a binder (where the hypothesis to the <code>WF</code> rule has an extended context) needs a type</p>



<a name="200203108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200203108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200203108">(Jun 09 2020 at 10:01)</a>:</h4>
<p>The general form of the claim would be that any term <code>p</code> has at most one type given a context <code>Gamma</code></p>



<a name="200203138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200203138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200203138">(Jun 09 2020 at 10:01)</a>:</h4>
<p>and I think you can even claim at most one type derivation</p>



<a name="200203389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200203389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200203389">(Jun 09 2020 at 10:04)</a>:</h4>
<p>That's very eye opening thank you. I was just here thinking "my terms seem so freely defined - but my proof constraints are enough to allow you to only prove true statements when you choose appropriate types for each term"</p>



<a name="200203443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200203443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200203443">(Jun 09 2020 at 10:05)</a>:</h4>
<p>If I have more related questions I'll continue them back in my usual channel/topic. I just thought my original question was general enough.</p>



<a name="200203472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200203472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200203472">(Jun 09 2020 at 10:05)</a>:</h4>
<p>the problem is that the terms are responsible for carrying type assignments from one line of proof to the next, so if they are too free then you can interpret the same term in two incompatible ways during the same proof</p>



<a name="200203537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/200203537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#200203537">(Jun 09 2020 at 10:06)</a>:</h4>
<p>proofs are irrelevant but terms aren't</p>



<a name="204069666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/inductive%20proposition%20tactics/near/204069666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/inductive.20proposition.20tactics.html#204069666">(Jul 16 2020 at 11:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  I've just noticed that my <code>elem : term -&gt; term -&gt; term</code> constructor doesn't have a <code>type</code> in the contstructor. It's <code>WF</code> rule does not extend the context, yet a term like <code>0 \in 1</code> doesn't tell me the types of 0 or 1 (though I can't think of an example term that's true with one type and false with another). Why is this different?</p>
<p>I noticed this because for all other term constructors I have a corresponding lemma which extracts a well-formedness proof of each argument, but I can't write one that does <code>WF Γ Ω (a∈α) → WF Γ A a</code>, because I can't presume to know <code>A</code>. This tempts me to add a type to the elem constructor - but is there a reason I shouldn't?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
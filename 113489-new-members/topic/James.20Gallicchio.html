---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/James.20Gallicchio.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html">James Gallicchio</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="239334763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239334763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239334763">(May 18 2021 at 22:20)</a>:</h4>
<p>Hi everybody! I'm a CS student at Carnegie Mellon, interested in formal verification and programming languages generally :)</p>
<p>I've been writing a formalization of super basic register machines in Lean to learn the language. Starting to get to the point in that project where I should probably reach out here for help... so here I am!</p>



<a name="239896428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239896428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239896428">(May 22 2021 at 19:59)</a>:</h4>
<p>Hm, so I've written a lemma which takes a couple values<br>
<code>{ip : fin ic} {regs : vector ℕ rc}</code><br>
and then is stated in terms of the object<br>
<code>{ip := some ip, regs := regs} : state ic rc</code><br>
(note the <code>some ip</code> rather than <code>ip</code>)</p>
<p>When trying to use this lemma, I have an expression <code>step M c.s : state ic rc</code> and a hypothesis that <code>(step M c.s).ip = some ip</code>; how would I then apply the lemma?</p>



<a name="239896521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239896521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239896521">(May 22 2021 at 20:00)</a>:</h4>
<p>(if this seems to indicate a fundamental issue with how I'm representing the problem, that'd also be appreciated, haha! not sure if the issue is with how I wrote out the hypotheses of the lemma or the application of the lemma or with the representation altogether)</p>



<a name="239896683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239896683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239896683">(May 22 2021 at 20:03)</a>:</h4>
<p>Can you share a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> ?</p>



<a name="239897455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239897455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239897455">(May 22 2021 at 20:17)</a>:</h4>
<p><a href="https://gist.github.com/JamesGallicchio/87e40a3fbd0b4c7ab3c1063f558517ad">https://gist.github.com/JamesGallicchio/87e40a3fbd0b4c7ab3c1063f558517ad</a> something like this -- I know in this mwe I can just use the definition of <code>pred_a</code>, but suppose the lemma is much less trivial than this and I want to use the lemma here instead</p>



<a name="239897506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239897506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239897506">(May 22 2021 at 20:18)</a>:</h4>
<p>For the full context not mwe, this is the <code>sorry</code> I'm trying to fill<br>
<a href="https://github.com/JamesGallicchio/lean_rms/blob/master/src/register_machine.lean#L229">https://github.com/JamesGallicchio/lean_rms/blob/master/src/register_machine.lean#L229</a></p>



<a name="239897533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239897533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239897533">(May 22 2021 at 20:19)</a>:</h4>
<p>oh, wait, in that mwe a simple rewrite works for applying the lemma</p>



<a name="239916866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239916866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239916866">(May 23 2021 at 02:22)</a>:</h4>
<p>(<a href="https://leanprover-community.github.io/mwe.html">#mwe</a>'s that fit inside a code block here are way more likely to get help; also the process of minimising often reveals the solution!)</p>



<a name="239928934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239928934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239928934">(May 23 2021 at 06:33)</a>:</h4>
<p>Okay, I reorganized a bunch and think I have a better MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">mystruct</span> <span class="o">:=</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">theorem</span> <span class="n">mytheorem</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">mystruct</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="o">{</span><span class="n">a</span> <span class="o">:=</span> <span class="n">s.a</span><span class="o">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">s.b</span><span class="o">}</span>
  <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>Not sure how to fill this sorry..?</p>



<a name="239929360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239929360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239929360">(May 23 2021 at 06:41)</a>:</h4>
<p>Wait, cases splits up the structure into its projections? <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> cases seems to do so much (I tried it randomly!)</p>



<a name="239933518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239933518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239933518">(May 23 2021 at 08:04)</a>:</h4>
<p><code>by cases s; refl</code></p>



<a name="239966375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239966375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239966375">(May 23 2021 at 17:37)</a>:</h4>
<p>So the reason cases works there is because structures are just inductive types with a single constructor; cases makes a case for that one constructor and introduces all the arguments. Right?</p>



<a name="239987399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239987399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239987399">(May 23 2021 at 23:58)</a>:</h4>
<p>Hm, how do you prove to the typechecker that certain types are equivalent?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">test</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">ℕ</span> <span class="n">ic</span> <span class="o">:=</span> <span class="n">vector.of_fn</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">thing</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">ℕ</span> <span class="o">(</span><span class="mi">1</span><span class="bp">+</span><span class="n">ic</span><span class="o">)</span> <span class="o">:=</span> <span class="n">vector.append</span> <span class="o">⟨[</span><span class="mi">0</span><span class="o">],</span><span class="n">rfl</span><span class="o">⟩</span> <span class="n">test</span>
</code></pre></div>
<p>Say I wanted <code>thing : vector ℕ ic.succ</code> instead.</p>



<a name="239987416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239987416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239987416">(May 23 2021 at 23:59)</a>:</h4>
<p>I'm sure this has to do with my fundamentally not understanding how equality works in Lean, so any resources/pointers there would be super appreciated!</p>



<a name="239987686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239987686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239987686">(May 24 2021 at 00:03)</a>:</h4>
<p>(Starting off by reading the equality section of TPIL, hopefully my answer lies in there...)</p>



<a name="239987841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239987841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239987841">(May 24 2021 at 00:05)</a>:</h4>
<p>To prove two types are equivalent, you need to provide an explicit iso between them. To start, here is an example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.vector2</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">ic</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">test</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">ℕ</span> <span class="n">ic</span> <span class="o">:=</span> <span class="n">vector.of_fn</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">thing</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">ℕ</span> <span class="o">(</span><span class="mi">1</span><span class="bp">+</span><span class="n">ic</span><span class="o">)</span> <span class="o">:=</span> <span class="n">vector.append</span> <span class="o">⟨[</span><span class="mi">0</span><span class="o">],</span><span class="n">rfl</span><span class="o">⟩</span> <span class="o">(</span><span class="n">test</span> <span class="n">ic</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">thing2</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">nat</span> <span class="n">ic.succ</span> <span class="o">:=</span> <span class="n">cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">add_comm</span><span class="o">)</span> <span class="o">(</span><span class="n">thing</span> <span class="n">ic</span><span class="o">)</span>
</code></pre></div>



<a name="239988037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239988037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239988037">(May 24 2021 at 00:08)</a>:</h4>
<p>In fact, you can use <code>equiv.cast</code> to get the iso</p>



<a name="239988055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239988055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239988055">(May 24 2021 at 00:09)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">thing3</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">nat</span> <span class="n">ic.succ</span> <span class="o">:=</span> <span class="n">equiv.cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">add_comm</span><span class="o">)</span> <span class="o">(</span><span class="n">thing</span> <span class="n">ic</span><span class="o">)</span>
</code></pre></div>



<a name="239988362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239988362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239988362">(May 24 2021 at 00:14)</a>:</h4>
<p>Ahh, cast is exactly what I needed. Thank you!</p>



<a name="239988492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239988492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239988492">(May 24 2021 at 00:16)</a>:</h4>
<p>But careful, it is difficult to make proofs about structures/terms that have been constructured through complex <code>cast</code> manipulation</p>



<a name="239989733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239989733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239989733">(May 24 2021 at 00:39)</a>:</h4>
<p>Hm... so my goal should be to avoid whenever possible?</p>



<a name="239997958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/239997958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#239997958">(May 24 2021 at 03:04)</a>:</h4>
<p>In what contexts do you need to modify types likes this? It's fine to do so if you know what you're striving for. What's your use case?</p>



<a name="240741232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240741232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240741232">(May 30 2021 at 06:27)</a>:</h4>
<p>Ended up rewriting a bunch of stuff to work around casts (so far <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span>)</p>



<a name="240741283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240741283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240741283">(May 30 2021 at 06:28)</a>:</h4>
<p>It was a good indication that something in my design wasn't great. Hopefully we're out of the swamp there</p>



<a name="240741387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240741387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240741387">(May 30 2021 at 06:31)</a>:</h4>
<p>But now I am stuck wondering how this definition works:<br>
<a href="https://leanprover-community.github.io/mathlib_docs/computability/primrec.html#primcodable">https://leanprover-community.github.io/mathlib_docs/computability/primrec.html#primcodable</a><br>
In my head, the <code>prim</code> type shouldn't typecheck.<br>
<code>encodable.decode α n : option ℕ</code>, but <code>encodable.encode : ℕ → ℕ</code>... how the heck?</p>



<a name="240744988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240744988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240744988">(May 30 2021 at 08:16)</a>:</h4>
<p>It's playing a bit of a trick. The type of <code>encodable.encode</code> isn't <code>ℕ → ℕ</code>, it's <code>α → ℕ</code> (for all encodable <code>α</code>), and there is an instance saying <code>option α</code> is encodable if <code>α</code> is, so it is using the <code>decode</code> instance for <code>α</code> and applying the <code>encode</code> instance for <code>option α</code> to the result.</p>



<a name="240782016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240782016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240782016">(May 31 2021 at 00:52)</a>:</h4>
<p>Ahh, that makes sense</p>



<a name="240846371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240846371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240846371">(May 31 2021 at 15:30)</a>:</h4>
<p>I guess I have a bit of a general question about choosing representations -- in doing some indexing trickery, I'm struggling to pick between representing a certain index as <code>fin n.succ</code> or <code>option (fin n)</code>, where <code>none</code> would correspond with <code>fin.last n</code></p>
<p>Sometimes the <code>fin n.succ</code> representation is super elegant, but other times it's easier to just case on an <code>option (fin n)</code>... is there an easy way to case on whether <code>i : fin n.succ</code> is <code>fin.last n</code> or else equals <code>i' : fin n</code>?</p>
<p>(If not, I'm gonna go with the <code>option (fin n)</code> one since it's pretty straightforward going to the <code>fin n.succ</code> representation from there)</p>



<a name="240849172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240849172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240849172">(May 31 2021 at 15:59)</a>:</h4>
<p><code>option (fin n)</code> is good, but I think the vector methods like <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.cons">docs#fin.cons</a> will work best (and yes, this appends at 0 instead of at <code>n</code>: this is honestly <em>so much easier</em> to work with in Lean)</p>



<a name="240849264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240849264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240849264">(May 31 2021 at 16:00)</a>:</h4>
<p>if you wanna append at the end, there's <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.snoc">docs#fin.snoc</a> (<code>cons</code> backwards). i would <strong>strongly advise</strong> you to avoid this unless it's needed</p>



<a name="240851914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240851914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240851914">(May 31 2021 at 16:31)</a>:</h4>
<p>hmm, yeah. Lean _really_ doesn't like working at the end of the range. gonna just go with <code>option (fin n)</code></p>



<a name="240851923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240851923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240851923">(May 31 2021 at 16:31)</a>:</h4>
<p>There are also <a href="https://leanprover-community.github.io/mathlib_docs/find/fin_succ_equiv">docs#fin_succ_equiv</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/fin_succ_equiv'">docs#fin_succ_equiv'</a> to easily convert between the two options you said</p>



<a name="240852051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240852051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240852051">(May 31 2021 at 16:33)</a>:</h4>
<p>Where <code>fin_succ_equiv</code> sends <code>0</code> to <code>none</code>, and the <code>fin_succ_equiv'</code> version lets you specify the "hole" explicitly.</p>



<a name="240852085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240852085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240852085">(May 31 2021 at 16:33)</a>:</h4>
<p>I was looking through the fin-tuple stuff -- is there a reason why both the fin tuples are defined and <code>vector</code>? Or rather where should I prefer one over the other? I just used <code>vector</code> cuz it was what I found first</p>



<a name="240852175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240852175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240852175">(May 31 2021 at 16:34)</a>:</h4>
<p>Depends on your use case. Of course, there are explicit equivs between all of these. But the API is different, and there might be different computability aspects</p>



<a name="240852343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240852343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240852343">(May 31 2021 at 16:36)</a>:</h4>
<p><code>vector</code> has treated me well so far, so I'll stick with it <span aria-label="thumbs up" class="emoji emoji-1f44d" role="img" title="thumbs up">:thumbs_up:</span> I did need a couple more quick vector lemmas that aren't in mathlib yet, but I assume the lemmas accumulate from people finding new use cases :-)</p>



<a name="240853039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240853039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240853039">(May 31 2021 at 16:45)</a>:</h4>
<p>fin tuples are generally easier to use for mathematics and have a better API</p>



<a name="240870713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240870713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240870713">(May 31 2021 at 21:00)</a>:</h4>
<p>fin tuples can be heterogeneous as well, IIRC</p>



<a name="240880873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240880873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240880873">(Jun 01 2021 at 00:05)</a>:</h4>
<p>Yeah; I kinda assumed that vectors would just have a better API for homogeneous tuples but maybe not <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> I'm gonna ask for feedback on my code once it's in a better state and maybe then I'll review whether I chose the wrong API :p</p>



<a name="240881201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240881201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240881201">(Jun 01 2021 at 00:11)</a>:</h4>
<p>(I'm mostly just using the <code>nth</code> and <code>update_nth</code> functions, along with lemmas like <a href="https://leanprover-community.github.io/mathlib_docs/data/vector2.html#vector.nth_update_nth_same"><code>vector.nth_update_nth_same</code></a>. not sure how i'd do that with the fin tuples)</p>



<a name="240888505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/240888505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#240888505">(Jun 01 2021 at 02:31)</a>:</h4>
<p>You could use <a href="https://leanprover-community.github.io/mathlib_docs/find/function.update">docs#function.update</a>, with help from lemmas like <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.cons_update">docs#fin.cons_update</a></p>



<a name="245410984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245410984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245410984">(Jul 09 2021 at 07:43)</a>:</h4>
<p>Hi, back to working on this project :) is it at all possible to do something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">match</span> <span class="n">i</span> <span class="k">with</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="kd">end</span>
</code></pre></div>
<p>for <code>i : fin 2</code> or similar? I see the <code>fin2</code> type which might be helpful here since it's defined inductively?</p>



<a name="245411276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245411276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245411276">(Jul 09 2021 at 07:47)</a>:</h4>
<p>Yes, but with <code>⟨0, _⟩</code> instead of <code>0</code> etc</p>



<a name="245411373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245411373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245411373">(Jul 09 2021 at 07:48)</a>:</h4>
<p>Although often <code>![..., ...]</code> is a better way to define such a function</p>



<a name="245411520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245411520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245411520">(Jul 09 2021 at 07:50)</a>:</h4>
<p>hm,  is that <code>![]</code> syntax behind some import?</p>



<a name="245411575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245411575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245411575">(Jul 09 2021 at 07:51)</a>:</h4>
<p>The exhaustiveness checker does not like <code>⟨0, _⟩</code> :/ I assume I'd need to have an extra case like <code>⟨n,h⟩</code> that derives bottom or something if I wanted the compiler to not complain</p>



<a name="245411754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245411754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245411754">(Jul 09 2021 at 07:53)</a>:</h4>
<p>Notation is here: <a href="https://leanprover-community.github.io/mathlib_docs/data/matrix/notation.html">https://leanprover-community.github.io/mathlib_docs/data/matrix/notation.html</a></p>



<a name="245411941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245411941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245411941">(Jul 09 2021 at 07:56)</a>:</h4>
<p>Oh, huh! Yeah, this could work. I'm a bit sad that the pattern match doesn't directly work, because in this context it actually is much more readable if each item is numbered...</p>



<a name="245437358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245437358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245437358">(Jul 09 2021 at 12:42)</a>:</h4>
<p>I think Anne did add support for the equation compiler to do what you'd like here, via wf recursion</p>



<a name="245437517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245437517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245437517">(Jul 09 2021 at 12:44)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fin.has_well_founded">docs#fin.has_well_founded</a>. So it's like what Eric said</p>



<a name="245439750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245439750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245439750">(Jul 09 2021 at 13:04)</a>:</h4>
<p>That instance is only needed if you actually need to recurse. If you're just case matching the equation compiler doesn't need it</p>



<a name="245473407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245473407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245473407">(Jul 09 2021 at 17:35)</a>:</h4>
<p><span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">1</span><span class="o">),</span> <span class="k">match</span> <span class="n">i</span> <span class="k">with</span>
<span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">instr.dec</span> <span class="o">(</span><span class="n">r_map</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">ai_map</span> <span class="mi">0</span><span class="o">))</span> <span class="n">none</span>
<span class="kd">end</span>
</code></pre></div>
<p>The compiler complains about missing the case</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rst._match_1</span> <span class="n">r</span> <span class="n">_x</span> <span class="n">_x_1</span> <span class="n">r_map</span> <span class="n">ai_map</span> <span class="o">⟨</span><span class="n">nat.succ</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span>
</code></pre></div>
<p>which is the absurd case. I can get around it by adding</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">1</span><span class="o">),</span> <span class="k">match</span> <span class="n">i</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">instr.dec</span> <span class="o">(</span><span class="n">r_map</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">ai_map</span> <span class="mi">0</span><span class="o">))</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span><span class="n">hi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hi.rec_on</span> <span class="n">_</span> <span class="kd">end</span>
<span class="kd">end</span><span class="o">)</span>
</code></pre></div>
<p>(not sure if there's a more canonical way to use absurdity)<br>
This is a bit unsatisfying though, and also won't be very practical if the case is <code>n.succ.succ.succ.succ.succ.succ</code> unless there's a better way to do it in that case.</p>



<a name="245473464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245473464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245473464">(Jul 09 2021 at 17:36)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mwe.html">#mwe</a> is always a good idea :-)</p>



<a name="245473545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245473545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245473545">(Jul 09 2021 at 17:36)</a>:</h4>
<p>ah, ye, I can strip this down, gimme a sec</p>



<a name="245473580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245473580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245473580">(Jul 09 2021 at 17:37)</a>:</h4>
<p>We're hoping you can just give us something which compiles for us :-) (but in general your strategy of using false.elim for the cases which can't happen is the correct one, if you can't persuade the equation compiler to do it for you)</p>



<a name="245473859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245473859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245473859">(Jul 09 2021 at 17:39)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mwe</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">string</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">match</span> <span class="n">i</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"zero!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"one!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">2</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"two!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">3</span><span class="o">,</span><span class="n">hi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="c">/-</span><span class="cm"> some way to absurdity -/</span>
<span class="kd">end</span>
</code></pre></div>
<p>This doesn't quite compile, but gives the idea</p>



<a name="245474509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245474509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245474509">(Jul 09 2021 at 17:45)</a>:</h4>
<p>You can use <code>sorry</code> to make it compile. Using the <code>rcases?</code> tactic you can prove it like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">mwe</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">string</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">match</span> <span class="n">i</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"zero!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"one!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">2</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"two!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">3</span><span class="o">,</span><span class="n">hi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">false.elim</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rcases</span> <span class="n">hi</span> <span class="k">with</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨⟩⟩⟩)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="245475497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245475497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245475497">(Jul 09 2021 at 17:51)</a>:</h4>
<p>Haven't heard of rcases (and don't understand how it works <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> will look at that) but I think this pattern grows with the size of the constant, no? I don't plan to have particularly large constants but it's still not ideal to have to expand that each time</p>



<a name="245475783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245475783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245475783">(Jul 09 2021 at 17:54)</a>:</h4>
<p>I'm abusing the definition of <code>&lt;</code>, which is defined as an inductive type. <code>rcases</code> is just recursive <code>cases</code>, available in the mathlib repo. The pattern grows with the size of the constant, as does your code dealing with the valid cases.</p>



<a name="245478885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245478885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245478885">(Jul 09 2021 at 18:19)</a>:</h4>
<p>The case of 2 is also absurd here, right? <code>fin 2</code> is just 0 and 1, isn't it? (I have never really worked with <code>fin</code>)</p>



<a name="245479335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245479335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245479335">(Jul 09 2021 at 18:23)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">mwe</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"zero!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"one!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">absurd</span>
  <span class="o">(</span><span class="k">show</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">&lt;</span> <span class="mi">2</span><span class="o">),</span> <span class="k">from</span> <span class="o">((</span><span class="n">nat.le_add_left</span> <span class="mi">2</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="n">hi</span><span class="o">))</span>
  <span class="o">(</span><span class="n">lt_irrefl</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>



<a name="245479394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245479394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245479394">(Jul 09 2021 at 18:23)</a>:</h4>
<p>this is better than my solution because it doesn't increase linearly as the number gets bigger</p>



<a name="245479777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245479777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245479777">(Jul 09 2021 at 18:26)</a>:</h4>
<p>Also this generates better definitional things because it's not hidden behind a <code>match</code></p>



<a name="245480305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245480305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245480305">(Jul 09 2021 at 18:30)</a>:</h4>
<p>Slightly shorter with <code>false.elim</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">mwe</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"zero!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"one!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">lt_irrefl</span> <span class="n">_</span> <span class="bp">$</span> <span class="o">(</span><span class="n">nat.le_add_left</span> <span class="mi">2</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="n">hi</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
</code></pre></div>



<a name="245480358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245480358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245480358">(Jul 09 2021 at 18:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/James.20Gallicchio/near/245479777">said</a>:</p>
<blockquote>
<p>Also this generates better definitional things because it's not hidden behind a <code>match</code></p>
</blockquote>
<p>Is there a way to do that for anonymous function declarations?</p>



<a name="245480826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245480826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245480826">(Jul 09 2021 at 18:35)</a>:</h4>
<p>For fin? I would just do matrix notation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.matrix.notation</span>

<span class="kd">def</span> <span class="n">mwe</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"zero!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"one!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">absurd</span>
  <span class="o">(</span><span class="k">show</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">&lt;</span> <span class="mi">2</span><span class="o">),</span> <span class="k">from</span> <span class="o">((</span><span class="n">nat.le_add_left</span> <span class="mi">2</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="n">hi</span><span class="o">))</span>
  <span class="o">(</span><span class="n">lt_irrefl</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">mwe'</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">string</span> <span class="o">:=</span>
<span class="bp">!</span><span class="o">[</span><span class="s2">"zero!"</span><span class="o">,</span> <span class="s2">"one!"</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">mwe</span> <span class="bp">=</span> <span class="n">mwe'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">fin_cases</span> <span class="n">i</span><span class="bp">;</span>
  <span class="n">refl</span>
<span class="kd">end</span>
</code></pre></div>



<a name="245481493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245481493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245481493">(Jul 09 2021 at 18:40)</a>:</h4>
<p>Yeah... :/ The reason I was preferring the explicit match syntax is because I'm trying to replicate a syntax that is like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">1</span><span class="o">:</span> <span class="n">line</span> <span class="n">of</span> <span class="n">code</span>
<span class="mi">2</span><span class="o">:</span> <span class="n">line</span> <span class="n">of</span> <span class="n">code</span>
<span class="mi">3</span><span class="o">:</span> <span class="n">line</span> <span class="n">of</span> <span class="n">code</span>
</code></pre></div>
<p>where the lines make reference to each other. so it's helpful to have the line numbers on the side as part of the syntax (since that makes it easy to see what line 3 is, for instance). But I may just revert back to matrix notation.</p>



<a name="245481993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245481993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245481993">(Jul 09 2021 at 18:45)</a>:</h4>
<p>You can't do self-referential definitions that rely on match.</p>



<a name="245482028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245482028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245482028">(Jul 09 2021 at 18:45)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.matrix.notation</span>

<span class="kd">def</span> <span class="n">mwe</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"zero!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mwe</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">nat.le_add_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="n">hi</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">mwe'</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">string</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">match</span> <span class="n">i</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"zero!"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mwe'</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">nat.le_add_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="n">hi</span><span class="o">⟩</span> <span class="c1">-- doesn't know about mwe'</span>
<span class="kd">end</span>
</code></pre></div>



<a name="245482270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245482270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245482270">(Jul 09 2021 at 18:47)</a>:</h4>
<p>Because lean needs to know that the function terminates. The equation compiler can figure that out, either by structural or well-founded recursion. That isn't available in match.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mweN</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="s2">"zero!"</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mweN</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">mweN'</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">string</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">match</span> <span class="n">i</span> <span class="k">with</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="s2">"zero!"</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mweN'</span> <span class="n">n</span> <span class="c1">-- still doesn't know</span>
<span class="kd">end</span>
</code></pre></div>



<a name="245482483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245482483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245482483">(Jul 09 2021 at 18:49)</a>:</h4>
<p>Yeah -- I don't mean literal self reference, just that when you say 3 in the "code" part it refers to line 3 of the "program," so it's helpful for line 3 to be labelled with a 3. I could get what I want via the matrix notation and comments:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">!</span><span class="o">[</span>
<span class="c">/-</span><span class="cm"> 1: -/</span> <span class="bp">...</span><span class="o">,</span>
<span class="c">/-</span><span class="cm"> 2: -/</span> <span class="bp">...</span><span class="o">,</span>
<span class="c">/-</span><span class="cm"> 3: -/</span> <span class="bp">...</span>
<span class="o">]</span>
</code></pre></div>
<p>which is what I think I'll end up doing.</p>



<a name="245482756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245482756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245482756">(Jul 09 2021 at 18:51)</a>:</h4>
<p>fyi, match and eq compiler does not need to have the cases in "order" -- how could it for types that have no inherent order for the terms?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.matrix.notation</span>

<span class="kd">def</span> <span class="n">mwe</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mwe</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">nat.le_add_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="n">hi</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"zero!"</span>
</code></pre></div>



<a name="245491404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/245491404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#245491404">(Jul 09 2021 at 20:08)</a>:</h4>
<p><code>by linarith</code> is able to close the absurd goal too, which while slower is easier to dismiss</p>



<a name="253999528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/253999528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#253999528">(Sep 20 2021 at 05:28)</a>:</h4>
<p>Lots more progress on this :) I'm finally hitting the wall of stuff I don't know again, though. Weird issue:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">n</span><span class="o">]</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">3</span><span class="o">,</span>
  <span class="bp">@</span><span class="n">sum.cases_on</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="n">sum.inl</span> <span class="mi">1</span><span class="o">,</span> <span class="n">sum.inl</span> <span class="mi">0</span><span class="o">,</span> <span class="n">sum.inr</span> <span class="n">n</span><span class="o">]</span> <span class="n">r</span><span class="o">)</span> <span class="bp">!</span><span class="o">[</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">ext</span><span class="o">,</span>
    <span class="n">fin_cases</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">iterate</span> <span class="o">{</span> <span class="gr">admit</span><span class="o">,</span> <span class="o">},</span>
  <span class="kd">end</span>
</code></pre></div>
<p>I'm trying to prove some small fin tuples equal, but for some reason simplifying these cases does not fully evaluate...</p>



<a name="253999614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/253999614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#253999614">(Sep 20 2021 at 05:30)</a>:</h4>
<p>Using <code>simp</code> on the first case reduces it to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">0</span> <span class="bp">=</span> <span class="n">sum.rec</span> <span class="bp">!</span><span class="o">[</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">val</span><span class="o">)</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="n">sum.inl</span> <span class="mi">1</span><span class="o">,</span> <span class="n">sum.inl</span> <span class="mi">0</span><span class="o">,</span> <span class="n">sum.inr</span> <span class="n">n</span><span class="o">]</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>
<p>which is clearly still simplifiable. Not sure why it's having a hard time reducing that.</p>



<a name="254000080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/254000080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#254000080">(Sep 20 2021 at 05:39)</a>:</h4>
<p>Raw <code>sum.rec</code> can block computation, because it is a dependent function. You should avoid using it and use <code>match</code> or definitions by the equation compiler instead</p>



<a name="254000185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/254000185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#254000185">(Sep 20 2021 at 05:41)</a>:</h4>
<p>using <code>sum.elim</code> also works</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">n</span><span class="o">]</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">3</span><span class="o">,</span>
  <span class="n">sum.elim</span> <span class="bp">!</span><span class="o">[</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="n">sum.inl</span> <span class="mi">1</span><span class="o">,</span> <span class="n">sum.inl</span> <span class="mi">0</span><span class="o">,</span> <span class="n">sum.inr</span> <span class="n">n</span><span class="o">]</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">fin_cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="254000265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/254000265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#254000265">(Sep 20 2021 at 05:42)</a>:</h4>
<p>Ah, okay, will give that a shot!</p>



<a name="254799858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/254799858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#254799858">(Sep 25 2021 at 02:26)</a>:</h4>
<p>Another weird thing, getting this error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">motive</span> <span class="n">is</span> <span class="n">not</span> <span class="n">type</span> <span class="n">correct</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">_a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">init</span> <span class="o">(</span><span class="n">ic1.succ</span> <span class="bp">+</span> <span class="n">ic2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">(</span><span class="bp">⇑</span><span class="o">(</span><span class="n">fin.cast_add</span> <span class="n">ic2</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">init</span> <span class="n">_a</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">(</span><span class="bp">⇑</span><span class="o">(</span><span class="n">fin.cast_add</span> <span class="n">ic2</span><span class="o">)</span> <span class="mi">0</span><span class="o">))</span>
</code></pre></div>
<p>MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.fin</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">init</span> <span class="o">(</span><span class="n">ic</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">fin</span> <span class="n">ic</span><span class="o">)</span>
  <span class="o">:=</span> <span class="k">match</span> <span class="n">ic</span> <span class="k">with</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">none</span> <span class="bp">|</span> <span class="n">icp</span><span class="bp">+</span><span class="mi">1</span> <span class="o">:=</span> <span class="n">some</span> <span class="mi">0</span> <span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">map_i</span> <span class="o">(</span><span class="n">ic1</span> <span class="n">ic2</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">ic1</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">ic1</span><span class="bp">+</span><span class="n">ic2</span><span class="o">)</span>
  <span class="o">:=</span> <span class="n">fin.cast_add</span> <span class="n">ic2</span> <span class="n">i</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ic1</span> <span class="n">ic2</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">init</span> <span class="o">(</span><span class="n">ic1.succ</span> <span class="bp">+</span> <span class="n">ic2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">(</span><span class="n">fin.cast_add</span> <span class="n">ic2</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">conv</span> <span class="o">{</span>
      <span class="n">to_lhs</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">nat.add_comm</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>
<p>Never seen that error before, poked around on zulip and Mario had suggested using conv, but I played around and couldn't figure how to avoid it...</p>



<a name="254800261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/254800261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#254800261">(Sep 25 2021 at 02:34)</a>:</h4>
<p>So the problem is that when you are trying to change <code>ic1.succ + ic2</code> into <code>ic2 + ic1.succ</code>, you would at the same time need to change the types of both sides of equation!</p>



<a name="254800434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/254800434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#254800434">(Sep 25 2021 at 02:36)</a>:</h4>
<p>This is avoiding the question, perhaps, but you could use:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.fin</span>

<span class="kd">def</span> <span class="n">init</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span><span class="o">,</span> <span class="n">option</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="mi">0</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">init</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">(</span><span class="n">fin.cast_add</span> <span class="n">m</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">induction</span> <span class="n">m</span><span class="bp">;</span> <span class="n">refl</span>
</code></pre></div>



<a name="254800537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/254800537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#254800537">(Sep 25 2021 at 02:38)</a>:</h4>
<p>(Asides: I'm not sure why you put <code>@[simp]</code> on both of your definitions. This was probably unnecessary. Also <code>map_i</code> is not needed for a MWE.)</p>



<a name="254800939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/254800939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#254800939">(Sep 25 2021 at 02:45)</a>:</h4>
<p>(Ah, sorry, hangovers from when I was cutting it down). Is there a reason this needs to be by induction?</p>



<a name="254801424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/254801424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#254801424">(Sep 25 2021 at 02:52)</a>:</h4>
<p>You should think a bit about this: if you could rewrite <code>n.succ + m</code> into <code>m + n.succ</code> on the LHS here, what type would you need to have on the RHS? What term would you expect to see there after the rewrite?</p>



<a name="254801490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/254801490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#254801490">(Sep 25 2021 at 02:53)</a>:</h4>
<p>Mm, fair enough. I guess the other option would be to insert a cast there?</p>



<a name="254801611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/254801611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#254801611">(Sep 25 2021 at 02:55)</a>:</h4>
<p>Cuz I could put a cast on both sides to <code>option (fin (n+m).succ</code></p>



<a name="254801751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/James%20Gallicchio/near/254801751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/James.20Gallicchio.html#254801751">(Sep 25 2021 at 02:58)</a>:</h4>
<p>Actually, that doesn't quite make sense either, hm</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
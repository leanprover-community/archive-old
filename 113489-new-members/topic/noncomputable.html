---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/noncomputable.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html">noncomputable</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="188389789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/188389789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#188389789">(Feb 17 2020 at 16:08)</a>:</h4>
<p>I'm trying</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">to_complex</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">[</span><span class="n">ω</span><span class="o">])</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="o">:=</span> <span class="n">x</span><span class="bp">.</span><span class="n">re</span> <span class="bp">+</span> <span class="n">x</span><span class="bp">.</span><span class="n">im</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">I</span> <span class="bp">*</span> <span class="n">real</span><span class="bp">.</span><span class="n">sqrt</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span>
</pre></div>


<p>but getting <code>definition 'to_complex' is noncomputable, it depends on 'complex.discrete_field'</code>.<br>
Is there some <code>import</code> or <code>open</code> that will "deal" with this? What are the consequences of ignoring the noncomputability of sqrt?<br>
It looks like an interesting exercise to make <code>real.sqrt</code> computable (looks like there is a proof sketch in the comments of <code>real.sqrt</code>'s definition). Is that worth trying? Is it just a matter of constructing the Cauchy sequence that converges to sqrt(n)?</p>



<a name="188390057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/188390057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#188390057">(Feb 17 2020 at 16:12)</a>:</h4>
<p>The real numbers as implemented in mathlib have no useful computational structure anyways (they are Cauchy sequences without any explicit rate of convergence). You should just put <code>noncomputable theory</code> at the top of your file if you are going to use the reals a lot.</p>



<a name="188391256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/188391256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#188391256">(Feb 17 2020 at 16:29)</a>:</h4>
<p>Thanks!<br>
Are you saying that even if we complete the proof of <code>sqrt_aux_converges</code> sqrt would still be "uncomputable"?</p>



<a name="188391396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/188391396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#188391396">(Feb 17 2020 at 16:31)</a>:</h4>
<p>It would be computable in the sense that Lean wouldn't have the <code>noncomputable</code> tag, but it would not be computable in any practical sense. There is no computable function <code>real -&gt; bool</code> for example, so there's basically nothing you can do with a "computable" function on the current implementation of the reals.</p>



<a name="188391780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/188391780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#188391780">(Feb 17 2020 at 16:37)</a>:</h4>
<p>I think I see :)<br>
Thanks again! (I must say I'm blown away by the support here...)</p>



<a name="188394508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/188394508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#188394508">(Feb 17 2020 at 17:16)</a>:</h4>
<p>I tend to not put <code>noncomputable theory</code> at the top of my files, and then every time Lean complains something is noncomputable I just write <code>noncomputable</code> in front of it, so e.g. <code>noncomputable def to_complex ...</code> would also remove the error.</p>



<a name="196719006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719006">(May 07 2020 at 01:42)</a>:</h4>
<p>Why for such simple theorems I need the <code>noncomputable</code> in front of the theorems? </p>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">Class</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="c1">-- SUMO immediateSubclass</span>
<span class="kn">constant</span> <span class="n">subClass</span> <span class="o">:</span> <span class="n">Class</span> <span class="bp">→</span> <span class="n">Class</span> <span class="bp">→</span> <span class="kt">Type</span>

<span class="c1">-- SUMO subclass</span>
<span class="kn">constant</span> <span class="n">Inherits</span> <span class="o">:</span> <span class="n">Class</span> <span class="bp">→</span> <span class="n">Class</span> <span class="bp">→</span> <span class="kt">Type</span>

<span class="kn">constant</span> <span class="n">inhz</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Class</span><span class="o">)</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">c</span> <span class="n">c</span>
<span class="kn">constant</span> <span class="n">inhs</span> <span class="o">(</span><span class="n">c1</span> <span class="n">c2</span> <span class="n">c3</span> <span class="o">:</span> <span class="n">Class</span><span class="o">)</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">c1</span> <span class="n">c2</span> <span class="bp">→</span> <span class="n">Inherits</span> <span class="n">c2</span> <span class="n">c3</span> <span class="bp">→</span> <span class="n">Inherits</span> <span class="n">c1</span> <span class="n">c3</span>

<span class="kn">constants</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="n">Entity</span> <span class="o">:</span> <span class="n">Class</span>

<span class="kn">constant</span> <span class="n">human_hominid</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">Human</span> <span class="n">Hominid</span>
<span class="kn">constant</span> <span class="n">hominid_entity</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">Hominid</span> <span class="n">Entity</span>

<span class="n">noncomputable</span> <span class="kn">theorem</span> <span class="n">test1</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="o">:=</span>
 <span class="n">inhs</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="n">Hominid</span> <span class="n">human_hominid</span> <span class="o">(</span><span class="n">inhz</span> <span class="n">Hominid</span><span class="o">)</span>

<span class="n">noncomputable</span> <span class="kn">theorem</span> <span class="n">test2</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">Human</span> <span class="n">Entity</span> <span class="o">:=</span>
 <span class="n">inhs</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="n">Entity</span> <span class="n">human_hominid</span> <span class="o">(</span><span class="n">inhs</span> <span class="n">Hominid</span> <span class="n">Entity</span> <span class="n">Entity</span> <span class="n">hominid_entity</span> <span class="o">(</span><span class="n">inhz</span> <span class="n">Entity</span><span class="o">))</span>
</code></pre></div>


<p>Is it possible, using some tactics, to let Lean come up of the proof terms automatically? That is, to synthesize the proof term?</p>



<a name="196719042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719042">(May 07 2020 at 01:43)</a>:</h4>
<p><code>noncomputable</code> has nothing to do with computation in this sense</p>



<a name="196719112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719112">(May 07 2020 at 01:44)</a>:</h4>
<p>it's <code>noncomputable</code> because you can't directly execute the proofs because they use undefined constants</p>



<a name="196719141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719141">(May 07 2020 at 01:45)</a>:</h4>
<p>undefined constants? but in my example, they are all defined.</p>



<a name="196719144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719144">(May 07 2020 at 01:45)</a>:</h4>
<p><code>noncomputable theorem</code> is an indication that you have incorrectly marked a <code>def</code> as a theorem, or you have a type where you wanted a prop. Are <code>subClass</code> and <code>Inherits</code> supposed to be propositions? They are named like such</p>



<a name="196719145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719145">(May 07 2020 at 01:45)</a>:</h4>
<p><code>constant</code> is the same as <code>axiom</code></p>



<a name="196719208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719208">(May 07 2020 at 01:46)</a>:</h4>
<p>No, subClass is supposed to be a dependent type and Inherits a function.</p>



<a name="196719236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719236">(May 07 2020 at 01:47)</a>:</h4>
<p>You may want to consider using <code>variable</code> or <code>parameter</code> here</p>



<a name="196719239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719239">(May 07 2020 at 01:47)</a>:</h4>
<p>actually, I would like to be able to have a term like <code>inhs Human Hominid Hominid human_hominid (inhz Hominid)</code> produced automatically for a type <code>Inherits Human Hominid</code></p>



<a name="196719286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719286">(May 07 2020 at 01:48)</a>:</h4>
<p>you can probably do that using typeclass inference</p>



<a name="196719362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719362">(May 07 2020 at 01:50)</a>:</h4>
<p>Wow! Thank you Mario. Can you give me any reference to understand it better? Probably I have to read <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html</a>, right?</p>



<a name="196719384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719384">(May 07 2020 at 01:51)</a>:</h4>
<p>BTW, nice, I don't need the noncomputable with variables </p>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">Class</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="c1">-- SUMO immediateSubclass</span>
<span class="kn">constant</span> <span class="n">subClass</span> <span class="o">:</span> <span class="n">Class</span> <span class="bp">→</span> <span class="n">Class</span> <span class="bp">→</span> <span class="kt">Type</span>

<span class="c1">-- SUMO subclass</span>
<span class="kn">constant</span> <span class="n">Inherits</span> <span class="o">:</span> <span class="n">Class</span> <span class="bp">→</span> <span class="n">Class</span> <span class="bp">→</span> <span class="kt">Type</span>

<span class="kn">variable</span> <span class="n">inhz</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Class</span><span class="o">)</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">c</span> <span class="n">c</span>
<span class="kn">variable</span> <span class="n">inhs</span> <span class="o">(</span><span class="n">c1</span> <span class="n">c2</span> <span class="n">c3</span> <span class="o">:</span> <span class="n">Class</span><span class="o">)</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">c1</span> <span class="n">c2</span> <span class="bp">→</span> <span class="n">Inherits</span> <span class="n">c2</span> <span class="n">c3</span> <span class="bp">→</span> <span class="n">Inherits</span> <span class="n">c1</span> <span class="n">c3</span>

<span class="kn">variables</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="n">Entity</span> <span class="o">:</span> <span class="n">Class</span>

<span class="kn">variable</span> <span class="n">human_hominid</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">Human</span> <span class="n">Hominid</span>
<span class="kn">variable</span> <span class="n">hominid_entity</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">Hominid</span> <span class="n">Entity</span>

<span class="kn">theorem</span> <span class="n">test1</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="o">:=</span>
 <span class="n">inhs</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="n">Hominid</span> <span class="n">human_hominid</span> <span class="o">(</span><span class="n">inhz</span> <span class="n">Hominid</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">test2</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">Human</span> <span class="n">Entity</span> <span class="o">:=</span>
 <span class="n">inhs</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="n">Entity</span> <span class="n">human_hominid</span> <span class="o">(</span><span class="n">inhs</span> <span class="n">Hominid</span> <span class="n">Entity</span> <span class="n">Entity</span> <span class="n">hominid_entity</span> <span class="o">(</span><span class="n">inhz</span> <span class="n">Entity</span><span class="o">))</span>
</code></pre></div>



<a name="196719490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719490">(May 07 2020 at 01:53)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">Class</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="c1">-- SUMO immediateSubclass</span>
<span class="bp">@</span><span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">subClass</span> <span class="o">:</span> <span class="n">Class</span> <span class="bp">→</span> <span class="n">Class</span> <span class="bp">→</span> <span class="kt">Type</span>

<span class="c1">-- SUMO subclass</span>
<span class="bp">@</span><span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">Inherits</span> <span class="o">:</span> <span class="n">Class</span> <span class="bp">→</span> <span class="n">Class</span> <span class="bp">→</span> <span class="kt">Type</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">inhz</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Class</span><span class="o">)</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">c</span> <span class="n">c</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">inhs</span> <span class="o">(</span><span class="n">c1</span> <span class="n">c2</span> <span class="n">c3</span> <span class="o">:</span> <span class="n">Class</span><span class="o">)</span> <span class="o">[</span><span class="n">Inherits</span> <span class="n">c2</span> <span class="n">c3</span><span class="o">]</span> <span class="o">[</span><span class="n">subClass</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">]</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">c1</span> <span class="n">c3</span>

<span class="kn">constants</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="n">Entity</span> <span class="o">:</span> <span class="n">Class</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">human_hominid</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">Human</span> <span class="n">Hominid</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">hominid_entity</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">Hominid</span> <span class="n">Entity</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">test1</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">test2</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">Human</span> <span class="n">Entity</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="196719663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196719663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196719663">(May 07 2020 at 01:57)</a>:</h4>
<p>thank you. I am getting two errors </p>
<div class="codehilite"><pre><span></span><code><span class="bp">.</span><span class="err">…</span>    <span class="mi">19</span>  <span class="mi">19</span> <span class="n">warning</span>         <span class="kn">definition</span> <span class="err">&#39;</span><span class="n">test1&#39;</span> <span class="n">was</span> <span class="n">incorrectly</span> <span class="n">marked</span> <span class="n">as</span> <span class="n">noncomputable</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
<span class="bp">.</span><span class="err">…</span>    <span class="mi">19</span>  <span class="mi">27</span> <span class="n">error</span>           <span class="n">maximum</span> <span class="n">class</span><span class="bp">-</span><span class="kn">instance</span> <span class="n">resolution</span> <span class="n">depth</span> <span class="n">has</span> <span class="n">been</span> <span class="n">reached</span> <span class="o">(</span><span class="n">the</span> <span class="n">limit</span> <span class="n">can</span> <span class="n">be</span> <span class="n">increased</span> <span class="k">by</span> <span class="n">setting</span> <span class="n">option</span> <span class="err">&#39;</span><span class="n">class</span><span class="bp">.</span><span class="n">instance_max_depth&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">the</span> <span class="n">class</span><span class="bp">-</span><span class="kn">instance</span> <span class="n">resolution</span> <span class="n">trace</span> <span class="n">can</span> <span class="n">be</span> <span class="n">visualized</span> <span class="k">by</span> <span class="n">setting</span> <span class="n">option</span> <span class="err">&#39;</span><span class="n">trace</span><span class="bp">.</span><span class="n">class_instances&#39;</span><span class="o">)</span>
 <span class="n">state</span><span class="o">:</span>
 <span class="err">⊢</span> <span class="n">Inherits</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</code></pre></div>



<a name="196720067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720067">(May 07 2020 at 02:05)</a>:</h4>
<p>You won't be able to use a variable for typeclass inference here. Instances have to be <code>def</code>s or <code>constant</code>s</p>



<a name="196720121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720121">(May 07 2020 at 02:06)</a>:</h4>
<p>The error is because you missed that I swapped the arguments to <code>inhs</code></p>



<a name="196720152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720152">(May 07 2020 at 02:07)</a>:</h4>
<p>I make no guarantees about the behavior of this typeclass search, and there are issues with infinite searches if it follows the wrong path</p>



<a name="196720153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720153">(May 07 2020 at 02:07)</a>:</h4>
<p>but it works in a pinch</p>



<a name="196720203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720203">(May 07 2020 at 02:08)</a>:</h4>
<p>I see. But I copied and pasted your code. So I didn't understand your point about the swapping of the arguments of inhs...</p>



<a name="196720248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720248">(May 07 2020 at 02:09)</a>:</h4>
<p>Are you sure? What version of lean are you running</p>



<a name="196720259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720259">(May 07 2020 at 02:09)</a>:</h4>
<p>I guessed that you modified your code to look like mine</p>



<a name="196720303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720303">(May 07 2020 at 02:10)</a>:</h4>
<p>Oh, I got. Now I have just green marks</p>



<a name="196720318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720318">(May 07 2020 at 02:10)</a>:</h4>
<p>but I don't know any version of lean where the <code>noncomputable</code> mark on the def is unnecessary</p>



<a name="196720402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720402">(May 07 2020 at 02:12)</a>:</h4>
<p>Hum, I see. So I guess that I can't expect too much from Lean to synthesize proof terms as I was expecting with this approach I was investigating.</p>



<a name="196720430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720430">(May 07 2020 at 02:13)</a>:</h4>
<p>there are other ways to do it but they are more complicated</p>



<a name="196720597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720597">(May 07 2020 at 02:16)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">Class</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="c1">-- SUMO immediateSubclass</span>
<span class="kn">constant</span> <span class="n">subClass</span> <span class="o">:</span> <span class="n">Class</span> <span class="bp">→</span> <span class="n">Class</span> <span class="bp">→</span> <span class="kt">Type</span>

<span class="c1">-- SUMO subclass</span>
<span class="kn">constant</span> <span class="n">Inherits</span> <span class="o">:</span> <span class="n">Class</span> <span class="bp">→</span> <span class="n">Class</span> <span class="bp">→</span> <span class="kt">Type</span>

<span class="kn">constant</span> <span class="n">inhz</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Class</span><span class="o">)</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">c</span> <span class="n">c</span>
<span class="kn">constant</span> <span class="n">inhs</span> <span class="o">(</span><span class="n">c1</span> <span class="n">c2</span> <span class="n">c3</span> <span class="o">:</span> <span class="n">Class</span><span class="o">)</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">c1</span> <span class="n">c2</span> <span class="bp">→</span> <span class="n">Inherits</span> <span class="n">c2</span> <span class="n">c3</span> <span class="bp">→</span> <span class="n">Inherits</span> <span class="n">c1</span> <span class="n">c3</span>

<span class="kn">constants</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="n">Entity</span> <span class="o">:</span> <span class="n">Class</span>

<span class="kn">constant</span> <span class="n">human_hominid</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">Human</span> <span class="n">Hominid</span>
<span class="kn">constant</span> <span class="n">hominid_entity</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">Hominid</span> <span class="n">Entity</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">prove_subclass</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">human_hominid</span><span class="o">]</span> <span class="bp">&lt;|&gt;</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">hominid_entity</span><span class="o">]</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">prove_inherits</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">inhz</span><span class="o">]</span> <span class="bp">&lt;|&gt;</span> <span class="o">(</span><span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">inhs</span><span class="o">]</span> <span class="bp">&gt;&gt;</span> <span class="n">prove_subclass</span> <span class="bp">&gt;&gt;</span> <span class="n">prove_inherits</span><span class="o">)</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">test1</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">prove_inherits</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">test2</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">Human</span> <span class="n">Entity</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">prove_inherits</span>
</code></pre></div>



<a name="196720859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720859">(May 07 2020 at 02:22)</a>:</h4>
<p>In this article, <a href="https://www.molto-project.eu/sites/default/files/FinalSUMOCNL.pdf" title="https://www.molto-project.eu/sites/default/files/FinalSUMOCNL.pdf">https://www.molto-project.eu/sites/default/files/FinalSUMOCNL.pdf</a>, the authors have an interesting idea of mapping a KIF ontology (a knowledge representation language) to dependent type. They used <a href="https://www.grammaticalframework.org" title="https://www.grammaticalframework.org">https://www.grammaticalframework.org</a> that implements dependent types too. I am trying to adapt their solution to Lean. The idea is to model the taxonomy of classes. Later, I would expect Lean to automatically construct terms that proof a chain of subclasses like  Human &lt; Hominid &lt; CognitiveAgent &lt; Agent &lt; ... &lt; Entity.</p>



<a name="196720960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196720960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196720960">(May 07 2020 at 02:24)</a>:</h4>
<p>What impressed me was that I was expecting Lean to have a much more powerful type system. But in GF they were able to easily generate a term for a given type. Page 6 of the article. The command mean: give me a term for the type <code>Inherits Human Hominid</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="bp">&gt;</span> <span class="n">gt</span> <span class="bp">-</span><span class="n">cat</span><span class="bp">=</span><span class="s2">&quot;Inherits Human Hominid&quot;</span>
<span class="o">(</span><span class="n">inhs</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="n">Hominid</span> <span class="n">Human_Class</span> <span class="o">(</span><span class="n">inhz</span> <span class="n">Hominid</span><span class="o">))</span>
</code></pre></div>



<a name="196721075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196721075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196721075">(May 07 2020 at 02:26)</a>:</h4>
<p>Oh, sorry I was answering a question that you made in another thread! ;-)</p>



<a name="196721121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196721121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196721121">(May 07 2020 at 02:27)</a>:</h4>
<p>Reading the paper, I'm pretty sure you want <code>subClass</code> and <code>Inherits</code> to be props. The reason they use a dependent type is because that's the nearest equivalent to a proposition in a haskell-esque type theory</p>



<a name="196721181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196721181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196721181">(May 07 2020 at 02:28)</a>:</h4>
<p>I think <code>gt -cat</code> is doing something similar to lean's typeclass inference</p>



<a name="196721382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196721382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196721382">(May 07 2020 at 02:33)</a>:</h4>
<p>pages 5-6 read very much like a description of typeclass inference. I'm pretty sure that <code>gt -cat</code> is a prolog-like search</p>
<blockquote>
<p>However, there are some types of axioms which could not be ported to SUMOGF, such as the ones that use quantification over classes, negative type declarations and axioms which use the predicates subclass, range or domain.</p>
</blockquote>
<p>...which also predicts that negations in theorems would be problematic to represent this way, because instance search only works with horn clauses (from A , B, ... Y infer Z)</p>



<a name="196721644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196721644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196721644">(May 07 2020 at 02:39)</a>:</h4>
<p>Thank you, I will think more about the implications of moving to propositions. In the previous example of trying to prove a simple SUMO axiom in Lean, I used untyped FOL mapping to Lean - <a href="https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean" title="https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean">https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean</a>. This makes the simple proof very verbose.  I had a single type <a href="https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean#L21" title="https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean#L21">https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean#L21</a> and guards in the axioms <a href="https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean#L96" title="https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean#L96">https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean#L96</a>. I am trying to better use types and have a way to move from the class hierarchy to types.  </p>
<p>Anyway, the use of tactics was interesting, thank you for sharing. Unfortunately, we needed to go back to constants and noncomputable...</p>



<a name="196721727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196721727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196721727">(May 07 2020 at 02:41)</a>:</h4>
<p>The reason lean gets lost with the initial version of <code>inhs</code> is because it builds up a stack <code>subclass Human ?a /\ subclass ?a ?b /\ subclass ?b ?c /\ Inherits ?c Hominid -&gt; Inherits Human Hominid</code> that doesn't resolve because it keeps applying <code>inhs</code> to the last <code>Inherits</code> subgoal. It's similar to the left recursion problem in context free grammars</p>



<a name="196721774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196721774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196721774">(May 07 2020 at 02:42)</a>:</h4>
<p>I am curious if GF has the same problem if you stated <code>inhs</code> as <code>Inherits c1 c2 → subClass c2 c3 → Inherits c1 c3</code> instead</p>



<a name="196721855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196721855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196721855">(May 07 2020 at 02:44)</a>:</h4>
<p>This is interesting. I moved subclass back to the original position and it is working for me</p>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">Class</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="c1">-- SUMO immediateSubclass</span>
<span class="bp">@</span><span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">subClass</span> <span class="o">:</span> <span class="n">Class</span> <span class="bp">→</span> <span class="n">Class</span> <span class="bp">→</span> <span class="kt">Type</span>

<span class="c1">-- SUMO subclass</span>
<span class="bp">@</span><span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">Inherits</span> <span class="o">:</span> <span class="n">Class</span> <span class="bp">→</span> <span class="n">Class</span> <span class="bp">→</span> <span class="kt">Type</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">inhz</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Class</span><span class="o">)</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">c</span> <span class="n">c</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">inhs</span> <span class="o">(</span><span class="n">c1</span> <span class="n">c2</span> <span class="n">c3</span> <span class="o">:</span> <span class="n">Class</span><span class="o">)</span> <span class="o">[</span><span class="n">subClass</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">]</span> <span class="o">[</span><span class="n">Inherits</span> <span class="n">c2</span> <span class="n">c3</span><span class="o">]</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">c1</span> <span class="n">c3</span>

<span class="kn">constants</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="n">Entity</span> <span class="o">:</span> <span class="n">Class</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">human_hominid</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">Human</span> <span class="n">Hominid</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">hominid_entity</span> <span class="o">:</span> <span class="n">subClass</span> <span class="n">Hominid</span> <span class="n">Entity</span>

<span class="kn">set_option</span> <span class="n">class</span><span class="bp">.</span><span class="n">instance_max_depth</span> <span class="mi">100</span>
<span class="kn">set_option</span> <span class="n">trace</span><span class="bp">.</span><span class="n">class_instances</span> <span class="n">true</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">test1</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">Human</span> <span class="n">Hominid</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">test2</span> <span class="o">:</span> <span class="n">Inherits</span> <span class="n">Human</span> <span class="n">Entity</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="196722128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196722128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196722128">(May 07 2020 at 02:50)</a>:</h4>
<p>Unfortunately, I can't test the change in GF, the code in <a href="https://github.com/GrammaticalFramework/gf-contrib/tree/master/SUMO" title="https://github.com/GrammaticalFramework/gf-contrib/tree/master/SUMO">https://github.com/GrammaticalFramework/gf-contrib/tree/master/SUMO</a> is incomplete.</p>



<a name="196722253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196722253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196722253">(May 07 2020 at 02:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/noncomputable/near/196720248" title="#narrow/stream/113489-new-members/topic/noncomputable/near/196720248">said</a>:</p>
<blockquote>
<p>Are you sure? What version of lean are you running</p>
</blockquote>
<p>% lean -v<br>
Lean (version 3.4.2, Release)</p>



<a name="196725430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196725430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196725430">(May 07 2020 at 04:09)</a>:</h4>
<p><span class="user-mention" data-user-id="121542">@Alexandre Rademaker</span> So I had a go at simplifying your <a href="https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean" title="https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean">bs.lean</a>, see <a href="https://gist.github.com/digama0/16c62d1af34212de2e3fba380d87c043" title="https://gist.github.com/digama0/16c62d1af34212de2e3fba380d87c043">https://gist.github.com/digama0/16c62d1af34212de2e3fba380d87c043</a> . You can't quite take care of everything with typeclass inference but almost all the proofs that look like typeclass inference can be done using it</p>



<a name="196765225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196765225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196765225">(May 07 2020 at 12:53)</a>:</h4>
<p>I see, thank you so much for your attention.  I will read it carefully to understand the details. The main issue, I believe, is to understand the limitations of that approach. The comments <code>not provable</code> in the end means not probable with typeclass inference or not provable at all with this way to model classes and instances? </p>
<p>Still, I think the predicates and functions are not really typed, right? I can't say that <code>partition : Class → Class → Class → Prop</code> and 'using it' like:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">axiom</span> <span class="n">a67131</span> <span class="o">{</span><span class="n">c</span> <span class="n">row0</span> <span class="n">row1</span> <span class="o">:</span> <span class="n">Class</span><span class="o">}</span> <span class="o">:</span>
 <span class="o">(</span><span class="n">partition3</span> <span class="n">c</span> <span class="n">row0</span> <span class="n">row1</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">exhaustiveDecomposition3</span> <span class="n">c</span> <span class="n">row0</span> <span class="n">row1</span> <span class="bp">∧</span> <span class="n">disjointDecomposition3</span> <span class="n">c</span> <span class="n">row0</span> <span class="n">row1</span><span class="o">))</span>
</code></pre></div>


<p>That is, I can't really internalize the class hierarchy in the types.</p>
<p>In Lean 3.4.2 almost all proofs reached the maximum class-instance resolution depth, and I set it to 1000.</p>



<a name="196975218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196975218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196975218">(May 09 2020 at 05:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="121542">Alexandre Rademaker</span> <a href="#narrow/stream/113489-new-members/topic/noncomputable/near/196765225" title="#narrow/stream/113489-new-members/topic/noncomputable/near/196765225">said</a>:</p>
<blockquote>
<p>I see, thank you so much for your attention.  I will read it carefully to understand the details. The main issue, I believe, is to understand the limitations of that approach. The comments <code>not provable</code> in the end means not probable with typeclass inference or not provable at all with this way to model classes and instances? </p>
</blockquote>
<p>Not provable from the axioms that were provided. Presumably you have omitted some axioms that are needed to prove these.</p>



<a name="196975285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/196975285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#196975285">(May 09 2020 at 05:47)</a>:</h4>
<p>Indeed, these predicates and functions are essentially untyped, and typeclass inference is having to solve a harder problem than it normally would because there are so few classes and so many instances. One simple way to improve this is to have one typeclass per property and try to minimize the number of two-argument typeclasses. And things like <code>ins x Class</code> are really calling out for a <code>Class</code> type as you indicate, which would eliminate the need to do any type class search, although you still have to do something about subtyping.</p>



<a name="244001663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/244001663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#244001663">(Jun 26 2021 at 08:01)</a>:</h4>
<p>What is the function of putting <code>noncomputable</code> before <code>instance</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="o">:</span> <span class="n">inner_product_space</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">inner_product_space.of_core</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="244002489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/244002489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#244002489">(Jun 26 2021 at 08:23)</a>:</h4>
<p>Perhaps it helps to realize that <code>instance</code> is just short for <code>@[instance] def</code>, so this is just like putting <code>noncomputable</code> before a def.</p>



<a name="244003170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/244003170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#244003170">(Jun 26 2021 at 08:39)</a>:</h4>
<p>What will be the difference in practice if I don't put the <code>noncomputable</code>?</p>



<a name="244008502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/244008502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#244008502">(Jun 26 2021 at 10:40)</a>:</h4>
<p>It's not you who chooses -- Lean will tell you what's computable and what isn't, and you tag appropriately. Noncomputability is irrelevant if you just want to prove theorems, it just stops you doing things like #eval and #reduce, but there are plenty of other ways to evaluate things eg use theorems</p>



<a name="244008621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/244008621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#244008621">(Jun 26 2021 at 10:44)</a>:</h4>
<p>Lean will give an error if you put <code>noncomputable</code> on something that is computable, or don't put it on something that isn't. Lean is trying to make you tell the human reader what is and is not computable, even though lean itself knows without you telling it</p>



<a name="244008658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/244008658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#244008658">(Jun 26 2021 at 10:44)</a>:</h4>
<p>If you think your readers don't care, you can start your file with <code>noncomputable theory</code> and lean will stop complaining.</p>



<a name="246507301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246507301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246507301">(Jul 19 2021 at 20:09)</a>:</h4>
<p>Why is this def noncomputable?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">of_bijective</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">bijective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">of_injective</span> <span class="n">f</span> <span class="n">hf.1</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="bp">$</span> <span class="o">(</span><span class="n">set_congr</span> <span class="n">hf.2.range_eq</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="bp">$</span> <span class="n">equiv.set.univ</span> <span class="n">β</span>
</code></pre></div>



<a name="246507468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246507468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246507468">(Jul 19 2021 at 20:10)</a>:</h4>
<p>Because it does not actually provide an explicit inverse function to <code>f</code></p>



<a name="246507681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246507681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246507681">(Jul 19 2021 at 20:12)</a>:</h4>
<p>Is it possible to make this computable by another proof?<br>
<code> def of_bijective {α β} (f : α → β) (hf : bijective f) : α ≃ β := sorry</code></p>



<a name="246507762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246507762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246507762">(Jul 19 2021 at 20:13)</a>:</h4>
<p>No.</p>



<a name="246507776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246507776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246507776">(Jul 19 2021 at 20:13)</a>:</h4>
<p>Oh, I see</p>



<a name="246507800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246507800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246507800">(Jul 19 2021 at 20:13)</a>:</h4>
<p>I depends on axiom of choice.</p>



<a name="246507840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246507840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246507840">(Jul 19 2021 at 20:13)</a>:</h4>
<p><a href="https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/">https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/</a></p>



<a name="246507947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246507947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246507947">(Jul 19 2021 at 20:14)</a>:</h4>
<p>If you see the other thread, you'll see that you don't actually care about the computability of that iso, because you need it solely in the context of a proof.</p>



<a name="246508111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246508111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246508111">(Jul 19 2021 at 20:15)</a>:</h4>
<p>Currently, for the purpose of my work, I actually don't need to care about the computability of anything at all :)</p>



<a name="246597892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246597892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246597892">(Jul 20 2021 at 14:39)</a>:</h4>
<p>Is it possible to make a computable instance? <code>F</code> is a finite field.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.finite.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">char_p</span> <span class="n">F</span> <span class="n">p</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">is_quad_residue</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span>

<span class="kd">noncomputable</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">is_quad_residue</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">simp</span><span class="o">[</span><span class="n">is_quad_residue</span><span class="o">],</span> <span class="n">exact</span> <span class="n">classical.dec</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">F</span><span class="o">),</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">_</span><span class="o">)}</span>
</code></pre></div>



<a name="246598865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246598865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246598865">(Jul 20 2021 at 14:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.finite.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">char_p</span> <span class="n">F</span> <span class="n">p</span><span class="o">]</span>

<span class="kd">@[derive decidable]</span>
<span class="kd">def</span> <span class="n">is_quad_residue</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">is_quad_residue</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="246599219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246599219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246599219">(Jul 20 2021 at 14:43)</a>:</h4>
<p>Similarly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.finite.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">char_p</span> <span class="n">F</span> <span class="n">p</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">is_quad_residue</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">is_quad_residue</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">unfold</span> <span class="n">is_quad_residue</span><span class="o">,</span> <span class="n">apply_instance</span> <span class="o">}</span>
</code></pre></div>



<a name="246601551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246601551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246601551">(Jul 20 2021 at 14:52)</a>:</h4>
<p>Just know that the decidable instance it generates is a brute force search over the entirety of F.</p>



<a name="246601821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246601821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246601821">(Jul 20 2021 at 14:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/noncomputable/near/246601551">said</a>:</p>
<blockquote>
<p>Just know that the decidable instance it generates is a brute force search over the entirety of F.</p>
</blockquote>
<p>As it should be!</p>



<a name="246602351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246602351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246602351">(Jul 20 2021 at 14:58)</a>:</h4>
<p>It would be fun to make a decidable instance based on quadratic reciprocity <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="246605860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246605860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246605860">(Jul 20 2021 at 15:20)</a>:</h4>
<p>Euler's criterion and exponentiation by squaring might be easier</p>



<a name="246605953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246605953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246605953">(Jul 20 2021 at 15:21)</a>:</h4>
<p>My instinct is that the QR proof is faster?</p>



<a name="246605971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246605971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246605971">(Jul 20 2021 at 15:21)</a>:</h4>
<p>Am I wrong?</p>



<a name="246606457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246606457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246606457">(Jul 20 2021 at 15:25)</a>:</h4>
<p>One would have to be careful to use a binary_rec pow definition and not the unary one.</p>



<a name="246606934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246606934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246606934">(Jul 20 2021 at 15:28)</a>:</h4>
<p>I guess the repeated squaring would work for finite fields other than Z/p</p>



<a name="246618466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246618466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246618466">(Jul 20 2021 at 16:52)</a>:</h4>
<p>Euler's criterion is easier to prove correct, but mathlib probably has all the theory needed to prove correctness of the QR algorithm. Both algorithms are very fast (polynomial in number of digits), but I would also guess that QR is faster by some constant factor</p>



<a name="246624183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/246624183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#246624183">(Jul 20 2021 at 17:35)</a>:</h4>
<p>One reason for doing this would be that there are fast primality tests which use this stuff -- they fail quickly for non-primes.</p>



<a name="279765661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279765661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279765661">(Apr 22 2022 at 01:16)</a>:</h4>
<p>What exactly is the meaning of <code>noncomputable</code> in Lean?</p>



<a name="279767802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279767802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279767802">(Apr 22 2022 at 01:50)</a>:</h4>
<p>not executable by the lean VM</p>



<a name="279768909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279768909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279768909">(Apr 22 2022 at 02:06)</a>:</h4>
<p>That makes it sound like one day it may become executable...</p>



<a name="279769071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279769071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279769071">(Apr 22 2022 at 02:10)</a>:</h4>
<p>And therefore become computable</p>



<a name="279772318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279772318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279772318">(Apr 22 2022 at 03:04)</a>:</h4>
<p>well sure, depending on what kind of evolution you have in mind</p>



<a name="279772335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279772335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279772335">(Apr 22 2022 at 03:04)</a>:</h4>
<p>you can rewrite a function to become computable</p>



<a name="279772380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279772380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279772380">(Apr 22 2022 at 03:05)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/12301">#12301</a> is a recent example of exactly that</p>



<a name="279772587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279772587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279772587">(Apr 22 2022 at 03:09)</a>:</h4>
<p>in particular, just because a function is marked <code>noncomputable</code> does not mean there is not an equal function which is computable</p>



<a name="279772747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279772747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279772747">(Apr 22 2022 at 03:11)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">classical.some</span> <span class="o">(⟨</span><span class="mi">37</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">37</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="mi">37</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">=</span> <span class="n">bar</span> <span class="o">:=</span> <span class="n">classical.some_spec</span> <span class="o">(⟨</span><span class="mi">37</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">37</span><span class="o">)</span>
</code></pre></div>



<a name="279772905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279772905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279772905">(Apr 22 2022 at 03:13)</a>:</h4>
<p>Using <code>noncomputable!</code> you can even force a computable definition to be noncomputable</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="mi">37</span>
<span class="kd">noncomputable</span><span class="bp">!</span> <span class="kd">def</span> <span class="n">baz</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="mi">37</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">bar</span> <span class="bp">=</span> <span class="n">baz</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="279782501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279782501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279782501">(Apr 22 2022 at 05:55)</a>:</h4>
<p>Hmm so in particular, noncomputable means "Lean, don't try to compute a representation for this, just check whether it's logically correct"?</p>



<a name="279782779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279782779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279782779">(Apr 22 2022 at 06:00)</a>:</h4>
<p>Usually it means "lean has told me it is unable to compute this"</p>



<a name="279811236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noncomputable/near/279811236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/noncomputable.html#279811236">(Apr 22 2022 at 11:37)</a>:</h4>
<p>In practice it means that your function can't be run from a tactic</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Explicit.20vector.20unfolding.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html">Explicit vector unfolding</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="268012036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268012036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268012036">(Jan 14 2022 at 13:20)</a>:</h4>
<p>I often struggle with subgoals like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">v</span><span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">⊢</span> <span class="n">v</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="n">v</span> <span class="mi">0</span><span class="o">,</span> <span class="n">v</span> <span class="mi">1</span><span class="o">]</span>
</code></pre></div>
<p>What is the easiest way to prove it?</p>



<a name="268012230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268012230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268012230">(Jan 14 2022 at 13:21)</a>:</h4>
<p><code>ext</code>?</p>



<a name="268012426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268012426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268012426">(Jan 14 2022 at 13:23)</a>:</h4>
<p>I can't check because you didn't post a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> and I don't know where that notation is defined.</p>



<a name="268012767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268012767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268012767">(Jan 14 2022 at 13:26)</a>:</h4>
<p>I am sorry. Here is MWE.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.vec_notation</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="n">v</span> <span class="mi">0</span><span class="o">,</span> <span class="n">v</span> <span class="mi">1</span><span class="o">]</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="268012811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268012811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268012811">(Jan 14 2022 at 13:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span>
<span class="n">v</span><span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span>
<span class="bp">⊢</span> <span class="n">v</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="n">v</span> <span class="mi">0</span><span class="o">,</span> <span class="n">v</span> <span class="mi">1</span><span class="o">]</span> <span class="n">x</span>
</code></pre></div>



<a name="268012969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268012969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268012969">(Jan 14 2022 at 13:28)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.vec_notation</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="n">v</span> <span class="mi">0</span><span class="o">,</span> <span class="n">v</span> <span class="mi">1</span><span class="o">]</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">fin_cases</span> <span class="n">x</span><span class="bp">;</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="268013203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268013203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268013203">(Jan 14 2022 at 13:30)</a>:</h4>
<p>Thank you!</p>
<p>I think that this is so basic that we should have a lemma or tactic for that, so we can prove my subgoal in "one command".</p>



<a name="268013460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268013460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268013460">(Jan 14 2022 at 13:32)</a>:</h4>
<p>As for it being lemma, I cannot make it generic for every vector size, so it should probably be done by a tactic.</p>



<a name="268013508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268013508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268013508">(Jan 14 2022 at 13:33)</a>:</h4>
<p>If you think that writing tactic for that would be hard, I will create several lemmata for all "small" vector sizes. Just tell me which file they should be added to.</p>



<a name="268015913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268015913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268015913">(Jan 14 2022 at 13:52)</a>:</h4>
<p>I think the generic version is <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.cons_head_tail">docs#matrix.cons_head_tail</a></p>



<a name="268016714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268016714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268016714">(Jan 14 2022 at 13:59)</a>:</h4>
<p>Can you please show me how you prove the following example using <code>matrix.cons_head_tail</code> please?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.vec_notation</span>
<span class="kn">import</span> <span class="n">data.matrix.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">fin</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="n">v</span> <span class="mi">0</span><span class="o">,</span> <span class="n">v</span> <span class="mi">1</span><span class="o">,</span> <span class="n">v</span> <span class="mi">2</span><span class="o">,</span> <span class="n">v</span> <span class="mi">3</span><span class="o">,</span> <span class="n">v</span> <span class="mi">4</span><span class="o">]</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">fin_cases</span> <span class="n">x</span><span class="bp">;</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="268018847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268018847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268018847">(Jan 14 2022 at 14:17)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">fin</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="n">v</span> <span class="mi">0</span><span class="o">,</span> <span class="n">v</span> <span class="mi">1</span><span class="o">,</span> <span class="n">v</span> <span class="mi">2</span><span class="o">,</span> <span class="n">v</span> <span class="mi">3</span><span class="o">,</span> <span class="n">v</span> <span class="mi">4</span><span class="o">]</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">iterate</span> <span class="mi">5</span> <span class="o">{</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">matrix.cons_head_tail</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.trans</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">congr'</span> <span class="mi">1</span> <span class="o">}</span>
</code></pre></div>



<a name="268019285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268019285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268019285">(Jan 14 2022 at 14:20)</a>:</h4>
<p>Thanks! I can see that it is not as friendly as I wished for. Can I create separate lemmata for vector sizes 1 to 9 for it? Or is there a better solution? I don't know whether a generic tactic for that is doable and desirable.</p>



<a name="268019579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268019579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268019579">(Jan 14 2022 at 14:22)</a>:</h4>
<p>This seems slightly better:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">matrix.eq_cons_iff</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">v</span> <span class="bp">=</span> <span class="n">vec_cons</span> <span class="n">x</span> <span class="n">u</span> <span class="bp">↔</span> <span class="n">vec_head</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">vec_tail</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">u</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.symm</span> <span class="bp">▸</span> <span class="o">⟨</span><span class="n">head_cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">tail_cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">hx</span><span class="o">,</span> <span class="n">hu</span><span class="o">⟩,</span> <span class="n">hx</span> <span class="bp">▸</span> <span class="n">hu</span> <span class="bp">▸</span> <span class="o">(</span><span class="n">matrix.cons_head_tail</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩</span>

<span class="c1">-- not used below, but for completeness</span>
<span class="kd">lemma</span> <span class="n">matrix.cons_eq_iff</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">vec_cons</span> <span class="n">x</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">v</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">vec_head</span> <span class="n">v</span> <span class="bp">∧</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">vec_tail</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">,</span> <span class="n">matrix.eq_cons_iff</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">fin</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="n">v</span> <span class="mi">0</span><span class="o">,</span> <span class="n">v</span> <span class="mi">1</span><span class="o">,</span> <span class="n">v</span> <span class="mi">2</span><span class="o">,</span> <span class="n">v</span> <span class="mi">3</span><span class="o">,</span> <span class="n">v</span> <span class="mi">4</span><span class="o">]</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">matrix.eq_cons_iff</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="268019848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268019848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268019848">(Jan 14 2022 at 14:24)</a>:</h4>
<p>Thanks!</p>
<p>Is it a code you would like to see in mathlib?</p>



<a name="268019907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268019907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268019907">(Jan 14 2022 at 14:25)</a>:</h4>
<p><code>matrix.eq_cons_iff</code> and <code>matrix.cons_eq_iff</code> seem harmless. I'm much less keen on hard-coding lemmas for <code>fin n</code> from 0 to 9</p>



<a name="268020139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268020139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268020139">(Jan 14 2022 at 14:26)</a>:</h4>
<p>What about <code>matrix.eq_cons_iff</code> and <code>matrix.cons_eq_iff</code> and explicit lemmata for <code>fin 2</code> and <code>fin 3</code> only? I really wish that was a one-liner.</p>



<a name="268020254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268020254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268020254">(Jan 14 2022 at 14:27)</a>:</h4>
<p><code>ext i, fin_cases; refl</code> is a pretty reasonable answer the the question</p>



<a name="268020351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268020351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268020351">(Jan 14 2022 at 14:28)</a>:</h4>
<p>What's the underlying motivation here? What are you trying to prove about <code>![...]</code> expressions?</p>



<a name="268020759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268020759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268020759">(Jan 14 2022 at 14:31)</a>:</h4>
<p>I'd like to provide <code>@[simp]</code> version of the lemmata <code>vec2_add</code>, <code>vec3_add</code>, <code>smul_vec2</code>, <code>smul_vec3</code> as we did with <code>vec2_dot_product</code>. Moreover, having lemma or tactic for things like <code>v = ![v 0, v 1]</code> seems that it would be useful in general — too often I was in situations like this.</p>



<a name="268020798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268020798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268020798">(Jan 14 2022 at 14:31)</a>:</h4>
<p>We already have the simp version of those lemmas though, it's <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.cons_add_cons">docs#matrix.cons_add_cons</a> etc?</p>



<a name="268020806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268020806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268020806">(Jan 14 2022 at 14:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">vec2_dot_product'</span> <span class="o">{</span><span class="n">a₀</span> <span class="n">a₁</span> <span class="n">b₀</span> <span class="n">b₁</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">!</span><span class="o">[</span><span class="n">a₀</span><span class="o">,</span> <span class="n">a₁</span><span class="o">]</span> <span class="bp">⬝ᵥ</span> <span class="bp">!</span><span class="o">[</span><span class="n">b₀</span><span class="o">,</span> <span class="n">b₁</span><span class="o">]</span> <span class="bp">=</span> <span class="n">a₀</span> <span class="bp">*</span> <span class="n">b₀</span> <span class="bp">+</span> <span class="n">a₁</span> <span class="bp">*</span> <span class="n">b₁</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">cons_dot_product_cons</span><span class="o">,</span> <span class="n">cons_dot_product_cons</span><span class="o">,</span> <span class="n">dot_product_empty</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">vec2_dot_product</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">v</span> <span class="bp">⬝ᵥ</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">v</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">w</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">v</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">w</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">vec2_dot_product'</span>
</code></pre></div>



<a name="268021163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021163">(Jan 14 2022 at 14:34)</a>:</h4>
<p>We have those already, right?</p>



<a name="268021203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021203">(Jan 14 2022 at 14:34)</a>:</h4>
<p>Yeah. That was just an example of what I wanted to do with the other lemmas.</p>



<a name="268021245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021245">(Jan 14 2022 at 14:34)</a>:</h4>
<p>I can't translate the dot_product lemmas into the add lemmas you have in mind</p>



<a name="268021263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021263">(Jan 14 2022 at 14:34)</a>:</h4>
<p>Can you give the statement of the lemmas you're thinking of?</p>



<a name="268021334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021334">(Jan 14 2022 at 14:35)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">vec2_add_</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">v</span> <span class="bp">+</span> <span class="n">w</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="n">v</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">w</span> <span class="mi">0</span><span class="o">,</span> <span class="n">v</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">w</span> <span class="mi">1</span><span class="o">]</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Unfortunately, <code>simp</code> cannot prove it automatically even when it has <code>cons_add_cons</code> available.</p>



<a name="268021447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021447">(Jan 14 2022 at 14:36)</a>:</h4>
<p>That doesn't look like a useful lemma to me</p>



<a name="268021469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021469">(Jan 14 2022 at 14:37)</a>:</h4>
<p>Do you have a goal in mind you want to use it on?</p>



<a name="268021493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021493">(Jan 14 2022 at 14:37)</a>:</h4>
<p>OK. I wanted to have them rather for completeness. If you think they are useless, I will forget about them.</p>



<a name="268021578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021578">(Jan 14 2022 at 14:38)</a>:</h4>
<p>What _might_ be useful is an <code>unfold_fin_vector v</code> tactic that replaces all unapplied <code>v</code>s in the goal with <code>![v 0, v 1, v 2, v 3, v 4]</code></p>



<a name="268021606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021606">(Jan 14 2022 at 14:38)</a>:</h4>
<p>But that would be a tactic, not a lemma</p>



<a name="268021621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021621">(Jan 14 2022 at 14:38)</a>:</h4>
<p>Yep!</p>



<a name="268021686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021686">(Jan 14 2022 at 14:39)</a>:</h4>
<p>It would probably be a good opportunity to throw yourself into the metaprogramming deep end, but I doubt it would actually end up all that useful</p>



<a name="268021715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021715">(Jan 14 2022 at 14:39)</a>:</h4>
<p>Actually, do you have an example where <code>simp</code> uses <code>cons_add_cons</code> automatically?</p>



<a name="268021761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021761">(Jan 14 2022 at 14:39)</a>:</h4>
<p>Sure,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">vec2_add</span> <span class="o">{</span><span class="n">a₀</span> <span class="n">a₁</span> <span class="n">b₀</span> <span class="n">b₁</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">!</span><span class="o">[</span><span class="n">a₀</span><span class="o">,</span> <span class="n">a₁</span><span class="o">]</span> <span class="bp">+</span> <span class="bp">!</span><span class="o">[</span><span class="n">b₀</span><span class="o">,</span> <span class="n">b₁</span><span class="o">]</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="n">a₀</span> <span class="bp">+</span> <span class="n">b₀</span><span class="o">,</span> <span class="n">a₁</span> <span class="bp">+</span> <span class="n">b₁</span><span class="o">]</span>  <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span>
</code></pre></div>



<a name="268021835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021835">(Jan 14 2022 at 14:40)</a>:</h4>
<p>I'm not sure if you've worked this out already, but <code>![a, b, c, ...]</code> is syntax for <code>vec_cons a ![b, c, ...]</code> and <code>![]</code> is syntax for <code>vec_empty</code></p>



<a name="268021858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021858">(Jan 14 2022 at 14:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Explicit.20vector.20unfolding/near/268021761">said</a>:</p>
<blockquote>
<p>Sure,</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">vec2_add</span> <span class="o">{</span><span class="n">a₀</span> <span class="n">a₁</span> <span class="n">b₀</span> <span class="n">b₁</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">!</span><span class="o">[</span><span class="n">a₀</span><span class="o">,</span> <span class="n">a₁</span><span class="o">]</span> <span class="bp">+</span> <span class="bp">!</span><span class="o">[</span><span class="n">b₀</span><span class="o">,</span> <span class="n">b₁</span><span class="o">]</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="n">a₀</span> <span class="bp">+</span> <span class="n">b₀</span><span class="o">,</span> <span class="n">a₁</span> <span class="bp">+</span> <span class="n">b₁</span><span class="o">]</span>  <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span>
</code></pre></div><br>
</p>
</blockquote>
<p>That's cool, thanks!</p>



<a name="268021893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268021893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268021893">(Jan 14 2022 at 14:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Explicit.20vector.20unfolding/near/268021835">said</a>:</p>
<blockquote>
<p>I'm not sure if you've worked this out already, but <code>![a, b, c, ...]</code> is syntax for <code>vec_cons a ![b, c, ...]</code> and <code>![]</code> is syntax for <code>vec_empty</code></p>
</blockquote>
<p>I know; I have been working with that all the time in past days.</p>



<a name="268022133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268022133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268022133">(Jan 14 2022 at 14:43)</a>:</h4>
<p>OK ok, so can we conclude that?<br>
– Having hard-coded lemmata like <code>v = ![v 0, v 1, v 2, v 3, v 4]</code> would not be useful enough.<br>
– Developing a tactic for that would not be worth the hassle.</p>



<a name="268030669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268030669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268030669">(Jan 14 2022 at 15:43)</a>:</h4>
<p>It would likely be worth the hassle for the sake of learning how to write tactics, but not for the sake of the end result</p>



<a name="268037204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268037204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268037204">(Jan 14 2022 at 16:27)</a>:</h4>
<p>Regarding your original question (how to prove <code>v = ![v 0, v 1, v 2, v 3, v 4]</code> for arbitrary <code>n</code>), since everything is computable, I don't think we need a tactic for that. A simple <code>decidable</code> instance should do the trick. Alternatively, you can prove a general lemma and apply it directly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.fin.vec_notation</span>

<span class="kn">open</span> <span class="n">nat</span> <span class="n">matrix</span>

<span class="kd">def</span> <span class="n">mk_vec</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">),</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">!</span><span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">vec_cons</span> <span class="o">(</span><span class="n">v</span> <span class="o">⟨</span><span class="n">n</span> <span class="bp">-</span> <span class="n">k</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="n">clear</span> <span class="n">mk_vec</span> <span class="n">v</span><span class="o">,</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_eq_add_of_le</span> <span class="n">h</span><span class="o">,</span> <span class="n">clear</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">tsub_tsub</span><span class="o">,</span> <span class="n">add_tsub_cancel_left</span><span class="o">,</span> <span class="n">succ_add</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">lt_succ_iff</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">le_self_add</span><span class="o">,</span>
<span class="kd">end</span><span class="o">⟩)</span> <span class="o">(</span><span class="n">mk_vec</span> <span class="o">(</span><span class="n">le_of_succ_le</span> <span class="n">h</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">vec_eq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">mk_vec</span> <span class="n">v</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="n">v</span> <span class="mi">0</span><span class="o">,</span> <span class="n">v</span> <span class="mi">1</span><span class="o">,</span> <span class="n">v</span> <span class="mi">2</span><span class="o">,</span> <span class="n">v</span> <span class="mi">3</span><span class="o">,</span> <span class="n">v</span> <span class="mi">4</span><span class="o">]</span>
<span class="o">:=</span> <span class="n">vec_eq</span> <span class="c1">-- Proves the goal automatically</span>
</code></pre></div>



<a name="268038191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268038191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268038191">(Jan 14 2022 at 16:34)</a>:</h4>
<p>I don't think a decidable instance would work, unless <code>α</code> has decidable equality</p>



<a name="268038517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268038517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268038517">(Jan 14 2022 at 16:37)</a>:</h4>
<p>That <code>mk_vec</code> is nifty, thanks!</p>



<a name="268038881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268038881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268038881">(Jan 14 2022 at 16:39)</a>:</h4>
<p>challenge question: write a similar dependent-type theorem schema for <code>\exists a b c d e, v = ![a, b, c, d, e]</code></p>



<a name="268041909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/268041909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#268041909">(Jan 14 2022 at 17:00)</a>:</h4>
<div class="spoiler-block"><div class="spoiler-header">
<p>Solution</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.vec_notation</span>

<span class="kn">open</span> <span class="n">nat</span> <span class="n">matrix</span>

<span class="kd">def</span> <span class="n">exists_vec_type</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span> <span class="o">((</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">P</span> <span class="bp">!</span><span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">P</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">exists_vec_type</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">vec_cons</span> <span class="n">a</span> <span class="n">v</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">exists_vec_aux</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">exists_vec_type</span> <span class="n">P</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">v</span> <span class="n">P</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="bp">←</span> <span class="n">empty_eq</span> <span class="n">v</span><span class="o">]</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">!</span><span class="o">[])</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">)</span> <span class="n">v</span> <span class="n">P</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">vec_head</span> <span class="n">v</span><span class="o">,</span> <span class="n">exists_vec_aux</span> <span class="o">(</span><span class="n">vec_tail</span> <span class="n">v</span><span class="o">)</span> <span class="n">_</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="n">cons_head_tail</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">exists_vec</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">exists_vec_type</span> <span class="o">(</span><span class="n">eq</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">exists_vec_aux</span> <span class="n">v</span> <span class="n">_</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">,</span> <span class="n">v</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">]</span> <span class="o">:=</span> <span class="n">exists_vec</span> <span class="n">v</span>
</code></pre></div>
</div></div>



<a name="291301682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Explicit%20vector%20unfolding/near/291301682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Explicit.20vector.20unfolding.html#291301682">(Jul 29 2022 at 09:45)</a>:</h4>
<p>The above is part of <a href="https://github.com/leanprover-community/mathlib/pull/15738">#15738</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
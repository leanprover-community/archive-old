---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html">Computability by Turing machines</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="205596004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205596004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205596004">(Jul 31 2020 at 14:24)</a>:</h4>
<p>Hi, me and <span class="user-mention" data-user-id="320867">@Daan van Gent</span> are trying to define problems in computability sense, and hence we want to use the Turing machine code in mathlib. But the current definition of the second kind of Turing machine in mathlib seems to be too powerful: because <code>\sigma</code> (the type of states) can be infinite, and you can choose any function <code>f: \sigma \to \Gamma k</code> (the alphabet) to be the "output" of the Turing machine. Taking $\sigma = \N$ for example, this function <code>f</code> does not need to be computable, but with the Turing machine as implemented, I think it can be computed. It seems like an easy fix: just demand that <code>\sigma</code> is finite (as is usually done in the definition of Turing machines). Should that be done, or am I missing something?</p>
<p>(Note the same problem holds for Turing machines of the zeroth kind as defined in mathlib; there, the type of states is called <code>\Lambda</code>, and can still be infinite.)</p>



<a name="205606490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205606490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205606490">(Jul 31 2020 at 15:43)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> had some discussion of this at <a href="https://github.com/formalabstracts/formalabstracts/issues/52">https://github.com/formalabstracts/formalabstracts/issues/52</a> recently.</p>



<a name="205607938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205607938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205607938">(Jul 31 2020 at 15:56)</a>:</h4>
<p>Ah, that makes sense! I think that means we will be defining our own computable demanding that the state set is finite.</p>



<a name="205651569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205651569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205651569">(Jul 31 2020 at 23:22)</a>:</h4>
<p><span class="user-mention" data-user-id="319356">@Pim Spelier</span> The Turing machine file doesn't define "computable" (IIRC), only a Turing machine with fixed types for input alphabet and so on. This allows you to use them as required for your application. If you want to define TM-computable, you would probably say something like "f : N -&gt; N is computable if there exists a <em>finite</em> alphabet S and a <em>finite</em> set of states G such that <code>machine G S</code> evaluates to <code>f n</code> given input <code>n</code> (after encoding and decoding <code>nat</code> to <code>list S</code> somehow"</p>



<a name="205651665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205651665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205651665">(Jul 31 2020 at 23:24)</a>:</h4>
<p>There is a definition of "computable" in <code>partrec</code> that I recommend you use as "the" definition of computable in the abstract, and it does require that the TM that computes it has finitely many states and is on a finite alphabet. (Well not really because it's not defined using TMs at all, but it is equivalent to such.)</p>



<a name="205651801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205651801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205651801">(Jul 31 2020 at 23:26)</a>:</h4>
<p>There are also some words on this in the module comment for <a href="https://leanprover-community.github.io/mathlib_docs/computability/turing_machine.html"><code>computability.turing_machine</code></a></p>



<a name="205651943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205651943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205651943">(Jul 31 2020 at 23:29)</a>:</h4>
<p>In particular, <a href="https://leanprover-community.github.io/mathlib_docs/find/turing.TM0.supports">docs#turing.TM0.supports</a> formalizes exactly how a TM is supposed to be finite without actually requiring that the types involved are finite. This is very useful for writing concrete TMs since it is nice to be able to use an inductive type for the space of states, and then just ensure that only a finite part of it is accessible from the initial state.</p>



<a name="205652731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205652731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205652731">(Jul 31 2020 at 23:43)</a>:</h4>
<p>Thanks! I think we do want to work with Turing machines though, to define computability, because we also want to work with it in practice (right now for example, we're working on showing that sat is decidable). Then definining computability only for functions of type <code>\N \to \N</code> seems restricted, and we'd rather work in higher generality. I agree, we will then have to demand that the alphabets and states are finite in some way.</p>



<a name="205652735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205652735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205652735">(Jul 31 2020 at 23:43)</a>:</h4>
<p>I did see the definition of the multiple supports functions, and that does seem a natural way to demand finiteness. Right now, in TM2, this is only done for the type of function labels \Lambda; would it make sense to make a similar definition for the type of states $\sigma$?</p>



<a name="205654460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205654460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205654460">(Aug 01 2020 at 00:15)</a>:</h4>
<p>If you want to show SAT is decidable, you can probably do so using the partrec API. Don't use TMs unless you like pain or are specifically interested in TMs</p>



<a name="205654518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205654518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205654518">(Aug 01 2020 at 00:16)</a>:</h4>
<p>The partrec API defines computability over general types FYI, that was just a sketch</p>



<a name="205654639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205654639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205654639">(Aug 01 2020 at 00:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="319356">Pim Spelier</span> <a href="#narrow/stream/113489-new-members/topic/Computability.20by.20Turing.20machines/near/205652735">said</a>:</p>
<blockquote>
<p>I did see the definition of the multiple supports functions, and that does seem a natural way to demand finiteness. Right now, in TM2, this is only done for the type of function labels \Lambda; would it make sense to make a similar definition for the type of states $\sigma$?</p>
</blockquote>
<p>If only finitely many states is accessible, this implies that only finitely many elements of the alphabet can be written. You will still have to ask that the input be encoded on the tape using finitely many symbols, but Sigma can be infinite (with the cofinitely many symbols being auxiliaries that never appear on the tape)</p>



<a name="205654748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205654748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205654748">(Aug 01 2020 at 00:21)</a>:</h4>
<p>Oops, misread, you are talking about the local state variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>. Yes this has to be finite too, and you can enforce this with a <code>fintype sigma</code>. It is possible to do a more refined thing but I haven't found as much use for sigma being "essentially finite" like the other types</p>



<a name="205654845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205654845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205654845">(Aug 01 2020 at 00:23)</a>:</h4>
<p>My plan has been to prove the equivalence of <code>computable</code> (as defined in partrec) with the existence of a TM that computes the function, and that theorem will of course have all the necessary finiteness assumptions. Since I'm not using TMs for the definition of <code>computable</code>, it's not so important if the definition allows infinite states and so on.</p>



<a name="205655389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205655389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205655389">(Aug 01 2020 at 00:36)</a>:</h4>
<p>We did think about using the partrec functions instead of Turing machines, but we saw two problems: first of all, if I understand correctly, although partrec is defined for any primcodable types, it still is fundamentally a statement about a function <code>\N \to \N</code> being primitive recursive. For SAT, you'd then need an encoding from propositional_formula to \N, and work with such an encoded propositional formula. Our main concern was that such an encoding feels ugly, and difficult to work with (if there is an easy way to do this, I'd love to know where I can read about it). While in theory doable, for us it seemed nicer to think of a function <code>list \Gamma \to list \Gamma'</code> being computable; then you'd need to encode a propositional_formula to a <code>list \Gamma</code> for some alphabet <code>\Gamma</code>. Taking for example a postfix notation, this kind of encoding seems to reflect the original structure a lot better than an encoding propositional_formal \to \N could.</p>



<a name="205655392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205655392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205655392">(Aug 01 2020 at 00:36)</a>:</h4>
<p>Second of all, we want to be able to define the classes P, NP and NPC, and for that you need the runtime of an algorithm. For Turing machines, this seems like an easy addition to the code that is already there; for partrec functions, we didn't know how we would do that.</p>



<a name="205656869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205656869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205656869">(Aug 01 2020 at 01:13)</a>:</h4>
<p>Ultimately, yes every type you want to talk about has to be encoded as a nat. But besides the abstract computability of this encoding, not much is required about it (and more to the point using TM's doesn't save you any trouble here). You can encode to another primcodable type if you prefer, such as <code>list Sigma</code> where <code>Sigma</code> is primcodable (for example if <code>Sigma</code> is finite then this is easy), and so that should put it on the same footing as what you get with TMs</p>



<a name="205656943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205656943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205656943">(Aug 01 2020 at 01:14)</a>:</h4>
<p>It would be nice if such an encoding is generated automatically for inductive types, but the required derive handler hasn't been written yet. So you have to cobble it from sums and products right now</p>



<a name="205657077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205657077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205657077">(Aug 01 2020 at 01:18)</a>:</h4>
<p>As for defining P and NP, it's true that TMs have a more natural description of what runtime means. It is possible to define polytime computable primrec functions; you need to restrict the growth rate of functions inside the <code>prec</code> constructor IIRC</p>



<a name="205657526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205657526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205657526">(Aug 01 2020 at 01:30)</a>:</h4>
<p><span class="user-mention" data-user-id="319356">@Pim Spelier</span> Here's a general interface for encoding inductive types:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">computability</span><span class="bp">.</span><span class="n">primrec</span>

<span class="kn">inductive</span> <span class="n">W</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">W</span><span class="o">)</span> <span class="bp">→</span> <span class="n">W</span>

<span class="n">class</span> <span class="n">listable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">[</span><span class="n">dec_eq</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
<span class="o">(</span><span class="n">elems</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">complete</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">elems</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">listable</span><span class="bp">.</span><span class="n">to_fintype</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">listable</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">listable</span><span class="bp">.</span><span class="n">dec_eq</span> <span class="n">α</span><span class="bp">;</span> <span class="n">exact</span>
<span class="bp">⟨</span><span class="o">(</span><span class="n">listable</span><span class="bp">.</span><span class="n">elems</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">listable</span><span class="bp">.</span><span class="n">complete</span> <span class="n">x</span><span class="o">]</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">primcodable</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">listable</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span> <span class="n">primcodable</span> <span class="o">(</span><span class="n">W</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="205657551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205657551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205657551">(Aug 01 2020 at 01:31)</a>:</h4>
<p>If you have some inductive type of propositional formulas, you can define a bijection to <code>W</code> of the appropriate types and get an encoding that way</p>



<a name="205677667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205677667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205677667">(Aug 01 2020 at 11:37)</a>:</h4>
<p>I have trouble parsing this, but that might have to do with me not understanding what W is supposed to be. If I understand correctly you say that every inductive type should be primcodable, but that it hasn't been proved yet? We have a inductive type for propositional formulas:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">inhabited</span><span class="o">]</span>
<span class="kn">inductive</span> <span class="n">propositional_formula</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">propositional_formula</span>
<span class="bp">|</span> <span class="n">conj</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">propositional_formula</span><span class="o">)</span> <span class="o">:</span> <span class="n">propositional_formula</span>
<span class="bp">|</span> <span class="n">disj</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">propositional_formula</span><span class="o">)</span> <span class="o">:</span> <span class="n">propositional_formula</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">propositional_formula</span><span class="o">)</span> <span class="o">:</span> <span class="n">propositional_formula</span>
</code></pre></div>


<p>We already managed to prove that it is encodable, which is enough when working with Turing machines. Proving primcodability shouldn't be very much harder.</p>
<p>How is <code>propositional_formula</code> in bijection with W for some choice of parameters?</p>



<a name="205678682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205678682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205678682">(Aug 01 2020 at 12:09)</a>:</h4>
<p>the first parameter of W is a type with α + 3 values, say <code>ATOM α | CONJ | DISJ | NEG</code>, and the second parameter of W takes these four constructors to, respectively, the empty type, the type with 2 values, the type with 2 values, the type with 1 value</p>



<a name="205679216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205679216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205679216">(Aug 01 2020 at 12:23)</a>:</h4>
<p>I see. If we say <code>s</code> is the type with values <code>ATOM \alpha | CONJ | DISJ | NEG</code> , then this <code>W</code> has a 'natural' map to <code>list(s)</code> via postfix notation, since <code>s</code> is trivially primcodable so is <code>list(s)</code>  (supposing alpha is primcodable). At least, this is how I see it with how I proved <code>propositional_formula</code> is primcodable in the back of my mind. This bijection of <code>W</code> with  <code>propositional_formula</code> seems very canonical. Is there a way to automate that, or is that just way too much technicalities with inductive types?</p>



<a name="205679285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205679285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205679285">(Aug 01 2020 at 12:24)</a>:</h4>
<p>It is definitely automatable, but I haven't bothered to write the derive handler for it</p>



<a name="205679351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205679351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205679351">(Aug 01 2020 at 12:26)</a>:</h4>
<p>It is reminiscent of Haskell's <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html"><code>deriving Generic</code></a></p>



<a name="205679530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205679530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205679530">(Aug 01 2020 at 12:32)</a>:</h4>
<p>The encodings I was thinking of use the encodings for lists and pairs. That is, you encode <code>conj (atom x) (neg (atom y))</code> as<br>
<code>(CONJ, [(ATOM x, []), (NEG, [(ATOM y, [])])])</code> where <code>(x, y)</code> denotes the pair encoding function and <code>[x,..]</code> is the list encoding function</p>



<a name="205679653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205679653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205679653">(Aug 01 2020 at 12:36)</a>:</h4>
<p>Up until now there hasn't really been a demand for <code>deriving primcodable</code>, and the only real usage of such a thing in mathlib would be <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.partrec.code.encode_code/src">src#nat.partrec.code.encode_code</a> (which you should totally use as a blueprint for your <code>propositional_formula</code> implementation)</p>



<a name="205679713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205679713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205679713">(Aug 01 2020 at 12:38)</a>:</h4>
<p>But what is the type of <code>(CONJ, [(ATOM x, []), (NEG, [(ATOM y, [])])])</code>? it seems like a recursive type instead of some composition of  products and lists.</p>



<a name="205679849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205679849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205679849">(Aug 01 2020 at 12:42)</a>:</h4>
<p>Oh nevermind, I think I understand. I should read it as a way to evaluate it as a natural number using the encodings for lists and products.</p>



<a name="205679919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205679919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205679919">(Aug 01 2020 at 12:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Thanks for all the help!<br>
On the subject of definining computability through partrec functions or through turing_machines: another objection we came up with for using partrec instead of turing_machine, is that in defining of computable through partial recursive functions, one seems to forget about the actual computation: i.e., once you've proven it's computable, you don't care about the algorithm. This is fine when you only want to talk about stuff being computable, but seems like a problem when you also want to talk about the algorithms, e.g. when defining P and NP. Do you agree, or am I missing something?</p>



<a name="205679930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205679930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205679930">(Aug 01 2020 at 12:45)</a>:</h4>
<p>That's correct, and in fact that's the whole point</p>



<a name="205679984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205679984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205679984">(Aug 01 2020 at 12:46)</a>:</h4>
<p><code>computable f</code> means <code>f</code> is abstractly computable. It does not make any guarantees about the complexity of the algorithm, nor does it provide an algorithm</p>



<a name="205679996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205679996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205679996">(Aug 01 2020 at 12:47)</a>:</h4>
<p>for example, it should be the case that the function that computes 1 if the riemann hypothesis is true and 0 otherwise, is computable</p>



<a name="205680006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205680006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205680006">(Aug 01 2020 at 12:47)</a>:</h4>
<p>because it is either the function <code>return 0</code> or <code>return 1</code>, both of which are computable</p>



<a name="205680074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205680074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205680074">(Aug 01 2020 at 12:49)</a>:</h4>
<p>I would say that P and NP are the same way, in the sense that they should not be "effective" but rather mere existence claims</p>



<a name="205680144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205680144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205680144">(Aug 01 2020 at 12:51)</a>:</h4>
<p>In particular cases, you can often say something more precise than that a particular problem is in P, but for the basic definition I wouldn't want any more than that, so that you can do nonconstructive proofs</p>



<a name="205680206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205680206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205680206">(Aug 01 2020 at 12:53)</a>:</h4>
<p>Isn't that also the case with computability by Turing machines? It is computable by either the algorithm that outputs 0, or the algorithm that outputs 1. So this problem would still be in P, as either way it has a constant time algorithm, right?</p>



<a name="205680262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205680262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205680262">(Aug 01 2020 at 12:55)</a>:</h4>
<p>Right, I imagine the TM-based definition would be something like <code>def ptime (f : A -&gt; B) := \ex G S [fintype G] (M : machine G S) (p : polynomial nat), \all x, eval_in_at_most M x (p.eval (size x)) = f x</code></p>



<a name="205680328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205680328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205680328">(Aug 01 2020 at 12:57)</a>:</h4>
<p>(I made up several things in that so don't expect it to type check)</p>



<a name="205680333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205680333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205680333">(Aug 01 2020 at 12:57)</a>:</h4>
<p>but because it uses <code>\ex</code>, there is no actual turing machine that is "data" in the predicate</p>



<a name="205680468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205680468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205680468">(Aug 01 2020 at 13:01)</a>:</h4>
<p>Exactly, that's the same kind of definition that we're working towards! But I do get your problem, there's no way to go from <code>\ex (a : \alpha), ...</code> to <code>\alpha</code> without using choice.</p>



<a name="205680524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205680524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205680524">(Aug 01 2020 at 13:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="320867">Daan van Gent</span> <a href="#narrow/stream/113489-new-members/topic/Computability.20by.20Turing.20machines/near/205679713">said</a>:</p>
<blockquote>
<p>But what is the type of <code>(CONJ, [(ATOM x, []), (NEG, [(ATOM y, [])])])</code>? it seems like a recursive type instead of some composition of  products and lists.</p>
</blockquote>
<p>I omitted the encodes that keep shoving everything back into nat. With the encodes, it looks like<br>
<code>e (CONJ, [e (ATOM x, []), e (NEG, [e (ATOM y, [])])])</code> where <code>e</code> is <code>encode : prop_A x list nat -&gt; nat</code></p>



<a name="205681223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205681223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205681223">(Aug 01 2020 at 13:23)</a>:</h4>
<p>Do you think there is a similarly easy definition of ptime using the partrec framework? Or would one need to define a similar inductive type ptime_computable_partrec, with a different way of constructing it? It seems rather difficult to pin down when a function is ptime_computable_partrec without directly referring to some sort of runtime.</p>



<a name="205685453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205685453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205685453">(Aug 01 2020 at 15:12)</a>:</h4>
<p>Well there is <code>evaln</code>, which seems to give a kind of step indexing to partrec evaluation, but I don't think it is correct for ptime, because it uses encoding to nat - many functions are going to be off by an exponential or so even with the optimal coding. The way I have heard for doing P properly using primitive recursion is to use "bounded recursion on notation", basically treating <code>nat</code> as <code>list bool</code> through a canonical bijection and defining simple recursive functions there. Cobham seems to be the progenitor of the idea, but there are several internet writeups, for example <a href="https://www.cs.toronto.edu/~sacook/homepage/survey_Dec26.2016.pdf">https://www.cs.toronto.edu/~sacook/homepage/survey_Dec26.2016.pdf</a></p>



<a name="205685534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205685534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205685534">(Aug 01 2020 at 15:15)</a>:</h4>
<p>By the way, while reading that paper I saw an idea that had never occurred to me: they call it <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>-adic notation, which is basically the same as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>-ary positional notation for natural numbers except that digits come from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1,\dots,m\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">}</span></span></span></span> instead of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0,\dots,m-1\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>. Amazingly, this simple change makes the notation a bijection between digit strings and nonnegative integers. Now I wish that lean had <code>bit1</code> and <code>bit2</code> instead of <code>bit0</code> and <code>bit1</code></p>



<a name="205685605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205685605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205685605">(Aug 01 2020 at 15:17)</a>:</h4>
<p>yeah but now you can't have extra 0's</p>



<a name="205685607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205685607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205685607">(Aug 01 2020 at 15:17)</a>:</h4>
<p>00003754 is no longer the same as 3754 because the former is not defined</p>



<a name="205685765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205685765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205685765">(Aug 01 2020 at 15:21)</a>:</h4>
<p>That's the point</p>



<a name="205685775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205685775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205685775">(Aug 01 2020 at 15:21)</a>:</h4>
<p>that's a failure of bijectivity</p>



<a name="205685821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205685821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205685821">(Aug 01 2020 at 15:22)</a>:</h4>
<p>those multiple representations are a formal headache</p>



<a name="205685967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205685967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Spelier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205685967">(Aug 01 2020 at 15:27)</a>:</h4>
<p>Thanks for the link, I'll take a look at it! I do think we'll stick with Turing machines for now, although I suppose the ultimate result would be to define polynomial time for both, and prove the definitions are equal :).</p>



<a name="205686009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Computability%20by%20Turing%20machines/near/205686009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Computability.20by.20Turing.20machines.html#205686009">(Aug 01 2020 at 15:28)</a>:</h4>
<p>I agree that polytime for TMs is more obviously correct</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html">What exactly does `meta def` do?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="203353486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353486">(Jul 09 2020 at 06:09)</a>:</h4>
<p>Can I think of <code>meta def</code> as just defining a tactic? Or does it do more than that? (I'm guessing if all it did was define a tactic it would've been called <code>tactic def</code>).</p>



<a name="203353541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353541">(Jul 09 2020 at 06:10)</a>:</h4>
<p><code>meta</code> turns off termination checks for recursive calls.</p>



<a name="203353553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353553">(Jul 09 2020 at 06:11)</a>:</h4>
<p>So you can define recursive functions without bothering to prove that they terminate (maybe the actually don't, but who cares, just make sure you only give inputs where termination is fine).</p>



<a name="203353559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353559">(Jul 09 2020 at 06:11)</a>:</h4>
<p>(deleted)</p>



<a name="203353571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353571">(Jul 09 2020 at 06:11)</a>:</h4>
<p>But everything that uses a <code>meta</code> def/lemma in it's proof or definition will also need to be <code>meta</code>. It's a bit like a virus (-;</p>



<a name="203353629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353629">(Jul 09 2020 at 06:12)</a>:</h4>
<p>Basically (but I'm not an expert) <code>meta</code> turns Lean into a functional programming language without all the proofy bits.</p>



<a name="203353655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353655">(Jul 09 2020 at 06:13)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">contradiction</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">contradiction</span>
</code></pre></div>



<a name="203353727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353727">(Jul 09 2020 at 06:15)</a>:</h4>
<p>The other thing <code>meta</code> does is it gives you access to the various <code>meta constant</code>s implemented in C++</p>



<a name="203353782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353782">(Jul 09 2020 at 06:16)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">Cantor</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="n">Cantor</span> <span class="bp">→</span> <span class="kt">Prop</span>
</code></pre></div>



<a name="203353788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353788">(Jul 09 2020 at 06:16)</a>:</h4>
<p>So my impression was that <code>tactics</code> are its own class of objects within the language, but they are just terms for which termination checking is turned off? I'm a bit confused by this.</p>



<a name="203353794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353794">(Jul 09 2020 at 06:17)</a>:</h4>
<p>it also has other technical effects like turning off universe checks, positivity checks in inductives, and the proofy part of the equation compiler</p>



<a name="203353847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353847">(Jul 09 2020 at 06:18)</a>:</h4>
<p><code>tactic A</code> is a lean type like most others, although it is <code>meta</code> meaning that anything of this type has to also be <code>meta</code></p>



<a name="203353856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353856">(Jul 09 2020 at 06:18)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="kn">inductive</span> <span class="n">Cantor</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="o">(</span><span class="n">Cantor</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Cantor</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">Cantor</span><span class="bp">.</span><span class="n">intro</span><span class="bp">.</span><span class="n">inj</span> <span class="c1">-- Cantor.intro ?M_1 = Cantor.intro ?M_2 → ?M_1 = ?M_2</span>
</code></pre></div>



<a name="203353877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353877">(Jul 09 2020 at 06:19)</a>:</h4>
<p>lean tactics are functional programs using the same term syntax as regular terms used in definitions and proofs</p>



<a name="203353926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353926">(Jul 09 2020 at 06:20)</a>:</h4>
<p>however they use various hooks into the lean elaborator which are written in C++ and provided as opaque constants on the lean side</p>



<a name="203353928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353928">(Jul 09 2020 at 06:20)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">logic</span><span class="bp">.</span><span class="n">function</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">meta</span> <span class="kn">inductive</span> <span class="n">Cantor</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="o">(</span><span class="n">Cantor</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Cantor</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">function</span><span class="bp">.</span><span class="n">cantor_injective</span> <span class="n">Cantor</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">Cantor</span><span class="bp">.</span><span class="n">intro</span><span class="bp">.</span><span class="n">inj</span><span class="o">)</span> <span class="c1">-- false</span>
</code></pre></div>



<a name="203353932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353932">(Jul 09 2020 at 06:20)</a>:</h4>
<p>a freshly made contradiction</p>



<a name="203353948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353948">(Jul 09 2020 at 06:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> why does <code>meta theorem</code> give me error?</p>



<a name="203353953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203353953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203353953">(Jul 09 2020 at 06:21)</a>:</h4>
<p>probably because lean thinks this is a stupid thing to do</p>



<a name="203354000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203354000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203354000">(Jul 09 2020 at 06:22)</a>:</h4>
<p>this works for me though</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="kn">theorem</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>
</code></pre></div>



<a name="203354008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203354008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203354008">(Jul 09 2020 at 06:22)</a>:</h4>
<p>oh, as in, whenever I "abuse" <code>meta theorem</code></p>



<a name="203354014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203354014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203354014">(Jul 09 2020 at 06:23)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">logic</span><span class="bp">.</span><span class="n">function</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">meta</span> <span class="kn">inductive</span> <span class="n">Cantor</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="o">(</span><span class="n">Cantor</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Cantor</span>

<span class="n">meta</span> <span class="kn">theorem</span> <span class="n">contradiction</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="n">function</span><span class="bp">.</span><span class="n">cantor_injective</span> <span class="n">Cantor</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">Cantor</span><span class="bp">.</span><span class="n">intro</span><span class="bp">.</span><span class="n">inj</span><span class="o">)</span> <span class="c1">-- false</span>
</code></pre></div>



<a name="203354017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203354017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203354017">(Jul 09 2020 at 06:23)</a>:</h4>
<p>"invalid definition, it uses untrusted declaration 'Cantor'"</p>



<a name="203354097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203354097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203354097">(Jul 09 2020 at 06:25)</a>:</h4>
<p>oh and why can't I recurse inside a <code>meta structure</code>?</p>



<a name="203354104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203354104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203354104">(Jul 09 2020 at 06:25)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="kn">structure</span> <span class="n">Cantor</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Cantor</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="c1">-- unknown identifier &#39;Cantor&#39;</span>
</code></pre></div>



<a name="203354364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203354364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203354364">(Jul 09 2020 at 06:31)</a>:</h4>
<p>You can't recurse in structures period</p>



<a name="203354424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203354424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203354424">(Jul 09 2020 at 06:32)</a>:</h4>
<p>making these things work in meta defs requires special hacks because the name scoping doesn't naturally make it happen</p>



<a name="203354445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203354445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203354445">(Jul 09 2020 at 06:33)</a>:</h4>
<p>I'm not sure why you are collecting meta proofs of false though</p>



<a name="203476834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203476834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203476834">(Jul 10 2020 at 07:26)</a>:</h4>
<p>I've been looking at this link, <a href="https://leanprover-community.github.io/extras/tactic_writing.html">https://leanprover-community.github.io/extras/tactic_writing.html</a>, and I would like to test my understanding of the Lean language. </p>
<p>Is the following correct?</p>
<p>When we write something like <code>lemma foo : .... := term</code> where <code>term</code> doesn't contain any tactic blocks like <code>begin ... end</code> or <code>by</code>, then Lean <em>only</em> parses and type checks your code. But when we write e.g. a <code>begin ... end</code> block, then Lean parses, compiles <em>and</em> executes the code within the <code>begin ... end</code> block during type checking, just as if e.g. in C++ we would have actually built and run the code. So in a sense, Lean contains a "compiler and execution environment within a type checker". After running this code, each <code>begin ... end</code> block produces a non-meta term, which is then type checked as a non-meta term. If it fails this type check, the <code>begin ... end</code> block produces an error.</p>
<p>Regarding tactic writing (), this means the following:<br>
We can essentially think of any <code>begin ... end</code> block as contain code that we will actually compile and run, just like any other language like C++, except this compilation and running will happen automatically, meaning you never have to press the "Run" button in your IDE. Moreover, we are not allowed to use terms within the <code>begin ... end</code> blocks that don't have the <code>meta</code> keyword, and conversely, we're only allowed to use terms with the <code>meta</code> keyword within <code>begin ... end</code> blocks. In short, <code>meta</code> terms are treated as objects that one can actually run, whereas non-<code>meta</code> terms are only type checked.</p>
<p>However, unlike C++, the Lean "meta-language" is a functional language, and so should be treated like e.g. Haskell. </p>
<p>To summarize, Lean essentially consists of "two separate languages", and an interface between them: the Lean "proof-language" consists of all terms without the <code>meta</code> keyword, and the Lean "meta-language" consists of those with the <code>meta</code> keyword. The meta-language behaves like a normal functional language. The proof-language has a special type system designed along the lines of the Curry-Howard isomorphism and is only type-checked but never executed. The interface between the proof- and meta-language are the tactic blocks <code>begin ... end</code> and <code>by</code>, which tell the meta-language compiler to compile and execute the contents of the block as source code in the meta-language, and interpreting the output as source code of the proof-language. It then replaces the <code>begin ... end</code> block with this source code, and leaves it to the proof-language type checker to type check it as code in the proof-language.</p>
<p><strong>Is this a correct view of how Lean works internally? Will it lead me astray if I would write tactics?</strong> Even if it wouldn't lead me astray, I'd still be interested in where I'm wrong on the details.</p>



<a name="203477686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203477686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203477686">(Jul 10 2020 at 07:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284606">Chris M</span> <a href="#narrow/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F/near/203476834">said</a>:</p>
<blockquote>
<p>We can essentially think of any <code>begin ... end</code> block as contain code that we will actually compile and run, just like any other language like C++, except this compilation and running will happen automatically, meaning you never have to press the "Run" button in your IDE.</p>
</blockquote>
<p>This only happens because VSCode runs Lean automatically. If you wrote Lean in a normal text editing software you still have to compile / run it elsewhere.</p>



<a name="203482265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203482265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203482265">(Jul 10 2020 at 08:34)</a>:</h4>
<p><span class="user-mention" data-user-id="284606">@Chris M</span> Lean compiles all definitions that aren't <code>noncomputable</code> to bytecode.  It turns out "only parsing and type checking" for dependent types can involve evaluating lots of code (for example, <code>rfl</code> proofs), though I'm not sure how much is bytecode evaluation and how much is term reduction.</p>
<p>Here's my rough understanding/guess for how some of this works, assuming nothing is <code>noncomputable</code>:</p>
<ul>
<li>
<p>Lean parses your definition (be it a <code>def</code> or <code>lemma</code>), and constructs a term full of metavariables for all the implicits.  This includes thinking of <code>begin ... end</code> blocks as a big metavariable, I think.</p>
</li>
<li>
<p>Then it does some depending type checking to figure out what it can.  This gives the <code>begin ... end</code> blocks types, possibly with metavariables.</p>
</li>
<li>
<p>The tactic language is procedural/monadic, modifying a tactic state that comes from the <code>begin ... end</code> block's type, while simultaneously constructing a term that will replace the block.</p>
</li>
<li>
<p>Eventually, if everything worked out, the definition is a complete term.</p>
</li>
</ul>
<p>I'm not sure the precise way this is enforced, but every definition that uses a term with a <code>meta</code> definition must itself be marked <code>meta</code>.  Being marked <code>meta</code> confers this and other privileges, like relaxing well-foundedness of recursion.  Then, you as a mathematician know that you should not extend the Curry-Howard isomorphism to the types of <code>meta</code> definitions since otherwise you would believe in contradictions.</p>
<p>Going the other way, every <code>meta</code> definition can use all the (computable) non-<code>meta</code> definitions it wants.</p>



<a name="203482292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203482292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203482292">(Jul 10 2020 at 08:34)</a>:</h4>
<p>So, I'm literally recording some videos about this today, in preparation for the <a href="https://leanprover-community.github.io/lftcm2020/">LFTCM</a> Monday afternoon session. Keep an eye out for some links soon.</p>
<p>You have most of it right. Let's set some terminology: meta-Lean is "Lean with the <code>meta</code> keyword." In some sense, all the <code>meta</code> keyword does is disable termination checking. Meta-Lean is an extension of non-meta Lean, in that any non-meta declaration can also be used in meta declarations. Meta-Lean is trivially unsound (see <code>meta def t : false := t</code>) so it's not interesting for writing proofs. </p>
<p>But you can evaluate meta declarations using <code>#eval</code>. This evaluation happens in the VM, which is not trusted code. So another reading of <code>meta</code> is "for evaluation only," non-meta is "for evaluation and proof."</p>
<p>The VM overrides certain declarations during evaluation. For instance, nats are not represented as the familiar inductive type in the VM. Importantly, a lot of Lean internals that are exposed as meta constants or defs in Lean (<code>expr</code>, <code>env</code>, all the atomic tactics) are overridden. This is confusing, because it's what "meta" should mean. In practice most (but not all) of the reflected Lean stuff has the <code>meta</code> keyword, and some reflected Lean stuff doesn't strictly need to be <code>meta</code>.</p>
<p>The code that appears between <code>begin</code> and <code>end</code> is a meta-Lean expression. It has type <code>tactic unit</code>, effectively a function <code>tactic_state -&gt; tactic_state</code>. (<code>tactic_state</code> is a meta constant in Lean, a C++ data structure in the VM.) <code>begin..end</code> and <code>by</code> are hooks that will construct the <code>tactic_state</code> at the start point, evaluate your tactic script on this tactic state, and deal with the output. Part of the tactic state is a (partially) constructed Lean expression. When this term is fully constructed, it's sent to the kernel to check. Indeed, this term is a result of executing your metaprogram, it doesn't contain the metaprogram you wrote itself. (But it's not necessarily non-meta. You can write a tactic script to produce a meta expr. <code>meta example : expr := by exact expr.var 0</code>) The kernel will never see the script between <code>begin..end</code>, just its output.</p>



<a name="203483294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203483294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203483294">(Jul 10 2020 at 08:48)</a>:</h4>
<p>So the "Lean kernel" is what I've called "proof-language type checker"?</p>



<a name="203483372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203483372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203483372">(Jul 10 2020 at 08:49)</a>:</h4>
<p>VM = virtual machine?</p>



<a name="203483749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203483749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203483749">(Jul 10 2020 at 08:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284606">Chris M</span> <a href="#narrow/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F/near/203483294">said</a>:</p>
<blockquote>
<p>So the "Lean kernel" is what I've called "proof-language type checker"?</p>
</blockquote>
<p>Effectively yes. I may have been a little brief -- the script between <code>begin..end</code> does get type checked, in that it has to have type <code>tactic unit</code>.</p>



<a name="203483758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203483758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203483758">(Jul 10 2020 at 08:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284606">Chris M</span> <a href="#narrow/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F/near/203483372">said</a>:</p>
<blockquote>
<p>VM = virtual machine?</p>
</blockquote>
<p>Yep.</p>



<a name="203483923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203483923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203483923">(Jul 10 2020 at 08:56)</a>:</h4>
<p>"In some sense, all the <code>meta</code> keyword does is disable termination checking."<br>
This I still don't really understand. It seems to me that it also completely changes the way that the Lean compiler deals with it?</p>
<p>Is it more correct to say:<br>
Lean-expressions and meta-lean expressions are treated in two separate ways. In particular, meta-lean expressions within <code>begin ... end</code> blocks are compiled to lean-expressions before any lean-expression type checking is performed. Moreover, their type checker is the same, except that the meta-lean type checker has disabled termination checking. Moreover, the actual type systems are different, in that some types are only recognized by the meta-type system (such as the type tactic unit).</p>



<a name="203492904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203492904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203492904">(Jul 10 2020 at 10:46)</a>:</h4>
<p>(I'm writing this because I have some interest in internals, and I would appreciate being corrected.)</p>
<p>The stuff about a VM is purely optimization.  Since <code>meta</code> definitions don't take part in mathematical truth, it's OK to evaluate such code in a faster way, even if the VM might be less trusted to be correct.  (Though what Rob was saying about some <code>meta</code> definitions being replaced by C++ implementations might be another reason: it helps keep the Lean kernel smaller and easier to trust if it doesn't also have to be able to reduce general <code>meta</code> terms too?)</p>
<p>I was looking through some of how the parser works, and <code>begin ... end</code> blocks are (seemingly) parsed into a special term (an external action) that contains a term that should be a <code>tactic unit</code>.  I presume the way it then works is that when the Lean compiler sends parsed definitions to the kernel, these terms, including the external actions, are type checked and, once the context around the external action is figured out as much as can be, the kernel asks the outer-layer compiler to fill in the hole.  In this particular case, this involves the compiler evaluating the <code>tactic unit</code> with respect to the context, producing a term -- some amount of type checking needs to have been done by this point so the goal window has anything to say, so to speak.</p>
<p>I'm hazy about lots of specifics here, but one conceptual model that seems OK is that you can think of most of the C++ code, the <code>meta</code> definitions, and the non-<code>meta</code> definitions as being the outer-layer compiler, and a subset of the C++ code and the non-<code>meta</code> definitions are the Lean kernel and math.  The overlap is that it's as if each non-<code>meta</code> definition also creates a companion <code>meta</code> definition.  The outer layer is responsible for interfacing with the real world and directs the Lean kernel, and there is some protocol (for example, <code>begin ... end</code> blocks) for the Lean kernel to ask the outer layer for more information during its type checking process.</p>
<p>I couldn't find the process by which the outer layer checks the types of its meta definitions.  I'm guessing there is some provision in the Lean kernel for this.</p>
<p>It seems the way disabling termination checking works is (1) that meta definitions are allowed to refer to the function being defined and (2) that the equation compiler is able to construct terms making use of this, whereas non-<code>meta</code> definitions cannot do so and instead need to resolve into the actual recursors for the given inductive types.  For example, compare these two definitions of factorial:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">n</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">f&#39;</span> <span class="n">n</span>
</code></pre></div>


<p>The first, when <code>#print</code>ed is roughly</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span>
  <span class="n">a</span><span class="bp">.</span><span class="n">brec_on</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">a</span><span class="o">),</span>
       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">a</span><span class="o">),</span>
          <span class="n">a</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="mi">0</span><span class="o">),</span> <span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">1</span><span class="o">)</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">a</span><span class="bp">.</span><span class="n">succ</span><span class="o">),</span> <span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="o">((</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="bp">_</span><span class="n">F</span><span class="bp">.</span><span class="n">fst</span><span class="bp">.</span><span class="n">fst</span><span class="o">))</span>
            <span class="bp">_</span><span class="n">F</span><span class="o">)</span>
         <span class="n">a</span>
         <span class="bp">_</span><span class="n">F</span><span class="o">)</span>
</code></pre></div>


<p>and the second is</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">a</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="o">((</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">f&#39;</span> <span class="n">a</span><span class="o">))</span>
</code></pre></div>


<p>(the pretty printer actually shows the <code>f'</code> in square brackets, but this does not seem to be meaningful syntax.)</p>



<a name="203548146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203548146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203548146">(Jul 10 2020 at 19:21)</a>:</h4>
<p>(As if there weren't enough explanations on the thread already:) There are two important and orthogonal properties that a lean term can have. (1) It can participate in the standard consistent CIC dependent type theory (as e.g described in <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">my thesis</a>), and (2) it can be evaluable by the lean virtual machine. These properties are negatively marked: a term lacking property (1) is called <code>meta</code>, and a term lacking property (2) is called <code>noncomputable</code>, and you are required to put these markings as appropriate on all definitions.</p>
<p>In particular, all four combinations of the two properties are possible: a <code>meta def</code> has (2), a <code>def</code> has (1) and (2), a <code>noncomputable def</code> has (1), and a <code>noncomputable meta def</code> has neither (this last class is basically useless).</p>
<p>All definitions go through lean's elaborator, which is responsible for inferring all the missing arguments. (This may involve running tactics but we'll get back to that.) From there definitions with (1) go to the small trusted kernel to be re-typechecked, and they also end up in the proof output format, while definitions with (2) go to the compiler to be turned into VM bytecode. A definition with both (1) and (2) gets both kernel typechecked and compiled to VM bytecode.</p>
<p>Because tactics are meant to be run, they must have property (2), but they need not have property (1). In particular, since most of the core primitives are <code>meta</code>, including the type <code>tactic</code> itself, tactics are always <code>meta</code> meaning they lack property (1). But that doesn't mean that you can't use non-<code>meta</code> definitions, as long as they are computable. A good example of a library with both (1) and (2) is <code>list A</code> and the functions manipulating it. This is used in both proofs (for example, to define finiteness) as well as in computations (running functions to filter <code>list</code>s of hypotheses and the like).</p>
<p>When the lean elaborator hits a <code>begin ... end</code> block, it elaborates the contents of the block in a special parser mode into a tactic, typechecks it as a <code>tactic unit</code> (not using the kernel, just the elaborator's basic haskell-like typechecker), compiles it to bytecode on the spot (so it needs to be computable, i.e. property (2)), and then runs it, whereupon the tactic will fill in the hole at the location of the <code>begin ... end</code> with a term (which may be non-meta, and is required to be if the definition itself is non-meta).</p>



<a name="203548472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203548472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203548472">(Jul 10 2020 at 19:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F/near/203492904">said</a>:</p>
<blockquote>
<p>The stuff about a VM is purely optimization.  Since <code>meta</code> definitions don't take part in mathematical truth, it's OK to evaluate such code in a faster way, even if the VM might be less trusted to be correct. </p>
</blockquote>
<p>Unfortunately it's not that simple. For definitions in both (1) and (2), we can say that the VM implementation (2) is just an optimization on the semantics (1), but there are definitions in (2) that don't even have a semantics in (1) and for those we have to just take the VM behavior as defining the meaning of the term.</p>



<a name="203548862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203548862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203548862">(Jul 10 2020 at 19:30)</a>:</h4>
<p>In particular, for definitions in (1) and (2) one property we have not proven but believe to be true (and will take steps to ensure) is that the VM will only ever compute a function in accordance with what the theory says it should, i.e. if the VM says <code>f a = b</code> then you can prove that in the kernel. There are lots of reasons why this is hard to state precisely much less prove, though.</p>



<a name="203549239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203549239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203549239">(Jul 10 2020 at 19:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F/near/203492904">said</a>:</p>
<blockquote>
<p>I couldn't find the process by which the outer layer checks the types of its meta definitions.  I'm guessing there is some provision in the Lean kernel for this.</p>
</blockquote>
<p>The lean elaborator has its own typechecker, basically a more complicated version of the kernel typechecker that includes support for metavariables, typeclass inference, tactic running and the like. There are terms that typecheck in the kernel but not the elaborator and vice versa.</p>



<a name="203549653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203549653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203549653">(Jul 10 2020 at 19:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284606">Chris M</span> <a href="#narrow/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F/near/203483923">said</a>:</p>
<blockquote>
<p>"In some sense, all the <code>meta</code> keyword does is disable termination checking."<br>
This I still don't really understand. It seems to me that it also completely changes the way that the Lean compiler deals with it?</p>
</blockquote>
<p>Hopefully what I've said above makes this clearer, but to directly address this point: Because <code>meta</code> determines whether the term has property (1) or not, the compiler actually doesn't care about it at all. The elaborator cares about it because it allows it to relax some checks, and the kernel cares about it because it won't see a <code>meta</code> definition at all while it will be asked to typecheck a non-<code>meta</code> definition, but the compiler will do the same thing on a <code>meta</code> definition as on a non-<code>meta</code> definition.</p>



<a name="203554021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203554021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203554021">(Jul 10 2020 at 20:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Thanks for elaborating about the elaborator.  That's interesting there's a sort of parallel implementation of a typechecker.  To check: once it passes the elaborator's typechecker, it's "correct," but then the elaborated term is certified by the kernel? (Barring complications you mentioned about terms that check in one but not the other, and vice versa.)</p>



<a name="203554826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203554826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203554826">(Jul 10 2020 at 20:32)</a>:</h4>
<p>Yes, the elaborator typechecker is at the level of "if it's not correct the user will get a really messy looking error so we'd really like it to be correct" rather than "if it's not correct then lean and possibly mathematics is fundamentally broken"</p>



<a name="203581482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203581482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203581482">(Jul 11 2020 at 05:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, is there a more detailed explanation of the elaborator typechecker somewhere?</p>
<p>Also, I thought "compiler" refers to the entire collection of parser, elaborator, kernel, etc. But does it only refer to the process of compiling to bytecode for evaluation?</p>



<a name="203581530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203581530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203581530">(Jul 11 2020 at 05:17)</a>:</h4>
<p>I'm using "compiler" to refer specifically to the lean -&gt; bytecode compiler. It's true that sometimes we also use the term "lean is compiling" for the overall process but it's more like a typechecker than a compiler at that level</p>



<a name="203581580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203581580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203581580">(Jul 11 2020 at 05:18)</a>:</h4>
<p>As for a more detailed explanation of the elaborator, nope it's just a whole mess of code that does what it does. I can give more specifics about parts of it if you want though</p>



<a name="203581589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203581589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203581589">(Jul 11 2020 at 05:19)</a>:</h4>
<p>(I should note that I learned most of what I know about the elaboration process by watching its behavior from the outside. I've done very little C++ hacking on it)</p>



<a name="203581643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203581643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203581643">(Jul 11 2020 at 05:21)</a>:</h4>
<p>Ok the specific question I have is: you suggested that the elaborator's type checker has knowledge of CIC. I was a bit surprised by this, since I would guess that within <code>begin ... end</code> blocks, it doesn't need any knowledge of this, since the types are things like <code>tactic unit</code> and <code>tactic expr</code>.</p>



<a name="203581950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203581950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203581950">(Jul 11 2020 at 05:32)</a>:</h4>
<p>Is it correct that the elaborator only needs knowledge of CIC in order to fill in implicit variables?</p>



<a name="203582094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582094">(Jul 11 2020 at 05:38)</a>:</h4>
<p><code>tactic unit</code> isn't making a lot of use of CIC but it's there. <code>tactic : Type -&gt; Type</code> and <code>unit : Type</code>, this is an application and you have to match the types</p>



<a name="203582105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582105">(Jul 11 2020 at 05:39)</a>:</h4>
<p>If you wanted to you could use a fancy dependent type for data structures in tactics, but it's not done most of the time because it isn't necessary</p>



<a name="203582106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582106">(Jul 11 2020 at 05:40)</a>:</h4>
<p>But look to haskell to see uses for various kinds of near-dependent types in programming applications</p>



<a name="203582127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582127">(Jul 11 2020 at 05:40)</a>:</h4>
<p>Doesn't the evaluation of a <code>tactic</code> involve elaborating the constructed terms?</p>



<a name="203582152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582152">(Jul 11 2020 at 05:40)</a>:</h4>
<p>There is a tactic called <code>to_expr : pexpr -&gt; tactic expr</code> that can be used to explicitly invoke the elaborator on a pre-term, but you don't have to use it</p>



<a name="203582200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582200">(Jul 11 2020 at 05:42)</a>:</h4>
<p>A tactic is responsible for producing fully elaborated terms, but it can also invent them from whole cloth. For example, <code>norm_num</code> and <code>ring</code> do this for efficiency reasons</p>



<a name="203582205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582205">(Jul 11 2020 at 05:43)</a>:</h4>
<p>By "fully elaborated" you mean, no implicit arguments?</p>



<a name="203582212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582212">(Jul 11 2020 at 05:43)</a>:</h4>
<p>No metavariables</p>



<a name="203582217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582217">(Jul 11 2020 at 05:43)</a>:</h4>
<p>Actually that's not quite true, a tactic can produce terms with metavariables but usually it will add them as subgoals before returning</p>



<a name="203582263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582263">(Jul 11 2020 at 05:44)</a>:</h4>
<p>if it doesn't you get a very user unfriendly error "term contains metavariables" which is not associated to the tactic</p>



<a name="203582267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582267">(Jul 11 2020 at 05:44)</a>:</h4>
<p>we've all learnt how the elaborator works without ever seeing the code</p>



<a name="203582270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582270">(Jul 11 2020 at 05:45)</a>:</h4>
<p>metavariables are the sequence <code>?M_1</code>, <code>?M_2</code>, ..., is that right?</p>



<a name="203582275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582275">(Jul 11 2020 at 05:45)</a>:</h4>
<p>That's how they get printed, yes</p>



<a name="203582321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582321">(Jul 11 2020 at 05:46)</a>:</h4>
<p>Is it correct to say that the kernel has an understanding of implicit arguments but not of meta variables?</p>



<a name="203582333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582333">(Jul 11 2020 at 05:47)</a>:</h4>
<p>Here's something I've been wondering: when exactly does a <code>begin ... end</code> block execute? I've been assuming Lean attempts to elaborate everything possible until it gets stuck in some sense, and then at this point it executes these blocks.  But, you're saying "term contains metavariables" is an error, so maybe getting stuck is not allowed: it has to be able to elaborate everything outside these blocks first.</p>



<a name="203582374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582374">(Jul 11 2020 at 05:48)</a>:</h4>
<p>Here's an example of a tactic that puts a metavariable in the term without making a goal for it, and as a result it appears to work fine but you get an error at the very end</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">bad_tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">split</span><span class="o">,</span>
  <span class="n">g</span><span class="bp">::</span><span class="n">gs</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">get_goals</span><span class="o">,</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">set_goals</span> <span class="n">gs</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- ⊢ p ∧ q</span>
  <span class="n">bad_tac</span><span class="o">,</span>
  <span class="c1">-- ⊢ q</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span> <span class="c1">-- tactic failed, result contains meta-variables</span>
</code></pre></div>



<a name="203582379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582379">(Jul 11 2020 at 05:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284606">Chris M</span> <a href="#narrow/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F/near/203582321">said</a>:</p>
<blockquote>
<p>Is it correct to say that the kernel has an understanding of implicit arguments but not of meta variables?</p>
</blockquote>
<p>To rephrase this, is it correct to say that after elaboration is finished, the elaborator has replaced all <code>begin ... end</code> blocks with proof terms, and has filled in all meta variables and implicit arguments?</p>



<a name="203582421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582421">(Jul 11 2020 at 05:50)</a>:</h4>
<p>Implicit arguments are an indication to insert a metavariable at this place in the application, which will then be inferred by unification or typeclass inference</p>



<a name="203582429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582429">(Jul 11 2020 at 05:51)</a>:</h4>
<p>A fully elaborated term contains no metavariables. It doesn't really make sense to say that they don't have implicit arguments because that's not a property of a term</p>



<a name="203582469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582469">(Jul 11 2020 at 05:52)</a>:</h4>
<p>But basically yes</p>



<a name="203582482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582482">(Jul 11 2020 at 05:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F/near/203582374">said</a>:</p>
<blockquote>
<p>Here's an example of a tactic that puts a metavariable in the term without making a goal for it, and as a result it appears to work fine but you get an error at the very end</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">bad_tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">split</span><span class="o">,</span>
  <span class="n">g</span><span class="bp">::</span><span class="n">gs</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">get_goals</span><span class="o">,</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">set_goals</span> <span class="n">gs</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- ⊢ p ∧ q</span>
  <span class="n">bad_tac</span><span class="o">,</span>
  <span class="c1">-- ⊢ q</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span> <span class="c1">-- tactic failed, result contains meta-variables</span>
</code></pre></div>


</blockquote>
<p>Is there a way to actually view the result that this tactic produces?</p>



<a name="203582485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582485">(Jul 11 2020 at 05:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F/near/203582333">said</a>:</p>
<blockquote>
<p>Here's something I've been wondering: when exactly does a <code>begin ... end</code> block execute? I've been assuming Lean attempts to elaborate everything possible until it gets stuck in some sense, and then at this point it executes these blocks.  But, you're saying "term contains metavariables" is an error, so maybe getting stuck is not allowed: it has to be able to elaborate everything outside these blocks first.</p>
</blockquote>
<p>Tactics are evaluated after most other parts of elaboration (they are delayed as long as possible, so that as much information as possible is available). There can still be metavariables in the term</p>



<a name="203582536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582536">(Jul 11 2020 at 05:55)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">result</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span><span class="o">,</span> <span class="c1">-- ?m_1</span>
  <span class="c1">-- ⊢ p ∧ q</span>
  <span class="n">bad_tac</span><span class="o">,</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">result</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span><span class="o">,</span> <span class="c1">-- ⟨?m_1, ?m_2⟩</span>
  <span class="c1">-- ⊢ q</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">result</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span><span class="o">,</span> <span class="c1">-- ⟨?m_1, h⟩</span>
<span class="kn">end</span> <span class="c1">-- tactic failed, result contains meta-variables</span>
</code></pre></div>



<a name="203582545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582545">(Jul 11 2020 at 05:55)</a>:</h4>
<p>Where exactly does the "term contains metavariables" happen? Is it at the end of a tactic block, or once all the tactic blocks are evaluated and the next stage detects metavariables still exist?</p>



<a name="203582591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582591">(Jul 11 2020 at 05:57)</a>:</h4>
<p>I'm actually not entirely sure. I think at the end of the tactic block: the tactic is initialized with the metavariable corresponding to the hole at the location of the begin-end, and at the end it is required to have unified that metavariable with some term that does not contain metavariables (except possibly metavariables from the external context, i.e. in the type of the term?)</p>



<a name="203582647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582647">(Jul 11 2020 at 05:59)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="k">begin</span>
  <span class="n">apply</span> <span class="n">h</span> <span class="bp">_</span><span class="o">,</span>
<span class="kn">end</span><span class="bp">⟩</span> <span class="c1">-- tactic failed, result contains meta-variables</span>
</code></pre></div>



<a name="203582684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582684">(Jul 11 2020 at 06:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> A quick reading of <code>elaborator::invoke_tactic</code> in <code>lean/src/frontends/lean/elaborator.cpp</code> suggests it's at the end of a tactic block.</p>



<a name="203582689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582689">(Jul 11 2020 at 06:00)</a>:</h4>
<p>a quick test reveals the same</p>



<a name="203582757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/203582757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#203582757">(Jul 11 2020 at 06:03)</a>:</h4>
<p>or if you prefer</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="k">begin</span>
    <span class="n">apply</span> <span class="n">h</span> <span class="bp">_</span>
  <span class="kn">end</span><span class="o">,</span> <span class="c1">-- tactic failed, result contains meta-variables</span>
  <span class="n">exact</span> <span class="mi">0</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="204786192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/204786192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#204786192">(Jul 23 2020 at 11:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F/near/203353541">said</a>:</p>
<blockquote>
<p><code>meta</code> turns off termination checks for recursive calls.</p>
</blockquote>
<p>I've been thinking more about this and want to test if I understand correctly what these "termination checks" are. Is the following correct?</p>
<p>By "termination checks" you are referring to the fact that Lean's type system doesn't allow for certain types of recursion. The halting problem is undecidable so Lean's recursion checking also rules out functions that halt, but basically it employs certain rules such that if the rules aren't satisfied, a term does not type check.</p>
<p>More specifically these rules are the following:</p>
<ol>
<li>
<p>Definitions of functions on "normal" types (non-inductive types) are not allowed any recursion whatsoever.</p>
</li>
<li>
<p>Definitions of functions on inductive types are allowed to recurse "backward" along the constructors, meaning for example that if there is a constructor <code>| intro : indType1 \to indType1</code> for inductive type <code>indType1</code>, then we can define a function <code>f</code> recursively by </p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">indType1</span> <span class="err">\</span><span class="n">to</span> <span class="n">indType1</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">...</span>
</code></pre></div>


<p>Where in the body of <code>f(intro (x))</code> we are only allowed to use <code>x</code> and not any newly constructors of <code>indType1</code></p>
<ol start="3">
<li>Any other recursion is forbidden without using the <code>meta</code> keyword.</li>
</ol>



<a name="204786661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/204786661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#204786661">(Jul 23 2020 at 11:55)</a>:</h4>
<p>Note that (unlike Coq) Lean's foundations don't have any notion of a "termination checker". Instead, the termination checks are a consequence of the equation compiler, which gets a bunch of equations and tries to figure out how to turn them into recursor applications. If you improve the equation compiler, the termination checks can change</p>



<a name="204787298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/What%20exactly%20does%20%60meta%20def%60%20do%3F/near/204787298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/What.20exactly.20does.20.60meta.20def.60.20do.3F.html#204787298">(Jul 23 2020 at 12:02)</a>:</h4>
<p>The equation compiler actually tries a few different compilation strategies on your definition, in order of generality:</p>
<ol>
<li>Definition by cases (non-recursive)</li>
<li>Structural recursion</li>
<li>Bounded recursion</li>
<li>Well founded recursion</li>
</ol>
<p>Actually it doesn't really use (2) even though that's the simplest compilation strategy, which sometimes leads to problems when (3) and (4) don't apply. But most of the time when you write a recursive definition (3) is doing the work, and the rules for (3) essentially match your description. For (4), the rule is that any recursive calls must be less according to the provided well founded relation. This is good for definitions where <code>f n</code> depends on <code>f (n / 2)</code>, for example.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/seq.20equality.20inductively.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html">seq equality inductively</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="241133079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241133079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241133079">(Jun 02 2021 at 10:56)</a>:</h4>
<p>Is there a way to prove that two <code>seq</code>s are equal by using an inductive approach?<br>
I have two sequences <code>s</code> and <code>s'</code> of which I know that <code>s.head = s'.head</code>, and I know that each element is determined by its predecessor alone.<br>
I don't know how to show <code>s = s'</code> from this though.</p>



<a name="241133337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241133337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241133337">(Jun 02 2021 at 10:59)</a>:</h4>
<p>I think using <code>seq.ext</code> and then performing induction on the index might work.</p>



<a name="241142714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241142714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241142714">(Jun 02 2021 at 12:44)</a>:</h4>
<p>Can you provide a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="241172121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241172121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241172121">(Jun 02 2021 at 16:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">evens</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">nums</span> <span class="o">:</span> <span class="n">seq</span> <span class="n">â„•</span><span class="o">)</span>
  <span class="o">(</span><span class="n">head</span> <span class="o">:</span> <span class="n">nums.head</span> <span class="bp">=</span> <span class="n">some</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">next</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">i</span><span class="o">,</span> <span class="n">nums.nth</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">nums.nth</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">nat.add</span> <span class="mi">2</span><span class="o">))</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">e</span> <span class="n">e'</span> <span class="o">:</span> <span class="n">evens</span><span class="o">)</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">e'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext1</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">seq.ext</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="241172172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241172172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241172172">(Jun 02 2021 at 16:14)</a>:</h4>
<p>The proof at the bottom is to demonstrate my current approach.</p>



<a name="241175758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241175758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241175758">(Jun 02 2021 at 16:41)</a>:</h4>
<p>This approach works, but you need to use what you know about e and e'.</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.seq.seq</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">evens</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">nums</span> <span class="o">:</span> <span class="n">seq</span> <span class="n">â„•</span><span class="o">)</span>
  <span class="o">(</span><span class="n">head</span> <span class="o">:</span> <span class="n">nums.head</span> <span class="bp">=</span> <span class="n">some</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">next</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">i</span><span class="o">,</span> <span class="n">nums.nth</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">nums.nth</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">nat.add</span> <span class="mi">2</span><span class="o">))</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">e</span> <span class="n">e'</span> <span class="o">:</span> <span class="n">evens</span><span class="o">)</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">e'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext1</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">seq.ext</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">change</span> <span class="n">e.nums.head</span> <span class="bp">=</span> <span class="n">e'.nums.head</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">e.head</span><span class="o">,</span> <span class="n">e'.head</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">e.next</span><span class="o">,</span> <span class="n">e'.next</span><span class="o">,</span> <span class="n">hn</span><span class="o">]</span>  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="241176406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241176406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241176406">(Jun 02 2021 at 16:46)</a>:</h4>
<p>I guess what I'm wondering is whether there exists a nice lemma that wraps up this induction approach?</p>



<a name="241176987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241176987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241176987">(Jun 02 2021 at 16:51)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/seq.coinduction">docs#seq.coinduction</a></p>



<a name="241177032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241177032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241177032">(Jun 02 2021 at 16:52)</a>:</h4>
<p>(seq is a "coinductive" type)</p>



<a name="241180213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241180213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241180213">(Jun 02 2021 at 17:16)</a>:</h4>
<p>it might not be obvious but <code>eq_of_bisim</code> is the general coinduction principle (<code>seq.coinduction</code> only applies when you have an appropriate function <code>fr</code>)</p>



<a name="241180484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241180484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241180484">(Jun 02 2021 at 17:18)</a>:</h4>
<p>well, actually for this theorem you probably want to use induction on the index since you have defined things in terms of <code>nth</code> instead of using the destructors <code>head</code> and <code>tail</code></p>



<a name="241353067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241353067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241353067">(Jun 03 2021 at 06:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/seq.20equality.20inductively/near/241177032">said</a>:</p>
<blockquote>
<p>(seq is a "coinductive" type)</p>
</blockquote>
<p>What does that mean (for non-mathematicians)/how does it manifest in Lean?<br>
I looked it up, but didn't understand the difference to inductive types.</p>



<a name="241353600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241353600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241353600">(Jun 03 2021 at 06:46)</a>:</h4>
<p>Trust me, mathematicians don't know anything about conductive types</p>



<a name="241353681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241353681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241353681">(Jun 03 2021 at 06:47)</a>:</h4>
<p>I was secretly hoping that the expected explanation from Adam would have been for mathematicians, to get an idea of what they are... <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="241357368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241357368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241357368">(Jun 03 2021 at 07:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/seq.20equality.20inductively/near/241353600">said</a>:</p>
<blockquote>
<p>Trust me, mathematicians don't know anything about conductive types</p>
</blockquote>
<p>I can't tell if the misspelling here is a joke...</p>



<a name="241405179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241405179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241405179">(Jun 03 2021 at 15:13)</a>:</h4>
<p>My flawed intuition is that inductive types are like colimits while coinductive types are like limits (in the categorical sense). There is a formal definition in terms of a terminal object which you can find on the nlab, which is probably even less helpful. </p>
<p>In less categorical terms, the defining property of an inductive type is the rule that tells you how to map out of it, while the defining property of a coinductive type tells you how to map into itâ€¦ I donâ€™t know if thatâ€™s helpful at all ðŸ˜•</p>



<a name="241406130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241406130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241406130">(Jun 03 2021 at 15:19)</a>:</h4>
<p>And of course this is the point of view of a mathematician who doesnâ€™t care about computations. A computer scientist will give you some other description in terms of infinite data and lazy evaluation or something ðŸ˜‰</p>



<a name="241432171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/seq%20equality%20inductively/near/241432171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/seq.20equality.20inductively.html#241432171">(Jun 03 2021 at 18:24)</a>:</h4>
<p>My naive mental picture always was that inductive means "the smallest type closed under these rules of construction", while coinductive means "the largest one". I don't know if that's entirely right</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
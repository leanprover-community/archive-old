---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html">`ite` with multiple decidable instances</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="273154544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273154544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273154544">(Feb 24 2022 at 21:54)</a>:</h4>
<p>So what would it take to make <code>finsupp</code> computable (or to make a computable replacement for <code>finsupp</code>)?  As <span class="user-mention" data-user-id="284160">@Eric Rodriguez</span>  notes (if I understand correctly), the noncomputability of finsupp is infecting things like <code>nat.factorization</code>, which in turn makes that less appealing than it might be.  For example, it seems reasonable to want to use <code>factorization</code> instead of <code>padic_val_nat</code> in <a href="https://github.com/leanprover-community/mathlib/pull/12254">#12254</a>, but we don't want to force other definitions in the file to be needlessly marked <code>noncomputable</code> just because of this design choice.</p>



<a name="273154786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273154786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273154786">(Feb 24 2022 at 21:56)</a>:</h4>
<p>Are these problems that go away if you write <code>noncomputable theory</code> at the top of your files?</p>



<a name="273154810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273154810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273154810">(Feb 24 2022 at 21:57)</a>:</h4>
<p>lol I was about to ping you, Reid <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="273155611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273155611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273155611">(Feb 24 2022 at 22:03)</a>:</h4>
<p>Yeah, I expect that would work for what's in this PR, but I'm not sure if that's compatible with the plans <span class="user-mention" data-user-id="282271">@Bolton Bailey</span> and <span class="user-mention" data-user-id="479997">@Sean Golinski</span> have for this file.</p>



<a name="273157581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273157581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273157581">(Feb 24 2022 at 22:20)</a>:</h4>
<p>I don't see how computability of <code>nat.factorization</code> could be relevant since it's just a thin wrapper around the computable <code>nat.factors</code> (and that uses an algorithm that you would never want to run anyways)</p>



<a name="273157648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273157648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273157648">(Feb 24 2022 at 22:21)</a>:</h4>
<p>But anyways <code>finsupp</code> is in a strange place that makes nobody happy, I think.</p>



<a name="273159283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273159283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273159283">(Feb 24 2022 at 22:37)</a>:</h4>
<p><code>multiset.to_finsupp</code> (used in nat.factorization) is noncomputable, but interestingly enough Eric W tells me this is due to the fact that it is an add-equiv - the equiv itself is computable</p>



<a name="273159363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273159363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273159363">(Feb 24 2022 at 22:38)</a>:</h4>
<p>You can get around this but it's mildly painful - see the proof of <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.rec_on_prime_pow">docs#nat.rec_on_prime_pow</a> for details</p>



<a name="273159387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273159387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273159387">(Feb 24 2022 at 22:38)</a>:</h4>
<p>That's really weird. <code>add_equiv</code> = <code>equiv</code> + Prop-fields</p>



<a name="273162674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273162674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273162674">(Feb 24 2022 at 23:09)</a>:</h4>
<p>The reason I like the idea of using <code>nat.factorization</code> is really that I just find it more readable than <code>padic_val_nat</code>, but I guess the algorithm I want to run is the <code>padic_val_nat</code> one. Perhaps a less painful way would be to simply redefine <code>nat.factorization</code> in terms of <code>padic_val_nat</code>, but perhaps there are other considerations at play.</p>



<a name="273162798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273162798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273162798">(Feb 24 2022 at 23:10)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>, the problem is the <code>has_add</code> argument to <code>@add_equiv.mk</code>, and the fact that <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.has_add">docs#finsupp.has_add</a> is noncomputable</p>



<a name="273162814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273162814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273162814">(Feb 24 2022 at 23:10)</a>:</h4>
<p>Ah okay, makes more sense</p>



<a name="273162853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273162853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273162853">(Feb 24 2022 at 23:10)</a>:</h4>
<p>Lean doesn't care that that <code>has_add</code> argument "isn't really part of the data", it's in the expression so the whole thing is poisoned</p>



<a name="273211231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273211231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273211231">(Feb 25 2022 at 10:21)</a>:</h4>
<p>can we not split this into a normal equiv and then an add equiv? and I guess we can make the normal equiv have a <code>map_add</code>, but that's kinda yucky...</p>



<a name="273386161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273386161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273386161">(Feb 27 2022 at 06:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances/near/273157581">said</a>:</p>
<blockquote>
<p>I don't see how computability of <code>nat.factorization</code> could be relevant since it's just a thin wrapper around the computable <code>nat.factors</code> (and that uses an algorithm that you would never want to run anyways)</p>
</blockquote>
<p>Not sure what you mean by this. The <code>nat.factors</code> algorithm uses trial division but besides that, for the range of numbers where trial division works well, the algorithm is reasonably computationally efficient and I don't know any easy wins to make it faster</p>



<a name="273392430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273392430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273392430">(Feb 27 2022 at 09:09)</a>:</h4>
<p>I think that number theorists would classify trial division as "an algorithm you would never want to run" but I'm not sure lean 3 is the place to be experimenting with better ones</p>



<a name="273392630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273392630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273392630">(Feb 27 2022 at 09:15)</a>:</h4>
<p>Trial division is the fastest algorithm for proving the primality of small primes. I implemented a more complicated and efficient algorithm in metamath but I realized it was a waste of time when the largest prime I needed was 4001 and a trial division proof was 10x smaller</p>



<a name="273392714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273392714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273392714">(Feb 27 2022 at 09:17)</a>:</h4>
<p>This is the same reason why <code>norm_num</code> uses the basic n^2 multiplication algorithm instead of FFT multiplication or Karatsuba multiplication</p>



<a name="273392722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273392722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273392722">(Feb 27 2022 at 09:17)</a>:</h4>
<p>you need stupidly large numbers for these algorithms to actually be worthwhile, numbers so large that many other things in lean would go wrong first</p>



<a name="273392789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273392789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273392789">(Feb 27 2022 at 09:19)</a>:</h4>
<p>I think the largest prime you needed might not be representative of the largest prime some of my friends will need if they want to do their kinds of maths in lean but I totally agree that trial division works fine for the kind of things we want to do (eg it enabled us to prove Bertrand's postulate)</p>



<a name="273392879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273392879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273392879">(Feb 27 2022 at 09:21)</a>:</h4>
<p>I think lean isn't ready for your friends' work for other reasons besides this. Lean 4 will be more prepared for a lot of this, not least because it uses GMP powered multiplication anyway</p>



<a name="273393003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273393003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273393003">(Feb 27 2022 at 09:24)</a>:</h4>
<p>Once mathlib4 is up and running, I'm sure we can port <a href="https://openresearch-repository.anu.edu.au/bitstream/1885/177195/1/thesis.pdf">the formalization of the AKS algorithm in HOL4</a> to lean as part of someone's bachelor thesis or similar</p>



<a name="273393110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273393110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273393110">(Feb 27 2022 at 09:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances/near/273392789">said</a>:</p>
<blockquote>
<p>I think the largest prime you needed might not be representative of the largest prime some of my friends will need if they want to do their kinds of maths in lean but I totally agree that trial division works fine for the kind of things we want to do (eg it enabled us to prove Bertrand's postulate)</p>
</blockquote>
<p>Actually, I am a bit curious about this. Do you have any concrete examples where large primes are needed in pure maths? (Cue joke about 57)</p>



<a name="273398942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273398942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273398942">(Feb 27 2022 at 11:41)</a>:</h4>
<p>Starting over from 2 each time you find a factor isn't great and you can get another constant factor by knowing primes mod 30 say but yes, it's not as bad as I expected.</p>



<a name="273399476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273399476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273399476">(Feb 27 2022 at 11:55)</a>:</h4>
<p>Oh, it isn't supposed to start over from 2</p>



<a name="273399955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273399955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273399955">(Feb 27 2022 at 12:03)</a>:</h4>
<p>it can be fixed, but I will wait for someone to complain about it</p>



<a name="273400033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273400033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273400033">(Feb 27 2022 at 12:04)</a>:</h4>
<p>I did something similar in the squarefree norm_num extension which does avoid starting over every time it finds a prime</p>



<a name="273401886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273401886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273401886">(Feb 27 2022 at 12:48)</a>:</h4>
<p>Mario, I am not sure if this counts as large, but in <a href="https://arxiv.org/abs/1110.1738#:~:text=We%20show%20that%20transcendental%20elements,can%20obstruct%20the%20Hasse%20principle.">this paper</a>, the authors use the factors of a 318 digit number to get their result.  Searching for <code>factor</code> yields some results in that paper and also see Section 5.1.</p>



<a name="273402045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273402045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273402045">(Feb 27 2022 at 12:52)</a>:</h4>
<p>The weak Goldbach work needs to verify quickly whether numbers with 30 digits are prime or not.</p>



<a name="273402710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273402710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273402710">(Feb 27 2022 at 13:06)</a>:</h4>
<p>Anyways, the point is that an awful algorithm is just as <code>computable</code> to Lean as a good one. I don't think having potentially awful algorithms to compute as many things in mathlib as possible is a useful goal, and I suspect that nobody would really be trying to add them if <code>noncomputable theory</code> was the default.</p>



<a name="273402730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273402730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273402730">(Feb 27 2022 at 13:07)</a>:</h4>
<p>"making <code>finsupp</code> computable" is not the right kind of goal, the correct goal should be "add data structure X which supports operations Y in time complexity Z, for use in algorithm W"</p>



<a name="273402934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273402934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273402934">(Feb 27 2022 at 13:12)</a>:</h4>
<p>And the definition of <code>nat.factorization</code> is going to (or at least should!) differ totally depending on whether it returns something computationally list-like or function-like--that is why I want to emphasize that computability is not a yes or no question.</p>



<a name="273403623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273403623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273403623">(Feb 27 2022 at 13:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances/near/273402710">said</a>:</p>
<blockquote>
<p>Anyways, the point is that an awful algorithm is just as <code>computable</code> to Lean as a good one. I don't think having potentially awful algorithms to compute as many things in mathlib as possible is a useful goal, and I suspect that nobody would really be trying to add them if <code>noncomputable theory</code> was the default.</p>
</blockquote>
<p>While I agree with you for the most part, having awful algorithms to compute lots of things is actually helpful if you want to use <code>dec_trivial</code> to prove trivial things</p>



<a name="273403990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273403990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273403990">(Feb 27 2022 at 13:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances/near/273401886">said</a>:</p>
<blockquote>
<p>Mario, I am not sure if this counts as large, but in <a href="https://arxiv.org/abs/1110.1738#:~:text=We%20show%20that%20transcendental%20elements,can%20obstruct%20the%20Hasse%20principle.">this paper</a>, the authors use the factors of a 318 digit number to get their result.  Searching for <code>factor</code> yields some results in that paper and also see Section 5.1.</p>
</blockquote>
<p>For a theorem like that, I would first reduce to the problem of proving primality of the (given) factors (so don't bother to compute <code>nat.factors</code> directly). The more advanced method for primality proving I used in metamath is <a href="https://en.wikipedia.org/wiki/Pocklington_primality_test">Pocklington certificates</a>, although it is hard to guess in advance whether a given prime number will be broken down into small primes by this method. Once the primes are about 6 digits or so I would use the usual trial division approach to finish it off.</p>



<a name="273420590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273420590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273420590">(Feb 27 2022 at 19:24)</a>:</h4>
<p>In the specific paper above they show that 809147864157687938441948148614369785987783654943839689121548451<br>
788111145202992792430023470932052297439515068068797124401938255<br>
799311490342451172887433057574480263654457987109316488649107 is prime by using elliptic curve primality testing.  This should yield a verifiable certificate, though verifying the certificate might also be computationally intensive, in this case, I'm not sure.</p>



<a name="273420979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%60ite%60%20with%20multiple%20decidable%20instances/near/273420979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances.html#273420979">(Feb 27 2022 at 19:31)</a>:</h4>
<p>Primality algorithms generally perform worse than <a href="https://en.wikipedia.org/wiki/Primality_certificate">primality certificates</a> when the goal is certification. Some primality certificates require prime factorizations of smaller numbers though, so it can be considerably harder to generate a certificate than to check primality directly</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
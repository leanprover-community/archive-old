---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Type.20.3A.20Type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html">Type : Type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="199740926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199740926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mateusz Zugaj <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199740926">(Jun 04 2020 at 12:48)</a>:</h4>
<p>What would happen if Type was of the type Type? I tried to make some sort of Russell's paradox out of this, but I cannot define a type T made of things that are not their own type.</p>



<a name="199741040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199741040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mateusz Zugaj <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199741040">(Jun 04 2020 at 12:49)</a>:</h4>
<p>Sorry for a noob question</p>



<a name="199741483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199741483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199741483">(Jun 04 2020 at 12:52)</a>:</h4>
<p>Which type are you talking about when you say <code>Type</code>? I think you mean <code>Type u</code> for some universe <code>u</code></p>



<a name="199741520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199741520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199741520">(Jun 04 2020 at 12:53)</a>:</h4>
<p><code>Type u</code> has type <code>Type (u +1)</code></p>



<a name="199741650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199741650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199741650">(Jun 04 2020 at 12:54)</a>:</h4>
<p>When I type <code>#check Type</code> into VSCode it decides that I'm talking about <code>Type 1</code></p>



<a name="199741893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199741893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199741893">(Jun 04 2020 at 12:56)</a>:</h4>
<p>If you use a recent enough Lean 3, I think the universe checks are disabled for <code>meta</code> inductive definitions, and then you can try to write your paradox.</p>



<a name="199741926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199741926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mateusz Zugaj <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199741926">(Jun 04 2020 at 12:56)</a>:</h4>
<p>Yes, and I want to understand the need for "+1" in Type u : Type (u+1)</p>



<a name="199742064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199742064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mateusz Zugaj <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199742064">(Jun 04 2020 at 12:57)</a>:</h4>
<p>Why there cannot be a type of all types?</p>



<a name="199742218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199742218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199742218">(Jun 04 2020 at 12:58)</a>:</h4>
<p>are you asking a question about Lean's type theory or a question about type theories in general?</p>



<a name="199742431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199742431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199742431">(Jun 04 2020 at 13:00)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="kn">inductive</span> <span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">â†’</span> <span class="n">T</span>
</code></pre></div>


<p>With a recent enough version, Lean will accept this and then you can implement the usual paradoxes.</p>



<a name="199742596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199742596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199742596">(Jun 04 2020 at 13:01)</a>:</h4>
<p>What's the shortest meta proof of false?</p>



<a name="199742800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199742800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199742800">(Jun 04 2020 at 13:03)</a>:</h4>
<p><code>meta def a : false := a</code>, but this isn't very exciting</p>



<a name="199746907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199746907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mateusz Zugaj <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199746907">(Jun 04 2020 at 13:33)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span>  The question is about Lean's type theory, but I suppose the answer to the general question should be the same.</p>



<a name="199747215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199747215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199747215">(Jun 04 2020 at 13:35)</a>:</h4>
<p>well, the answer for Lean's type theory is going to be something like "Lean requires the judgement relation <code>:</code> to be well-founded"<br>
(with the caveat that I don't know whether the thing I'm saying is literally true. one can do real maths in Lean without understanding its type theory on a deep level)</p>



<a name="199747360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199747360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199747360">(Jun 04 2020 at 13:36)</a>:</h4>
<p>whereas for general type theory it's going to be "well-founded judgement relations enjoy nice properties that ill-founded ones in general do not"</p>



<a name="199747974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199747974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199747974">(Jun 04 2020 at 13:40)</a>:</h4>
<p>I thought we had a proof in mathlib that <code>Type (u+1)</code> is bigger than <code>Type u</code>, but it's not easy to search for.</p>



<a name="199748040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199748040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mateusz Zugaj <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199748040">(Jun 04 2020 at 13:41)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span> "ill-founded ones in general do not" - so it's not like we have a paradox instantly, just some bad behaviour?</p>



<a name="199748068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199748068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199748068">(Jun 04 2020 at 13:41)</a>:</h4>
<p>No, there really is a paradox.</p>



<a name="199748291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199748291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199748291">(Jun 04 2020 at 13:42)</a>:</h4>
<p>I was speaking mildly to avoid saying false things. Reid knows more than me and can speak more decisively.</p>



<a name="199749136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199749136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199749136">(Jun 04 2020 at 13:48)</a>:</h4>
<p>Although it's not super easy to see, it follows from <a href="https://github.com/leanprover-community/mathlib/blob/e397b4c/src/set_theory/ordinal.lean#L1855-L1868">https://github.com/leanprover-community/mathlib/blob/e397b4c/src/set_theory/ordinal.lean#L1855-L1868</a> that each universe has more ordinals than the previous one</p>



<a name="199749972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199749972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199749972">(Jun 04 2020 at 13:55)</a>:</h4>
<p>So, in Lean, you can prove <code>not (Type u = Type (u+1))</code>, and that should be pretty convincing that <code>Type : Type</code> would lead to inconsistency</p>



<a name="199752501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199752501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mateusz Zugaj <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199752501">(Jun 04 2020 at 14:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  Yes, that is convincing. The one more bit I'm missing is what exactly universes are, and why not u+1 = u. But that (I hope) I will learn from tutorials</p>



<a name="199752928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199752928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199752928">(Jun 04 2020 at 14:15)</a>:</h4>
<p>i don't think the tutorials try to teach you that, since it's not very necessary for typical lean use cases</p>



<a name="199753271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199753271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199753271">(Jun 04 2020 at 14:18)</a>:</h4>
<p>I'm not sure what your background is, but for most people it's probably better to start out by taking on faith that <code>Type : Type</code> would lead to inconsistencies which are avoided by introducing universe levels.</p>



<a name="199754114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199754114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mateusz Zugaj <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199754114">(Jun 04 2020 at 14:23)</a>:</h4>
<p>So one of my takeaways is that in ZFC it is really easy to say why the set of all sets doesn't exists, but it turns out that in type theory that it isn't so easy to say why there is not a type of all types, right?</p>



<a name="199755593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199755593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199755593">(Jun 04 2020 at 14:34)</a>:</h4>
<p>Yeah, somehow the global membership concept gives you easier access to these paradoxes. I guess another way to prove it in Lean should be to use its model of ZFC, and then run a proof that there is no set of all sets there.</p>



<a name="199756203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199756203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199756203">(Jun 04 2020 at 14:37)</a>:</h4>
<p>If you like ZFC then you may also want to think of the "intended model" of Lean as fixing a sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">U</mi><mn>0</mn></msub><mo>âˆˆ</mo><msub><mi mathvariant="script">U</mi><mn>1</mn></msub><mo>âˆˆ</mo><mo>â‹¯</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}_0 \in \mathcal{U}_1 \in \cdots</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">U</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">âˆˆ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">U</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">âˆˆ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">â‹¯</span></span></span></span> of Grothendieck universes, thinking of universe levels as external natural numbers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>â€¦</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0, 1, \ldots\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">â€¦</span><span class="mclose">}</span></span></span></span>, and interpreting a type of type <code>Type u</code> as a set belonging to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">U</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{U}_u</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">U</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>



<a name="199759621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199759621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David WÃ¤rn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199759621">(Jun 04 2020 at 15:00)</a>:</h4>
<p>You should be able to derive a quick contradiction from <code>Type : Type</code> using Cantor?<br>
Let <code>K := Î£ Î± : Type, Î±</code>. Any <code>Î± : Type</code> injects into <code>K</code>. So assuming <code>Type : Type</code>, we get that <code>set K</code> embeds into <code>K</code>.</p>



<a name="199761016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199761016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199761016">(Jun 04 2020 at 15:09)</a>:</h4>
<p>well Cantor's Theorem (or Russell's paradox) is that there is no surjection from <code>A</code> to <code>P(A)</code> right</p>



<a name="199761055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199761055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199761055">(Jun 04 2020 at 15:09)</a>:</h4>
<p>but I guess you can noncomputably construct a surjection from an injection the other way</p>



<a name="199763397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199763397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199763397">(Jun 04 2020 at 15:24)</a>:</h4>
<p>You can constructively prove there's no injection from the powerset.</p>



<a name="199763966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199763966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199763966">(Jun 04 2020 at 15:28)</a>:</h4>
<p>how?</p>



<a name="199766749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199766749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199766749">(Jun 04 2020 at 15:45)</a>:</h4>
<p>i think this is constructive:</p>
<p>given f : set \a \to \a,<br>
make g (x : set \a) : \set \a := {a | \ex y \sub x, f y = a}</p>
<p>g has a least fixpoint x := \bigcup_n g^n \emptyset</p>
<p>f (g x) = f x \in x</p>
<p>since f x \in x, we must have f x \in g^n \emptyset for some finite n, contradicting injectivity</p>



<a name="199769567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199769567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David WÃ¤rn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199769567">(Jun 04 2020 at 16:02)</a>:</h4>
<p>A formal proof:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">def</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span> <span class="o">:=</span> <span class="err">Î£</span> <span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span> <span class="n">Î±</span>

<span class="n">def</span> <span class="n">embed_sum</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">Î±</span> <span class="bp">â†’</span> <span class="n">K</span> <span class="o">:=</span> <span class="bp">Î»</span> <span class="n">a</span><span class="o">,</span> <span class="bp">âŸ¨</span><span class="n">Î±</span><span class="o">,</span> <span class="n">a</span><span class="bp">âŸ©</span>

<span class="kn">lemma</span> <span class="n">embed_inj</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="o">(</span><span class="n">embed_sum</span> <span class="n">Î±</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tidy</span>

<span class="kn">theorem</span> <span class="n">cantor</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span> <span class="bp">â†’</span> <span class="n">Î±</span><span class="o">)</span>
  <span class="o">(</span><span class="n">inj</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="bp">âˆƒ</span> <span class="n">t</span><span class="o">,</span> <span class="n">f</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">âˆ§</span> <span class="bp">Â¬</span> <span class="n">x</span> <span class="err">âˆˆ</span> <span class="n">t</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">not_mem</span> <span class="o">:</span> <span class="bp">Â¬</span> <span class="n">f</span> <span class="n">s</span> <span class="err">âˆˆ</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="bp">Â¬</span> <span class="n">f</span> <span class="n">s</span> <span class="err">âˆˆ</span> <span class="n">s</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="n">h</span> <span class="o">},</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">âŸ¨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">hn</span><span class="bp">âŸ©</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="n">inj</span> <span class="n">ht</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">is_mem</span> <span class="o">:</span> <span class="n">f</span> <span class="n">s</span> <span class="err">âˆˆ</span> <span class="n">s</span> <span class="o">:=</span> <span class="bp">âŸ¨</span><span class="n">s</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">not_mem</span><span class="bp">âŸ©</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">not_mem</span> <span class="n">is_mem</span><span class="o">,</span>
<span class="kn">end</span>

<span class="c1">-- fails due to some issue with universes...</span>
<span class="c1">-- theorem falso : false :=</span>
<span class="c1">-- cantor (set K) (embed_sum K) (embed_inj K)</span>
</code></pre></div>



<a name="199774749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199774749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199774749">(Jun 04 2020 at 16:40)</a>:</h4>
<p>FWIW if you're interested in the <em>general</em> question of Type in Type, rather than how it applies to Lean, I found <a href="http://liamoc.net/posts/2015-09-10-girards-paradox.html">http://liamoc.net/posts/2015-09-10-girards-paradox.html</a> very clear</p>



<a name="199774829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20%3A%20Type/near/199774829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20.3A.20Type.html#199774829">(Jun 04 2020 at 16:41)</a>:</h4>
<p>Although I can read Agda, so I can't promise it's readable to people who haven't spent ages learning the syntax of Agda :P</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
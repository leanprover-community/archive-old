---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/support_add.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html">support_add</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209128481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209128481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209128481">(Sep 04 2020 at 18:49)</a>:</h4>
<p>Dear All,</p>
<p>I am trying to get Lean to check that the support of the sum of two polynomials is contained in the union of the supports.  I found the command <code>finsupp.support_add</code>, claiming to do exactly this.  Unfortunately, with the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> below, I get an error.  I imagine that Lean has coerced something in the wrong type, but I have been unable to figure out what...</p>
<p>Can someone help me, please?</p>
<p>Thank you!</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">polynomial</span><span class="bp">.</span><span class="n">degree</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">lemma</span> <span class="n">supps</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span><span class="bp">+</span><span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">exact</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">support_add</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>Error (with <code>finsupp</code> underlined in red in the code):</p>
<div class="codehilite"><pre><span></span><code><span class="n">invalid</span> <span class="n">type</span> <span class="n">ascription</span><span class="o">,</span> <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="o">(</span><span class="err">?</span><span class="n">m_4</span> <span class="bp">+</span> <span class="err">?</span><span class="n">m_5</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="err">⊆</span> <span class="err">?</span><span class="n">m_4</span><span class="bp">.</span><span class="n">support</span> <span class="err">∪</span> <span class="err">?</span><span class="n">m_5</span><span class="bp">.</span><span class="n">support</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="o">(</span><span class="n">p</span> <span class="bp">+</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">support</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">field</span> <span class="n">R</span><span class="o">,</span>
<span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span>
<span class="err">⊢</span> <span class="o">(</span><span class="n">p</span> <span class="bp">+</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">support</span>
</code></pre></div>



<a name="209128702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209128702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209128702">(Sep 04 2020 at 18:51)</a>:</h4>
<p><code>convert finsupp.support_add,</code> does it</p>



<a name="209128865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209128865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209128865">(Sep 04 2020 at 18:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  Thank you so much!!  I wasted so much time trying to figure out what types Lean was inferring!!</p>



<a name="209128919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209128919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209128919">(Sep 04 2020 at 18:53)</a>:</h4>
<p>What is <code>convert</code>?</p>



<a name="209128953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209128953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209128953">(Sep 04 2020 at 18:53)</a>:</h4>
<p><code>#check convert</code> says unknown identifier...</p>



<a name="209129018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209129018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209129018">(Sep 04 2020 at 18:54)</a>:</h4>
<p><code>exact @finsupp.support_add _ _ _ p q,</code> gives the following error:</p>
<div class="codehilite"><pre><span></span><code>invalid type ascription, term has type
  (p + q).support ⊆
    @finsupp.support ℕ R
        (@add_monoid.to_has_zero R
           (@add_group.to_add_monoid R
              (@add_comm_group.to_add_group R
                 (@ring.to_add_comm_group R (@division_ring.to_ring R (@field.to_division_ring R _inst_1))))))
        p ∪
      @finsupp.support ℕ R
        (@add_monoid.to_has_zero R
           (@add_group.to_add_monoid R
              (@add_comm_group.to_add_group R
                 (@ring.to_add_comm_group R (@division_ring.to_ring R (@field.to_division_ring R _inst_1))))))
        q
but is expected to have type
  @finsupp.support ℕ R
      (@mul_zero_class.to_has_zero R
         (@monoid_with_zero.to_mul_zero_class R
            (@semiring.to_monoid_with_zero R
               (@ring.to_semiring R (@division_ring.to_ring R (@field.to_division_ring R _inst_1))))))
      (p + q) ⊆
    @finsupp.support ℕ R
        (@mul_zero_class.to_has_zero R
           (@monoid_with_zero.to_mul_zero_class R
              (@semiring.to_monoid_with_zero R
                 (@ring.to_semiring R (@division_ring.to_ring R (@field.to_division_ring R _inst_1))))))
        p ∪
      @finsupp.support ℕ R
        (@mul_zero_class.to_has_zero R
           (@monoid_with_zero.to_mul_zero_class R
              (@semiring.to_monoid_with_zero R
                 (@ring.to_semiring R (@division_ring.to_ring R (@field.to_division_ring R _inst_1))))))
        q
</code></pre></div>


<p>and we can see if we can debug this.</p>



<a name="209129045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209129045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209129045">(Sep 04 2020 at 18:54)</a>:</h4>
<p><code>convert</code> is a tactic, so <code>#check</code> doesn't work. You can hover over it to see the docstring.</p>



<a name="209129106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209129106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209129106">(Sep 04 2020 at 18:55)</a>:</h4>
<p>See also <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#convert">tactic#convert</a></p>



<a name="209129130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209129130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209129130">(Sep 04 2020 at 18:55)</a>:</h4>
<p>They do look different, but I do not know why...</p>



<a name="209129231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209129231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209129231">(Sep 04 2020 at 18:56)</a>:</h4>
<p>Me neither -- this is what type class inference is doing under the hood.</p>



<a name="209129312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209129312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209129312">(Sep 04 2020 at 18:57)</a>:</h4>
<p>Ok, anyway, I am glad that I learned how to see what Lean is doing and I will now learn <code>convert</code>!</p>



<a name="209129553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209129553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209129553">(Sep 04 2020 at 18:59)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">X</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support</span> <span class="bp">ℕ</span> <span class="n">R</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">to_has_zero</span> <span class="n">R</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">add_group</span><span class="bp">.</span><span class="n">to_add_monoid</span> <span class="n">R</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_group</span><span class="bp">.</span><span class="n">to_add_group</span> <span class="n">R</span>
                 <span class="o">(</span><span class="bp">@</span><span class="n">ring</span><span class="bp">.</span><span class="n">to_add_comm_group</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">division_ring</span><span class="bp">.</span><span class="n">to_ring</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">field</span><span class="bp">.</span><span class="n">to_division_ring</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">))))))</span>

<span class="n">def</span> <span class="n">Y</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support</span> <span class="bp">ℕ</span> <span class="n">R</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">mul_zero_class</span><span class="bp">.</span><span class="n">to_has_zero</span> <span class="n">R</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">monoid_with_zero</span><span class="bp">.</span><span class="n">to_mul_zero_class</span> <span class="n">R</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">semiring</span><span class="bp">.</span><span class="n">to_monoid_with_zero</span> <span class="n">R</span>
                 <span class="o">(</span><span class="bp">@</span><span class="n">ring</span><span class="bp">.</span><span class="n">to_semiring</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">division_ring</span><span class="bp">.</span><span class="n">to_ring</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">field</span><span class="bp">.</span><span class="n">to_division_ring</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">))))))</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">X</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">Y</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>


<p>So those outputs were more similar than we thought.</p>



<a name="209129706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209129706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209129706">(Sep 04 2020 at 19:01)</a>:</h4>
<p>I interpret this as Lean having found 2 separate ways of loosing information to obtain a semi-quasi-almost-monoid and then being confused about why they are the same... is this more or less correct?</p>



<a name="209129922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209129922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209129922">(Sep 04 2020 at 19:03)</a>:</h4>
<p>Well, exact is failing so there are some things which really are not equal by definition. We have to dig deeper:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">polynomial</span><span class="bp">.</span><span class="n">degree</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">}</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">all</span> <span class="n">true</span> <span class="c1">-- NEW</span>

<span class="kn">lemma</span> <span class="n">supps</span>  <span class="o">:</span> <span class="o">(</span><span class="n">p</span><span class="bp">+</span><span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">exact</span> <span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support_add</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="209130288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209130288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209130288">(Sep 04 2020 at 19:06)</a>:</h4>
<p>Btw, also assuming <code>semiring</code> things do not work with <code>exact</code>: that might have less overhead of conversion...</p>



<a name="209130379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209130379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209130379">(Sep 04 2020 at 19:07)</a>:</h4>
<p>(I'm feeding my cats, so I can only type with my phone for a couple minutes!)</p>



<a name="209130511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209130511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209130511">(Sep 04 2020 at 19:08)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">polynomial</span><span class="bp">.</span><span class="n">degree</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">}</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">all</span> <span class="n">true</span>

<span class="kn">lemma</span> <span class="n">supps</span>  <span class="o">:</span> <span class="o">(</span><span class="n">p</span><span class="bp">+</span><span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">exact</span> <span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support_add</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
<span class="kn">end</span>


<span class="n">def</span> <span class="n">X</span> <span class="o">:=</span>  <span class="bp">@</span><span class="n">has_subset</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">has_subset</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">nat</span> <span class="n">R</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">to_has_zero</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_monoid</span><span class="bp">.</span><span class="n">to_add_monoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">semiring</span><span class="bp">.</span><span class="n">to_add_comm_monoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">has_add</span><span class="bp">.</span><span class="n">add</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">nat</span> <span class="n">R</span>
             <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">to_has_zero</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span>
                <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_monoid</span><span class="bp">.</span><span class="n">to_add_monoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">semiring</span><span class="bp">.</span><span class="n">to_add_comm_monoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">))))</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">has_add</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">nat</span> <span class="n">R</span>
             <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_monoid</span><span class="bp">.</span><span class="n">to_add_monoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">semiring</span><span class="bp">.</span><span class="n">to_add_comm_monoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)))</span>
          <span class="n">p</span>
          <span class="n">q</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">has_union</span><span class="bp">.</span><span class="n">union</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">has_union</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span> <span class="o">(</span><span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="n">a</span> <span class="n">b</span><span class="o">)))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">nat</span> <span class="n">R</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">to_has_zero</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span>
             <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_monoid</span><span class="bp">.</span><span class="n">to_add_monoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">semiring</span><span class="bp">.</span><span class="n">to_add_comm_monoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)))</span>
          <span class="n">p</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">nat</span> <span class="n">R</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">to_has_zero</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span>
             <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_monoid</span><span class="bp">.</span><span class="n">to_add_monoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">semiring</span><span class="bp">.</span><span class="n">to_add_comm_monoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)))</span>
          <span class="n">q</span><span class="o">))</span>

<span class="n">def</span> <span class="n">Y</span> <span class="o">:=</span>  <span class="bp">@</span><span class="n">has_subset</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">has_subset</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">nat</span> <span class="n">R</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">mul_zero_class</span><span class="bp">.</span><span class="n">to_has_zero</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">monoid_with_zero</span><span class="bp">.</span><span class="n">to_mul_zero_class</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">semiring</span><span class="bp">.</span><span class="n">to_monoid_with_zero</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">has_add</span><span class="bp">.</span><span class="n">add</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="o">(</span><span class="bp">@</span><span class="n">polynomial</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">distrib</span><span class="bp">.</span><span class="n">to_has_add</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="o">(</span><span class="bp">@</span><span class="n">polynomial</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span>
             <span class="o">(</span><span class="bp">@</span><span class="n">semiring</span><span class="bp">.</span><span class="n">to_distrib</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="o">(</span><span class="bp">@</span><span class="n">polynomial</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">polynomial</span><span class="bp">.</span><span class="n">semiring</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)))</span>
          <span class="n">p</span>
          <span class="n">q</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">has_union</span><span class="bp">.</span><span class="n">union</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">has_union</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat</span><span class="bp">.</span><span class="n">decidable_eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">nat</span> <span class="n">R</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">mul_zero_class</span><span class="bp">.</span><span class="n">to_has_zero</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span>
             <span class="o">(</span><span class="bp">@</span><span class="n">monoid_with_zero</span><span class="bp">.</span><span class="n">to_mul_zero_class</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">semiring</span><span class="bp">.</span><span class="n">to_monoid_with_zero</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)))</span>
          <span class="n">p</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">nat</span> <span class="n">R</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">mul_zero_class</span><span class="bp">.</span><span class="n">to_has_zero</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span>
             <span class="o">(</span><span class="bp">@</span><span class="n">monoid_with_zero</span><span class="bp">.</span><span class="n">to_mul_zero_class</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">semiring</span><span class="bp">.</span><span class="n">to_monoid_with_zero</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)))</span>
          <span class="n">q</span><span class="o">))</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">X</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">Y</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails</span>
</code></pre></div>



<a name="209130543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209130543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209130543">(Sep 04 2020 at 19:08)</a>:</h4>
<p>In case it's helpful, I've expanded out <code>convert</code> as tactics:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">supps</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">+</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support_add</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">eq</span><span class="bp">.</span><span class="n">mpr</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="209130578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209130578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209130578">(Sep 04 2020 at 19:09)</a>:</h4>
<p>Now it's <code>congr</code> that's doing the heavy lifting, somehow.</p>



<a name="209131010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209131010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209131010">(Sep 04 2020 at 19:13)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">X</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">Y</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">X</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">Y</span><span class="o">,</span>
  <span class="c1">-- refl, -- fails</span>
  <span class="n">congr&#39;</span> <span class="c1">-- works</span>
<span class="kn">end</span>
</code></pre></div>


<p>Right, so you've got to the same stage as me but without the ugly staring at types. Nice!</p>



<a name="209131185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209131185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209131185">(Sep 04 2020 at 19:14)</a>:</h4>
<p>I've gotten down to <code>finset.has_union</code> not equaling <code>finset.has_union</code> by <code>refl</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">supps</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">+</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support_add</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">eq</span><span class="bp">.</span><span class="n">mpr</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">congr_core&#39;</span><span class="o">,</span>
  <span class="c1">-- finset ℕ = finset ℕ</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="c1">-- finset.has_subset = finset.has_subset</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="c1">-- (p + q).support = (p + q).support</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="c1">-- p.support ∪ q.support = p.support ∪ q.support</span>
  <span class="c1">-- refl doesn&#39;t work!</span>
  <span class="n">congr_core&#39;</span><span class="o">,</span>
  <span class="c1">-- finset ℕ = finset ℕ</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="c1">-- p.support = p.support</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="c1">-- q.support = q.support</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="c1">-- finset.has_union = finset.has_union</span>
  <span class="c1">-- refl doesn&#39;t work!</span>

<span class="kn">end</span>
</code></pre></div>



<a name="209131266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209131266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209131266">(Sep 04 2020 at 19:15)</a>:</h4>
<p>Here's another way:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">supps</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">+</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support_add</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">eq</span><span class="bp">.</span><span class="n">mpr</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">congr&#39;</span> <span class="mi">2</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span> <span class="c1">-- fails</span>
<span class="kn">end</span>
</code></pre></div>


<p>Note <code>congr' 3</code> solves the goal.</p>



<a name="209131285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209131285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209131285">(Sep 04 2020 at 19:15)</a>:</h4>
<p>It looks like it's the decidability proof for finset's union:</p>
<div class="codehilite"><pre><span></span><code><span class="err">⊢</span> <span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">has_union</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">))</span> <span class="o">(</span><span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">has_union</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat</span><span class="bp">.</span><span class="n">decidable_eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">has_union</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span> <span class="o">(</span><span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="n">a</span> <span class="n">b</span><span class="o">)))</span>
</code></pre></div>



<a name="209131357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209131357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209131357">(Sep 04 2020 at 19:16)</a>:</h4>
<p>Can I say that <code>finset</code>s are evil?  They <em>always</em> cause problems for me...</p>



<a name="209131377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209131377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209131377">(Sep 04 2020 at 19:16)</a>:</h4>
<p>just put <code>open_locale classical</code> at the beginning</p>



<a name="209131427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209131427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209131427">(Sep 04 2020 at 19:17)</a>:</h4>
<p>edit: still doesn't work</p>



<a name="209131430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209131430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209131430">(Sep 04 2020 at 19:17)</a>:</h4>
<p>So <span class="user-mention" data-user-id="321459">@Damiano Testa</span> the solution is that <code>nat.decidable_eq a b</code> is not equal <em>by definition</em> to <code>classical.prop_decidable (@eq.{1} nat a b)</code>.</p>



<a name="209131529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209131529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209131529">(Sep 04 2020 at 19:18)</a>:</h4>
<p>Ok, I am not sure that I understand, but at least I am getting a sense of what is happening...</p>



<a name="209131672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209131672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209131672">(Sep 04 2020 at 19:20)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">decidable_eq</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span> <span class="o">(</span><span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">subsingleton</span> <span class="o">(</span><span class="n">decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">))</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span> <span class="c1">-- works</span>
</code></pre></div>


<p>This is why <code>exact</code> fails but <code>convert</code> works.</p>



<a name="209131917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209131917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209131917">(Sep 04 2020 at 19:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> are your two examples equivalent mathematically?  I do not really understand what they say...</p>



<a name="209131952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209131952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209131952">(Sep 04 2020 at 19:22)</a>:</h4>
<p>It turns out that the two terms were not exactly the same. Lean's type class inference system fills in a lot of missing information for you -- that's its job. When you have (a b : nat) and write <code>a + b</code> this literally means <code>has_add.add a b</code>. Lean now has to figure out exactly the addition you mean, and it asks the type class inference system for an addition on the naturals, and the type class inference system returns one. </p>
<p>When you were trying to use the finsupp lemma to prove a result about polynomials, Lean twice had to ask the type class inference system for a proof that it is possible to decide whether two naturals are equal -- first when you stated the theorem, and secondly when you used the term that you hoped would prove it. However it got two different answers.</p>



<a name="209132019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132019">(Sep 04 2020 at 19:23)</a>:</h4>
<p>Ok, this is clearer, thanks!</p>



<a name="209132111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132111">(Sep 04 2020 at 19:24)</a>:</h4>
<p>By the way, the reason it's asking for this is that for finitely supported functions, the way they are implemented, the support is part of the data, and for Lean to figure out exactly which naturals are in the support it needs an algorithm to work out if two naturals are equal. It found two algorithms.</p>



<a name="209132151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132151">(Sep 04 2020 at 19:25)</a>:</h4>
<p>I had thought that the issue was with identifying the supports of the sum and the individual supports as being sets in the same ambient space...  If I understand correctly, the issue was at a deeper level</p>



<a name="209132171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132171">(Sep 04 2020 at 19:25)</a>:</h4>
<p>The first one is <code>nat.decidable_eq</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">zero</span>     <span class="n">zero</span>     <span class="o">:=</span> <span class="n">is_true</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="n">zero</span>     <span class="o">:=</span> <span class="n">is_false</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">no_confusion</span> <span class="n">h</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">zero</span>     <span class="o">(</span><span class="n">succ</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">is_false</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">no_confusion</span> <span class="n">h</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">decidable_eq</span> <span class="n">x</span> <span class="n">y</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">is_true</span> <span class="n">xeqy</span> <span class="o">:=</span> <span class="n">is_true</span> <span class="o">(</span><span class="n">xeqy</span> <span class="bp">▸</span> <span class="n">eq</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">))</span>
    <span class="bp">|</span> <span class="n">is_false</span> <span class="n">xney</span> <span class="o">:=</span> <span class="n">is_false</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">no_confusion</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">xeqy</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">xeqy</span> <span class="n">xney</span><span class="o">))</span>
    <span class="kn">end</span>
</code></pre></div>


<p>This is the algorithm which uses induction: zero = zero, and succ m = succ n iff m = n.</p>



<a name="209132347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132347">(Sep 04 2020 at 19:27)</a>:</h4>
<p>But <code>classical.prop_decidable</code> just says "oh come on, x=y is a true-false statement, and mathematicians believe in the law of the excluded middle, which means that an algorithm exists for figuring out whether this is true or false, and let's use that algorithm."</p>



<a name="209132449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132449">(Sep 04 2020 at 19:28)</a>:</h4>
<p>These are definitely two different algorithms, not least because one of them isn't really an algorithm, it's just switching on a switch which says "forget the algorithm stuff, we are mathematicians and do not care about decidable equality"</p>



<a name="209132546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132546">(Sep 04 2020 at 19:29)</a>:</h4>
<p>However, Lean also knows that both these algorithms are correct, and hence must produce the same answer. Hence the algorithms must be equal, if we define equal algorithms in a highly mathematical way as "must produce the same answer".</p>



<a name="209132626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132626">(Sep 04 2020 at 19:30)</a>:</h4>
<p>This is making more sense.  This is now off a tangent and is completely irrelevant for the purpose of my original question: <em>why</em> did Lean once use <code>nat.decidable</code> and once <code>classical.prop_decidable</code>?</p>



<a name="209132630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132630">(Sep 04 2020 at 19:30)</a>:</h4>
<p>For example, there is only one "sort" function, which takes a finite list of natural numbers and returns the same list but sorted. Two functions are equal if and only if they output the same output given the same input, right?</p>



<a name="209132681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132681">(Sep 04 2020 at 19:30)</a>:</h4>
<p>But computer scientists would argue that there were many sorting algorithms, because they care about the implementation and not just the output.</p>



<a name="209132734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132734">(Sep 04 2020 at 19:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/support_add/near/209132630">said</a>:</p>
<blockquote>
<p>For example, there is only one "sort" function, which takes a finite list of natural numbers and returns the same list but sorted. Two functions are equal if and only if they output the same output given the same input, right?</p>
</blockquote>
<p>It is similar to using or not using the bound given by GRH to compute class groups...</p>



<a name="209132736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132736">(Sep 04 2020 at 19:31)</a>:</h4>
<p><code>convert</code> is clever. It looks for subsingleton instances, and if it finds them then it uses them. So <code>convert</code> can find a proof that <code>a = b</code> if it knows that <code>a : T</code> and <code>b : T</code> and <code>subsingleton T</code>.</p>



<a name="209132800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132800">(Sep 04 2020 at 19:32)</a>:</h4>
<p>well the problem with the GRH algorithm is that we haven't yet proved that it works :-)</p>



<a name="209132845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132845">(Sep 04 2020 at 19:33)</a>:</h4>
<p>The reason Lean found both is because they are both in the system, and Lean used different methods to look for them and found them both.</p>



<a name="209132854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132854">(Sep 04 2020 at 19:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/support_add/near/209132800">said</a>:</p>
<blockquote>
<p>well the problem with the GRH algorithm is that we haven't yet proved that it works :-)</p>
</blockquote>
<p>Right, but should GRH be true, the two algorithms are <code>the same</code>!  </p>
<p>Anyway, I understand the difference, thanks!</p>



<a name="209132887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132887">(Sep 04 2020 at 19:33)</a>:</h4>
<p>This has been very informative: thanks!</p>



<a name="209132896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132896">(Sep 04 2020 at 19:33)</a>:</h4>
<p>One could fiddle with instance priorities to try and make this not happen, but this is beyond my pay grade. I have no idea why Lean finds them both.</p>



<a name="209132977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209132977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209132977">(Sep 04 2020 at 19:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/support_add/near/209132896">said</a>:</p>
<blockquote>
<p>One could fiddle with instance priorities to try and make this not happen, but this is beyond my pay grade. I have no idea why Lean finds them both.</p>
</blockquote>
<p>Sure and, for me, already just knowing that I could use <code>convert</code> was a pretty good answer!</p>



<a name="209144058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209144058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209144058">(Sep 04 2020 at 21:47)</a>:</h4>
<p><code>convert</code> is a great tactic when something which should work, doesn't. It's also a cool way of reasoning -- I use it a lot. You kind of know what the last line of the proof is, approximately, early on, and <code>convert</code> lets you apply it it immediately.</p>



<a name="209144291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209144291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209144291">(Sep 04 2020 at 21:50)</a>:</h4>
<p>I'll try it often, then!</p>



<a name="209144531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209144531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209144531">(Sep 04 2020 at 21:54)</a>:</h4>
<p>I also think <code>convert</code> is great, but one thing to keep in mind: sometimes it spits out incomprehensible nonsense. When this has happened to me, it was always my fault, and just meant that I needed to do a bit more work before using it.</p>



<a name="209182312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209182312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209182312">(Sep 05 2020 at 15:08)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> I looked into this a bit more. The file <code>data.finsupp.basic</code> in mathlib has the following warning at the beginning:</p>
<div class="codehilite"><pre><span></span><code>A general piece of advice is to not use `α →₀ β` directly, as the type class setup might not be a
good fit. Defining a copy and selecting the instances that are best suited for the application works
better.

## Implementation notes

This file is a `noncomputable theory` and uses classical logic throughout.

## Notation

This file defines `α →₀ β` as notation for `finsupp α β`.
</code></pre></div>


<p>So what's happening is that when you use <code>finsupp.support_add</code> it uses classical logic to deal with the decidable equality issues, but when you use <code>polynomial</code> it uses constructive logic. </p>
<p>I can't find <code>polynomial.support_add</code> in mathlib -- you should make a PR adding it, and proving it using <code>convert</code>.</p>



<a name="209187707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209187707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209187707">(Sep 05 2020 at 17:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/support_add/near/209182312">said</a>:</p>
<blockquote>
<p>I can't find <code>polynomial.support_add</code> in mathlib -- you should make a PR adding it, and proving it using <code>convert</code>.</p>
</blockquote>
<p>I will try it!</p>



<a name="209187734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209187734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209187734">(Sep 05 2020 at 17:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/support_add/near/209182312">said</a>:</p>
<blockquote>
<p>So what's happening is that when you use <code>finsupp.support_add</code> it uses classical logic to deal with the decidable equality issues, but when you use <code>polynomial</code> it uses constructive logic. </p>
</blockquote>
<p>Whut? <code>polynomial</code> is quite classical I would think.</p>



<a name="209187778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209187778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209187778">(Sep 05 2020 at 17:28)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> There are lemmas called <code>support_add</code>. But maybe about multivariate polynomials.</p>



<a name="209187782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209187782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209187782">(Sep 05 2020 at 17:28)</a>:</h4>
<p>They might serve as inspiration.</p>



<a name="209192644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209192644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209192644">(Sep 05 2020 at 19:35)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">polynomial</span><span class="bp">.</span><span class="n">degree</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">all</span> <span class="n">true</span>

<span class="kn">lemma</span> <span class="n">supps</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">p</span><span class="bp">+</span><span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support_add</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
  <span class="c1">-- h uses classical.prop_decidable</span>
  <span class="c1">-- polynomials (the goal) use nat.decidable</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>



<a name="209204904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209204904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209204904">(Sep 06 2020 at 02:17)</a>:</h4>
<p>Ouch, I see.</p>



<a name="209206085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209206085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Wong <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209206085">(Sep 06 2020 at 02:59)</a>:</h4>
<blockquote>
<p><code>convert</code> is clever. It looks for subsingleton instances, and if it finds them then it uses them. So <code>convert</code> can find a proof that <code>a = b</code> if it knows that <code>a : T</code> and <code>b : T</code> and <code>subsingleton T</code>.</p>
</blockquote>
<p>Should this be mentioned in the docs somewhere? That's the first time I've heard that.</p>



<a name="209209074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209209074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209209074">(Sep 06 2020 at 04:42)</a>:</h4>
<p>Yes, it should be! Interested in making a documentation-only PR, that adds a sentence to the doc-string for <code>convert</code>?</p>



<a name="209209608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209209608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209209608">(Sep 06 2020 at 05:01)</a>:</h4>
<p>It's actually a feature of <code>congr</code>, which is inherited by <code>congr'</code> and <code>convert</code></p>



<a name="209257764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209257764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Wong <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209257764">(Sep 07 2020 at 05:08)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/4060">https://github.com/leanprover-community/mathlib/pull/4060</a> <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="209260111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209260111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209260111">(Sep 07 2020 at 06:05)</a>:</h4>
<p>Thanks!</p>



<a name="209265568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209265568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209265568">(Sep 07 2020 at 07:35)</a>:</h4>
<p>I am glad that <span class="user-mention" data-user-id="294142">@Chris Wong</span> took care of this, since, even after looking at the suggestion, I am still unsure about what all this means!</p>
<p>Thanks!</p>



<a name="209285910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209285910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209285910">(Sep 07 2020 at 11:38)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> The job of tactics like <code>convert</code> and <code>congr</code> is to try and prove that two terms are equal.</p>



<a name="209285919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209285919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209285919">(Sep 07 2020 at 11:38)</a>:</h4>
<p>This is also the job of <code>exact</code></p>



<a name="209285950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209285950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209285950">(Sep 07 2020 at 11:39)</a>:</h4>
<p><code>exact</code> is quick because it works with definitional equality which is exactly what lean is good at</p>



<a name="209285976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209285976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209285976">(Sep 07 2020 at 11:39)</a>:</h4>
<p>But <code>convert</code> is more powerful because it has a second trick up its sleeve</p>



<a name="209286100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286100">(Sep 07 2020 at 11:41)</a>:</h4>
<p>If it has <code>a : X</code> and <code>b : X</code> and it can't prove that they are definitionally equal, it asks the type class inference system if perchance it knows a proof that X is a subsingleton</p>



<a name="209286112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286112">(Sep 07 2020 at 11:41)</a>:</h4>
<p>It's a brilliant idea</p>



<a name="209286125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286125">(Sep 07 2020 at 11:41)</a>:</h4>
<p>Subsingleton is a class so the type class system is very happy to manage this job</p>



<a name="209286230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286230">(Sep 07 2020 at 11:42)</a>:</h4>
<p>What is a subsingleton?  I am reading <code>#print subsingleton</code>, but I cannot say that I understand the output.</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">class</span><span class="o">]</span>
<span class="kn">inductive</span> <span class="n">subsingleton</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="n">constructors</span><span class="o">:</span>
<span class="n">subsingleton</span><span class="bp">.</span><span class="n">intro</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">subsingleton</span> <span class="n">α</span>
</code></pre></div>



<a name="209286239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286239">(Sep 07 2020 at 11:42)</a>:</h4>
<p>Which means that occasionally <code>convert</code> gets lucky, finds an instance of <code>subsingleton X</code>, unwraps it to get a proof of "for all a and b : X, a=b" (the definition of subsingleton) and then applies this and moves on</p>



<a name="209286261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286261">(Sep 07 2020 at 11:43)</a>:</h4>
<p>Just #check subsingleton and jump to definition</p>



<a name="209286271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286271">(Sep 07 2020 at 11:43)</a>:</h4>
<p>Or read the docs</p>



<a name="209286368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286368">(Sep 07 2020 at 11:44)</a>:</h4>
<p>Use #print just to get technical information such as whether a certain lemma is tagged with <code>[simp]</code>. You almost always don't want <code>#print</code>.</p>



<a name="209286371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286371">(Sep 07 2020 at 11:44)</a>:</h4>
<p>Ok, so subsingleton is a singleton where you do not assume that it has one element, right?  it is a type with at most one term, correct?</p>



<a name="209286378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286378">(Sep 07 2020 at 11:44)</a>:</h4>
<p>Right</p>



<a name="209286392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286392">(Sep 07 2020 at 11:44)</a>:</h4>
<p>Ok, indeed looking at the definition was much easier to understand than print!</p>



<a name="209286396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286396">(Sep 07 2020 at 11:44)</a>:</h4>
<p>So lean knows that a bunch of things are subsingletons</p>



<a name="209286417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286417">(Sep 07 2020 at 11:45)</a>:</h4>
<p>(I did not realize that <code>#print</code> and jumping to the definition were different)</p>



<a name="209286434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286434">(Sep 07 2020 at 11:45)</a>:</h4>
<p>Like presumably <code>fin 0</code> and <code>fin 1</code> (do you know how to check?)</p>



<a name="209286500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286500">(Sep 07 2020 at 11:46)</a>:</h4>
<p>#print gives you a description which doesn't use any variables and which doesn't display the docstring</p>



<a name="209286501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286501">(Sep 07 2020 at 11:46)</a>:</h4>
<p><code>#check (fin 0) : subsingleton </code> did not work...</p>



<a name="209286558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286558">(Sep 07 2020 at 11:46)</a>:</h4>
<p>That's not the type of <code>fin 0</code></p>



<a name="209286594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286594">(Sep 07 2020 at 11:47)</a>:</h4>
<p><code>fin 0</code> has type <code>Type </code> because it's what I'd call a set</p>



<a name="209286659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286659">(Sep 07 2020 at 11:47)</a>:</h4>
<p>So I asked "can you see if the type class system knows that <code>fin 0</code> is a subsingleton"</p>



<a name="209286664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286664">(Sep 07 2020 at 11:47)</a>:</h4>
<p>Ok, so I do not know how to check whether <code>fin 0</code> is a subsingleton</p>



<a name="209286733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286733">(Sep 07 2020 at 11:48)</a>:</h4>
<p>And the thing we have to do is to turn this into a question of the form "make a term of a type"</p>



<a name="209286745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286745">(Sep 07 2020 at 11:48)</a>:</h4>
<p>So the first question is "what is the type"</p>



<a name="209286778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286778">(Sep 07 2020 at 11:48)</a>:</h4>
<p>And the second question is what to use to make the term</p>



<a name="209286827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286827">(Sep 07 2020 at 11:49)</a>:</h4>
<p>You can try <code>#check @subsingleton</code></p>



<a name="209286894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286894">(Sep 07 2020 at 11:50)</a>:</h4>
<p>That's the sort of output I'd find useful for making the type</p>



<a name="209286909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286909">(Sep 07 2020 at 11:50)</a>:</h4>
<p>Also look at the docstring for subsingleton</p>



<a name="209286955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286955">(Sep 07 2020 at 11:51)</a>:</h4>
<p>Lean says: <code>subsingleton : Sort u_1 → Prop</code>, so I understand that subsingleton takes a term of type u_1 and produces a proposition, likely saying whether or not what I feed to subsingleton is a subsingleton!</p>



<a name="209286982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209286982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209286982">(Sep 07 2020 at 11:51)</a>:</h4>
<p>So what is the type that we want to construct a term of?</p>



<a name="209287054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287054">(Sep 07 2020 at 11:52)</a>:</h4>
<p>The translation into Lean of the <em>statement</em> of the theorem that <code>fin 0</code> is a subsingleton?</p>



<a name="209287085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287085">(Sep 07 2020 at 11:53)</a>:</h4>
<p>we would like <code>subsingleton (fin 0)</code> is the type whose terms will be proofs of what we want, right?</p>



<a name="209287093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287093">(Sep 07 2020 at 11:53)</a>:</h4>
<p>Right</p>



<a name="209287100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287100">(Sep 07 2020 at 11:53)</a>:</h4>
<p>(and all those proofs will be the same!)</p>



<a name="209287102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287102">(Sep 07 2020 at 11:53)</a>:</h4>
<p>You can <code>#check</code> what you just posted</p>



<a name="209287126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287126">(Sep 07 2020 at 11:53)</a>:</h4>
<p>I get <br>
<code>subsingleton (fin 0) : Prop</code>, which I confirms that this is a proposition!</p>



<a name="209287128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287128">(Sep 07 2020 at 11:53)</a>:</h4>
<p>And observe that it has type <code>Prop</code> which means it's a theorem statement</p>



<a name="209287139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287139">(Sep 07 2020 at 11:54)</a>:</h4>
<p>ok, good!</p>



<a name="209287176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287176">(Sep 07 2020 at 11:54)</a>:</h4>
<p>So now the question is how to prove it</p>



<a name="209287181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287181">(Sep 07 2020 at 11:54)</a>:</h4>
<p>so now I would like to know that there are terms in this type</p>



<a name="209287210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287210">(Sep 07 2020 at 11:54)</a>:</h4>
<p>You can put <code>example : subsingleton $ fin 0 := begin</code></p>



<a name="209287236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287236">(Sep 07 2020 at 11:55)</a>:</h4>
<p>Does the $ work there instead of the bracket? I'm on mobile</p>



<a name="209287243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287243">(Sep 07 2020 at 11:55)</a>:</h4>
<p>library_search says</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">ss</span> <span class="o">:</span> <span class="n">subsingleton</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">exact</span> <span class="n">subsingleton_fin_zero</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="209287252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287252">(Sep 07 2020 at 11:55)</a>:</h4>
<p>Oh you cheated!</p>



<a name="209287258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287258">(Sep 07 2020 at 11:55)</a>:</h4>
<p>That's not the answer to the question</p>



<a name="209287270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287270">(Sep 07 2020 at 11:55)</a>:</h4>
<p>You just proved the theorem yourself</p>



<a name="209287346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287346">(Sep 07 2020 at 11:56)</a>:</h4>
<p>You don't want <code>convert</code> saying "ok they're equal as long as you can prove that the following things are subsingletons"</p>



<a name="209287351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287351">(Sep 07 2020 at 11:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/support_add/near/209287210">said</a>:</p>
<blockquote>
<p>You can put <code>example : subsingleton $ fin 0 := begin</code></p>
</blockquote>
<p>This compiles, I added <code>end</code> after and Lean interprets it as looking for a term of the correct type</p>



<a name="209287359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287359">(Sep 07 2020 at 11:56)</a>:</h4>
<p>We need to use a tactic which doesn't involve knowing the name of the term beforehand</p>



<a name="209287373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287373">(Sep 07 2020 at 11:57)</a>:</h4>
<p>And that tactic is called <code>apply_instance</code></p>



<a name="209287398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287398">(Sep 07 2020 at 11:57)</a>:</h4>
<p>And I don't know if it will solve the goal -- let me know!</p>



<a name="209287409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287409">(Sep 07 2020 at 11:57)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="n">subsingleton</span> <span class="err">$</span> <span class="n">fin</span> <span class="mi">0</span> <span class="o">:=</span> <span class="k">begin</span>
 <span class="n">apply_instance</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>solves the goal indeed!</p>



<a name="209287418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287418">(Sep 07 2020 at 11:57)</a>:</h4>
<p>Great. So here's how that magic worked</p>



<a name="209287429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287429">(Sep 07 2020 at 11:57)</a>:</h4>
<p>Because lean does not do magic</p>



<a name="209287471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287471">(Sep 07 2020 at 11:58)</a>:</h4>
<p>You found the name of the term already</p>



<a name="209287487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287487">(Sep 07 2020 at 11:58)</a>:</h4>
<p>Maybe you used library_search (which might be very slow)</p>



<a name="209287505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287505">(Sep 07 2020 at 11:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/support_add/near/209287487">said</a>:</p>
<blockquote>
<p>Maybe you used library_search (which might be very slow)</p>
</blockquote>
<p>Yes, I do not like using it</p>



<a name="209287521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287521">(Sep 07 2020 at 11:59)</a>:</h4>
<p>But now let's <code>#print subsingleton_fin_zero</code></p>



<a name="209287538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287538">(Sep 07 2020 at 11:59)</a>:</h4>
<p>To see what's going on under the hood. Can you post the output? I'm on mobile</p>



<a name="209287554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287554">(Sep 07 2020 at 11:59)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span>
<span class="kn">protected</span> <span class="n">def</span> <span class="n">subsingleton_fin_zero</span> <span class="o">:</span> <span class="n">subsingleton</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">fin_zero_equiv</span><span class="bp">.</span><span class="n">subsingleton</span>
</code></pre></div>



<a name="209287573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287573">(Sep 07 2020 at 11:59)</a>:</h4>
<p>So that definition is tagged with <code>instance</code></p>



<a name="209287666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287666">(Sep 07 2020 at 12:00)</a>:</h4>
<p>And all the type class inference system does is that it's a fast program written in C or C++ or something which looks through everything tagged with <code>instance</code> and sees if anything helps</p>



<a name="209287701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287701">(Sep 07 2020 at 12:01)</a>:</h4>
<p>That's why the tactic is called <code>apply_instance</code>.</p>



<a name="209287710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287710">(Sep 07 2020 at 12:01)</a>:</h4>
<p>Ah, so <code>apply_instance</code> is similar to <code>library_search</code>, except that it only searches for statements tagged <code>instance</code>?</p>



<a name="209287815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287815">(Sep 07 2020 at 12:02)</a>:</h4>
<p>All of those @[derive decibable_equality, ext, simp]` things you see lying around in mathlib are just literally doing nothing more than tagging words onto the names of theorems and definitions</p>



<a name="209287844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287844">(Sep 07 2020 at 12:02)</a>:</h4>
<p>And then other things like tactics can use the tags</p>



<a name="209287888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287888">(Sep 07 2020 at 12:03)</a>:</h4>
<p>Right, <code>apply_instance</code> is similar but it's only looking at instances. But there's also another thing</p>



<a name="209287945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209287945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209287945">(Sep 07 2020 at 12:04)</a>:</h4>
<p>This tactic is running behind the scenes all of the time because the elaborator is calling it every time you write 2+2</p>



<a name="209288005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288005">(Sep 07 2020 at 12:04)</a>:</h4>
<p>The elaborator sees this and says to the type class inference system "do you happen to know an addition on the naturals"</p>



<a name="209288032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288032">(Sep 07 2020 at 12:05)</a>:</h4>
<p>(or integers or reals or p-adics)</p>



<a name="209288044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288044">(Sep 07 2020 at 12:05)</a>:</h4>
<p>This probably explains why sometimes, when I type <code>1 : something</code>, Lean then asks me for a <code>has_one</code> instance, right?</p>



<a name="209288074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288074">(Sep 07 2020 at 12:05)</a>:</h4>
<p>And the type class inference system says "sure, they're a semiring, let me just look up the addition for you"</p>



<a name="209288171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288171">(Sep 07 2020 at 12:06)</a>:</h4>
<p>Because there are functions defined in lean saying things like "if you are a semiring then you have an addition" and a carefully chosen collection are tagged with <code>instance</code></p>



<a name="209288201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288201">(Sep 07 2020 at 12:07)</a>:</h4>
<p>Choosing the right ones to tag is a complicated research topic</p>



<a name="209288228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288228">(Sep 07 2020 at 12:07)</a>:</h4>
<p>Ok</p>



<a name="209288229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288229">(Sep 07 2020 at 12:07)</a>:</h4>
<p>In Lean 4 the algorithm will be replaced by a completely different one so we will have to learn how to use it from scratch</p>



<a name="209288296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288296">(Sep 07 2020 at 12:08)</a>:</h4>
<p>so, all terms in <code>Prop</code> are subsingletons, right?  (this is just to make sure that I understand the definitions)</p>



<a name="209288308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288308">(Sep 07 2020 at 12:08)</a>:</h4>
<p>But if you just want to do mathematics then we basically have worked out what works best in lean 3</p>



<a name="209288334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288334">(Sep 07 2020 at 12:08)</a>:</h4>
<p>Right</p>



<a name="209288344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288344">(Sep 07 2020 at 12:08)</a>:</h4>
<p>Ok</p>



<a name="209288394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288394">(Sep 07 2020 at 12:09)</a>:</h4>
<p>So that means lean will be able to make a term of type <code>subsingleton P</code> if P : Prop`</p>



<a name="209288403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288403">(Sep 07 2020 at 12:09)</a>:</h4>
<p>But some things are <code>subsingleton</code> even though they don't have type <code>Prop</code>. Like <code>prime_spectrum K</code>.</p>



<a name="209288476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288476">(Sep 07 2020 at 12:10)</a>:</h4>
<p>yes, ok, I only meant it as an example, not an exhaustive one!</p>



<a name="209288478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288478">(Sep 07 2020 at 12:10)</a>:</h4>
<p>Or <code>fin 0</code>, which has type Type</p>



<a name="209288503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288503">(Sep 07 2020 at 12:10)</a>:</h4>
<p>It's all the propositions and all the sets with at most one element</p>



<a name="209288515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288515">(Sep 07 2020 at 12:10)</a>:</h4>
<p>for instance, I guess that you could formulate the valuative criterion of separatedness using subsingletons</p>



<a name="209288537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288537">(Sep 07 2020 at 12:11)</a>:</h4>
<p>You can model a false proposition as a set with no elements and a true one as a set with one element</p>



<a name="209288552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288552">(Sep 07 2020 at 12:11)</a>:</h4>
<p>What do you mean about the valuative criterion?</p>



<a name="209288558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288558">(Sep 07 2020 at 12:11)</a>:</h4>
<p>Oh you mean subsingleton schemes</p>



<a name="209288559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288559">(Sep 07 2020 at 12:11)</a>:</h4>
<p>yes</p>



<a name="209288578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288578">(Sep 07 2020 at 12:11)</a>:</h4>
<p>Do you need Noetherian hypotheses here?</p>



<a name="209288631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288631">(Sep 07 2020 at 12:12)</a>:</h4>
<p>I can't remember the non noeth story</p>



<a name="209288640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288640">(Sep 07 2020 at 12:12)</a>:</h4>
<p>I think Hartshorne does it</p>



<a name="209288642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288642">(Sep 07 2020 at 12:12)</a>:</h4>
<p>in the proof, you reduce to something being noetherian, but the statement may not require it</p>



<a name="209288669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288669">(Sep 07 2020 at 12:12)</a>:</h4>
<p>Is the statement about valuation rings?</p>



<a name="209288706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288706">(Sep 07 2020 at 12:13)</a>:</h4>
<p>Wait they have two points</p>



<a name="209288782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209288782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209288782">(Sep 07 2020 at 12:14)</a>:</h4>
<p>yes, so i think that you can formulate the valuative criterion without noetherian hypotheses, but then they crop up somewhere...</p>



<a name="209289192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209289192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209289192">(Sep 07 2020 at 12:18)</a>:</h4>
<p>General valuation rings can have more than two primes. Subsingleton is less than two</p>



<a name="209289663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209289663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209289663">(Sep 07 2020 at 12:24)</a>:</h4>
<p>Ok, I had in mind the statement of the valuative criterion for "reasonable" schemes: I think that if <code>X</code> is of finite type, then you only need to check dvrs in the valuative criteria</p>



<a name="209291887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209291887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209291887">(Sep 07 2020 at 12:48)</a>:</h4>
<p>Yes and this doesn't change the fact that <code>fin 2</code> is not a subsingleton :-)</p>



<a name="209291943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209291943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209291943">(Sep 07 2020 at 12:49)</a>:</h4>
<p>The criterion uses doubletons</p>



<a name="209292083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209292083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209292083">(Sep 07 2020 at 12:50)</a>:</h4>
<p>Ok, I see what you are saying!  I was thinking that once you fix the generic morphism, then there is at most one way of filling it in...</p>



<a name="209292122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209292122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209292122">(Sep 07 2020 at 12:51)</a>:</h4>
<p>so, one of the elements of the doubleton is fixed and the other one is... a subsingleton!  Ahahaha</p>



<a name="209292169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209292169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209292169">(Sep 07 2020 at 12:52)</a>:</h4>
<p>(at least, this is how i view the valuative criteria: you are given the generic map and all you want to do is know if</p>
<ol>
<li>you can extend it;</li>
<li>if so, can you extend it uniquely.<br>
)</li>
</ol>



<a name="209292436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209292436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209292436">(Sep 07 2020 at 12:55)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> Yup, that makes sense</p>



<a name="209292471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209292471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209292471">(Sep 07 2020 at 12:55)</a>:</h4>
<p>Oh I see! Yes you should have formalised what you meant. Yes, separated is at most one, there's some adjective which is at least one and then proper is <code>singleton</code></p>



<a name="209292568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209292568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209292568">(Sep 07 2020 at 12:56)</a>:</h4>
<p>Great!  I realize that explaining <code>subsingleton</code> via the valuative criteria is maybe not the most direct route...</p>



<a name="209292587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209292587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209292587">(Sep 07 2020 at 12:57)</a>:</h4>
<p>There's a way of formalising the definition of compact to mean some statement involving filters has at least one answer, and a way of formalising Hausdorff so that it says the same statement has at most one answer</p>



<a name="209292634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209292634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209292634">(Sep 07 2020 at 12:57)</a>:</h4>
<p>Basically certain filters have at least one limit in a compact space and at most one limit in a Hausdorff space</p>



<a name="209292652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209292652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209292652">(Sep 07 2020 at 12:57)</a>:</h4>
<p>That's why compact Hausdorff is such a powerful criterion</p>



<a name="209292837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/support_add/near/209292837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/support_add.html#209292837">(Sep 07 2020 at 12:59)</a>:</h4>
<p>I think that what you described is very close to my intuition for proper</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
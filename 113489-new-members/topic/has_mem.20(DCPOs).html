---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/has_mem.20(DCPOs).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html">has_mem (DCPOs)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="217539571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217539571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aram Bingham <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217539571">(Nov 22 2020 at 07:39)</a>:</h4>
<p>I'm trying to define DCPOs and I'm sure I'm doing a zillion things wrong but mostly I don't understand the behavior of has_mem, which seems to be needed somehow in part of my code. I see has_mem is in a lot of other mathlib files used for defining things like subgroups, subrings with lines like <code>instance : has_mem G (subgroup G) := ⟨λ m K, m ∈ (K : set G)⟩</code> which I have tried to mimic but I can't get  this message to go away:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
<span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">,</span>
<span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">to_partial_order</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">P</span><span class="o">,</span>
<span class="n">to_has_sup</span> <span class="o">:</span> <span class="n">has_sup</span> <span class="n">P</span><span class="o">,</span>
<span class="n">le</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="n">to_partial_order</span> <span class="o">:=</span> <span class="n">partial_order.le</span><span class="o">,</span>
<span class="n">lt</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="n">to_partial_order</span> <span class="o">:=</span> <span class="n">partial_order.lt</span><span class="o">,</span>
<span class="n">le_refl</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="n">to_partial_order</span> <span class="o">:=</span> <span class="n">partial_order.le_refl</span><span class="o">,</span>
<span class="n">le_trans</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c_1</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c_1</span><span class="o">)</span>
  <span class="n">to_partial_order</span> <span class="o">:=</span>
  <span class="n">partial_order.le_trans</span><span class="o">,</span>
<span class="n">lt_iff_le_not_le</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">α</span><span class="o">),</span>
   <span class="n">auto_param</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">name.mk_string</span> <span class="s2">"order_laws_tac"</span> <span class="n">name.anonymous</span><span class="o">))</span>
  <span class="n">to_partial_order</span> <span class="o">:=</span>
  <span class="n">partial_order.lt_iff_le_not_le</span><span class="o">,</span>
<span class="n">le_antisymm</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="n">to_partial_order</span> <span class="o">:=</span>
  <span class="n">partial_order.le_antisymm</span><span class="o">,</span>
<span class="n">sup</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">P</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">has_sup</span> <span class="n">P</span><span class="o">),</span> <span class="n">dset</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span> <span class="n">to_has_sup</span> <span class="o">:=</span> <span class="n">has_sup.sup</span><span class="o">,</span>
<span class="n">D</span> <span class="o">:</span> <span class="n">dset</span> <span class="n">P</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">P</span>
<span class="bp">⊢</span> <span class="n">has_mem</span> <span class="n">P</span> <span class="o">(</span><span class="n">dset</span> <span class="n">P</span><span class="o">)</span>
</code></pre></div>
<p>I guess I don't really know why all those other mathlib files need this has_mem instance, or why it's showing up in my infoview. Here's roughly what I have so far. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">dset</span> <span class="o">(</span><span class="n">P</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">P</span><span class="o">]:=</span>
    <span class="o">(</span><span class="n">D</span><span class="o">:</span> <span class="n">set</span> <span class="n">P</span> <span class="o">)</span>
    <span class="o">(</span><span class="n">is_directed</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">P</span><span class="o">}:</span> <span class="o">((</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">D</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">y</span> <span class="bp">∈</span> <span class="n">D</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span><span class="n">z</span> <span class="bp">∈</span> <span class="n">D</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">z</span><span class="o">))</span>
<span class="kd">class</span> <span class="n">has_sup</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">P</span><span class="o">]</span> <span class="o">:=</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">dset</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">)</span>

<span class="kd">class</span> <span class="n">dcpo</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">partial_order</span> <span class="n">P</span><span class="o">,</span> <span class="n">has_sup</span> <span class="n">P</span><span class="o">:=</span>
    <span class="o">(</span><span class="n">le_sup</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="n">D</span> <span class="o">:</span> <span class="n">dset</span> <span class="n">P</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">D</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">sup</span> <span class="n">D</span><span class="o">)</span>
</code></pre></div>
<p>Any help would be appreciated!</p>



<a name="217539826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217539826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217539826">(Nov 22 2020 at 07:48)</a>:</h4>
<p><code>has_mem</code> is a <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#inferring-notation">notation type class</a> associated to the symbol <code>∈</code>. To provide a <code>has_mem P (dset P)</code> instance, you need to supply a function of type <code>P → dset P → Prop</code>.</p>



<a name="217539905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217539905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217539905">(Nov 22 2020 at 07:51)</a>:</h4>
<p>I'm guessing something like the following is what you want:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">P</span> <span class="o">(</span><span class="n">dset</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">dP</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">dP.D</span><span class="o">⟩</span>
</code></pre></div>



<a name="217540009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217540009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217540009">(Nov 22 2020 at 07:55)</a>:</h4>
<p>It might end up being more convenient to first provide a coercion from <code>dset P</code> to <code>set P</code>, like so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">dset</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">dset.D</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">P</span> <span class="o">(</span><span class="n">dset</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">dP</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">dP</span> <span class="o">:</span> <span class="n">set</span> <span class="n">P</span><span class="o">)⟩</span>
</code></pre></div>



<a name="217540235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217540235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aram Bingham <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217540235">(Nov 22 2020 at 08:02)</a>:</h4>
<p>ahhh ok thank you this works! so is the idea that i have to tell lean what it means for terms of type  P to be in a directed set by coercing dsets to be sets<br>
 and then the symbol <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> makes sense?</p>



<a name="217540320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217540320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217540320">(Nov 22 2020 at 08:05)</a>:</h4>
<p>An instance of <code>has_mem</code> tells Lean what <code>∈</code> should mean, and the instance of <code>has_coe (dset P) (set P)</code> tells Lean how to coerce something of type <code>dset P</code> to type <code>set P</code>. That's used in the expression <code>(dP : set P)</code> in the second <code>has_mem</code> instance I defined above.</p>



<a name="217540389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217540389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aram Bingham <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217540389">(Nov 22 2020 at 08:07)</a>:</h4>
<p>Gotcha this is making much more sense now, thank you!</p>



<a name="217566862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217566862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aram Bingham <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217566862">(Nov 22 2020 at 19:53)</a>:</h4>
<p>OK so now I'm trying to show that DCPOs are also <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span>-CPOs. To do this, I want to be able to coerce chains into directed sets and I'm trying to do this in stages by first defining the set that is the image of the underlying function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex"> \N \to \alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> of a chain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>. Something is not type-checking with the first part already</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">chain</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">infer_instance</span> <span class="o">(</span><span class="n">has_coe_to_fun</span> <span class="bp">$</span> <span class="n">ℕ</span> <span class="bp">→ₘ</span> <span class="n">P</span><span class="o">)</span> <span class="n">_</span>

<span class="kd">def</span> <span class="n">has_coe_to_dset</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="n">chain</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">dset</span> <span class="n">P</span> <span class="o">:=</span>
    <span class="o">{</span><span class="n">D</span><span class="o">:=</span> <span class="n">set.image</span> <span class="n">has_coe_to_fun</span> <span class="n">c</span><span class="o">,</span>
     <span class="n">is_directed</span><span class="o">:=</span> <span class="n">sorry</span><span class="o">}</span>
</code></pre></div>
<p>where I get  the error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">has_coe_to_fun</span> <span class="n">c</span>
<span class="n">term</span>
  <span class="n">c</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">chain</span> <span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="kt">Sort</span> <span class="bp">?</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span>
</code></pre></div>
<p>I don't have a great grasp of what this means, but when I go to the mathlib file omega_complete_partial_order and try to check the same thing with  <code>#check has_coe_to_fun c</code>  I get a very similar error. What's going wrong?</p>



<a name="217568130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217568130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aram Bingham <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217568130">(Nov 22 2020 at 20:23)</a>:</h4>
<p>nvm, I think I got around it by defining </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">chain_image</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="n">chain</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">P</span> <span class="o">:=</span>
    <span class="o">{</span><span class="n">p</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">c</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">p</span><span class="o">}</span>
</code></pre></div>



<a name="217575990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217575990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aram Bingham <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217575990">(Nov 22 2020 at 23:26)</a>:</h4>
<p>OK, i've been able to show that chains give directed sets, now I think it makes sense to create an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span>-CPO as an instance of a DCPO but having a new trouble</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">P</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">dcpo</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span> <span class="n">ωcpo</span> <span class="n">P</span><span class="o">:=</span>
    <span class="o">{</span> <span class="n">ωsup</span><span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
      <span class="n">le_ωsup</span><span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
      <span class="n">ωsup_le</span><span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>
<p>gives the error<br>
<code>invalid definition, a declaration named 'ωcpo' has already been declared</code><br>
I assume I have bad syntax somewhere but I was just trying to copy examples from lftcm2020 so I'm not sure where...</p>



<a name="217576110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217576110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217576110">(Nov 22 2020 at 23:28)</a>:</h4>
<p>You should name the instance if it doesn't get a good name</p>



<a name="217576130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217576130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217576130">(Nov 22 2020 at 23:29)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">dcpo.to_ωcpo</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">dcpo</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span> <span class="n">ωcpo</span> <span class="n">P</span> <span class="o">:=</span>
</code></pre></div>



<a name="217576316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_mem%20%28DCPOs%29/near/217576316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aram Bingham <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_mem.20(DCPOs).html#217576316">(Nov 22 2020 at 23:33)</a>:</h4>
<p>aha! thank you, so it was that the instance was trying to take on the name <code>ωcpo</code> by default ?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Complicated.20induction.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html">Complicated induction</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="283177015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283177015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283177015">(May 21 2022 at 14:44)</a>:</h4>
<p>When one needs to do an induction on an object that depends on many things, how to have the induction hypothesis be made variable ?</p>
<p>The context is the following :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">M</span> <span class="n">X</span><span class="o">]</span>
</code></pre></div>
<p>and I want to prove a proposition for all <code>s : finset X</code> by induction on <code>s</code> or on its cardinality. However, the inductive step, if <code>s = a :: t</code>, needs to replace <code>M</code> and <code>X</code> (by <code>stabilizer M a</code> and <code>X</code> by <code>X \ {a}</code>, about which I have the required <code>mul_action</code>).</p>
<p>The problem is that  applying <code>finset.induction_on</code> furnishes an induction hypothesis that has not modified <code>M</code> and <code>X</code>, so is useless. </p>
<p>I can of course introduce an auxiliary integer <code>n</code>, with hypothesis <code>s.card = n</code>, and doing induction on <code>n</code>, but then, in the induction step, I need to rewrite myself <code>s</code> as <code>a :: t</code>, etc.</p>



<a name="283177187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283177187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283177187">(May 21 2022 at 14:48)</a>:</h4>
<p>It sounds like the real proof is either (1) induction on <code>n = s.card</code>, with induction hypothesis quantifying over all groups and actions, as you suggest, or (2) induction on <code>s : finset X</code>, but then quantifying over all subgroups <code>M'</code> of <code>M</code> and subsets <code>X'</code> of <code>X</code> with <code>M'</code> acting on <code>X'</code>, and <code>s</code> contained in <code>X'</code>, etc</p>



<a name="283177217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283177217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283177217">(May 21 2022 at 14:49)</a>:</h4>
<p>If you are mostly concerned with the manual labor you have to do in the proof to get here you can also define your own induction principle that sets this environment up and tell the <code>induction</code> tactic to use that instead.</p>



<a name="283178435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283178435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283178435">(May 21 2022 at 15:14)</a>:</h4>
<p>What's the statement that includes <code>s</code>?</p>



<a name="283183312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283183312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283183312">(May 21 2022 at 17:08)</a>:</h4>
<p>Did you try <code>induction...generalizing M X</code>?</p>



<a name="283186878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283186878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283186878">(May 21 2022 at 18:33)</a>:</h4>
<p>I doubt that's going to work when the type of <code>s</code> depends on <code>X</code></p>



<a name="283187701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283187701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Dickinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283187701">(May 21 2022 at 18:54)</a>:</h4>
<p>I found myself needing something similar earlier today: I wanted to prove something about all objects of a given type by complete induction on the "height" of those objects (with the height being an element of <code>ℕ</code>). I ended up abstracting out what I needed to the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">height_induction_gen</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="n">K</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">L</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">ht</span> <span class="n">L</span> <span class="bp">&lt;</span> <span class="n">ht</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">L</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">K</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">J</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">ht</span> <span class="n">J</span> <span class="n">using</span> <span class="n">nat.strong_induction_on</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ind_hyp</span> <span class="n">generalizing</span> <span class="n">J</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">J</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">K</span> <span class="n">ht_lt_ht</span><span class="o">,</span> <span class="n">ind_hyp</span> <span class="o">(</span><span class="n">ht</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">eq.rec</span> <span class="n">ht_lt_ht</span> <span class="n">hn</span><span class="o">)</span> <span class="n">K</span> <span class="n">rfl</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>
<p>and then using a specialisation <code>height_induction</code> of that in an <code>induction J using height_induction</code> statement in my main proof. I dare say there's a better way, though. (I'm very much still learning Lean.)</p>



<a name="283189290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283189290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283189290">(May 21 2022 at 19:29)</a>:</h4>
<p>The kind of statement I wanted to prove is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">index_of_fixing_subgroup_of_multiply_pretransitive</span> <span class="o">{</span><span class="n">M</span> <span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">M</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span>
     <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>  <span class="o">(</span><span class="n">fixing_subgroup</span> <span class="n">M</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">))</span><span class="bp">.</span><span class="n">index</span> <span class="bp">*</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">α</span> <span class="bp">-</span> <span class="n">s.card</span><span class="o">)</span><span class="bp">.</span><span class="n">factorial</span> <span class="bp">=</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">factorial</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>(possibly replacing the finset <code>s</code> by a set).</p>



<a name="283190555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283190555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283190555">(May 21 2022 at 20:01)</a>:</h4>
<p>But your inductive step involved alphas of smaller size, right? So you should be able to generalise X and M using tricks like the one Mark is demonstrating. Their alpha is your triple X,M,alpha</p>



<a name="283195740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283195740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283195740">(May 21 2022 at 22:13)</a>:</h4>
<p>Right, but there are also the instances that M is a group and X a mul_action, and I don't know how to write it up.<br>
I started with </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="kd">lemma</span> <span class="n">induction_on_finset_mul_action</span>
  <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)(</span><span class="n">group</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">mul_action</span> <span class="n">G</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">),</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">G</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">G</span> <span class="n">X</span><span class="o">],</span> <span class="n">P</span> <span class="o">(</span><span class="bp">∅</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">))</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">G</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">G</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">sub_mul_action_of_stabilizer</span> <span class="n">G</span> <span class="n">X</span> <span class="n">a</span><span class="o">)),</span>
    <span class="n">P</span> <span class="o">(</span><span class="n">stabilizer</span> <span class="n">G</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">sub_mul_action_of_stabilizer</span> <span class="n">G</span> <span class="n">X</span> <span class="n">a</span><span class="o">)</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">G</span> <span class="n">X</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="n">s</span><span class="o">))</span> <span class="bp">→</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">G</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">G</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">),</span> <span class="n">P</span> <span class="n">G</span> <span class="n">X</span> <span class="n">s</span> <span class="o">:=</span> <span class="gr">sorry</span>
  <span class="bp">```</span>
<span class="n">but</span> <span class="n">some</span> <span class="n">type</span> <span class="n">inference</span> <span class="n">does</span> <span class="n">not</span> <span class="n">work.</span>
</code></pre></div>



<a name="283196181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283196181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283196181">(May 21 2022 at 22:24)</a>:</h4>
<p>You need the <code>by exactI</code> trick for <code>∀ [group G] [mul_action G X],</code> to work</p>



<a name="283196249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283196249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283196249">(May 21 2022 at 22:26)</a>:</h4>
<p>That is, <code>∀ [group G], by exactI ∀ [mul_action G X],</code></p>



<a name="283198350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/283198350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#283198350">(May 21 2022 at 23:24)</a>:</h4>
<p>Typeclasses after the colon don't get put into the typeclass system so you have to put them there manually, typically with an <code>I</code> tactic.</p>



<a name="284061618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284061618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284061618">(May 26 2022 at 21:08)</a>:</h4>
<p>It seems that I now need to add an exactI whenever I use something that refers to an instance…</p>



<a name="284062110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284062110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284062110">(May 26 2022 at 21:13)</a>:</h4>
<p>thankfully all this will be gone(tm) in lean4</p>



<a name="284065299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284065299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284065299">(May 26 2022 at 21:43)</a>:</h4>
<p>And even this is a nightmare : I can't do <code>rw</code> anymore, I get strange error messages that <code>rw</code> or <code>refine</code>are unknown…</p>



<a name="284065626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284065626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284065626">(May 26 2022 at 21:46)</a>:</h4>
<p>Just in case a good soul passes nearby, and although this is not a MWE at all, here is the kind of stuff I wrote.<br>
The <code>rw [by exactI…</code> does not work.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">jordan0</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">],</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">hGα</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="n">mul_action</span> <span class="n">G</span> <span class="n">α</span><span class="o">],</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="n">is_preprimitive</span> <span class="n">G</span> <span class="n">α</span><span class="o">)</span>
    <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hsn</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="n">fintype.card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n.succ</span><span class="o">)</span>
    <span class="o">(</span><span class="n">hsn'</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">n.succ</span> <span class="bp">&lt;</span> <span class="n">fintype.card</span> <span class="n">α</span><span class="o">)</span>
    <span class="o">(</span><span class="n">hs_trans</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="n">is_pretransitive</span> <span class="o">(</span><span class="n">fixing_subgroup</span> <span class="n">G</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">sub_mul_action_of_fixing_subgroup</span> <span class="n">G</span> <span class="n">s</span><span class="o">)),</span>
  <span class="kd">by</span> <span class="n">exactI</span> <span class="n">is_multiply_pretransitive</span> <span class="o">(</span><span class="n">subgroup.normal_closure</span> <span class="o">(</span><span class="n">fixing_subgroup</span> <span class="n">G</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">carrier</span><span class="o">)</span> <span class="n">α</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hrec</span><span class="o">,</span>
  <span class="c1">-- Initialization : n = 0</span>
  <span class="o">{</span> <span class="c1">-- s = {a}</span>
    <span class="n">intros</span> <span class="n">α</span> <span class="n">_</span> <span class="n">_</span> <span class="n">G</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s</span> <span class="n">hsn</span> <span class="n">hsn'</span> <span class="n">hs_trans</span><span class="o">,</span>

    <span class="k">let</span> <span class="n">hG_eq</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="n">hG.to_is_pretransitive.exists_smul_eq</span><span class="o">,</span>

    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">hsa</span><span class="o">⟩</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="n">card_eq_one_iff_is_singleton</span> <span class="n">s</span> <span class="n">hsn</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hsa</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>

    <span class="k">have</span> <span class="n">hG'</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="n">is_multiply_pretransitive</span> <span class="n">G</span> <span class="n">α</span> <span class="mi">2</span><span class="o">,</span>

<span class="c1">-- up to here Lean stays silent, although I cannot be sure he's doing what I expect,</span>
<span class="c1">-- but on that point, it definitely complains.</span>
      <span class="n">rw</span> <span class="o">[</span><span class="kd">by</span> <span class="n">exactI</span> <span class="n">stabilizer.is_multiply_pretransitive</span> <span class="n">G</span> <span class="n">α</span> <span class="n">hG.to_is_pretransitive</span><span class="o">],</span>

      <span class="n">rw</span> <span class="bp">←</span> <span class="n">is_pretransitive_iff_is_one_pretransitive</span><span class="o">,</span>
      <span class="c1">-- is_pretransitive (stabilizer G a) (sub_mul_action_of_stabilizer G α a),</span>
      <span class="n">refine</span> <span class="n">is_pretransitive_of_bihom</span>
        <span class="o">(</span><span class="n">sub_mul_action_of_fixing_subgroup_of_singleton_bihom</span> <span class="n">G</span> <span class="n">a</span><span class="o">)</span>
        <span class="o">(</span><span class="n">function.bijective.surjective</span>
          <span class="o">(</span><span class="n">sub_mul_action_of_fixing_subgroup_of_singleton_bihom_bijective</span> <span class="n">G</span> <span class="n">a</span><span class="o">))</span>
        <span class="n">hs_trans</span><span class="o">,</span>


    <span class="k">let</span> <span class="n">this</span> <span class="o">:</span> <span class="n">fixing_subgroup</span> <span class="n">G</span> <span class="o">({</span><span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">stabilizer</span> <span class="n">G</span> <span class="n">a</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="c1">-- stabilizer G a = fixing_subgroup G ({a} : set α),</span>
      <span class="kd">by</span> <span class="n">exactI</span> <span class="n">ext</span> <span class="n">g</span><span class="o">,</span>  <span class="n">split</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">hg</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">mem_fixing_subgroup_iff</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hg</span> <span class="n">a</span> <span class="o">(</span><span class="n">set.mem_singleton</span> <span class="n">a</span><span class="o">)</span> <span class="o">,</span>
      <span class="n">intro</span> <span class="n">hg</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mem_fixing_subgroup_iff</span><span class="o">,</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">(</span><span class="n">set.mem_singleton_iff.mp</span> <span class="n">hx</span><span class="o">),</span> <span class="n">exact</span> <span class="n">hg</span> <span class="o">},</span>

    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>

    <span class="kd">by</span> <span class="n">exactI</span> <span class="n">refine</span> <span class="n">jordan0_init</span> <span class="n">G</span> <span class="n">hG</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">lt_of_eq_of_lt</span> <span class="n">_</span> <span class="n">hsn'</span><span class="o">,</span> <span class="n">norm_num</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">is_pretransitive_iff_is_one_pretransitive</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">stabilizer.is_multiply_pretransitive</span> <span class="n">G</span> <span class="n">α</span> <span class="n">hG.to_is_pretransitive</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hG'</span><span class="o">,</span>
    <span class="o">},</span>

<span class="o">{</span>
  <span class="c1">-- Induction step</span>



    <span class="gr">sorry</span>
<span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="284065902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284065902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284065902">(May 26 2022 at 21:49)</a>:</h4>
<p>Does the <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#resetI">tactic#resetI</a> tactic help at all?</p>



<a name="284066073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284066073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284066073">(May 26 2022 at 21:51)</a>:</h4>
<p>When you're in a tactic block, using <code>resetI</code> tells lean to consider all the things that you have in context that could be considered as instances, to actually be considered as instances.</p>



<a name="284066351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284066351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284066351">(May 26 2022 at 21:54)</a>:</h4>
<p>You can also use <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#introsI">tactic#introsI</a> when you're introducing an instance</p>



<a name="284066357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284066357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284066357">(May 26 2022 at 21:54)</a>:</h4>
<p>That does <code>resetI</code> for you under the hood.</p>



<a name="284066591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284066591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284066591">(May 26 2022 at 21:57)</a>:</h4>
<p>You don't need it here, but <code>unfreezingI { induction n with n hrec }</code> is something that is useful if somehow there were instances whose types depend on <code>n</code>. It also effectively does <code>resetI</code> while also unfreezing the local instances -- for efficiency local instances are "frozen" in Lean 3.</p>



<a name="284241673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284241673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284241673">(May 28 2022 at 18:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130609">Antoine Chambert-Loir</span> <a href="#narrow/stream/113489-new-members/topic/Complicated.20induction/near/284065299">said</a>:</p>
<blockquote>
<p>And even this is a nightmare : I can't do <code>rw</code> anymore, I get strange error messages that <code>rw</code> or <code>refine</code>are unknown…</p>
</blockquote>
<p>Probably you've made a syntax error.</p>



<a name="284241744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284241744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284241744">(May 28 2022 at 18:18)</a>:</h4>
<p>Why the heck are you putting all those typeclasses after the colon? Why not put them all before the colon? I can't get anything to work, I don't know what <code>is_preprimitive</code> is.</p>



<a name="284243416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284243416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284243416">(May 28 2022 at 19:00)</a>:</h4>
<p>My guess is they're before the colon because Antoine wasn't aware of <code>unfreezingI {induction n generalizing G ... }</code></p>



<a name="284407796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284407796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284407796">(May 30 2022 at 21:32)</a>:</h4>
<p>Well, I managed to do the induction by hand, but this may deserve a general lemma.<br>
I had to put some <code>exactI</code> in the statement, but after that, <code>introsI</code> did the job! Phew! (See <a href="https://github.com/leanprover-community/mathlib/tree/acl-Wielandt">branch#acl-Wielandt</a>)</p>



<a name="284410830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284410830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284410830">(May 30 2022 at 22:34)</a>:</h4>
<p>Can you link to a specific line in that branch?</p>



<a name="284417090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284417090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284417090">(May 31 2022 at 00:55)</a>:</h4>
<p>lol 9000 lines :-) Antoine it will start rotting if you're not careful. They change the definition of groups occasionally, remember?</p>



<a name="284432429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284432429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284432429">(May 31 2022 at 06:25)</a>:</h4>
<p>For example : <a href="https://github.com/leanprover-community/mathlib/blob/3804896f0d9de686a81005b5928371da5ec598d3/acl-sandbox/group_theory/multiple_trans_specific.lean#L1120">https://github.com/leanprover-community/mathlib/blob/3804896f0d9de686a81005b5928371da5ec598d3/acl-sandbox/group_theory/multiple_trans_specific.lean#L1120</a></p>



<a name="284432532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284432532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284432532">(May 31 2022 at 06:27)</a>:</h4>
<p>Now that the proof works, I need to tidy everything up and push PRs. <br>
This will require : uniform naming of lemmas, cleaner APIs,  but in the next days, I have some works to grade…</p>



<a name="284776994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/284776994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin C. Martin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#284776994">(Jun 02 2022 at 17:21)</a>:</h4>
<p>.</p>



<a name="286484151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/286484151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bart Michels <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#286484151">(Jun 17 2022 at 12:46)</a>:</h4>
<p>I have a situation that looks like this, where I want to do induction on dimension:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.free_module.finite.basic</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">division_ring</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">K</span> <span class="n">V</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">K</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>
</code></pre></div>
<p>After lots of searching and trial and error I figured out I can do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">unfreezingI</span> <span class="o">{</span> <span class="n">induction</span> <span class="n">h_dim</span> <span class="o">:</span> <span class="o">(</span><span class="n">module.rank</span> <span class="n">K</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">to_nat</span> <span class="n">using</span> <span class="n">nat.rec_on</span>
  <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span> <span class="n">generalizing</span> <span class="n">V</span> <span class="o">},</span>
</code></pre></div>
<p>Is this the correct way? I can't find this <code>induction h : something</code> type of thing in the tactics docs.</p>



<a name="286484161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/286484161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bart Michels <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#286484161">(Jun 17 2022 at 12:46)</a>:</h4>
<p>Also, is it true that Lean will always figure out it needs to <code>generalize</code> everything that depends on <code>V</code> as well (here, <code>f</code>) ? Edit: ok surely.</p>



<a name="286484444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Complicated%20induction/near/286484444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Complicated.20induction.html#286484444">(Jun 17 2022 at 12:49)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#induction">tactic#induction</a> mentioned "induction h : t will introduce an equality of the form h : t = C x y, asserting that the input term is equal to the current constructor case, to the context." but not so much why that would be useful</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
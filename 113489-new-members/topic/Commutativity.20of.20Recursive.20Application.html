---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html">Commutativity of Recursive Application</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="223407485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223407485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223407485">(Jan 20 2021 at 17:38)</a>:</h4>
<p>I have a function that recursively applies a commutative operation and would like to show that this recursive application is also commutative.<br>
Here's an analogous example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="o">(</span><span class="n">content</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">pour</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="o">{</span><span class="n">content</span> <span class="o">:=</span> <span class="n">b.content</span> <span class="bp">+</span> <span class="n">c</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">pour_comm</span> <span class="o">(</span><span class="n">c</span> <span class="n">c'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span>
<span class="n">pour</span> <span class="n">c</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c'</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pour</span> <span class="n">c'</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">pour_list</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bucket</span> <span class="bp">→</span> <span class="n">bucket</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">pour_list</span> <span class="n">tl</span> <span class="o">(</span><span class="n">pour</span> <span class="n">hd</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">pour_list_comm</span> <span class="o">(</span><span class="n">cs</span> <span class="n">cs'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span>
<span class="n">pour_list</span> <span class="n">cs</span> <span class="o">(</span><span class="n">pour_list</span> <span class="n">cs'</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pour_list</span> <span class="n">cs'</span> <span class="o">(</span><span class="n">pour_list</span> <span class="n">cs</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">--?</span>
<span class="kd">end</span>
</code></pre></div>
<p>The target of the operation is a <code>bucket</code>. Doing a single <code>pour</code> is proven to be commutative. I would like to show that <code>pour_list</code> is also commutative.<br>
Is there a neat way of proving this?<br>
Thanks</p>



<a name="223409173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223409173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223409173">(Jan 20 2021 at 17:51)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="o">(</span><span class="n">content</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">pour</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="o">{</span><span class="n">content</span> <span class="o">:=</span> <span class="n">b.content</span> <span class="bp">+</span> <span class="n">c</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">pour_comm</span> <span class="o">(</span><span class="n">c</span> <span class="n">c'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">pour</span> <span class="n">c</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c'</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pour</span> <span class="n">c'</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">pour_list</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bucket</span> <span class="bp">→</span> <span class="n">bucket</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">pour_list</span> <span class="n">tl</span> <span class="o">(</span><span class="n">pour</span> <span class="n">hd</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">pour_list_comm_singleton</span> <span class="o">(</span><span class="n">cs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">pour_list</span> <span class="n">cs</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pour</span> <span class="n">c</span> <span class="o">(</span><span class="n">pour_list</span> <span class="n">cs</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">cs</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">pour_list</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">pour_list</span><span class="o">,</span> <span class="n">hl</span><span class="o">,</span> <span class="n">pour_comm</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">pour_list_comm</span> <span class="o">(</span><span class="n">cs</span> <span class="n">cs'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">pour_list</span> <span class="n">cs</span> <span class="o">(</span><span class="n">pour_list</span> <span class="n">cs'</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pour_list</span> <span class="n">cs'</span> <span class="o">(</span><span class="n">pour_list</span> <span class="n">cs</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">cs'</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">cs</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">pour_list</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">pour_list</span><span class="o">,</span> <span class="n">pour_list_comm_singleton</span><span class="o">,</span> <span class="n">hl</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="223409214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223409214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223409214">(Jan 20 2021 at 17:51)</a>:</h4>
<p>I had to prove the simpler <code>pour_list_comm_singleton</code> first.</p>



<a name="223409454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223409454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223409454">(Jan 20 2021 at 17:52)</a>:</h4>
<p>You might like the <code>is_commutative</code> Prop</p>



<a name="223409746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223409746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223409746">(Jan 20 2021 at 17:54)</a>:</h4>
<p>Although that operation is limited to things that are all in the same type. I think Kevin remarked on this at some point (or for <code>is_associative</code>).</p>



<a name="223411655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223411655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223411655">(Jan 20 2021 at 18:07)</a>:</h4>
<p>Thanks for your feedback <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span>! Unfortunately I noticed that the example I gave above was actually a bit weaker than what I'm trying to prove. What I actually want to prove is that if I pass two lists to <code>pour_list</code> where one is just a  permutation of the other, the results stay the same. So:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.perm</span>

<span class="kd">structure</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="o">(</span><span class="n">content</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">pour</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="o">{</span><span class="n">content</span> <span class="o">:=</span> <span class="n">b.content</span> <span class="bp">+</span> <span class="n">c</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">pour_comm</span> <span class="o">(</span><span class="n">c</span> <span class="n">c'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span>
<span class="n">pour</span> <span class="n">c</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c'</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pour</span> <span class="n">c'</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">pour_list</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bucket</span> <span class="bp">→</span> <span class="n">bucket</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">pour_list</span> <span class="n">tl</span> <span class="o">(</span><span class="n">pour</span> <span class="n">hd</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">pour_list_comm</span> <span class="o">(</span><span class="n">cs</span> <span class="n">cs'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">cs</span> <span class="bp">~</span> <span class="n">cs'</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span>
<span class="n">pour_list</span> <span class="n">cs</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">pour_list</span> <span class="n">cs'</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">--?</span>
<span class="kd">end</span>
</code></pre></div>



<a name="223411882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223411882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223411882">(Jan 20 2021 at 18:09)</a>:</h4>
<p>Do you know that your <code>pour</code> is associative too?</p>



<a name="223411894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223411894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223411894">(Jan 20 2021 at 18:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application/near/223409746">said</a>:</p>
<blockquote>
<p>Although that operation is limited to things that are all in the same type. I think Kevin remarked on this at some point (or for <code>is_associative</code>).</p>
</blockquote>
<p>Yeah, there's <a href="https://leanprover-community.github.io/mathlib_docs/init/logic.html#right_commutative"><code>right_commutative</code></a> and <code>left_commutative</code> to work around that.</p>



<a name="223412038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223412038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223412038">(Jan 20 2021 at 18:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application/near/223411882">said</a>:</p>
<blockquote>
<p>Do you know that your <code>pour</code> is associative too?</p>
</blockquote>
<p>Yes it is :)</p>



<a name="223412079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223412079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223412079">(Jan 20 2021 at 18:11)</a>:</h4>
<p>Can you show that?</p>



<a name="223412161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223412161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223412161">(Jan 20 2021 at 18:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application/near/223412079">said</a>:</p>
<blockquote>
<p>Can you show that?</p>
</blockquote>
<p>Yeah, I think I could come up with a proof of that.</p>



<a name="223412838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223412838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223412838">(Jan 20 2021 at 18:16)</a>:</h4>
<p>Ok, I guess I got ahead of myself there. How would associativity work for a function whose output type is not the same as its input type?</p>



<a name="223412999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223412999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223412999">(Jan 20 2021 at 18:17)</a>:</h4>
<p>Right.</p>



<a name="223413350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223413350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223413350">(Jan 20 2021 at 18:20)</a>:</h4>
<p>Here's a sort of cheating way to prove <code>pour_list_comm</code>:</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.perm</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="o">(</span><span class="n">content</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">pour</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="o">{</span><span class="n">content</span> <span class="o">:=</span> <span class="n">b.content</span> <span class="bp">+</span> <span class="n">c</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">pour_comm</span> <span class="o">(</span><span class="n">c</span> <span class="n">c'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">pour</span> <span class="n">c</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c'</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pour</span> <span class="n">c'</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">bucket.ext</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">pour</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">add_left_comm</span><span class="o">]</span> <span class="o">})</span>

<span class="kd">def</span> <span class="n">pour_list</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bucket</span> <span class="bp">→</span> <span class="n">bucket</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">pour_list</span> <span class="n">tl</span> <span class="o">(</span><span class="n">pour</span> <span class="n">hd</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">pour_list_eq</span> <span class="o">(</span><span class="n">cs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span> <span class="n">pour_list</span> <span class="n">cs</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">pour</span> <span class="n">cs.sum</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">cs</span> <span class="n">generalizing</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">b</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">pour_list</span><span class="o">,</span> <span class="n">pour</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">pour_list</span><span class="o">],</span> <span class="n">rw</span> <span class="n">cs_ih</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">pour</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">add_left_comm</span><span class="o">],</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">pour_list_comm</span> <span class="o">(</span><span class="n">cs</span> <span class="n">cs'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">cs</span> <span class="bp">~</span> <span class="n">cs'</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">pour_list</span> <span class="n">cs</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">pour_list</span> <span class="n">cs'</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">pour_list_eq</span><span class="o">,</span> <span class="n">list.perm.sum_eq</span> <span class="n">h</span><span class="o">]</span>
</code></pre></div>
</div></div>



<a name="223413407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223413407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223413407">(Jan 20 2021 at 18:20)</a>:</h4>
<p>I've gotten to the point in the proof where the remaining goal is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="n">pour_list</span> <span class="o">(</span><span class="n">pour</span> <span class="n">b</span> <span class="n">hd</span><span class="o">)</span> <span class="o">(</span><span class="n">cs'.erase</span> <span class="n">hd</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pour_list</span> <span class="n">b</span> <span class="n">cs'</span>
</code></pre></div>
<p>(where <code>hd</code> is the head of <code>cs'</code>) but I don't know if I took the right path, or how to continue from here.</p>



<a name="223413485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223413485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223413485">(Jan 20 2021 at 18:20)</a>:</h4>
<p>Can you just use <code>multiset.foldr</code> directly here?</p>



<a name="223413541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223413541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223413541">(Jan 20 2021 at 18:21)</a>:</h4>
<p>If you've proven <a href="https://leanprover-community.github.io/mathlib_docs/find/left_commutative">docs#left_commutative</a> then it will do the rest of the work for you</p>



<a name="223413559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223413559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223413559">(Jan 20 2021 at 18:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application/near/223413485">said</a>:</p>
<blockquote>
<p>Can you just use <code>multiset.foldr</code> directly here?</p>
</blockquote>
<p>You mean instead of the inductive definition over a list?</p>



<a name="223413574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223413574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223413574">(Jan 20 2021 at 18:21)</a>:</h4>
<p>Yes</p>



<a name="223413697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223413697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223413697">(Jan 20 2021 at 18:22)</a>:</h4>
<p>Yeah, I could do that. How would I get the commutativity of <code>foldr</code> then?</p>



<a name="223413730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223413730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223413730">(Jan 20 2021 at 18:22)</a>:</h4>
<p>Ah, you want <a href="https://leanprover-community.github.io/mathlib_docs/find/list.perm.foldr_eq">docs#list.perm.foldr_eq</a></p>



<a name="223413747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223413747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223413747">(Jan 20 2021 at 18:22)</a>:</h4>
<p><code>multiset</code> not needed</p>



<a name="223413787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223413787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223413787">(Jan 20 2021 at 18:23)</a>:</h4>
<p>wow, list has fold too :D</p>



<a name="223413822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223413822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223413822">(Jan 20 2021 at 18:23)</a>:</h4>
<p>If you insist on your inductive definition, then you could hopefully prove very easily that it's equal to a fold</p>



<a name="223413873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223413873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223413873">(Jan 20 2021 at 18:23)</a>:</h4>
<p>Nah, fold is perfect.<br>
Thanks everybody! I think I'll be able to get it from here :)</p>



<a name="223414078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223414078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223414078">(Jan 20 2021 at 18:25)</a>:</h4>
<p>Yeah, <code>pour_list</code> is best defined as a <code>foldr</code></p>



<a name="223428178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223428178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223428178">(Jan 20 2021 at 20:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="372804">Marcus Rossel</span> <a href="#narrow/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application/near/223413873">said</a>:</p>
<blockquote>
<p>Nah, fold is perfect.<br>
Thanks everybody! I think I'll be able to get it from here :)</p>
</blockquote>
<p>Well bummer, I'm not able to get it from here ^^<br>
There's a constraint on the commutativity of my <code>pour</code> function, that's giving me a hard time extending the commutativity to <code>pour_list</code>.</p>
<p>Let's say the commutativity of <code>pour</code> depends on a <code>belongs_to</code> property:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.perm</span>

<span class="kd">structure</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="o">(</span><span class="n">content</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">pour</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="o">{</span><span class="n">content</span> <span class="o">:=</span> <span class="n">b.content</span> <span class="bp">+</span> <span class="n">c</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">belongs_to</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">pour_comm</span> <span class="o">(</span><span class="n">c</span> <span class="n">c'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">belongs_to</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">belongs_to</span> <span class="n">c'</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
<span class="n">pour</span> <span class="n">c</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c'</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pour</span> <span class="n">c'</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">pour_list</span> <span class="o">:</span> <span class="n">bucket</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="n">list.foldr</span> <span class="n">pour</span>

<span class="kd">theorem</span> <span class="n">pour_list_comm</span> <span class="o">(</span><span class="n">cs</span> <span class="n">cs'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">cs</span> <span class="bp">~</span> <span class="n">cs'</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">(</span><span class="n">h_b</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">cs</span><span class="o">,</span> <span class="n">belongs_to</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h_b'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x'</span> <span class="bp">∈</span> <span class="n">cs'</span><span class="o">,</span> <span class="n">belongs_to</span> <span class="n">x'</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
<span class="n">pour_list</span> <span class="n">b</span> <span class="n">cs'</span> <span class="bp">=</span> <span class="n">pour_list</span> <span class="n">b</span> <span class="n">cs'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- Can't just use `list.perm.foldr_eq` here ...</span>
<span class="kd">end</span>
</code></pre></div>
<p>Using <code>list.perm.foldr_eq</code> or <code>list.perm.foldr_eq'</code> in the proof of the theorem doesn't work anymore, because the commutativity of <code>pour</code> doesn't hold for <em>all</em> <code>c</code>s. But assuming that all of the elements in <code>cs</code> and <code>cs'</code> <em>do</em> have that property (required by <code>h_b</code> and <code>h_b'</code>), is there a way to show that <code>pour_list</code> is the same for permutations?</p>



<a name="223433513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223433513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223433513">(Jan 20 2021 at 20:53)</a>:</h4>
<p>Do you know <code>belongs_to c (pour c' b)</code>? Otherwise that theorem looks difficult to apply</p>



<a name="223433581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223433581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223433581">(Jan 20 2021 at 20:53)</a>:</h4>
<p>in fact I'm not even sure it's true for three elements</p>



<a name="223435228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223435228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223435228">(Jan 20 2021 at 21:04)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.perm</span>
<span class="kd">inductive</span> <span class="n">bucket</span>
<span class="bp">|</span> <span class="n">zero</span>
<span class="bp">|</span> <span class="n">one</span>
<span class="bp">|</span> <span class="n">two</span>
<span class="bp">|</span> <span class="n">three</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">pour</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">bucket</span> <span class="bp">→</span> <span class="n">bucket</span>
<span class="bp">|</span> <span class="n">bucket.zero</span> <span class="o">:=</span> <span class="n">bucket.one</span>
<span class="bp">|</span> <span class="n">bucket.one</span> <span class="o">:=</span> <span class="n">bucket.two</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">bucket.three</span> <span class="n">c</span>

<span class="kd">def</span> <span class="n">belongs_to</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">:=</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">bucket.zero</span>

<span class="kd">lemma</span> <span class="n">pour_comm</span> <span class="o">(</span><span class="n">c</span> <span class="n">c'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">belongs_to</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">belongs_to</span> <span class="n">c'</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">pour</span> <span class="n">c</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c'</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pour</span> <span class="n">c'</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h'</span><span class="o">,</span> <span class="n">refl</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">pour_list</span> <span class="o">:</span> <span class="n">bucket</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="n">list.foldr</span> <span class="n">pour</span>

<span class="kd">theorem</span> <span class="n">pour_list_comm</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">cs</span> <span class="n">cs'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">cs</span> <span class="bp">~</span> <span class="n">cs'</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_b</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">cs</span><span class="o">,</span> <span class="n">belongs_to</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h_b'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x'</span> <span class="bp">∈</span> <span class="n">cs'</span><span class="o">,</span> <span class="n">belongs_to</span> <span class="n">x'</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">pour_list</span> <span class="n">b</span> <span class="n">cs</span> <span class="bp">=</span> <span class="n">pour_list</span> <span class="n">b</span> <span class="n">cs'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">H</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="n">dec_trivial</span> <span class="n">bucket.zero</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="223439194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223439194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223439194">(Jan 20 2021 at 21:36)</a>:</h4>
<p>However if you assume that <code>belongs_to</code> is closed under <code>pour</code> then it is true:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.perm</span>
<span class="kd">def</span> <span class="n">bucket</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">pour</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">bucket</span> <span class="bp">→</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">belongs_to</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">),</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">belongs_to.pour</span> <span class="o">{</span><span class="n">c</span> <span class="n">c'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">belongs_to</span> <span class="n">c</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">belongs_to</span> <span class="n">c'</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">belongs_to</span> <span class="n">c</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c'</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">pour_comm</span> <span class="o">{</span><span class="n">c</span> <span class="n">c'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">belongs_to</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">belongs_to</span> <span class="n">c'</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">pour</span> <span class="n">c</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c'</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pour</span> <span class="n">c'</span> <span class="o">(</span><span class="n">pour</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">pour_list</span> <span class="o">:</span> <span class="n">bucket</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="n">list.foldr</span> <span class="n">pour</span>

<span class="kd">theorem</span> <span class="n">belongs_to.pour_list</span> <span class="o">{</span><span class="n">c</span><span class="o">}</span> <span class="o">{</span><span class="n">cs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">belongs_to</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hcs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x'</span> <span class="bp">∈</span> <span class="n">cs</span><span class="o">,</span> <span class="n">belongs_to</span> <span class="n">x'</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">belongs_to</span> <span class="n">c</span> <span class="o">(</span><span class="n">pour_list</span> <span class="n">b</span> <span class="n">cs</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">cs</span> <span class="n">generalizing</span> <span class="n">c</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">hc</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">list.forall_mem_cons.1</span> <span class="n">hcs</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">belongs_to.pour</span> <span class="o">(</span><span class="n">cs_ih</span> <span class="n">h2</span> <span class="n">hc</span><span class="o">)</span> <span class="o">(</span><span class="n">cs_ih</span> <span class="n">h2</span> <span class="n">h1</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">pour_list_comm</span> <span class="o">(</span><span class="n">cs</span> <span class="n">cs'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">cs</span> <span class="bp">~</span> <span class="n">cs'</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bucket</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_b</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">cs</span><span class="o">,</span> <span class="n">belongs_to</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h_b'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x'</span> <span class="bp">∈</span> <span class="n">cs'</span><span class="o">,</span> <span class="n">belongs_to</span> <span class="n">x'</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">pour_list</span> <span class="n">b</span> <span class="n">cs</span> <span class="bp">=</span> <span class="n">pour_list</span> <span class="n">b</span> <span class="n">cs'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">pour_list</span><span class="o">],</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">list.perm.cons</span> <span class="o">:</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">IH</span> <span class="o">{</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">list.foldr</span><span class="o">],</span> <span class="n">rw</span> <span class="n">IH</span> <span class="o">(</span><span class="n">list.forall_mem_cons.1</span> <span class="n">h_b</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">list.forall_mem_cons.1</span> <span class="n">h_b'</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">list.perm.swap</span> <span class="o">{</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">list.foldr</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">list.forall_mem_cons</span><span class="o">,</span> <span class="n">list.forall_mem_cons</span><span class="o">]</span> <span class="n">at</span> <span class="n">h_b</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h_b</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">,</span> <span class="n">h3</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">pour_comm</span> <span class="o">(</span><span class="n">belongs_to.pour_list</span> <span class="n">h1</span> <span class="n">h3</span><span class="o">)</span> <span class="o">(</span><span class="n">belongs_to.pour_list</span> <span class="n">h2</span> <span class="n">h3</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">list.perm.trans</span> <span class="o">:</span> <span class="n">l1</span> <span class="n">l2</span> <span class="n">l3</span> <span class="n">p1</span> <span class="n">p2</span> <span class="n">IH1</span> <span class="n">IH2</span> <span class="o">{</span>
    <span class="k">have</span> <span class="n">hc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">h_b</span> <span class="n">x</span> <span class="o">(</span><span class="n">p1.mem_iff.2</span> <span class="n">h</span><span class="o">),</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">IH1</span> <span class="n">h_b</span> <span class="n">hc</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">IH2</span> <span class="n">hc</span> <span class="n">h_b'</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="223548141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Commutativity%20of%20Recursive%20Application/near/223548141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Commutativity.20of.20Recursive.20Application.html#223548141">(Jan 21 2021 at 18:09)</a>:</h4>
<p>Wow, thanks <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>! The "<code>belongs_to</code> is closed under <code>pour</code>"-part and the special induction for <code>list.perm</code> was what I was missing.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
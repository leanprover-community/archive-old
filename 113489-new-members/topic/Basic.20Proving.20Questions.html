---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Basic.20Proving.20Questions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html">Basic Proving Questions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="267675531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267675531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267675531">(Jan 12 2022 at 02:34)</a>:</h4>
<p>My tactic state is this: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span>
<span class="n">ha</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span>
<span class="n">heq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∪</span> <span class="n">B</span><span class="o">,</span>
<span class="n">heqa</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∪</span> <span class="n">B</span><span class="o">,</span>
<span class="n">heqb</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∪</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span>
<span class="bp">⊢</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span>
</code></pre></div>
<p>The union is defined as <code>x ∈ A ∪ B ↔ x ∈ A ∨ x ∈ B</code>,  so it seems like I need a proof of  <code>x ∈ A ∨ x ∈ B</code> from <code>ha : x ∈ A,</code> how could I do it?</p>



<a name="267675715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267675715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267675715">(Jan 12 2022 at 02:38)</a>:</h4>
<p><code>or.inl ha</code></p>



<a name="267675729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267675729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267675729">(Jan 12 2022 at 02:38)</a>:</h4>
<p>I am not sure offhand whether the other proposition is an explicit argument to <code>or.inl</code> or not</p>



<a name="267676109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267676109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267676109">(Jan 12 2022 at 02:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/267675715">said</a>:</p>
<blockquote>
<p><code>or.inl ha</code></p>
</blockquote>
<p>Hey I think you're right, thank you!</p>
<p>Here it is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="kd">inductive</span> <span class="n">or</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
<span class="kt">Prop</span>

    <span class="n">inl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">b</span>
    <span class="n">inr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">b</span>
</code></pre></div>
<p>I have an issue though, when I write <code>  have ho := or.inl ha (x ∈ B),</code> I get this as my tactic state:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">or.inl</span> <span class="n">ha</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∨</span> <span class="bp">?</span><span class="n">m_1</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span>
<span class="n">ha</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span>
<span class="n">heq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∪</span> <span class="n">B</span><span class="o">,</span>
<span class="n">heqa</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∪</span> <span class="n">B</span><span class="o">,</span>
<span class="n">heqb</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∪</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span>
<span class="bp">⊢</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span>
</code></pre></div>



<a name="267676515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267676515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267676515">(Jan 12 2022 at 02:55)</a>:</h4>
<p>That's suggesting that <code>or.inl</code> is taking only one argument, and you want <code>or.inl ha</code>.  I expect that <code>rw heqa, exact or.inl ha,</code> ought to finish the proof.</p>



<a name="267677016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267677016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267677016">(Jan 12 2022 at 03:03)</a>:</h4>
<p>Hmm, you're right, that closes the goal. I don't think I fully understand <code>or.inl ha</code> doesn't it take two parameters namely a and b ? <code>  inl : ∀ (a b : Prop), a → a ∨ b</code></p>



<a name="267677198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267677198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267677198">(Jan 12 2022 at 03:06)</a>:</h4>
<p>I guess that's a bug in our documentation generator.<br>
If you do this in Lean</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">or.inl</span>
</code></pre></div>
<p>we can see that Lean thinks the type is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">b</span>
</code></pre></div>
<p>which has implicit a and b arguments</p>



<a name="267678492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267678492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267678492">(Jan 12 2022 at 03:28)</a>:</h4>
<p><code>#print or</code> at least gets it all right:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">or</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="n">constructors</span><span class="o">:</span>
<span class="n">or.inl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">b</span>
<span class="n">or.inr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">b</span>
</code></pre></div>



<a name="267780305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267780305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267780305">(Jan 12 2022 at 20:19)</a>:</h4>
<p>With <a href="https://github.com/leanprover-community/doc-gen/pull/151">doc-gen#151</a> this should be fixed after the next time docs build</p>



<a name="267784932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267784932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267784932">(Jan 12 2022 at 20:56)</a>:</h4>
<p>Last night Kyle showed me that </p>
<p><code>exact or.inl ha</code></p>
<p>finishes the following proof</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span>
<span class="n">ha</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span>
<span class="n">heq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∪</span> <span class="n">B</span><span class="o">,</span>
<span class="n">heqa</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∪</span> <span class="n">B</span><span class="o">,</span>
<span class="n">heqb</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∪</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span>
<span class="bp">⊢</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∪</span> <span class="n">B</span>
</code></pre></div>
<p>I'm having trouble seeing why this is true, <code>or.inl ha</code> would just be <code>∀ {b : Prop}, x ∈ A -&gt; x ∈ A V b</code> I think I'm interpreting the implicit arguments wrong...</p>



<a name="267786046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267786046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267786046">(Jan 12 2022 at 21:04)</a>:</h4>
<p><span class="user-mention" data-user-id="367659">@ccn</span> The secret is in the definition of union <a href="https://leanprover-community.github.io/mathlib_docs/find/set.union">docs#set.union</a></p>
<p>It's definitionally "x in A or x in B"</p>



<a name="267786141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267786141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267786141">(Jan 12 2022 at 21:05)</a>:</h4>
<p>Oh, also <code>b</code> ends up being "x in B", which Lean infers through its elaboration process.</p>



<a name="267787887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267787887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267787887">(Jan 12 2022 at 21:21)</a>:</h4>
<p>So it's able to guess it because it knows that that's what my goal is?</p>



<a name="267787932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267787932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267787932">(Jan 12 2022 at 21:21)</a>:</h4>
<p>Is there a way to specifically create the term  "x in A or x in B" without letting it infer?</p>



<a name="267796068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267796068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267796068">(Jan 12 2022 at 22:30)</a>:</h4>
<p>There are a couple of ways:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- -- uncomment ONE:</span>
  <span class="c1">-- simp</span>
  <span class="c1">-- dsimp only [mem_union_eq]</span>
  <span class="c1">-- change x ∈ s ∨ x ∈ t</span>
<span class="kd">end</span>
</code></pre></div>



<a name="267800272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267800272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267800272">(Jan 12 2022 at 23:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/267787932">said</a>:</p>
<blockquote>
<p>Is there a way to specifically create the term  "x in A or x in B" without letting it infer?</p>
</blockquote>
<p>You can also use <code>@or.inl</code> to turn all the implicit arguments into explicit arguments.  Fill in as many underscores as you want: <code>@or.inl _ _ ha</code> (the second underscore would be for the "<code>b</code>").</p>



<a name="267800704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267800704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267800704">(Jan 12 2022 at 23:14)</a>:</h4>
<p>There's also <a href="https://leanprover-community.github.io/mathlib_docs/find/or.intro_left">docs#or.intro_left</a></p>



<a name="267808278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267808278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267808278">(Jan 13 2022 at 00:27)</a>:</h4>
<p>I was proving a basic set theory fact and this suprised me</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span>
<span class="n">hint</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∩</span> <span class="n">B</span><span class="bp">ᶜ</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span>
</code></pre></div>
<p>I'm not really sure what the goal is here, am I supposed to be making a function? I've tried <code>exact x</code> and <code>exact hint</code> but they don't work.</p>



<a name="267808437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267808437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267808437">(Jan 13 2022 at 00:29)</a>:</h4>
<p>Try dsimp first</p>



<a name="267808440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267808440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267808440">(Jan 13 2022 at 00:29)</a>:</h4>
<p>A <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> would be good for this to know how you got into this situation. You can do <code>dsimp only</code> to beta reduce that lambda expression, giving you something definitionally equal.</p>



<a name="267808498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267808498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267808498">(Jan 13 2022 at 00:30)</a>:</h4>
<p>fwiw this is the function mapping "a" to the proposition "a is not in B", applied to x.</p>



<a name="267808735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267808735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267808735">(Jan 13 2022 at 00:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/267808440">said</a>:</p>
<blockquote>
<p>A <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> would be good for this to know how you got into this situation. You can do <code>dsimp only</code> to beta reduce that lambda expression, giving you something definitionally equal.</p>
</blockquote>
<p>No problem, I am working on the real number game (<a href="https://www.ma.imperial.ac.uk/~buzzard/xena/rng090720/?world=1&amp;level=6">https://www.ma.imperial.ac.uk/~buzzard/xena/rng090720/?world=1&amp;level=6</a>), click that link and paste in this code, you should be where I am at: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rw</span> <span class="n">ext_iff</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>
<span class="o">{</span>
  <span class="n">intro</span> <span class="n">hdiff</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hdiff.1</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hdiff.2</span><span class="o">,</span>
<span class="o">},</span>
<span class="o">{</span>
  <span class="n">intro</span> <span class="n">hint</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hint.1</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>



<a name="267808831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267808831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267808831">(Jan 13 2022 at 00:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/267808498">said</a>:</p>
<blockquote>
<p>fwiw this is the function mapping "a" to the proposition "a is not in B", applied to x.</p>
</blockquote>
<p>Ok, so that means I'm trying to prove that x is not in B right?</p>



<a name="267808947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267808947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267808947">(Jan 13 2022 at 00:35)</a>:</h4>
<p>That was a good tip, <code>hint.2</code> solved it for me!</p>
<p>It's a little weird why it didn't just say prove x is not in B though...</p>



<a name="267809189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267809189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267809189">(Jan 13 2022 at 00:38)</a>:</h4>
<p>Is there a general way to prove arbitrary "true" inequalities like 57374 &lt; 99999999 ?</p>



<a name="267809211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267809211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267809211">(Jan 13 2022 at 00:39)</a>:</h4>
<p><code>norm_num</code></p>



<a name="267809607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267809607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267809607">(Jan 13 2022 at 00:45)</a>:</h4>
<p>Would you be referring to this: <a href="https://leanprover-community.github.io/mathlib_docs/tactic/norm_num.html#norm_num.prove_lt_nat">https://leanprover-community.github.io/mathlib_docs/tactic/norm_num.html#norm_num.prove_lt_nat</a> ?</p>



<a name="267809687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267809687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267809687">(Jan 13 2022 at 00:46)</a>:</h4>
<p>Btw you can just write <a href="https://leanprover-community.github.io/mathlib_docs/find/norm_num.prove_lt_nat">docs#norm_num.prove_lt_nat</a> and zulip will figure out the link <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="267809723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267809723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267809723">(Jan 13 2022 at 00:47)</a>:</h4>
<p><span class="user-mention" data-user-id="367659">@ccn</span> <a href="https://leanprover-community.github.io/mathlib_docs/find/set.diff">docs#set.diff</a> is defined using set separation notation -- it takes a set and a predicate. What happened is that you <code>split</code> it, which while works, "breaks the set API", so you got something that notationally looks weird. (<code>dsimp only</code> does renormalize it, though).</p>
<p>You're supposed to use <code>rw mem_sdiff_iff</code> like the level introduces to not have things look weird.</p>



<a name="267809737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267809737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267809737">(Jan 13 2022 at 00:47)</a>:</h4>
<p>and eric means <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#norm_num">tactic#norm_num</a></p>



<a name="267809744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267809744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267809744">(Jan 13 2022 at 00:47)</a>:</h4>
<p>but no, it's just a tactic; if your goal is <code>1233462734 &gt; 0</code>, then <code>by norm_num</code> will solve it</p>



<a name="267809864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267809864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267809864">(Jan 13 2022 at 00:49)</a>:</h4>
<p>And for similar reasons, I gave you bad advice about how to prove union membership earlier. You should be doing <code>rw mem_union_iff</code> first to not accidentally rely on implementation details.</p>



<a name="267810016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267810016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267810016">(Jan 13 2022 at 00:51)</a>:</h4>
<p>Someone else used <code>linarith</code> what is that doing?</p>



<a name="267810116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267810116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267810116">(Jan 13 2022 at 00:52)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#linarith">tactic#linarith</a> automatically solves linear (in)equalities</p>



<a name="267946313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267946313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267946313">(Jan 13 2022 at 23:23)</a>:</h4>
<p>I've been working on this limit proof, but I get stuck around here</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span> <span class="n">algebra.geom_sum</span>
<span class="kn">import</span> <span class="n">analysis.special_functions.log</span>
<span class="kn">import</span> <span class="n">order.succ_pred</span>

<span class="kd">def</span> <span class="n">lim_to_inf</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">N</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">N</span><span class="o">,</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">l</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span>

<span class="k">#check</span> <span class="o">(</span><span class="mi">3</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">zero_point_nine_recurring_is_one</span> <span class="o">:</span>
  <span class="n">lim_to_inf</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="mi">9</span> <span class="bp">/</span> <span class="mi">10</span> <span class="bp">*</span> <span class="n">geom_sum</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">ε</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">hε</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">nat.ceil</span> <span class="o">((</span><span class="n">real.log</span> <span class="o">(</span><span class="n">ε</span><span class="o">))</span> <span class="bp">/</span> <span class="o">(</span><span class="n">real.log</span> <span class="mi">1</span><span class="bp">/</span><span class="mi">10</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ge_iff_le</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">nat.lt_succ_self</span> <span class="o">(</span><span class="bp">⌈</span><span class="n">real.log</span> <span class="n">ε</span> <span class="bp">/</span> <span class="o">(</span><span class="n">real.log</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">⌉₊</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="n">lt_of_lt_of_le</span> <span class="n">h1</span> <span class="n">hn</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:=</span> <span class="n">nat.le_ceil</span> <span class="o">(</span><span class="n">real.log</span> <span class="n">ε</span> <span class="bp">/</span> <span class="o">(</span><span class="n">real.log</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">),</span>
  <span class="c1">-- have h4 := lt_of_le_of_lt h3 h2,</span>
<span class="kd">end</span>
</code></pre></div>
<p>When I uncomment the last line there I get the following</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">lt_of_le_of_lt</span> <span class="n">h3</span> <span class="n">h2</span>
<span class="n">term</span>
  <span class="n">h2</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">⌈</span><span class="n">real.log</span> <span class="n">ε</span> <span class="bp">/</span> <span class="o">(</span><span class="n">real.log</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">⌉₊</span> <span class="bp">&lt;</span> <span class="n">n</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">↑⌈</span><span class="n">real.log</span> <span class="n">ε</span> <span class="bp">/</span> <span class="o">(</span><span class="n">real.log</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">⌉₊</span> <span class="bp">&lt;</span> <span class="bp">?</span><span class="n">m_1</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
<span class="n">hε</span> <span class="o">:</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">hn</span> <span class="o">:</span> <span class="bp">⌈</span><span class="n">real.log</span> <span class="n">ε</span> <span class="bp">/</span> <span class="o">(</span><span class="n">real.log</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">⌉₊</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="bp">⌈</span><span class="n">real.log</span> <span class="n">ε</span> <span class="bp">/</span> <span class="o">(</span><span class="n">real.log</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">⌉₊</span> <span class="bp">&lt;</span> <span class="bp">⌈</span><span class="n">real.log</span> <span class="n">ε</span> <span class="bp">/</span> <span class="o">(</span><span class="n">real.log</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">⌉₊.</span><span class="n">succ</span><span class="o">,</span>
<span class="n">h2</span> <span class="o">:</span> <span class="bp">⌈</span><span class="n">real.log</span> <span class="n">ε</span> <span class="bp">/</span> <span class="o">(</span><span class="n">real.log</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">⌉₊</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span>
<span class="n">h3</span> <span class="o">:</span> <span class="n">real.log</span> <span class="n">ε</span> <span class="bp">/</span> <span class="o">(</span><span class="n">real.log</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="bp">↑⌈</span><span class="n">real.log</span> <span class="n">ε</span> <span class="bp">/</span> <span class="o">(</span><span class="n">real.log</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">⌉₊</span>
<span class="bp">⊢</span> <span class="bp">|</span><span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="mi">9</span> <span class="bp">/</span> <span class="mi">10</span> <span class="bp">*</span> <span class="n">geom_sum</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">|</span> <span class="bp">&lt;</span> <span class="n">ε</span>
</code></pre></div>
<p>I know that  this has to do with coercion in some way, but I'm not sure how to get it to work, I think I need to somehow convert it all to real numbers, any tips?</p>



<a name="267947087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267947087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267947087">(Jan 13 2022 at 23:30)</a>:</h4>
<p>Can you give your h1, h2, h3 explicit types? It'll be clearer to you and to us what you expect them to be.</p>



<a name="267947755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267947755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267947755">(Jan 13 2022 at 23:37)</a>:</h4>
<p><span class="user-mention" data-user-id="367659">@ccn</span> Just answering your question without checking what you're doing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="n">h2'</span> <span class="o">:=</span> <span class="n">nat.cast_lt.mpr</span> <span class="n">h2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h4</span> <span class="o">:=</span> <span class="n">lt_of_le_of_lt</span> <span class="n">h3</span> <span class="n">h2'</span><span class="o">,</span>
</code></pre></div>
<p>I found this by</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="n">h2'</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⌈</span><span class="n">real.log</span> <span class="n">ε</span> <span class="bp">/</span> <span class="o">(</span><span class="n">real.log</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">⌉₊</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">library_search</span><span class="o">,</span>
</code></pre></div>



<a name="267949479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267949479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267949479">(Jan 13 2022 at 23:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/267947087">said</a>:</p>
<blockquote>
<p>Can you give your h1, h2, h3 explicit types? It'll be clearer to you and to us what you expect them to be.</p>
</blockquote>
<p>Sure I'll send it when I get home</p>



<a name="267952227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267952227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267952227">(Jan 14 2022 at 00:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/267947087">said</a>:</p>
<blockquote>
<p>Can you give your h1, h2, h3 explicit types? It'll be clearer to you and to us what you expect them to be.</p>
</blockquote>
<p>I want to make the inequalities involving real numbers for now, would the type of that be <code>ℝ &lt; ℝ</code></p>



<a name="267952614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/267952614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#267952614">(Jan 14 2022 at 00:32)</a>:</h4>
<p>The type of <code>h1</code> is whatever it is a proof of. It's displayed in the proof state you pasted earlier.</p>



<a name="268217935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268217935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268217935">(Jan 17 2022 at 01:17)</a>:</h4>
<p>I have this proof: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">≤</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span>  <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span><span class="bp">*</span><span class="n">c</span> <span class="bp">≤</span> <span class="n">a</span><span class="bp">*</span><span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">sub_nonneg</span><span class="o">,</span>
  <span class="k">calc</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span><span class="bp">*</span><span class="n">c</span> <span class="o">:</span> <span class="n">mul_nonneg_of_nonpos_of_nonpos</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rwa</span> <span class="n">sub_nonpos</span><span class="o">)</span> <span class="n">hc</span>
    <span class="bp">...</span>  <span class="bp">=</span> <span class="n">a</span><span class="bp">*</span><span class="n">c</span> <span class="bp">-</span> <span class="n">b</span><span class="bp">*</span><span class="n">c</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">ring</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>But I'm having trouble understanding some parts of it. Namely what the <code>(by rwa sub_nonpos)</code> is producing and how the <code>calc</code> tactic works.</p>



<a name="268218070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268218070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268218070">(Jan 17 2022 at 01:20)</a>:</h4>
<p>To my understanding the <code>by</code> command will produce something? So it would be re-writing the current goal and outputting what that is (without changing what the actual goal is).</p>
<p>Does the calc tactic take a chain of inequalities and then just compress it to to the final inequality (in our case <code>0 \le a*c - b*c</code>) and then exit tactic mode?</p>



<a name="268218603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268218603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268218603">(Jan 17 2022 at 01:33)</a>:</h4>
<p>You're right about calc, although in a technical sense it's not actually a tactic. It has a special place in leans core systems but it's not super important; but note that you can <code>calc</code> in term mode</p>



<a name="268218663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268218663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268218663">(Jan 17 2022 at 01:35)</a>:</h4>
<p>For the <code>by</code>, lean is working outside in -  it knows what inequality you want, so it can synthesise the exact required goal for that specific term. You can see that by replacing the by with a begin end and seeing the goal there</p>



<a name="268319129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268319129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268319129">(Jan 17 2022 at 22:05)</a>:</h4>
<p>I was recalling the different ways to define something:</p>
<p>I thought that when we have something like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">double</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">x</span>
</code></pre></div>
<p>It's the same as </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">double</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">-&gt;</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">lambda</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">x</span>
</code></pre></div>
<p>I wanted to try that out on this example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">,</span> <span class="n">hg</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₁</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>
<p>I tried to do it myself, but I know something is off:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span>  <span class="o">(</span><span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">non_decreasing</span> <span class="n">f</span>  <span class="bp">→</span> <span class="n">non_decreasing</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">non_decreasing</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">,</span> <span class="n">hg</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₁</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>
<p>What would be the correct way of stating it?</p>



<a name="268320437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268320437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268320437">(Jan 17 2022 at 22:26)</a>:</h4>
<p>fyi, there's a missing colon after <code>example</code> for the last one.</p>



<a name="268320535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268320535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268320535">(Jan 17 2022 at 22:27)</a>:</h4>
<p>Haven't tested, but for the dependent types you need the pi:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">non_decreasing</span> <span class="n">f</span>  <span class="bp">→</span> <span class="n">non_decreasing</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">non_decreasing</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">,</span> <span class="n">hg</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₁</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>



<a name="268321145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268321145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268321145">(Jan 17 2022 at 22:35)</a>:</h4>
<p>Ah ok, that's making more sense, I managed to use <code>check</code> to get the type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">non_decreasing</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">non_decreasing</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">non_decreasing</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div>
<p>I recall that the forall symbol is the same thing as the pi symbol under the proposition and types correspondance?</p>



<a name="268321616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268321616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268321616">(Jan 17 2022 at 22:41)</a>:</h4>
<p>Oh, sure, forall is idiomatic here.</p>
<p>The forall and pi symbols are completely equivalent, yielding the same type (a pi type). The pretty printer, when printing a pi type, looks to see if it's wrapping a <code>Prop</code>, and if it is the expression is printed with a forall rather than a pi symbol.</p>



<a name="268323132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268323132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268323132">(Jan 17 2022 at 23:01)</a>:</h4>
<p>So this theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">x</span>  <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">,</span> <span class="n">hg</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₁</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>
<p>Even though the Pi isn't there is dependent just because of <code>(hf : non_decreasing f) (hg : non_decreasing g)</code> using <code>f</code> and <code>g</code> which were declared as arguments earlier?</p>



<a name="268323665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268323665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268323665">(Jan 17 2022 at 23:09)</a>:</h4>
<p>Also if they have the same type then how come the same proof term doesn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">non_decreasing</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">non_decreasing</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">non_decreasing</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">,</span> <span class="n">hg</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₁</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>



<a name="268323751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268323751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268323751">(Jan 17 2022 at 23:10)</a>:</h4>
<p>The rule is simply that when you move an argument from "before the colon" to after, you add a <code>Π</code> like so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">g</span><span class="o">),</span> <span class="n">non_decreasing</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">f</span><span class="o">),</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">g</span><span class="o">),</span> <span class="n">non_decreasing</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">f</span><span class="o">),</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">g</span><span class="o">),</span> <span class="n">non_decreasing</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">f</span><span class="o">),</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">non_decreasing</span> <span class="n">g</span><span class="o">),</span> <span class="n">non_decreasing</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>(of course, using foralls instead of pis if you want). You can merge adjacent pis into a single one (that's a syntactic convenience). And, if it's non-dependent, you can use a function arrow (another syntactic convenience.)</p>



<a name="268323769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268323769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268323769">(Jan 17 2022 at 23:10)</a>:</h4>
<p>That doesn't work because things before the colon are all automatically introduced with an implicit lambda.</p>



<a name="268323776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268323776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268323776">(Jan 17 2022 at 23:10)</a>:</h4>
<p>You need <code>f</code> and <code>g</code> as additional arguments for the lambda after the <code>:=</code>.</p>



<a name="268324380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268324380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268324380">(Jan 17 2022 at 23:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/268323769">said</a>:</p>
<blockquote>
<p>That doesn't work because things before the colon are all automatically introduced with an implicit lambda.</p>
</blockquote>
<p>woah that's super cool, how did you know about that?</p>



<a name="268326401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268326401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomaz Gomes Mascarenhas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268326401">(Jan 17 2022 at 23:52)</a>:</h4>
<p>About the cases tactic:</p>
<p>when we try to case an element directly, like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">g</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Option</span> <span class="n">Nat</span>
<span class="kd">constant</span> <span class="n">f</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">Nat</span> <span class="bp">→</span>  <span class="n">Option</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Option</span> <span class="n">Nat</span>

<span class="kd">theorem</span> <span class="n">thm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">Nat</span><span class="o">},</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">k</span><span class="o">)</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">some</span> <span class="mi">4</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">some</span> <span class="mi">3</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">intros</span> <span class="n">k</span> <span class="n">h</span>
     <span class="n">cases</span> <span class="n">k</span>
     <span class="o">(</span><span class="bp">...</span><span class="o">)</span>
</code></pre></div>
<p>all the <code>k</code>s in the hypothesis gets substituted by none and some val. But, if we pattern match on (g k), then the (g k) in the hypothesis don't get substituted:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">thm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">Nat</span><span class="o">},</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">k</span><span class="o">)</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">some</span> <span class="mi">4</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">some</span> <span class="mi">3</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">intros</span> <span class="n">k</span> <span class="n">h</span>
     <span class="n">cases</span> <span class="o">(</span><span class="n">g</span> <span class="n">k</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">...</span><span class="o">)</span>
</code></pre></div>
<p>How do I substitute the (g k) in the hypothesis in this context?</p>



<a name="268329054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268329054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268329054">(Jan 18 2022 at 00:37)</a>:</h4>
<p>Does "cases v : g k" work for you?</p>



<a name="268329164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268329164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomaz Gomes Mascarenhas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268329164">(Jan 18 2022 at 00:39)</a>:</h4>
<p>oh, didn't know about that hehe. Yes, thanks! It is still weird though, this difference in the behaviour of this tactic</p>



<a name="268333704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268333704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268333704">(Jan 18 2022 at 01:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/268323776">said</a>:</p>
<blockquote>
<p>You need <code>f</code> and <code>g</code> as additional arguments for the lambda after the <code>:=</code>.</p>
</blockquote>
<p>Ok, so I think I built this correctly now:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">non_decreasing</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">non_decreasing</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">non_decreasing</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span> <span class="n">hf</span> <span class="n">hg</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">,</span> <span class="n">hg</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₁</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>
<p>Are the types (<code>f g hf hg x₁ x₂ h</code>) of my lambda function automatically inferred?</p>



<a name="268333860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268333860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268333860">(Jan 18 2022 at 01:55)</a>:</h4>
<p><span class="user-mention" data-user-id="367659">@ccn</span> I'm not sure how I knew about the implicit lambda, but this is how many programming languages seem to work (although many don't have dependent types).</p>
<p>Anyway, here are some examples:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="k">#reduce</span> <span class="n">foo</span>
<span class="c">/-</span><span class="cm"> λ (x : ℕ), x.succ -/</span>

<span class="kd">def</span> <span class="n">foo'</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="k">#reduce</span> <span class="n">foo'</span>
<span class="c">/-</span><span class="cm"> λ (x : ℕ), x.succ -/</span>

<span class="kd">def</span> <span class="n">foo''</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="k">#reduce</span> <span class="n">foo''</span>
<span class="c">/-</span><span class="cm"> λ (x : ℕ), x.succ -/</span>
</code></pre></div>



<a name="268333968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268333968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268333968">(Jan 18 2022 at 01:56)</a>:</h4>
<p>@ccn Yes. <code>λ x, x + 1</code> is short for <code>λ (x : _), x + 1</code>, for example, and Lean will try to fill in the the placeholder (the <code>_</code>).</p>



<a name="268334068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268334068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268334068">(Jan 18 2022 at 01:58)</a>:</h4>
<p>So under the "type" way of thinking, I've showed a concrete example of an element of the correct type. In the proof way of thinking, we've found a proof for arbitrary f, g?</p>



<a name="268334070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268334070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268334070">(Jan 18 2022 at 01:58)</a>:</h4>
<p>You can see for yourself by doing <code>#print y</code> after your theorem.</p>



<a name="268334099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268334099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268334099">(Jan 18 2022 at 01:58)</a>:</h4>
<p>that's useful!</p>



<a name="268337142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268337142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268337142">(Jan 18 2022 at 02:53)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">t1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span>
<span class="k">show</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">hp</span>
</code></pre></div>
<p>what does <code>show p, from hp</code> do?</p>



<a name="268339288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268339288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268339288">(Jan 18 2022 at 03:35)</a>:</h4>
<p><a href="https://leanprover.github.io/reference/expressions.html#structured-proofs">https://leanprover.github.io/reference/expressions.html#structured-proofs</a></p>



<a name="268339678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268339678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268339678">(Jan 18 2022 at 03:42)</a>:</h4>
<p>it's the same as <code>hp</code> -- it just announces what it's going to prove before it proves it.</p>



<a name="268619767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268619767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268619767">(Jan 19 2022 at 23:33)</a>:</h4>
<p>Another model is that <code>show P, from hp</code> (in term mode) has the same effect as <code>(id hp : P)</code>, both of which are a less forgetful version of <code>(p : P)</code>.</p>



<a name="268991897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268991897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268991897">(Jan 23 2022 at 02:25)</a>:</h4>
<p>I found this calc proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">calc</span>
  <span class="bp">|</span><span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="n">v</span><span class="o">)</span> <span class="n">n</span> <span class="bp">-</span> <span class="o">(</span><span class="n">l</span> <span class="bp">+</span> <span class="n">l'</span><span class="o">)</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">u</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">v</span> <span class="n">n</span> <span class="bp">-</span> <span class="o">(</span><span class="n">l</span> <span class="bp">+</span> <span class="n">l'</span><span class="o">)</span><span class="bp">|</span>   <span class="o">:</span> <span class="n">rfl</span>
                     <span class="bp">...</span> <span class="bp">=</span> <span class="bp">|</span><span class="o">(</span><span class="n">u</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">l</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">v</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">l'</span><span class="o">)</span><span class="bp">|</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">congr'</span> <span class="mi">1</span> <span class="bp">;</span> <span class="n">ring</span>
                     <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">|</span><span class="n">u</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">l</span><span class="bp">|</span> <span class="bp">+</span> <span class="bp">|</span><span class="n">v</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">l'</span><span class="bp">|</span>   <span class="o">:</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">abs_add</span>
                     <span class="bp">...</span> <span class="bp">≤</span>  <span class="n">ε</span>                       <span class="o">:</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
</code></pre></div>
<p>I have a question about this line:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="bp">|</span><span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="n">v</span><span class="o">)</span> <span class="n">n</span> <span class="bp">-</span> <span class="o">(</span><span class="n">l</span> <span class="bp">+</span> <span class="n">l'</span><span class="o">)</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">u</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">v</span> <span class="n">n</span> <span class="bp">-</span> <span class="o">(</span><span class="n">l</span> <span class="bp">+</span> <span class="n">l'</span><span class="o">)</span><span class="bp">|</span>   <span class="o">:</span> <span class="n">rfl</span>
</code></pre></div>
<p>I read about what <code>rfl</code> is and apparently it is <code>eq.refl _</code> how is this different than refl? how can <code>rfl</code> work here if the two things on either side are different? Wouldn't we be using the fact that (a +b)*c = ac + bc ?</p>
<p>And also about the line </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>                     <span class="bp">...</span> <span class="bp">=</span> <span class="bp">|</span><span class="o">(</span><span class="n">u</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">l</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">v</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">l'</span><span class="o">)</span><span class="bp">|</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">congr'</span> <span class="mi">1</span> <span class="bp">;</span> <span class="n">ring</span>
</code></pre></div>
<p>I don't really understand what <code>by congr' 1 ; ring</code> is doing I know that  <code>congr'</code> tries to prove equalities between applications of functions by recursively proving the arguments are the same. But what is the function here? Also what does the <code>;</code> do in this case. </p>
<p>Thanks.</p>



<a name="268994740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268994740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268994740">(Jan 23 2022 at 03:45)</a>:</h4>
<p>I guess you're referring to <a href="https://github.com/leanprover-community/tutorials/blob/3eb9ca22d213f2644ec7bd094becde1c7786114a/src/exercises/05_sequence_limits.lean#L118">this tutorial</a>.</p>
<p>Tactic <code>refl</code> can be used in proof mode to prove any reflexive relation between definitionally equal terms.</p>
<p>Term <code>rfl</code> is defined to be equal to the constructor <code>eq.refl</code> of the equality type <code>eq</code>. Whenever two terms are definitionally equal, <code>rfl</code> can construct an equality between them.</p>
<p>In your example, <code>u</code> and <code>v</code> are functions from natural numbers to real numbers. Adding two functions is <a href="https://github.com/leanprover-community/mathlib/blob/f4b93c8c14da58eac47b5cc9ce45c1d5319a6275/src/data/pi.lean#L45">defined</a> as <code>u + v = λ x, u x + v x</code>. That's definitional equality, so <code>|(u + v) n - (l + l')|</code> is definitionally equal to <code>|u n + v n - (l + l')|</code> and <code>rfl</code> can prove (construct) the equality.</p>
<p>Tactic <code>congr' 1</code> reduces the goal from <code>|u n + v n - (l + l')| = |u n - l + (v n - l')|</code> to <code>u n + v n - (l + l') = u n - l + (v n - l')</code>. The absolute value is a unary function (see <a href="https://leanprover-community.github.io/mathlib_docs/algebra/abs.html">here</a>). The semicolon applies the tactic on the right to every subgoal created by the tactic on the left. <code>congr' 1</code> created just one goal, so <code>ring</code> is used to solve that goal. Semicolon is used instead of a comma to save us from adding parentheses around <code>congr' 1 ; ring</code></p>



<a name="268996868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268996868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268996868">(Jan 23 2022 at 04:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/268994740">said</a>:</p>
<blockquote>
<p>I guess you're referring to <a href="https://github.com/leanprover-community/tutorials/blob/3eb9ca22d213f2644ec7bd094becde1c7786114a/src/exercises/05_sequence_limits.lean#L118">this tutorial</a>.</p>
<p>Tactic <code>refl</code> can be used in proof mode to prove any reflexive relation between definitionally equal terms.</p>
<p>Term <code>rfl</code> is defined to be equal to the constructor <code>eq.refl</code> of the equality type <code>eq</code>. Whenever two terms are definitionally equal, <code>rfl</code> can construct an equality between them.</p>
<p>In your example, <code>u</code> and <code>v</code> are functions from natural numbers to real numbers. Adding two functions is <a href="https://github.com/leanprover-community/mathlib/blob/f4b93c8c14da58eac47b5cc9ce45c1d5319a6275/src/data/pi.lean#L45">defined</a> as <code>u + v = λ x, u x + v x</code>. That's definitional equality, so <code>|(u + v) n - (l + l')|</code> is definitionally equal to <code>|u n + v n - (l + l')|</code> and <code>rfl</code> can prove (construct) the equality.</p>
<p>Tactic <code>congr' 1</code> reduces the goal from <code>|u n + v n - (l + l')| = |u n - l + (v n - l')|</code> to <code>u n + v n - (l + l') = u n - l + (v n - l')</code>. The absolute value is a unary function (see <a href="https://leanprover-community.github.io/mathlib_docs/algebra/abs.html">here</a>). The semicolon applies the tactic on the right to every subgoal created by the tactic on the left. <code>congr' 1</code> created just one goal, so <code>ring</code> is used to solve that goal. Semicolon is used instead of a comma to save us from adding parentheses around <code>congr' 1 ; ring</code></p>
</blockquote>
<p>Great explanation thank you!</p>



<a name="268997143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268997143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268997143">(Jan 23 2022 at 04:48)</a>:</h4>
<p>I also had another related question. I am reading this proof</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- A sequence admits at most one limit</span>
<span class="c1">-- 0037</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">seq_limit</span> <span class="n">u</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">seq_limit</span> <span class="n">u</span> <span class="n">l'</span> <span class="bp">→</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">l'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- sorry</span>
  <span class="n">intros</span> <span class="n">hl</span> <span class="n">hl'</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">eq_of_abs_sub_le_all</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">ε</span> <span class="n">ε_pos</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hl</span> <span class="o">(</span><span class="n">ε</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">linarith</span><span class="o">)</span> <span class="k">with</span> <span class="n">N</span> <span class="n">hN</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hl'</span> <span class="o">(</span><span class="n">ε</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">linarith</span><span class="o">)</span> <span class="k">with</span> <span class="n">N'</span> <span class="n">hN'</span><span class="o">,</span>
  <span class="k">calc</span> <span class="bp">|</span><span class="n">l</span> <span class="bp">-</span> <span class="n">l'</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="o">(</span><span class="n">l</span><span class="bp">-</span><span class="n">u</span> <span class="o">(</span><span class="n">max</span> <span class="n">N</span> <span class="n">N'</span><span class="o">))</span> <span class="bp">+</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">max</span> <span class="n">N</span> <span class="n">N'</span><span class="o">)</span> <span class="bp">-</span><span class="n">l'</span><span class="o">)</span><span class="bp">|</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">ring_nf</span>
  <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">|</span><span class="n">l</span> <span class="bp">-</span> <span class="n">u</span> <span class="o">(</span><span class="n">max</span> <span class="n">N</span> <span class="n">N'</span><span class="o">)</span><span class="bp">|</span> <span class="bp">+</span> <span class="bp">|</span><span class="n">u</span> <span class="o">(</span><span class="n">max</span> <span class="n">N</span> <span class="n">N'</span><span class="o">)</span> <span class="bp">-</span> <span class="n">l'</span><span class="bp">|</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">abs_add</span>
  <span class="bp">...</span> <span class="bp">=</span>  <span class="bp">|</span><span class="n">u</span> <span class="o">(</span><span class="n">max</span> <span class="n">N</span> <span class="n">N'</span><span class="o">)</span> <span class="bp">-</span> <span class="n">l</span><span class="bp">|</span> <span class="bp">+</span> <span class="bp">|</span><span class="n">u</span> <span class="o">(</span><span class="n">max</span> <span class="n">N</span> <span class="n">N'</span><span class="o">)</span> <span class="bp">-</span> <span class="n">l'</span><span class="bp">|</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">abs_sub_comm</span>
  <span class="bp">...</span> <span class="bp">≤</span> <span class="n">ε</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">hN</span> <span class="o">(</span><span class="n">max</span> <span class="n">N</span> <span class="n">N'</span><span class="o">)</span> <span class="o">(</span><span class="n">le_max_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span> <span class="n">hN'</span> <span class="o">(</span><span class="n">max</span> <span class="n">N</span> <span class="n">N'</span><span class="o">)</span> <span class="o">(</span><span class="n">le_max_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">)]</span>
  <span class="c1">-- sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>But I have trouble with this line:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">|</span><span class="n">l</span> <span class="bp">-</span> <span class="n">u</span> <span class="o">(</span><span class="n">max</span> <span class="n">N</span> <span class="n">N'</span><span class="o">)</span><span class="bp">|</span> <span class="bp">+</span> <span class="bp">|</span><span class="n">u</span> <span class="o">(</span><span class="n">max</span> <span class="n">N</span> <span class="n">N'</span><span class="o">)</span> <span class="bp">-</span> <span class="n">l'</span><span class="bp">|</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">abs_add</span>
</code></pre></div>
<p>why aren't they just writing <code>abs_add</code> here? Doesn't apply  get used when you have a function like <code>p -&gt; q</code> and your goal is <code>q</code> so using apply you can change your goal to just <code>p</code>?</p>
<p><a href="https://leanprover-community.github.io/mathlib_docs/algebra/order/group.html#abs_add">https://leanprover-community.github.io/mathlib_docs/algebra/order/group.html#abs_add</a></p>



<a name="268998119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268998119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268998119">(Jan 23 2022 at 05:13)</a>:</h4>
<p>if you write just <code>abs_add</code>, it would be a type error since <code>abs_add</code> has a type like <code>\forall x y, |x + y| &lt;= |x| + |y|</code> while the goal is <code>|a + b| &lt;= |a| + |b|</code> for some <code>a,b</code></p>



<a name="268998125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268998125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268998125">(Jan 23 2022 at 05:13)</a>:</h4>
<p>you would have to write <code>abs_add _ _</code></p>



<a name="268998170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/268998170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#268998170">(Jan 23 2022 at 05:14)</a>:</h4>
<p><code>by apply abs_add</code> is saying "add underscores as necessary to make the types match up"</p>



<a name="269021501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269021501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269021501">(Jan 23 2022 at 14:46)</a>:</h4>
<blockquote>
<p>Doesn't <code>apply</code> get used when you have a function like <code>p -&gt; q</code> and your goal is <code>q</code> so using <code>apply</code> you can change your goal to just <code>p</code>?</p>
</blockquote>
<p>That's correct. Note that <code>A → B</code> is a non-dependent function type (the type of the result does not depend on the value of the argument). A more general function type is <code>Π (x : A), ϕ</code>, where <code>ϕ</code> is some expression that depends on <code>x</code>. The <code>Π</code> symbol can be written as <code>∀</code> (they are interchangeable).</p>
<p>Term <code>abs_add</code> is a function whose type is <code>∀ x y, |x + y| ≤ |x| + |y|</code>. As its type says, <code>abs_add</code> is a function that takes two arguments <code>x</code> and <code>y</code>, and returns a term of type <code>|x + y| ≤ |x| + |y|</code>. When you perform <code>apply abs_add</code>, the <code>apply</code> tactic looks at the type of the goal and figures out what <code>x</code> and <code>y</code> should be.</p>



<a name="269031365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269031365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269031365">(Jan 23 2022 at 18:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/268991897">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code>                     <span class="bp">...</span> <span class="bp">=</span> <span class="bp">|</span><span class="o">(</span><span class="n">u</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">l</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">v</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">l'</span><span class="o">)</span><span class="bp">|</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">congr'</span> <span class="mi">1</span> <span class="bp">;</span> <span class="n">ring</span>
</code></pre></div><br>
</p>
</blockquote>
<p>If <code>congr' 1</code> leads to only one goal, it's considered to be better style to write it like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>                     <span class="bp">...</span> <span class="bp">=</span> <span class="bp">|</span><span class="o">(</span><span class="n">u</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">l</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">v</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">l'</span><span class="o">)</span><span class="bp">|</span> <span class="o">:</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span> <span class="n">ring</span> <span class="o">}</span>
</code></pre></div>
<p>That makes is so that whenever you see <code>;</code> then you can be sure it's because more than one goal is being manipulated.</p>
<p>Just thought I'd mention this.  (I'm not sure when this became the style. Maybe within the last two years?)</p>



<a name="269031577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269031577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269031577">(Jan 23 2022 at 18:18)</a>:</h4>
<p>It also means you can see the proof state after <code>congr' 1</code> by positioning the cursor there</p>



<a name="269299856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269299856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269299856">(Jan 25 2022 at 18:18)</a>:</h4>
<p>I have this proof I wrote down on paper and I'd like to try to get it into a lean proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">4</span><span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">-</span> <span class="mi">7</span><span class="n">y</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≠</span> <span class="mi">2003</span>

<span class="n">pf</span><span class="o">:</span>

<span class="mi">2003</span> <span class="bp">≡</span> <span class="mi">1</span> <span class="o">(</span><span class="n">mod</span> <span class="mi">7</span><span class="o">)</span> <span class="n">because</span> <span class="mi">2002</span> <span class="bp">=</span> <span class="mi">7</span> <span class="bp">*</span> <span class="mi">286</span>

<span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="n">mod</span> <span class="mi">7</span> <span class="n">is</span> <span class="n">congruent</span> <span class="n">to</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">-</span><span class="mi">1</span><span class="o">}</span> <span class="n">because</span>

<span class="mi">0</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="bp">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="bp">^</span><span class="mi">3</span>  <span class="bp">≡</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="bp">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="bp">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="mi">0</span>

<span class="n">so</span> <span class="n">the</span> <span class="n">pattern</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="bp">-</span><span class="mi">1</span> <span class="mi">1</span> <span class="bp">-</span><span class="mi">1</span> <span class="bp">-</span><span class="mi">1</span> <span class="mi">0</span> <span class="n">repeats</span> <span class="n">forever</span>

<span class="n">thus</span> <span class="mi">4</span><span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="n">is</span> <span class="n">congruent</span> <span class="n">to</span> <span class="n">one</span> <span class="n">of</span> <span class="o">{</span><span class="mi">0</span> <span class="mi">4</span><span class="o">,</span> <span class="bp">-</span><span class="mi">4</span><span class="o">}</span><span class="bp">.</span>

<span class="n">For</span> <span class="n">a</span> <span class="n">contradiction</span> <span class="k">assume</span> <span class="mi">4</span><span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">-</span> <span class="mi">7</span><span class="n">y</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">=</span> <span class="mi">2003</span><span class="o">,</span> <span class="k">then</span>

<span class="mi">4</span><span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">-</span> <span class="mi">7</span><span class="n">y</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="mi">2003</span>

<span class="mi">4</span><span class="n">x</span><span class="bp">^</span><span class="mi">3</span>  <span class="bp">≡</span> <span class="mi">1</span>

<span class="n">which</span> <span class="n">is</span> <span class="n">impossible</span>
</code></pre></div>
<p>My main questions are how we  would show <code>2003 ≡ 1 (mod 7)</code> and how we would prove something like this:</p>
<blockquote>
<p>x^3 mod 7 is congruent to {0, 1, -1} because </p>
<p>0^3 ≡ 0, 1^3 ≡ 1, 2^3 ≡ 1, 3^3 ≡ -1, 4^3  ≡ 1, 5^3 ≡ -1, 6^3 ≡ -1, 7^3 ≡ 0 </p>
<p>so the pattern 0 1 1 -1 1 -1 -1 0 repeats forever</p>
</blockquote>
<p>Thanks!</p>



<a name="269300702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269300702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269300702">(Jan 25 2022 at 18:24)</a>:</h4>
<p>Is this the answer to your first question?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.int.modeq</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">2003</span> <span class="bp">≡</span> <span class="mi">1</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">7</span><span class="o">]</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">int.modeq_iff_dvd</span><span class="o">,</span>
  <span class="n">norm_num</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="269302494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269302494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269302494">(Jan 25 2022 at 18:36)</a>:</h4>
<p>Yeah it does, thank you! This <code>norm_num</code> thing seems super powerful</p>



<a name="269302559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269302559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269302559">(Jan 25 2022 at 18:36)</a>:</h4>
<p>What does it mean to normalize numerical expressions?</p>



<a name="269302974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269302974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269302974">(Jan 25 2022 at 18:39)</a>:</h4>
<p>Some other useful tactics for this sort of thing are <a href="https://leanprover-community.github.io/mathlib_docs/find/dec_trivial">docs#dec_trivial</a> and <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#norm_cast">tactic#norm_cast</a> or <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#push_cast">tactic#push_cast</a> to deal with coercions from the integers to integers mod a number</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Here's how I'd show this</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ok</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">,</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">∈</span> <span class="o">[(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">),</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
<span class="kd">lemma</span> <span class="n">problem</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">4</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">-</span> <span class="mi">7</span> <span class="bp">*</span> <span class="n">y</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≠</span> <span class="mi">2003</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="mi">4</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">-</span> <span class="mi">7</span> <span class="bp">*</span> <span class="n">y</span><span class="bp">^</span><span class="mi">3</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">2003</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">apply_fun</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">push_cast</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2003</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">),</span>
  <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="mi">7</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">),</span>
  <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">,</span> <span class="n">sub_zero</span><span class="o">],</span>
  <span class="n">generalize</span> <span class="o">:</span> <span class="o">(</span><span class="bp">↑</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="bp">=</span> <span class="n">X</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">ok</span> <span class="n">X</span> <span class="k">with</span> <span class="n">h</span> <span class="bp">|</span> <span class="n">h</span> <span class="bp">|</span> <span class="n">h</span> <span class="bp">|</span> <span class="o">⟨⟨⟩⟩</span><span class="bp">;</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span><span class="bp">;</span> <span class="n">dec_trivial</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="269303747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269303747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269303747">(Jan 25 2022 at 18:43)</a>:</h4>
<p><code>zmod</code>, like what <span class="user-mention" data-user-id="127136">@Alex J. Best</span>, is a lot easier to work with and probably a better choice.</p>
<p>I wanted to see what it was like continuing to work with ZMOD for the next part:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="mi">0</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">7</span><span class="o">]</span> <span class="bp">∨</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="mi">1</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">7</span><span class="o">]</span> <span class="bp">∨</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">7</span><span class="o">]</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">%</span> <span class="mi">7</span><span class="o">)</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">7</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">int.modeq.pow</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">int.mod_modeq</span> <span class="n">x</span> <span class="mi">7</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="n">n</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">7</span><span class="o">]</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">%</span> <span class="mi">7</span><span class="o">)</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≡</span> <span class="n">n</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">7</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h1.trans</span> <span class="n">h</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h1.symm.trans</span> <span class="n">h</span> <span class="o">},</span> <span class="o">},</span>
  <span class="n">simp_rw</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">generalize</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">%</span> <span class="mi">7</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">subst</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">int.mod_nonneg</span><span class="o">,</span>
    <span class="n">norm_num</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">7</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">subst</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">int.mod_lt_of_pos</span><span class="o">,</span>
    <span class="n">norm_num</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">clear</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">hy</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">int.modeq_iff_dvd</span><span class="o">,</span>
  <span class="n">interval_cases</span> <span class="n">using</span> <span class="n">h3</span> <span class="n">h4</span><span class="bp">;</span>
  <span class="n">norm_num</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="269303896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269303896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269303896">(Jan 25 2022 at 18:44)</a>:</h4>
<p><code>interval_cases</code> seems to be rather slow in this proof. I don't have much experience with it to know whether that's expected</p>



<a name="269305418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269305418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269305418">(Jan 25 2022 at 18:55)</a>:</h4>
<p>Thanks for the help both of you! </p>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span> I'm trying to explore your proof but it's giving me some issues, do I need to import some things? <a href="/user_uploads/3121/-S_4u_YYnY6ScVgKicmP7QlW/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/-S_4u_YYnY6ScVgKicmP7QlW/image.png" title="image.png"><img src="/user_uploads/3121/-S_4u_YYnY6ScVgKicmP7QlW/image.png"></a></div>



<a name="269305480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269305480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269305480">(Jan 25 2022 at 18:55)</a>:</h4>
<p>Probably <code>import data.zmod.basic</code>?</p>



<a name="269305595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269305595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269305595">(Jan 25 2022 at 18:56)</a>:</h4>
<p>I wrote this in another file with other stuff in so I'm not sure sorry!</p>



<a name="269306845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269306845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269306845">(Jan 25 2022 at 19:04)</a>:</h4>
<p>that solved it!</p>



<a name="269306954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269306954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269306954">(Jan 25 2022 at 19:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269302974">said</a>:</p>
<blockquote>
<p>Some other useful tactics for this sort of thing are <a href="https://leanprover-community.github.io/mathlib_docs/find/dec_trivial">docs#dec_trivial</a> and <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#norm_cast">tactic#norm_cast</a> or <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#push_cast">tactic#push_cast</a> to deal with coercions from the integers to integers mod a number</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Here's how I'd show this</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ok</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">,</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">∈</span> <span class="o">[(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">),</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
<span class="kd">lemma</span> <span class="n">problem</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">4</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">-</span> <span class="mi">7</span> <span class="bp">*</span> <span class="n">y</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≠</span> <span class="mi">2003</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="mi">4</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">-</span> <span class="mi">7</span> <span class="bp">*</span> <span class="n">y</span><span class="bp">^</span><span class="mi">3</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">2003</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">apply_fun</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">push_cast</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2003</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">),</span>
  <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="mi">7</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">),</span>
  <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">,</span> <span class="n">sub_zero</span><span class="o">],</span>
  <span class="n">generalize</span> <span class="o">:</span> <span class="o">(</span><span class="bp">↑</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="bp">=</span> <span class="n">X</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">ok</span> <span class="n">X</span> <span class="k">with</span> <span class="n">h</span> <span class="bp">|</span> <span class="n">h</span> <span class="bp">|</span> <span class="n">h</span> <span class="bp">|</span> <span class="o">⟨⟨⟩⟩</span><span class="bp">;</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span><span class="bp">;</span> <span class="n">dec_trivial</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p></div></div><br>
</p>
</blockquote>
<p>Your link to <code>dec_trivial</code> didn't load for me, where can I read about it?</p>



<a name="269307212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269307212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269307212">(Jan 25 2022 at 19:06)</a>:</h4>
<p>Oh right, its a funny one, both a tactic and a term, but defined via notation so there isn't a docs link.<br>
Anyway you can read this section of tpil to learn about it <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions</a></p>



<a name="269308253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269308253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269308253">(Jan 25 2022 at 19:14)</a>:</h4>
<p>So I'm trying to understand what's happening in this section of the proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="mi">4</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">-</span> <span class="mi">7</span> <span class="bp">*</span> <span class="n">y</span><span class="bp">^</span><span class="mi">3</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">2003</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">apply_fun</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">push_cast</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
</code></pre></div>
<p>So far my  translation is, let's prove <code>(4 * x^3 - 7 * y^3 : zmod 7) ≠ 2003</code> so for the sake of contradiction, we assume <code> (4 * x^3 - 7 * y^3 : zmod 7) = 2003</code>, now we have to derive a contradiction.</p>
<p>What does the <code>apply this</code> mean?</p>



<a name="269308494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269308494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269308494">(Jan 25 2022 at 19:15)</a>:</h4>
<p>My confusion comes in because in the tactic screen everything looks the same:<br>
<a href="http://">Uploading image.png…</a></p>



<a name="269308624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269308624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269308624">(Jan 25 2022 at 19:16)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">xy</span><span class="o">:</span> <span class="n">ℤ</span>
<span class="n">this</span><span class="o">:</span> <span class="mi">4</span> <span class="bp">*</span> <span class="bp">↑</span><span class="n">x</span> <span class="bp">^</span> <span class="mi">3</span> <span class="bp">-</span> <span class="mi">7</span> <span class="bp">*</span> <span class="bp">↑</span><span class="n">y</span> <span class="bp">^</span> <span class="mi">3</span> <span class="bp">≠</span> <span class="mi">2003</span>
<span class="n">h</span><span class="o">:</span> <span class="mi">4</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">^</span> <span class="mi">3</span> <span class="bp">-</span> <span class="mi">7</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">^</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">2003</span>
<span class="bp">⊢</span> <span class="mi">4</span> <span class="bp">*</span> <span class="bp">↑</span><span class="n">x</span> <span class="bp">^</span> <span class="mi">3</span> <span class="bp">-</span> <span class="mi">7</span> <span class="bp">*</span> <span class="bp">↑</span><span class="n">y</span> <span class="bp">^</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">2003</span>
</code></pre></div>



<a name="269308740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269308740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269308740">(Jan 25 2022 at 19:17)</a>:</h4>
<p>Hmm <code>↑x ^ 3</code> has type <code>zmod 7</code></p>



<a name="269308863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269308863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269308863">(Jan 25 2022 at 19:18)</a>:</h4>
<p>Oh so <code>this</code> is actually everything <code>(mod 7)</code> right?</p>



<a name="269309167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269309167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269309167">(Jan 25 2022 at 19:20)</a>:</h4>
<p>Disregard above questions, I think I understand what's going on now.</p>



<a name="269309325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269309325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269309325">(Jan 25 2022 at 19:22)</a>:</h4>
<p>I guess it's just confusing when the goal state says something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">2</span> <span class="n">goals</span>
<span class="n">xy</span><span class="o">:</span> <span class="n">ℤ</span>
<span class="bp">⊢</span> <span class="mi">2003</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>
<p>and you don't know it's <code>mod 7</code> until you hover</p>



<a name="269311103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269311103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269311103">(Jan 25 2022 at 19:33)</a>:</h4>
<p>Yeah that is a bit unfortunate, I don't know any way of getting it to tell you that info other than hovering.<br>
But yes the idea is first to move the goal to zmod 7 <br>
Here's another way of phrasing the same proof, maybe its simpler to see what's happening?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ok</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">,</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">∈</span> <span class="o">[(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">),</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
<span class="kd">lemma</span> <span class="n">problem</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">4</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">-</span> <span class="mi">7</span> <span class="bp">*</span> <span class="n">y</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">≠</span> <span class="mi">2003</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- asume they are equal</span>
  <span class="n">apply_fun</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- then they are equal mod 7</span>
  <span class="n">push_cast</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- simplifying coercions</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2003</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">),</span>
  <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="mi">7</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">),</span>
  <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">,</span> <span class="n">sub_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- more simplifying</span>
  <span class="n">rcases</span> <span class="n">ok</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="k">with</span> <span class="n">h'</span> <span class="bp">|</span> <span class="n">h'</span> <span class="bp">|</span> <span class="n">h'</span> <span class="bp">|</span> <span class="o">⟨⟨⟩⟩</span><span class="bp">;</span> <span class="c1">-- now we have only the 3 cases from before</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h'</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="bp">;</span> <span class="n">revert</span> <span class="n">h</span><span class="bp">;</span> <span class="n">dec_trivial</span><span class="o">,</span> <span class="c1">-- h is decidably a contradiction in all cases</span>
<span class="kd">end</span>
</code></pre></div>



<a name="269311567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269311567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269311567">(Jan 25 2022 at 19:36)</a>:</h4>
<p>Ok, I'm understanding more and more of this proof, only part that's tripping me up is now this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">rcases</span> <span class="n">ok</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="k">with</span> <span class="n">h'</span> <span class="bp">|</span> <span class="n">h'</span> <span class="bp">|</span> <span class="n">h'</span> <span class="bp">|</span> <span class="o">⟨⟨⟩⟩</span><span class="bp">;</span> <span class="c1">-- now we have only the 3 cases from before</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h'</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="bp">;</span> <span class="n">revert</span> <span class="n">h</span><span class="bp">;</span> <span class="n">dec_trivial</span><span class="o">,</span> <span class="c1">-- h is decidably a contradiction in all case</span>
</code></pre></div>
<p>So I'm assuming <code>h' | h' | h' | ⟨⟨⟩⟩</code> gives us the three cases on the value of what x could be  what does the <code>⟨⟨⟩⟩</code> do though?</p>



<a name="269311779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269311779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269311779">(Jan 25 2022 at 19:38)</a>:</h4>
<p>it gets rid of the trivial goal that <code>x</code> is in the empty list, if you delete just <code>| ⟨⟨⟩⟩</code> and the semicolon you'll see there are 4 goals, adding the <code>| ⟨⟨⟩⟩</code> back there are only 3</p>



<a name="269311873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269311873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269311873">(Jan 25 2022 at 19:38)</a>:</h4>
<p>but the trick is I didn't write that by hand <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span> I used <code>rcases? ok (x : zmod 7)</code>, which tells me the magic words to type for me</p>



<a name="269311981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269311981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269311981">(Jan 25 2022 at 19:39)</a>:</h4>
<p>Well it tries to anyway, seems there is a bit of a bug with <code>x : zmod 7</code> but hopefully you can see it tells us almost the right thing here</p>



<a name="269312237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269312237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269312237">(Jan 25 2022 at 19:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269311779">said</a>:</p>
<blockquote>
<p>it gets rid of the trivial goal that <code>x</code> is in the empty list, if you delete just <code>| ⟨⟨⟩⟩</code> and the semicolon you'll see there are 4 goals, adding the <code>| ⟨⟨⟩⟩</code> back there are only 3</p>
</blockquote>
<p>What does it mean for x to be in the empty list</p>



<a name="269312341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269312341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269312341">(Jan 25 2022 at 19:42)</a>:</h4>
<p>(Maybe there should be a pretty printer option to print certain numerals in the form <code>(2007 : zmod 7)</code>? I've found this to be confusing to manipulate before.)</p>



<a name="269312771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269312771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269312771">(Jan 25 2022 at 19:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269307212">said</a>:</p>
<blockquote>
<p>Oh right, its a funny one, both a tactic and a term, but defined via notation so there isn't a docs link.<br>
Anyway you can read this section of tpil to learn about it <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions</a></p>
</blockquote>
<p>So <code>dec_trivial</code> is like if a computer has an algorithm to figure out if this thing is true or not</p>



<a name="269312868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269312868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269312868">(Jan 25 2022 at 19:46)</a>:</h4>
<p>How does that differ from things like <code>linarith</code> and <code>ring</code> then?</p>



<a name="269312890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269312890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269312890">(Jan 25 2022 at 19:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269312237">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269311779">said</a>:</p>
<blockquote>
<p>it gets rid of the trivial goal that <code>x</code> is in the empty list, if you delete just <code>| ⟨⟨⟩⟩</code> and the semicolon you'll see there are 4 goals, adding the <code>| ⟨⟨⟩⟩</code> back there are only 3</p>
</blockquote>
<p>What does it mean for x to be in the empty list</p>
</blockquote>
<p>Well it doesn't make sense, so we don't need to consider that case, but lean needs to be reminded of that somehow.</p>



<a name="269313118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269313118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269313118">(Jan 25 2022 at 19:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269312890">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269312237">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269311779">said</a>:</p>
<blockquote>
<p>it gets rid of the trivial goal that <code>x</code> is in the empty list, if you delete just <code>| ⟨⟨⟩⟩</code> and the semicolon you'll see there are 4 goals, adding the <code>| ⟨⟨⟩⟩</code> back there are only 3</p>
</blockquote>
<p>What does it mean for x to be in the empty list</p>
</blockquote>
<p>Well it doesn't make sense, so we don't need to consider that case, but lean needs to be reminded of that somehow.</p>
</blockquote>
<p>How come that case is generated anyways then?</p>



<a name="269313241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269313241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269313241">(Jan 25 2022 at 19:48)</a>:</h4>
<p>There are a few difference but the main one is that linarith and ring are allowed to fail, if a decidable algorithm exists it will always (eventually return) either a proof or a disproof.</p>



<a name="269313880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269313880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269313880">(Jan 25 2022 at 19:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269313118">said</a>:</p>
<blockquote>
<p>How come that case is generated anyways then?</p>
</blockquote>
<p>These cases appear because the definition of <code>x^3 ∈ [(0 : zmod 7), 1, -1] </code> unfolds to <code>x^3 ∈ [(0 : zmod 7), 1] \/ x^3 = -1</code> which is then <code>x^3 ∈ [(0 : zmod 7)] \/ x^3 = 1 \/ x^3 = -1</code> which becomes <code>x^3 ∈ [] \/ x^3 = 0 \/ x^3 = 1 \/ x^3 = -1</code>. The empty list is treated the same as all others in the definition of being a member of a list</p>



<a name="269314320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269314320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269314320">(Jan 25 2022 at 19:53)</a>:</h4>
<p>What is the point of the <code>revert h; dec_trivial</code> ?</p>



<a name="269314383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269314383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269314383">(Jan 25 2022 at 19:54)</a>:</h4>
<p>expanding it out it looks like this: <a href="/user_uploads/3121/h_0H4YxZqP482lYRPftBIE67/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/h_0H4YxZqP482lYRPftBIE67/image.png" title="image.png"><img src="/user_uploads/3121/h_0H4YxZqP482lYRPftBIE67/image.png"></a></div>



<a name="269314612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269314612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269314612">(Jan 25 2022 at 19:55)</a>:</h4>
<p><code>dec_trivial</code> tries to prove the goal, without looking at your assumptions.</p>



<a name="269314637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269314637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269314637">(Jan 25 2022 at 19:55)</a>:</h4>
<p>Wouldn't we want to use somethign like <a href="https://leanprover-community.github.io/mathlib_docs/find/succ_ne_zero">docs#succ_ne_zero</a> ?</p>



<a name="269314638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269314638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269314638">(Jan 25 2022 at 19:55)</a>:</h4>
<p>So any assumptions that should be used must be reverted into the goal first.</p>



<a name="269314726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269314726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269314726">(Jan 25 2022 at 19:56)</a>:</h4>
<p>I see</p>



<a name="269314745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269314745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269314745">(Jan 25 2022 at 19:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269314637">said</a>:</p>
<blockquote>
<p>Wouldn't we want to use somethign like <a href="https://leanprover-community.github.io/mathlib_docs/find/succ_ne_zero">docs#succ_ne_zero</a> ?</p>
</blockquote>
<p>this goal is about <code>zmod 7</code> so <code>succ_ne_zero</code> won't apply I think</p>



<a name="269314761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269314761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269314761">(Jan 25 2022 at 19:56)</a>:</h4>
<p>I haven't followed the thread. But <code>succ_ne_zero</code> doesn't hold in <code>zmod 7</code>, right? <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="269314783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269314783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269314783">(Jan 25 2022 at 19:56)</a>:</h4>
<p>Oh right</p>



<a name="269314824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269314824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269314824">(Jan 25 2022 at 19:57)</a>:</h4>
<p>You could use <code>mul_zero</code> and <code>zero_ne_one</code>.</p>



<a name="269314901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269314901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269314901">(Jan 25 2022 at 19:57)</a>:</h4>
<p>So that's like a more generalized version</p>



<a name="269315113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269315113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269315113">(Jan 25 2022 at 19:59)</a>:</h4>
<p>where does the the decidability aspect come into the proving of <code>4 * 0 = 1 -&gt; false</code> ?</p>



<a name="269315291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269315291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269315291">(Jan 25 2022 at 20:00)</a>:</h4>
<p>You can use other proof methods here, but the nice thing about decidability is that once we get to a small finite statement in the right form we can be pretty sure it will work without worrying about what other lemmas we need.</p>



<a name="269315387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269315387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269315387">(Jan 25 2022 at 20:00)</a>:</h4>
<p>What constitutes the right form?</p>



<a name="269315395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269315395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269315395">(Jan 25 2022 at 20:01)</a>:</h4>
<p>The lemma <code>ok</code> is where this method really shines.</p>



<a name="269315557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269315557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269315557">(Jan 25 2022 at 20:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269315387">said</a>:</p>
<blockquote>
<p>What constitutes the right form?</p>
</blockquote>
<p>Well the main thing is what Johan says, <code>dec_trivial</code> doesn't look at your assumptions, so you have to use revert to make the goal statement false on its own.</p>



<a name="269315682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269315682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269315682">(Jan 25 2022 at 20:03)</a>:</h4>
<p>Ok, I get the gist of it, I think it'll get more clear the more I use it</p>



<a name="269315858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269315858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269315858">(Jan 25 2022 at 20:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269315387">said</a>:</p>
<blockquote>
<p>What constitutes the right form?</p>
</blockquote>
<p>There's are a great number of <code>decidable</code> instances in mathlib, and "the right form" is that one of them matches your proposition. (Though, even if one matches, that doesn't guarantee <code>dec_trivial</code> will succeed...)</p>



<a name="269315947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269315947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269315947">(Jan 25 2022 at 20:05)</a>:</h4>
<p>If you click the dropdown under <a href="https://leanprover-community.github.io/mathlib_docs/find/decidable">docs#decidable</a> you can see them (not that this is very helpful -- the only point is that there are quite a few!)</p>



<a name="269316425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269316425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269316425">(Jan 25 2022 at 20:09)</a>:</h4>
<p>thanks!</p>



<a name="269316750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269316750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269316750">(Jan 25 2022 at 20:11)</a>:</h4>
<p>I know about the <code> ⟨⟩</code> as the anonymouse construction notation so when we prove something like there exists x in N P(x), we can just do like <code> ⟨3, Q 3⟩</code> or something like that, but I feel like it's being used in a different fashion  in </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">rcases</span> <span class="n">ok</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">)</span> <span class="k">with</span> <span class="n">h'</span> <span class="bp">|</span> <span class="n">h'</span> <span class="bp">|</span> <span class="n">h'</span> <span class="bp">|</span> <span class="o">⟨⟨⟩⟩,</span> <span class="c1">-- now we have only the 3 cases from before</span>
</code></pre></div>
<p>what's going on there?</p>



<a name="269317775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269317775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269317775">(Jan 25 2022 at 20:18)</a>:</h4>
<p>It's being used in the exact same way here. Its point is to construct and destruct structures. In that case, it destructs one-field structures.</p>



<a name="269317812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269317812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269317812">(Jan 25 2022 at 20:18)</a>:</h4>
<p>I suspect one of them being <a href="https://leanprover-community.github.io/mathlib_docs/find/eq">docs#eq</a></p>



<a name="269318695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269318695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269318695">(Jan 25 2022 at 20:25)</a>:</h4>
<p>Ok so this thing is a structure and we're taking it apart?<br>
<a href="/user_uploads/3121/RCbG6asHvz2BklwTbq84m_6k/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/RCbG6asHvz2BklwTbq84m_6k/image.png" title="image.png"><img src="/user_uploads/3121/RCbG6asHvz2BklwTbq84m_6k/image.png"></a></div>



<a name="269318728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269318728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269318728">(Jan 25 2022 at 20:25)</a>:</h4>
<p>Isn't that like a hypothesis though?</p>



<a name="269318851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269318851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269318851">(Jan 25 2022 at 20:26)</a>:</h4>
<p>Precisely, it's an inductive!</p>



<a name="269318858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269318858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269318858">(Jan 25 2022 at 20:26)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.mem">docs#list.mem</a></p>



<a name="269318941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269318941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269318941">(Jan 25 2022 at 20:27)</a>:</h4>
<p>The <code>... | ...</code> bit breaks the inductive part. The <code>⟨...⟩</code> bit breaks the structure part.</p>



<a name="269318998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269318998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269318998">(Jan 25 2022 at 20:27)</a>:</h4>
<p>An inductive type is a type where you make some constructors which describe how to make new elements right?</p>



<a name="269319264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269319264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269319264">(Jan 25 2022 at 20:29)</a>:</h4>
<p>Hmm, yes, but that's true of everything.</p>



<a name="269319577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269319577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269319577">(Jan 25 2022 at 20:31)</a>:</h4>
<p>Take it as a pinch of salt, I'm not a type theorist, but an inductive type at your level is a primitive in the calculus of inductive constructions. Each inductive has a bunch of constructors, and constructors can refer to each other (in specific ways and the rules are complicated). Structures too are inductives, but they only have one constructor.</p>



<a name="269320544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269320544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269320544">(Jan 25 2022 at 20:39)</a>:</h4>
<p>Ok, I'm trying to understand the usage of the <code> ... |  ...</code> and the <code>⟨...⟩</code> on this example: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">∨</span> <span class="n">d</span>
</code></pre></div>
<p>and in the docs they do <code>rcases h1 with ⟨ha, hb, hc⟩ | hd</code></p>
<p>Why didn't they just do : <code>rcases h1 with ⟨ha, hb, hc, hd⟩</code> ?</p>



<a name="269320677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269320677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269320677">(Jan 25 2022 at 20:40)</a>:</h4>
<p>because <code>∨</code> is an inductive with two constructors</p>



<a name="269320679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269320679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269320679">(Jan 25 2022 at 20:40)</a>:</h4>
<p><code>|</code> is for alternatives, angle brackets are for (generalized) products. So, different constructors vs arguments to same constructor</p>



<a name="269320919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269320919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269320919">(Jan 25 2022 at 20:42)</a>:</h4>
<p>If it helps, these are the parentheses:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">b</span> <span class="bp">∧</span> <span class="n">c</span><span class="o">))</span> <span class="bp">∨</span> <span class="n">d</span>
</code></pre></div>



<a name="269321604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269321604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269321604">(Jan 25 2022 at 20:48)</a>:</h4>
<p>Why is <code>and</code> a structure but <code>or</code> is an inductive shouldn't they be the same?</p>



<a name="269321680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269321680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269321680">(Jan 25 2022 at 20:49)</a>:</h4>
<p>If they were the same, we wouldn't need both!</p>



<a name="269321714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269321714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269321714">(Jan 25 2022 at 20:49)</a>:</h4>
<p>Think about it. How do you build an <code>and</code>? How do you build an <code>or</code>?</p>



<a name="269321736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269321736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269321736">(Jan 25 2022 at 20:49)</a>:</h4>
<p>two things and put them together</p>



<a name="269321839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269321839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269321839">(Jan 25 2022 at 20:50)</a>:</h4>
<p>But they would be different right? One is true in the example of T and F and the other false?</p>



<a name="269321878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269321878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269321878">(Jan 25 2022 at 20:50)</a>:</h4>
<p>You're thinking <a href="https://leanprover-community.github.io/mathlib_docs/find/band">docs#band</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/bor">docs#bor</a></p>



<a name="269321919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269321919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269321919">(Jan 25 2022 at 20:50)</a>:</h4>
<p>But how to make the <em>type</em> of proofs of <code>P</code> and <code>Q</code>?</p>



<a name="269321944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269321944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269321944">(Jan 25 2022 at 20:51)</a>:</h4>
<p>by "build", Yael means roughly, "how would you prove an 'and'? how would you prove an 'or'?"</p>



<a name="269321954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269321954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269321954">(Jan 25 2022 at 20:51)</a>:</h4>
<p>and the <em>type</em> of proofs of <code>P</code> or <code>Q</code>?</p>



<a name="269322010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269322010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269322010">(Jan 25 2022 at 20:51)</a>:</h4>
<p>When we have <code>p : Prop</code> p is a proof of the proposition right?</p>



<a name="269322147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269322147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269322147">(Jan 25 2022 at 20:52)</a>:</h4>
<p>Going back to "why is <code>and</code> a structure": a <code>structure</code> is an inductive with exactly one constructor</p>



<a name="269322159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269322159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269322159">(Jan 25 2022 at 20:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269321919">said</a>:</p>
<blockquote>
<p>But how to make the <em>type</em> of proofs of <code>P</code> and <code>Q</code>?</p>
</blockquote>
<p>So you would want P and Q to have the type <code>Prop</code> and then you need <code>p: P</code> and <code>q:Q</code></p>



<a name="269322195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269322195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269322195">(Jan 25 2022 at 20:53)</a>:</h4>
<p>(<code>structure</code> is a special case with some special notation because it's useful)</p>



<a name="269322407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269322407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269322407">(Jan 25 2022 at 20:54)</a>:</h4>
<p>Wait, is that correct? -- zulip lagged, sorry -- <code>p : Prop</code> -- p is the <em>statement</em>, not the proof, and <code>f : p</code> <code>f</code> is a proof of <code>p</code>, right?</p>



<a name="269322734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269322734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269322734">(Jan 25 2022 at 20:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269322010">said</a>:</p>
<blockquote>
<p>When we have <code>p : Prop</code> p is a proof of the proposition right?</p>
</blockquote>
<p>No. <code>p: Prop</code> means <code>p</code> is a proposition. Then <code>hp : p</code> means <code>hp</code> is a proof of that proposition <code>p</code>.</p>



<a name="269322947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269322947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269322947">(Jan 25 2022 at 20:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321696">Julian Berman</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269322407">said</a>:</p>
<blockquote>
<p>Wait, is that correct? -- zulip lagged, sorry -- <code>p : Prop</code> -- p is the <em>statement</em>, not the proof, and <code>f : p</code> <code>f</code> is a proof of <code>p</code>, right?</p>
</blockquote>
<p>Whoops sorry, read that too quick</p>



<a name="269323065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269323065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269323065">(Jan 25 2022 at 20:59)</a>:</h4>
<p>Ok, I see. so if we have <code>p q: Prop</code> then <code>p ∧ q</code> should also be  a proposition and then <code>j : p ∧ q</code> would mean <code>j</code> is a proof of <code>p ∧ q</code> right?</p>



<a name="269323230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269323230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269323230">(Jan 25 2022 at 21:00)</a>:</h4>
<p>If I replace the and symbol with or in above, then that would be right when we're talking about the or as well right?</p>



<a name="269323334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269323334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269323334">(Jan 25 2022 at 21:00)</a>:</h4>
<p>Yep, those are also ways to make propositions out of other <del>ones</del> things.</p>



<a name="269323632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269323632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269323632">(Jan 25 2022 at 21:02)</a>:</h4>
<p>So this is somehow a roadblock for us to have <code>or</code> and <code>and</code> both be inductive types?</p>



<a name="269323960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269323960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269323960">(Jan 25 2022 at 21:04)</a>:</h4>
<p>Strictly speaking, they both are.</p>



<a name="269323968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269323968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269323968">(Jan 25 2022 at 21:04)</a>:</h4>
<p>Don't be fooled by <code>structure</code>, they're both inductive types. They can be written like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">and</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="n">and</span>

<span class="kd">inductive</span> <span class="n">or</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">inl</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">or</span>
<span class="bp">|</span> <span class="n">inr</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="n">or</span>
</code></pre></div>



<a name="269324126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269324126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269324126">(Jan 25 2022 at 21:05)</a>:</h4>
<p>My question is why can't they be described in the same fashion</p>



<a name="269324246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269324246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269324246">(Jan 25 2022 at 21:06)</a>:</h4>
<blockquote>
<p>by "build", Yael means roughly, "how would you prove an 'and'? how would you prove an 'or'?"</p>
</blockquote>
<p>this question is really insightful</p>



<a name="269324256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269324256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269324256">(Jan 25 2022 at 21:06)</a>:</h4>
<p>Isn't that the same fashion enough to you?</p>



<a name="269324306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269324306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269324306">(Jan 25 2022 at 21:06)</a>:</h4>
<p>I guess like Yael said earlier, if they were described in exactly the same way, then <code>and</code> and <code>or</code> would be logically equivalent. That doesn't sound right, right?</p>



<a name="269324420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269324420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269324420">(Jan 25 2022 at 21:07)</a>:</h4>
<p>I think I understand his doubt. Abstracting technicalities, <code>and</code> and <code>or</code> have different levels of restrictions to be instantiated</p>



<a name="269324529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269324529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269324529">(Jan 25 2022 at 21:08)</a>:</h4>
<p>For an <code>and</code>, you need two things to be true in order to build it. Whereas for an <code>or</code> one true thing is enough</p>



<a name="269324582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269324582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269324582">(Jan 25 2022 at 21:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269324529">said</a>:</p>
<blockquote>
<p>For an <code>and</code>, you need two things to be true in order to build it. Whereas for an <code>or</code> one true thing is enough</p>
</blockquote>
<p>Oh ok, this helps me think about it!</p>



<a name="269324823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269324823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269324823">(Jan 25 2022 at 21:10)</a>:</h4>
<p>Then you need to think about the reverse for <code>rcases</code>: if you have an <code>and</code>, then you can get both things out of it, and if you have an <code>or</code>, you can get one thing, but you don't know which, so you have to be able to handle both cases.</p>



<a name="269326011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269326011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269326011">(Jan 25 2022 at 21:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269313880">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269313118">said</a>:</p>
<blockquote>
<p>How come that case is generated anyways then?</p>
</blockquote>
<p>These cases appear because the definition of <code>x^3 ∈ [(0 : zmod 7), 1, -1] </code> unfolds to <code>x^3 ∈ [(0 : zmod 7), 1] \/ x^3 = -1</code> which is then <code>x^3 ∈ [(0 : zmod 7)] \/ x^3 = 1 \/ x^3 = -1</code> which becomes <code>x^3 ∈ [] \/ x^3 = 0 \/ x^3 = 1 \/ x^3 = -1</code>. The empty list is treated the same as all others in the definition of being a member of a list</p>
</blockquote>
<p>So because the <code>or</code> is an inductive type with multiple constructors we can use the <code> ... | ...</code> syntax to break it into different cases (but if that's true why is the first case <code>x^3 = 0</code> rather than x^3 being in the empty list?),  in any case when we deal with the empty list somehow <code>⟨⟨⟩⟩</code> solves it automatically? How is it doing that?</p>



<a name="269326537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269326537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269326537">(Jan 25 2022 at 21:22)</a>:</h4>
<p>Are these <code>list.mem</code>'s constructors? <a href="/user_uploads/3121/RglAKOF3W-zMjXBWSq4SpKST/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/RglAKOF3W-zMjXBWSq4SpKST/image.png" title="image.png"><img src="/user_uploads/3121/RglAKOF3W-zMjXBWSq4SpKST/image.png"></a></div>



<a name="269326598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269326598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269326598">(Jan 25 2022 at 21:23)</a>:</h4>
<p>Is it normal in the docs to not say that it's an inductive type ?</p>



<a name="269326627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269326627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269326627">(Jan 25 2022 at 21:23)</a>:</h4>
<p>list.mem is not an inductive type</p>



<a name="269326649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269326649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269326649">(Jan 25 2022 at 21:23)</a>:</h4>
<p>it's a function that creates an or expression (so creates an inductive type)</p>



<a name="269326711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269326711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269326711">(Jan 25 2022 at 21:24)</a>:</h4>
<p><code>list.mem a [b1, b2]</code> is <code>a = b1 or a = b2 or false</code></p>



<a name="269326792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269326792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269326792">(Jan 25 2022 at 21:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269318851">said</a>:</p>
<blockquote>
<p>Precisely, it's an inductive!</p>
</blockquote>
<p>Wait is an inductive an instance of an inductive type?</p>



<a name="269327176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269327176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269327176">(Jan 25 2022 at 21:26)</a>:</h4>
<p>If <code>list.mem</code> has two constructors  (like the or example)though shouldn't we be using the <code>... | ... </code>on it rather than using the <code>⟨⟩</code></p>



<a name="269327302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269327302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269327302">(Jan 25 2022 at 21:27)</a>:</h4>
<p><code>list.mem</code> is just a recursive function, and I wouldn't call those two cases with red arrows in your image "constructors". I presume Yael is referring to this function's output</p>



<a name="269327526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269327526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269327526">(Jan 25 2022 at 21:29)</a>:</h4>
<p>Ok, so somehow the <code>⟨⟨⟩⟩</code> can solve <code>list.mem (↑x ^ 3) list.nil</code>, what's happening there?</p>



<a name="269327598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269327598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269327598">(Jan 25 2022 at 21:30)</a>:</h4>
<p><code>false</code> too is an inductive type!</p>



<a name="269327936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269327936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269327936">(Jan 25 2022 at 21:32)</a>:</h4>
<p><a href="/user_uploads/3121/4UoRCuCo_058fMjGlYgfMp0f/image.png">image.png</a>  I thought they're supposed to have constructors?</p>
<div class="message_inline_image"><a href="/user_uploads/3121/4UoRCuCo_058fMjGlYgfMp0f/image.png" title="image.png"><img src="/user_uploads/3121/4UoRCuCo_058fMjGlYgfMp0f/image.png"></a></div>



<a name="269327950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269327950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269327950">(Jan 25 2022 at 21:32)</a>:</h4>
<p>how do you even make this thing</p>



<a name="269328004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328004">(Jan 25 2022 at 21:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269327950">said</a>:</p>
<blockquote>
<p>how do you even make this thing</p>
</blockquote>
<p>exactly <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="269328036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328036">(Jan 25 2022 at 21:33)</a>:</h4>
<p>oh ok, so you're allowed to have zero constructor inductive type</p>



<a name="269328059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328059">(Jan 25 2022 at 21:33)</a>:</h4>
<p>And you're not allowed to make something false is what that means?</p>



<a name="269328200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328200">(Jan 25 2022 at 21:34)</a>:</h4>
<p><a href="/user_uploads/3121/Jokx5-EnxkfGETgafCKYiNqm/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/Jokx5-EnxkfGETgafCKYiNqm/image.png" title="image.png"><img src="/user_uploads/3121/Jokx5-EnxkfGETgafCKYiNqm/image.png"></a></div>



<a name="269328241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328241">(Jan 25 2022 at 21:35)</a>:</h4>
<p>It's even stronger! If you happen to have made a term of type <code>false</code>, then <span aria-label="explosion" class="emoji emoji-1f4a5" role="img" title="explosion">:explosion:</span></p>



<a name="269328244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328244">(Jan 25 2022 at 21:35)</a>:</h4>
<p>(I'm not understanding why rcases needs two levels of angle brackets for this nil case.  The first level seems to do nothing...)</p>



<a name="269328281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328281">(Jan 25 2022 at 21:35)</a>:</h4>
<p>it's really called the principle of explosion <span aria-label="boom" class="emoji emoji-1f4a5" role="img" title="boom">:boom:</span></p>



<a name="269328431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328431">(Jan 25 2022 at 21:36)</a>:</h4>
<p>this is the main way you use <code>false</code>, by getting anything you want from it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">false.elim</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u_1</span><span class="o">},</span> <span class="n">false</span> <span class="bp">→</span> <span class="n">C</span>
</code></pre></div>



<a name="269328468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328468">(Jan 25 2022 at 21:36)</a>:</h4>
<p>What does it mean for true to have a constructor?</p>



<a name="269328513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328513">(Jan 25 2022 at 21:37)</a>:</h4>
<p>it means you can prove <code>true</code> by definition</p>



<a name="269328536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328536">(Jan 25 2022 at 21:37)</a>:</h4>
<p>the proof is <code>true.intro</code></p>



<a name="269328578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328578">(Jan 25 2022 at 21:37)</a>:</h4>
<p>So true can prove itself</p>



<a name="269328668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328668">(Jan 25 2022 at 21:38)</a>:</h4>
<p>and <code>false</code> having no constructors: by definition you cannot prove it</p>



<a name="269328710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328710">(Jan 25 2022 at 21:38)</a>:</h4>
<p>I see</p>



<a name="269328722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328722">(Jan 25 2022 at 21:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269328578">said</a>:</p>
<blockquote>
<p>So true can prove itself</p>
</blockquote>
<p><code>true</code> is not a proof of <code>true</code>, if that's what you mean. <code>true.intro</code> is the proof of <code>true</code></p>



<a name="269328733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328733">(Jan 25 2022 at 21:39)</a>:</h4>
<p>right right</p>



<a name="269328938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269328938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269328938">(Jan 25 2022 at 21:40)</a>:</h4>
<p>Ok, if you have <code>h: a ∧b</code> then we can deconstruct it like <code>⟨ha, hb⟩</code> but  what does if you deconstructed something by using <code>⟨⟩</code> that means that whatever you deconstructed has no constructors?</p>



<a name="269329240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269329240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269329240">(Jan 25 2022 at 21:43)</a>:</h4>
<p><code>⟨⟩</code> is the constructor that takes no parameter</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Q</span>
<span class="kd">def</span> <span class="n">q</span> <span class="o">:</span> <span class="n">Q</span> <span class="o">:=</span> <span class="o">⟨⟩</span>
<span class="k">#check</span> <span class="n">q</span> <span class="c1">-- q : Q</span>
</code></pre></div>



<a name="269329394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269329394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269329394">(Jan 25 2022 at 21:45)</a>:</h4>
<p>Ok so the <code>⟨...⟩</code> is only used on things with only one constructor?</p>



<a name="269329410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269329410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269329410">(Jan 25 2022 at 21:45)</a>:</h4>
<p>I'm confused with you here, @ccn. Angle brackets are for a constructor of an inductive type, but false has no constructors. Maybe this is undocumented behavior of <code>rcases</code>?</p>



<a name="269329541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269329541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269329541">(Jan 25 2022 at 21:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269329394">said</a>:</p>
<blockquote>
<p>Ok so the <code>⟨...⟩</code> is only used on things with only one constructor?</p>
</blockquote>
<p>Hm? <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> <br>
Things that have constructors can only have one constructor</p>



<a name="269329569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269329569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269329569">(Jan 25 2022 at 21:46)</a>:</h4>
<p>Wrong, Arthur. All inductives have constructors.</p>



<a name="269329584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269329584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269329584">(Jan 25 2022 at 21:47)</a>:</h4>
<p><code>rcases</code> lets you use angle brackets for each constructor using <code>⟨...⟩ | ⟨...⟩ | ... | ⟨...⟩</code></p>



<a name="269329623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269329623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269329623">(Jan 25 2022 at 21:47)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Arthur is referring to generic constructor syntax being for only one-constructor inductives</p>



<a name="269329628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269329628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269329628">(Jan 25 2022 at 21:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269329569">said</a>:</p>
<blockquote>
<p>Wrong, Arthur. All inductives have constructors.</p>
</blockquote>
<p>But I mean, each inductive has its own constructor (and it's unique) (except for things like <code>false</code>?)</p>



<a name="269329680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269329680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269329680">(Jan 25 2022 at 21:47)</a>:</h4>
<p>I'm confused by what you're confused about</p>



<a name="269329775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269329775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269329775">(Jan 25 2022 at 21:48)</a>:</h4>
<p><code>⟨⟩</code> to me is just syntax for the nullary <code>⟨...⟩ | ⟨...⟩ | ... | ⟨...⟩</code>.</p>



<a name="269329847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269329847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269329847">(Jan 25 2022 at 21:48)</a>:</h4>
<p>or the unary version with no arguments, typically for <a href="https://leanprover-community.github.io/mathlib_docs/find/eq">docs#eq</a></p>



<a name="269329941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269329941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269329941">(Jan 25 2022 at 21:49)</a>:</h4>
<p>it might be "just" syntax for that, but it appears to be undocumented</p>



<a name="269330081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269330081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269330081">(Jan 25 2022 at 21:50)</a>:</h4>
<p>It seems like it needs either a special case, or it's a side-effect of how <code>rcases</code> is implemented, to have <code>⟨⟩</code> work for <code>false</code></p>



<a name="269330579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269330579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269330579">(Jan 25 2022 at 21:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269329394">said</a>:</p>
<blockquote>
<p>Ok so the <code>⟨...⟩</code> is only used on things with only one constructor?</p>
</blockquote>
<p>What got me confused was that this question seemed to raise the possibility of certain types having two or more constructors</p>



<a name="269330626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269330626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269330626">(Jan 25 2022 at 21:55)</a>:</h4>
<p>Like <code>or</code>?</p>



<a name="269330744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269330744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269330744">(Jan 25 2022 at 21:56)</a>:</h4>
<p><em>mindblow</em><br>
I never thought of it this way <span aria-label="open mouth" class="emoji emoji-1f62e" role="img" title="open mouth">:open_mouth:</span></p>



<a name="269330765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269330765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269330765">(Jan 25 2022 at 21:56)</a>:</h4>
<p>Indeed, it has two distinct constructors</p>



<a name="269333347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269333347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269333347">(Jan 25 2022 at 22:16)</a>:</h4>
<p>But then his question holds. Is it possible to instantiate <code>or</code> with two distinct anonymous constructors?</p>



<a name="269333982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269333982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269333982">(Jan 25 2022 at 22:20)</a>:</h4>
<p>For <code>sum</code> at least, I don't see how. How would Lean know which side to put <code>a : α</code> in <code>α ⊕ α</code>? For <code>p ∨ p</code>, proof irrelevance means it doesn't matter.</p>



<a name="269369487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269369487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269369487">(Jan 26 2022 at 06:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269328244">said</a>:</p>
<blockquote>
<p>(I'm not understanding why rcases needs two levels of angle brackets for this nil case.  The first level seems to do nothing...)</p>
</blockquote>
<p>The reason is because the general case of <code>rcases</code> destructuring is <code>⟨a⟩ | ⟨b, c⟩ | ⟨d, e, f⟩</code> (if the inductive had one argument in the first constructor, two in the second and three in the third). You can also leave off trailing arguments and they will be filled with <code>_</code> as needed. When a constructor has only one argument the angle brackets can be omitted when there is already a <code>|</code> indicating that we need to pattern match, but this leads to an ambiguity if you use an empty bracket: <code>⟨⟩ | ⟨hb⟩</code> matching <code>a \/ b</code> could mean either <code>⟨_⟩ | ⟨b⟩</code> (bind <code>_ha : a</code> and <code>hb : b</code>) or <code>⟨⟨⟩⟩ | ⟨b⟩</code> (bind <code>_ha : a</code> and <code>hb : b</code>, and then pattern match <code>_ha : a</code> with pattern <code>⟨⟩</code>, which in this case would fail but might clear the case if <code>a</code> was, say, <code>false</code>). So the convention in this case is to use double brackets.</p>



<a name="269369865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269369865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269369865">(Jan 26 2022 at 06:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269330081">said</a>:</p>
<blockquote>
<p>It seems like it needs either a special case, or it's a side-effect of how <code>rcases</code> is implemented, to have <code>⟨⟩</code> work for <code>false</code></p>
</blockquote>
<p>There is kind of a syntactic hole for zero-ary patterns. <code>(a | b | c)</code> matches a 3-variant inductive, <code>(a | b)</code> matches 2-variant, <code>a</code> is a no op but <code>⟨a⟩</code> can be used to match a 1-variant inductive (a structure), but what would you write for a zero-variant inductive? <code>()</code>? <code>⟨⟩</code>? Nothing at all? In reality, anything other than an atomic pattern like <code>a</code> or <code>_</code> can be used to indicate that you want to keep matching, and once it hits a <code>false</code> anything beyond that is ignored. So you could use <code>(_|_)</code> or <code>⟨⟨but⟩|⟨why⟩⟩</code> if you wanted, and the convention is to use <code>⟨⟩</code> to match on a unit structure (like <code>unit</code> or <code>eq</code>) or an empty inductive like <code>false</code> or <code>empty</code>.</p>



<a name="269774913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269774913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269774913">(Jan 28 2022 at 17:52)</a>:</h4>
<p>Hey I want to prove this theorem, </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">induction_nfactltnexpnm1ngt3</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nat.factorial</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>

<span class="kd">end</span>
</code></pre></div>
<p>I've come up with the proof on paper by using induction on numbers greater than 3, so my base case is when n = 3, but when I try to start the proof off with <code>induction n with k IH</code> I get</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">case</span> <span class="n">nat.zero</span>
<span class="n">h₀</span><span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="mi">0</span>
<span class="bp">⊢</span> <span class="mi">0</span><span class="bp">!</span> <span class="bp">&lt;</span> <span class="mi">0</span> <span class="bp">^</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">case</span> <span class="n">nat.succ</span>
<span class="n">k</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">IH</span><span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">k</span><span class="bp">!</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">h₀</span><span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">k.succ</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="n">k.succ</span><span class="o">)</span><span class="bp">!</span> <span class="bp">&lt;</span> <span class="n">k.succ</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k.succ</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>as a tactic state which isn't really what I wanted to prove (the base case).</p>
<p>How could I model this correctly? (eg having base case of k =3)</p>



<a name="269775923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269775923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269775923">(Jan 28 2022 at 17:58)</a>:</h4>
<p>Do induction on <code>h₀</code>!</p>



<a name="269778414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269778414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269778414">(Jan 28 2022 at 18:13)</a>:</h4>
<p>Ah, I didn't know it could be used more generally like that. What's going on when it's not a varaible, but a hypothesis instead?</p>



<a name="269778540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269778540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269778540">(Jan 28 2022 at 18:14)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/nat.le">docs#nat.le</a> is defined inductively, so <code>induction</code> simply follows the definition.</p>



<a name="269778703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269778703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269778703">(Jan 28 2022 at 18:15)</a>:</h4>
<p>Thank you! <a href="/user_uploads/3121/4Myml8FLYC_37LJLTys4ZhAK/image.png">image.png</a>  which part is inductive?</p>
<div class="message_inline_image"><a href="/user_uploads/3121/4Myml8FLYC_37LJLTys4ZhAK/image.png" title="image.png"><img src="/user_uploads/3121/4Myml8FLYC_37LJLTys4ZhAK/image.png"></a></div>



<a name="269778860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269778860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269778860">(Jan 28 2022 at 18:16)</a>:</h4>
<p>isn't it using <code>less_than_or_equal</code> ?</p>



<a name="269778915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269778915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269778915">(Jan 28 2022 at 18:17)</a>:</h4>
<p>Ah, and that is recursive: <a href="/user_uploads/3121/KlehlWkwhVZduYj0sLaCgVXl/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/KlehlWkwhVZduYj0sLaCgVXl/image.png" title="image.png"><img src="/user_uploads/3121/KlehlWkwhVZduYj0sLaCgVXl/image.png"></a></div>



<a name="269783051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269783051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269783051">(Jan 28 2022 at 18:44)</a>:</h4>
<p>One downside of induction on the <code>le</code> is that the syntax goes so wrong. Is this something we can fix? (Also: is there a reason we have <code>nat.le</code> in front of <code>nat.less_than_or_equal</code>?)</p>



<a name="269783133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269783133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269783133">(Jan 28 2022 at 18:44)</a>:</h4>
<p>One solution is having a custom induction principle for <code>le</code> notation for <code>nat</code></p>



<a name="269783379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269783379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269783379">(Jan 28 2022 at 18:46)</a>:</h4>
<p>Do you mean <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.le_induction">docs#nat.le_induction</a>? <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="269787342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269787342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269787342">(Jan 28 2022 at 19:12)</a>:</h4>
<p>It seems like that doesn't work with <code>induction</code>, but <code>refine</code> is fine:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">induction_nfactltnexpnm1ngt3</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nat.factorial</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">nat.le_induction</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n'</span> <span class="n">ih</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">n</span> <span class="n">h₀</span><span class="o">,</span>

<span class="kd">end</span>
</code></pre></div>
<p>(@ccn That's how you can get some better syntax for your contexts.)</p>



<a name="269896704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269896704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269896704">(Jan 29 2022 at 23:53)</a>:</h4>
<p>How would I prove something like <code>c * x^a &lt; c * (x+1)^a</code> (I'm just adding one to x, but it has to get bigger)</p>



<a name="269896772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269896772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269896772">(Jan 29 2022 at 23:54)</a>:</h4>
<p>first get rid of the c with <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_lt_mul_left">docs#mul_lt_mul_left</a></p>



<a name="269896777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269896777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269896777">(Jan 29 2022 at 23:54)</a>:</h4>
<p>then use <a href="https://leanprover-community.github.io/mathlib_docs/find/pow_lt_pow_of_lt_left">docs#pow_lt_pow_of_lt_left</a></p>



<a name="269897234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269897234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269897234">(Jan 30 2022 at 00:03)</a>:</h4>
<p>Thanks Mario!</p>



<a name="269902558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269902558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269902558">(Jan 30 2022 at 01:55)</a>:</h4>
<p>What do you use to prove this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="mi">3</span> <span class="bp">&lt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">linarith</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>linarith fails here, if I change k to be an integer instead of a natural number it works though...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">linarith</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">find</span> <span class="n">a</span> <span class="n">contradiction</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">,</span>
<span class="n">ᾰ</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≥</span> <span class="n">k</span> <span class="bp">-</span> <span class="mi">1</span>
<span class="bp">⊢</span> <span class="n">false</span>
</code></pre></div>



<a name="269902958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269902958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269902958">(Jan 30 2022 at 02:02)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">nat.sub_pos_of_lt</span> <span class="o">(</span><span class="n">lt_of_lt_of_le</span> <span class="n">dec_trivial</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>



<a name="269904437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269904437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269904437">(Jan 30 2022 at 02:35)</a>:</h4>
<p>Thanks Patrick</p>



<a name="269904495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269904495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269904495">(Jan 30 2022 at 02:36)</a>:</h4>
<p>I worked on this proof for a while and managed to get it this far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">induction_nfactltnexpnm1ngt3</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nat.factorial</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">h₀</span> <span class="k">with</span> <span class="n">k</span> <span class="n">h₀</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">norm_num</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="k">have</span> <span class="n">h</span><span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">k.succ</span> <span class="o">:=</span> <span class="n">lt_add_one</span> <span class="n">k</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hpos</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;=</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">zero_le</span> <span class="n">k</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">kpos</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span> <span class="n">nat.sub_pos_of_lt</span> <span class="o">(</span><span class="n">lt_of_le_of_lt</span> <span class="n">dec_trivial</span> <span class="n">h₀</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">hpow</span> <span class="o">:</span> <span class="n">k</span><span class="bp">^</span><span class="o">(</span><span class="n">k</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">k.succ</span><span class="bp">^</span><span class="o">(</span><span class="n">k</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="k">from</span> <span class="n">pow_lt_pow_of_lt_left</span> <span class="n">h</span> <span class="n">hpos</span> <span class="n">kpos</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">kp1pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k.succ</span><span class="o">,</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hf</span> <span class="o">:</span> <span class="n">k.succ</span> <span class="bp">*</span> <span class="n">k</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">k.succ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">k.succ</span><span class="o">)</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="k">from</span> <span class="o">(</span><span class="n">mul_lt_mul_left</span> <span class="n">kp1pos</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hpow</span><span class="o">,</span>

    <span class="k">calc</span> <span class="n">k.succ.factorial</span> <span class="bp">=</span> <span class="n">k.succ</span> <span class="bp">*</span> <span class="n">k.factorial</span> <span class="o">:</span> <span class="n">rfl</span>
                      <span class="bp">...</span> <span class="bp">&lt;</span> <span class="n">k.succ</span> <span class="bp">*</span> <span class="n">k</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">mul_lt_mul_left</span> <span class="n">kp1pos</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">h₀_ih</span>
                      <span class="bp">...</span> <span class="bp">&lt;</span> <span class="n">k.succ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">k.succ</span><span class="o">)</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k</span><span class="bp">-</span><span class="mi">1</span><span class="o">):</span> <span class="n">hf</span>
                      <span class="bp">...</span> <span class="bp">=</span> <span class="n">k.succ</span> <span class="bp">^</span> <span class="n">k</span><span class="o">:</span> <span class="gr">sorry</span>
                      <span class="bp">...</span> <span class="bp">=</span> <span class="n">k.succ</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k.succ</span><span class="bp">-</span><span class="mi">1</span><span class="o">):</span> <span class="n">rfl</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>aside from the one sorry, this proof should be correct, but I'd like to reduce the size of it somehow so it reads more like this: </p>
<div class="message_inline_image"><a href="https://i.imgur.com/izClHvy.jpg"><img src="https://uploads.zulipusercontent.net/75cd11987b70284217568782c963168ae51eb8ec/68747470733a2f2f692e696d6775722e636f6d2f697a436c4876792e6a7067"></a></div><p>Could anyone help me reduce the size of my proof? </p>
<p>I mainly want to get rid of the trivial inequalities involving zero.</p>



<a name="269904905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269904905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269904905">(Jan 30 2022 at 02:44)</a>:</h4>
<p>to prove the sorry, rewrite with <a href="https://leanprover-community.github.io/mathlib_docs/find/pow_succ">docs#pow_succ</a> and then <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.sub_add_cancel">docs#nat.sub_add_cancel</a></p>



<a name="269905030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269905030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269905030">(Jan 30 2022 at 02:47)</a>:</h4>
<p>also don't forget to make an <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> when you post theorems here</p>



<a name="269905036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269905036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269905036">(Jan 30 2022 at 02:48)</a>:</h4>
<p>(i.e. put the <code>import</code> line)</p>



<a name="269905508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269905508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269905508">(Jan 30 2022 at 02:57)</a>:</h4>
<p>Here's how I would write it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.linarith</span>

<span class="kd">theorem</span> <span class="n">fact_lt_pow_self_sub_one</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nat.factorial</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">h₀</span> <span class="k">with</span> <span class="n">k</span> <span class="n">h₀</span> <span class="n">ih</span><span class="o">,</span> <span class="o">{</span><span class="n">dec_trivial</span><span class="o">},</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">((</span><span class="n">mul_lt_mul_left</span> <span class="o">(</span><span class="n">nat.succ_pos</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ih</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_le</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">nat.mul_le_mul_left</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">nat.pow_le_pow_of_le_left</span> <span class="o">(</span><span class="n">nat.le_succ</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">pow_succ</span><span class="o">,</span> <span class="n">nat.sub_add_cancel</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">le_trans</span> <span class="n">dec_trivial</span> <span class="n">h₀</span>
<span class="kd">end</span>
</code></pre></div>



<a name="269905805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269905805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269905805">(Jan 30 2022 at 03:03)</a>:</h4>
<p>Here it is with a calc block if you're into that sort of thing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.linarith</span>

<span class="n">open_locale</span> <span class="n">nat</span>
<span class="kd">theorem</span> <span class="n">fact_lt_pow_self_sub_one</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nat.factorial</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">h₀</span> <span class="k">with</span> <span class="n">k</span> <span class="n">h₀</span> <span class="n">ih</span><span class="o">,</span> <span class="o">{</span><span class="n">dec_trivial</span><span class="o">},</span>
  <span class="k">have</span> <span class="n">k1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">le_trans</span> <span class="n">dec_trivial</span> <span class="n">h₀</span><span class="o">,</span>
  <span class="k">calc</span> <span class="n">k.succ</span> <span class="bp">*</span> <span class="n">k</span><span class="bp">!</span>
      <span class="bp">&lt;</span> <span class="n">k.succ</span> <span class="bp">*</span> <span class="n">k</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">mul_lt_mul_left</span> <span class="o">(</span><span class="n">nat.succ_pos</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ih</span>
  <span class="bp">...</span> <span class="bp">≤</span> <span class="n">k.succ</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat.mul_le_mul_left</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">nat.pow_le_pow_of_le_left</span> <span class="o">(</span><span class="n">nat.le_succ</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">k.succ</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.sub_add_cancel</span> <span class="n">k1</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="269906893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269906893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269906893">(Jan 30 2022 at 03:29)</a>:</h4>
<p>If you prefer to do induction on <code>nat</code> instead of <code>≤</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">n.factorial</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">nat.exists_eq_add_of_le</span> <span class="n">h</span><span class="o">,</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">nat.add_succ</span><span class="o">,</span> <span class="n">nat.factorial</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">nth_rewrite</span> <span class="mi">3</span> <span class="n">nat.succ_add</span><span class="o">,</span> <span class="n">rw</span> <span class="n">pow_succ</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">mul_lt_mul_left</span> <span class="o">(</span><span class="n">nat.zero_lt_succ</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">lt_trans</span> <span class="n">hn</span> <span class="n">_</span><span class="o">),</span> <span class="n">simp_rw</span> <span class="n">nat.succ_add</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nat.pow_lt_pow_of_lt_left</span> <span class="o">(</span><span class="n">nat.lt_succ_self</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">nat.zero_lt_succ</span> <span class="n">_</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="269907745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269907745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269907745">(Jan 30 2022 at 03:49)</a>:</h4>
<p>Thanks for showing me your approaches, it helps me learn a lot!</p>



<a name="269908053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269908053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269908053">(Jan 30 2022 at 03:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/269905805">said</a>:</p>
<blockquote>
<p>Here it is with a calc block if you're into that sort of thing:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.linarith</span>

<span class="n">open_locale</span> <span class="n">nat</span>
<span class="kd">theorem</span> <span class="n">fact_lt_pow_self_sub_one</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nat.factorial</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">h₀</span> <span class="k">with</span> <span class="n">k</span> <span class="n">h₀</span> <span class="n">ih</span><span class="o">,</span> <span class="o">{</span><span class="n">dec_trivial</span><span class="o">},</span>
  <span class="k">have</span> <span class="n">k1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">le_trans</span> <span class="n">dec_trivial</span> <span class="n">h₀</span><span class="o">,</span>
  <span class="k">calc</span> <span class="n">k.succ</span> <span class="bp">*</span> <span class="n">k</span><span class="bp">!</span>
      <span class="bp">&lt;</span> <span class="n">k.succ</span> <span class="bp">*</span> <span class="n">k</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">mul_lt_mul_left</span> <span class="o">(</span><span class="n">nat.succ_pos</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ih</span>
  <span class="bp">...</span> <span class="bp">≤</span> <span class="n">k.succ</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat.mul_le_mul_left</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">nat.pow_le_pow_of_le_left</span> <span class="o">(</span><span class="n">nat.le_succ</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">k.succ</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat.sub_add_cancel</span> <span class="n">k1</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p>How does the dollar sign work here?</p>



<a name="269908155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269908155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269908155">(Jan 30 2022 at 03:59)</a>:</h4>
<p><code>$ nat.pow_le_pow_of_le_left (nat.le_succ _) _</code> is the same as <code>(nat.pow_le_pow_of_le_left (nat.le_succ _) _)</code></p>
<p>It's just a way to write with less parentheses</p>



<a name="269908288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269908288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269908288">(Jan 30 2022 at 04:01)</a>:</h4>
<p>Is the purpose so you can delimit in a more readable fashion?</p>



<a name="269908410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/269908410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#269908410">(Jan 30 2022 at 04:03)</a>:</h4>
<p>Also note that <code>$</code> is right associative, so <code>a $ b $ c $ d</code> is equal to <code>a (b (c d))</code></p>



<a name="270138388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270138388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270138388">(Feb 01 2022 at 01:48)</a>:</h4>
<p>Previously we were able to have this proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="n">main</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">),</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">∈</span> <span class="o">[(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">7</span><span class="o">),</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">-</span><span class="mi">1</span><span class="o">],</span>
    <span class="n">dec_trivial</span>
</code></pre></div>
<p>I wanted to prove another fact about modular arithmetic, but the same proof didn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="n">main</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span><span class="bp">^</span><span class="n">n</span><span class="o">:</span> <span class="n">zmod</span> <span class="mi">12</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">4</span><span class="o">:</span> <span class="n">zmod</span> <span class="mi">12</span><span class="o">),</span>
    <span class="n">dec_trivial</span>
</code></pre></div>
<p>because it failed to synthesize the type class.</p>
<p>Would I have to prove this by induction?</p>



<a name="270139944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270139944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270139944">(Feb 01 2022 at 02:06)</a>:</h4>
<p>It's not at all obvious that the same kind of proof works. <code>4^n % 12</code> could have arbitrary non-periodic behavior</p>



<a name="270139977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270139977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270139977">(Feb 01 2022 at 02:06)</a>:</h4>
<p>In fact it doesn't, this is Fermat's little theorem, but there is definitely something to show</p>



<a name="270140040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270140040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270140040">(Feb 01 2022 at 02:07)</a>:</h4>
<p>In this case the simplest proof is induction, like you suggest, since the period is 1</p>



<a name="270141461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270141461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270141461">(Feb 01 2022 at 02:27)</a>:</h4>
<p>I'm not at a computer now, but is it even true for <code>n=0</code>?</p>



<a name="270141676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270141676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270141676">(Feb 01 2022 at 02:30)</a>:</h4>
<p>You're right, It'll have to be for positive naturals.</p>



<a name="270141683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270141683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270141683">(Feb 01 2022 at 02:30)</a>:</h4>
<p>Thanks for the feedback</p>



<a name="270141847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270141847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Lubrino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270141847">(Feb 01 2022 at 02:32)</a>:</h4>
<p>removed</p>



<a name="270142179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270142179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270142179">(Feb 01 2022 at 02:37)</a>:</h4>
<p>I've modified the statement to be this now: <code> ∀ (n : ℕ), (4^(n+1): zmod 12) = (4: zmod 12)</code></p>
<p>in the induction step, I have this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">case</span> <span class="n">nat.succ</span>
<span class="n">k</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">IH</span><span class="o">:</span> <span class="mi">4</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">4</span>
<span class="bp">⊢</span> <span class="mi">4</span> <span class="bp">^</span> <span class="o">(</span><span class="n">k.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">4</span>
</code></pre></div>
<p>(note these numbers are mod 12).</p>
<p>I want to use the fact that if 4^(k+1) = 4 (mod 12), then I can multiply both sides by any constant (in this case 4). </p>
<p>I've been looking around for the modular arithmetic docuemntation, but just found this link: <a href="https://leanprover-community.github.io/mathlib_docs/number_theory/modular.html">https://leanprover-community.github.io/mathlib_docs/number_theory/modular.html</a> which doesn't seem right when I read the contents. Where could I find the theorem I need here?</p>



<a name="270142521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270142521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270142521">(Feb 01 2022 at 02:41)</a>:</h4>
<p>Does <code>rw [pow_succ, IH]</code> get you to <code>4 * 4 = 4</code>?</p>



<a name="270142609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270142609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270142609">(Feb 01 2022 at 02:42)</a>:</h4>
<p>Yes it does!</p>



<a name="270142610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270142610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270142610">(Feb 01 2022 at 02:42)</a>:</h4>
<p><del>You may need an <code>succ_eq_add_one</code> as well.</del> apparently not!</p>



<a name="270142647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270142647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270142647">(Feb 01 2022 at 02:43)</a>:</h4>
<p>so now I just need to prove <code>4 * 4 = 4</code> (mod 12) I can just use <code>norm_num</code> for something like that right?</p>



<a name="270142735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270142735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270142735">(Feb 01 2022 at 02:44)</a>:</h4>
<p>norm_num just makes the goal <code>16 = 4</code></p>



<a name="270142810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270142810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270142810">(Feb 01 2022 at 02:45)</a>:</h4>
<p>At this stage, <code>dec_trivial</code> might work?  Not sure...</p>



<a name="270142869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270142869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270142869">(Feb 01 2022 at 02:46)</a>:</h4>
<p>Oh, you're right <code>dec_trivial</code> works, that works because that fact is something that could be derived from an algorithm, is that right?</p>



<a name="270142922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270142922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270142922">(Feb 01 2022 at 02:47)</a>:</h4>
<p>I think so, but a very specific type of algorithm: brute-force.</p>



<a name="270142945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270142945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270142945">(Feb 01 2022 at 02:47)</a>:</h4>
<p>Your previous statement was a fact about all natural numbers, while this one is about elements of zmod 12.</p>



<a name="270142954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270142954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270142954">(Feb 01 2022 at 02:48)</a>:</h4>
<p>Which works because these are now finite things?</p>



<a name="270142957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270142957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270142957">(Feb 01 2022 at 02:48)</a>:</h4>
<p>Brute-force works in the latter but not in the former</p>



<a name="270143016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270143016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270143016">(Feb 01 2022 at 02:48)</a>:</h4>
<p>Thanks for the help, I'm still a little interested in the basic number theory facts though, do you think you could point me to where I could learn about them in the docs?</p>



<a name="270143051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270143051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270143051">(Feb 01 2022 at 02:49)</a>:</h4>
<p>Things are more subtle than this and I do not really know the details, but for dec_trivial to work you should really have a finite statement, not just a trivial-looking one.</p>



<a name="270143244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270143244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270143244">(Feb 01 2022 at 02:51)</a>:</h4>
<p>The <code>pow_succ</code> was simply manipulating powers in lean: you should "happen to know" that powers by natural numbers are defined inductively and therefore there should be a lemma about pow_zero and one about pow_succ (and of course others as well!).</p>



<a name="270143337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270143337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270143337">(Feb 01 2022 at 02:53)</a>:</h4>
<p>For actually learning number theory, I am not sure, since I learned what I know before using Lean, from people and books: two activities that have changed much in recent years!  <span aria-label="lol" class="emoji emoji-1f606" role="img" title="lol">:lol:</span></p>



<a name="270144467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270144467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270144467">(Feb 01 2022 at 03:07)</a>:</h4>
<p>No problem, I managed to find a thoerem I wanted to use: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="kd">theorem</span> <span class="n">nat.modeq_iff_dvd</span> <span class="o">{</span><span class="n">n</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span>
<span class="n">a</span> <span class="bp">≡</span> <span class="n">b</span> <span class="o">[</span><span class="n">MOD</span> <span class="n">n</span><span class="o">]</span> <span class="bp">↔</span> <span class="bp">↑</span><span class="n">n</span> <span class="bp">∣</span> <span class="bp">↑</span><span class="n">b</span> <span class="bp">-</span> <span class="bp">↑</span><span class="n">a</span>
</code></pre></div>
<p>My goal state looks like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">nat.modeq_iff_dvd</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_2</span> <span class="bp">≡</span> <span class="bp">?</span><span class="n">m_3</span> <span class="o">[</span><span class="n">MOD</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">]</span> <span class="bp">↔</span> <span class="bp">↑?</span><span class="n">m_1</span> <span class="bp">∣</span> <span class="bp">↑?</span><span class="n">m_3</span> <span class="bp">-</span> <span class="bp">↑?</span><span class="n">m_2</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">main</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="mi">4</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">,</span>
<span class="n">twenty_fact</span> <span class="o">:</span> <span class="mi">20</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">4</span>
<span class="bp">⊢</span> <span class="mi">12</span> <span class="bp">∣</span> <span class="mi">4</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">20</span>
</code></pre></div>
<p>and my usage of that theorem is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">rw</span> <span class="bp">←</span> <span class="o">(</span><span class="n">nat.modeq_iff_dvd</span> <span class="mi">12</span> <span class="o">(</span><span class="mi">4</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="mi">20</span><span class="o">),</span>
</code></pre></div>
<p>am I doing it wrong?</p>



<a name="270144535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270144535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270144535">(Feb 01 2022 at 03:08)</a>:</h4>
<p>Yes, <code>n a b</code> are implicit parameters (in <code>{}</code>), so don't write them</p>



<a name="270144562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270144562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270144562">(Feb 01 2022 at 03:09)</a>:</h4>
<p>If I leave off the arguments I get the error: <code>rewrite tactic failed, did not find instance of the pattern in the target expression
  ↑?m_1 ∣ ↑?m_2 - ↑?m_3</code></p>



<a name="270144580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270144580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270144580">(Feb 01 2022 at 03:09)</a>:</h4>
<p>But then, the pattern won't match because there is a <code>+</code> and not a <code>-</code></p>



<a name="270144599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270144599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270144599">(Feb 01 2022 at 03:09)</a>:</h4>
<p>Ah I see</p>



<a name="270144606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270144606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270144606">(Feb 01 2022 at 03:09)</a>:</h4>
<p>So I need to turn my 20 into a - (- 20)</p>



<a name="270144859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270144859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270144859">(Feb 01 2022 at 03:12)</a>:</h4>
<p>I tried using this: </p>
<p><code>  rw ← neg_neg 20,</code> but it fails because it cannot synthesize the type class</p>



<a name="270144871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270144871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270144871">(Feb 01 2022 at 03:13)</a>:</h4>
<p>```@[simp]<br>
theorem neg_neg {G : Type u} [add_group G] (a : G) :<br>
--a = a</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>
</code></pre></div>



<a name="270144914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270144914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270144914">(Feb 01 2022 at 03:14)</a>:</h4>
<p>Oh right because you are using <code>nat</code></p>



<a name="270145027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270145027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270145027">(Feb 01 2022 at 03:15)</a>:</h4>
<p>Oh ok, that's because the numbers doesn't have an additive inverse right?</p>



<a name="270145093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270145093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270145093">(Feb 01 2022 at 03:16)</a>:</h4>
<p>Shouldn't there be a <code>neg_neg</code> that works for what I'm trying to do?</p>



<a name="270145571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270145571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270145571">(Feb 01 2022 at 03:23)</a>:</h4>
<p>The arrows ↑ next to <code>?m_i</code> mean that whatever <code>?m_i</code> was (a natural number in this case) has been coerced into some other type (an integer in this case).  So, if you want to proceed along this path, you should change the divisibility statement about natural numbers to one about integers.</p>
<p>[Note: I guessed the types of <code>?m_i</code> and <code>↑?m_i</code> since I've played with these objects, but the error above does not tell you what the types are.]</p>



<a name="270145875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270145875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270145875">(Feb 01 2022 at 03:28)</a>:</h4>
<p>Ah I see, I'll keep playing with it then to get the right types</p>



<a name="270146236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270146236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270146236">(Feb 01 2022 at 03:33)</a>:</h4>
<p>I also have a lingering doubt: if you use <code>-(-20)</code>, then -20 is not a natural number and you might run into more issues applying the result above anyway.</p>



<a name="270146430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270146430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270146430">(Feb 01 2022 at 03:35)</a>:</h4>
<p>You're right, I've changed my twenty fact to look like <code>-20 = 4 (mod 12)</code></p>



<a name="270146692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270146692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270146692">(Feb 01 2022 at 03:38)</a>:</h4>
<p>Does this congruence really work <em>in Lean</em>?  What is the type of -20?  ℤ?</p>



<a name="270147556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270147556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270147556">(Feb 01 2022 at 03:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270146692">said</a>:</p>
<blockquote>
<p>Does this congruence really work <em>in Lean</em>?  What is the type of -20?  ℤ?</p>
</blockquote>
<p>This is what my proof is looking like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">induction_12dvd4expnp1p20</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">12</span> <span class="bp">∣</span> <span class="mi">4</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">20</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">main</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">):</span> <span class="n">zmod</span> <span class="mi">12</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">4</span><span class="o">:</span> <span class="n">zmod</span> <span class="mi">12</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">k</span> <span class="n">IH</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">norm_num</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">pow_succ</span><span class="o">,</span> <span class="n">IH</span><span class="o">],</span>
      <span class="n">dec_trivial</span><span class="o">,</span>
    <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">twenty_fact</span> <span class="o">:</span> <span class="o">(</span><span class="bp">-</span><span class="mi">20</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">12</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">4</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">12</span><span class="o">),</span>
    <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">int.coe_nat_dvd</span><span class="o">,</span>
  <span class="c1">-- rw ← (nat.modeq_iff_dvd),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="270147654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270147654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270147654">(Feb 01 2022 at 03:50)</a>:</h4>
<p>I think i'm having trouble because I forgot that everything has a different type in lean</p>



<a name="270147660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270147660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270147660">(Feb 01 2022 at 03:50)</a>:</h4>
<p>What do you think the best way forward would be?</p>



<a name="270147704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270147704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270147704">(Feb 01 2022 at 03:51)</a>:</h4>
<p>I was trying to use <code> rw ← int.coe_nat_dvd,</code> but I think that's making things harder to prove</p>



<a name="270148603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270148603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270148603">(Feb 01 2022 at 04:01)</a>:</h4>
<p>I also think I'm confused about the difference between <code>MOD</code> and <code>zmod</code></p>



<a name="270166198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270166198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270166198">(Feb 01 2022 at 08:08)</a>:</h4>
<p>I have a goal state of </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">main</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="mi">4</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">4</span>
<span class="n">twenty_fact</span><span class="o">:</span> <span class="bp">-</span><span class="mi">20</span> <span class="bp">=</span> <span class="mi">4</span>
<span class="bp">⊢</span> <span class="bp">↑</span><span class="o">(</span><span class="mi">4</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">20</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">↑</span><span class="mi">0</span>
</code></pre></div>
<p>where the arrow means that they both have type <code>zmod 12</code>, I want to push the cast through, by using <code>push_cast</code>, but when I do that the goal state changes to </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span>
</code></pre></div>
<p>How can I do this properly?</p>



<a name="270167223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270167223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270167223">(Feb 01 2022 at 08:20)</a>:</h4>
<p>Below is my solution, in case you are interested!</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.zmod.algebra</span>

<span class="kd">lemma</span> <span class="n">four_eq_one</span> <span class="o">:</span> <span class="o">(</span><span class="mi">4</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">induction_12dvd4expnp1p20</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">12</span> <span class="bp">∣</span> <span class="mi">4</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">20</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">show</span>  <span class="mi">4</span> <span class="bp">*</span> <span class="mi">3</span> <span class="bp">∣</span> <span class="mi">4</span> <span class="bp">*</span> <span class="mi">4</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">4</span> <span class="bp">*</span> <span class="mi">5</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_add</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">mul_dvd_mul_left</span> <span class="mi">4</span> <span class="o">((</span><span class="n">zmod.nat_coe_zmod_eq_zero_iff_dvd</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">four_eq_one</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="270167608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270167608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270167608">(Feb 01 2022 at 08:22)</a>:</h4>
<p>Oh very nice Damiano! I was working on something but it was longer. Do we have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∣</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∣</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>
</code></pre></div>
<p>? I was wondering whether it was easier or harder to avoid zmod completely.</p>



<a name="270167731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270167731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270167731">(Feb 01 2022 at 08:23)</a>:</h4>
<p>Cool, I seemed to have tunnel visioned on getting the coe stuff to work instead of trying a new approach, thanks for new angles on the question</p>



<a name="270168061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270168061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270168061">(Feb 01 2022 at 08:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270167608">said</a>:</p>
<blockquote>
<p>Oh very nice Damiano! I was working on something but it was longer. Do we have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∣</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∣</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>
</code></pre></div>
<p>? I was wondering whether it was easier or harder to avoid zmod completely.</p>
</blockquote>
<p>If that's not in the mathlib, I could help add it in</p>



<a name="270168079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270168079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270168079">(Feb 01 2022 at 08:26)</a>:</h4>
<p>My solution using it:</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="kd">lemma</span> <span class="n">dvd_of_dvd_add_mul_left</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∣</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∣</span> <span class="n">b</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">induction_12dvd4expnp1p20</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">12</span> <span class="bp">∣</span> <span class="mi">4</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">20</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">k</span> <span class="n">IH</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">norm_num</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pow_succ</span><span class="o">,</span> <span class="n">succ_eq_add_one</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">dvd_of_dvd_add_mul_left</span> <span class="n">_</span> <span class="n">_</span> <span class="mi">5</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">dvd_mul_of_dvd_right</span> <span class="n">IH</span> <span class="mi">4</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="270168656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270168656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270168656">(Feb 01 2022 at 08:33)</a>:</h4>
<p>ok, so this would complete it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">dvd_of_dvd_add_mul_left</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∣</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∣</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">nat.dvd_add_left</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">dvd_mul_right</span> <span class="n">a</span> <span class="n">n</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="270168680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270168680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270168680">(Feb 01 2022 at 08:33)</a>:</h4>
<p>Should I add it to mathlib?</p>



<a name="270168772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270168772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270168772">(Feb 01 2022 at 08:34)</a>:</h4>
<p>You could try! I don't know the naming convention well enough to know whether it's <code>left</code> or <code>right</code>, and it should perhaps be an iff. We might have it; I just couldn't find it. Nice proof!</p>



<a name="270168834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270168834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270168834">(Feb 01 2022 at 08:34)</a>:</h4>
<p>I guess people might say that it's just an easy combination of two existing lemmas</p>



<a name="270168999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270168999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270168999">(Feb 01 2022 at 08:35)</a>:</h4>
<p>After studying your proofs the biggest thing that caused me trouble was involving modular arithmetic because I have trouble with coe stuff</p>



<a name="270169126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270169126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270169126">(Feb 01 2022 at 08:36)</a>:</h4>
<p>No one seems to have mentioned <code>norm_fin</code> yet. It should be able to prove <code>(16 : zmod 12) = 4</code></p>



<a name="270169219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270169219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270169219">(Feb 01 2022 at 08:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270168772">said</a>:</p>
<blockquote>
<p>You could try! I don't know the naming convention well enough to know whether it's <code>left</code> or <code>right</code>, and it should perhaps be an iff. We might have it; I just couldn't find it. Nice proof!</p>
</blockquote>
<p>What's the procedure for checking? I've looked here so far and I didn't see it on a first look over: <a href="https://leanprover-community.github.io/mathlib_docs/data/nat/modeq.html#nat.modeq">https://leanprover-community.github.io/mathlib_docs/data/nat/modeq.html#nat.modeq</a></p>



<a name="270169414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270169414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270169414">(Feb 01 2022 at 08:38)</a>:</h4>
<p>Here's a proof which doesn't use it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">induction_12dvd4expnp1p20</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">12</span> <span class="bp">∣</span> <span class="mi">4</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">20</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">k</span> <span class="n">IH</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">norm_num</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pow_succ</span><span class="o">,</span> <span class="n">succ_eq_add_one</span><span class="o">,</span> <span class="bp">←</span> <span class="n">nat.dvd_add_left</span> <span class="o">(</span><span class="k">show</span> <span class="mi">12</span> <span class="bp">∣</span> <span class="mi">60</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">)],</span>
    <span class="n">exact</span> <span class="n">dvd_mul_of_dvd_right</span> <span class="n">IH</span> <span class="mi">4</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>inspired by your <code>nat.dvd_add_left</code> proof.</p>



<a name="270169439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270169439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270169439">(Feb 01 2022 at 08:38)</a>:</h4>
<p>actually that's a lie, it only works on <code>fin</code> not <code>zmod</code>. Alternatively you can rewrite the goal to <code>16 % 12 = 4 % 12</code> and use <code>norm_num</code></p>



<a name="270169546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270169546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270169546">(Feb 01 2022 at 08:39)</a>:</h4>
<p>Damiano's is still shorter though :-)</p>



<a name="270169733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270169733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270169733">(Feb 01 2022 at 08:40)</a>:</h4>
<p>So in Damiano's proof somehow we used the fact : <code>(4 : zmod 3) = 1</code> so that <code>4^n</code> would simplify to <code>1^n</code> ?  which in-turn became just 1 ?</p>



<a name="270169778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270169778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270169778">(Feb 01 2022 at 08:41)</a>:</h4>
<p><span class="user-mention" data-user-id="367659">@ccn</span>  My line of reasoning was that I always try to get common factors out of the way from congruences and you had a 4 dividing everything in sight.  Once that is gone, you are really trying to prove that <code>4^n = 1 mod 3</code>, which is one step away from <code>4 = 1 mod 3</code>, which is so trivial that even <code>rfl</code> solves it!</p>
<p>I hope that the thought process helps!</p>



<a name="270169832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270169832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270169832">(Feb 01 2022 at 08:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270169778">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="367659">ccn</span>  My line of reasoning was that I always try to get common factors out of the way from congruences and you had a 4 dividing everything in sight.  Once that is gone, you are really trying to prove that <code>4^n = 1 mod 3</code>, which is one step away from <code>4 = 1 mod 3</code>, which is so trivial that even <code>rfl</code> solves it!</p>
<p>I hope that the thought process helps!</p>
</blockquote>
<p>It does help! for the proof of <code>4^n = 1 mod 3</code> that probably has induction in it somewhere right?</p>



<a name="270169862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270169862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270169862">(Feb 01 2022 at 08:42)</a>:</h4>
<p>But <code>rfl</code> is able to do it?</p>



<a name="270169914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270169914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270169914">(Feb 01 2022 at 08:42)</a>:</h4>
<p>You're going slightly the wrong way. The point is that<code>simp</code> knows that <code>1^n=1</code>. The route is 4^n=1^n=1, not 4^n=4=1.</p>



<a name="270169984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270169984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270169984">(Feb 01 2022 at 08:43)</a>:</h4>
<p>There are hidden coercions in the statement: you use the lemma to see that <code>4^n=1^n</code>, after that simp uses that <code>1^n=1</code>.</p>



<a name="270170173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270170173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270170173">(Feb 01 2022 at 08:45)</a>:</h4>
<p>If you see, in the <code>simpa</code> I explicitly told the simplifier that <code>four_eq_one</code> was a useful lemma.  It turned out that I was right!  <span aria-label="stuck out tongue closed eyes" class="emoji emoji-1f61d" role="img" title="stuck out tongue closed eyes">:stuck_out_tongue_closed_eyes:</span></p>



<a name="270170245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270170245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270170245">(Feb 01 2022 at 08:46)</a>:</h4>
<p>Can't that be changed to <code>simp</code>? (edit: apparently not!)</p>



<a name="270170338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270170338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270170338">(Feb 01 2022 at 08:46)</a>:</h4>
<p>(btw, the <code>a</code> in <code>simpa</code> takes care of another <code>rfl</code>: the proof that <code>1 + 5 = 0 mod 3</code>.)</p>



<a name="270170496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270170496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270170496">(Feb 01 2022 at 08:48)</a>:</h4>
<p>Also, I recently learned that if you use <code>simpa</code> where <code>simp</code> suffices, you get an error.</p>



<a name="270170579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270170579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270170579">(Feb 01 2022 at 08:49)</a>:</h4>
<p>Oh I see -- you're using the fact that <code>simpa</code> tries <code>refl</code> whereas <code>simp</code> doesn't? Or tries it harder, or something?</p>



<a name="270170638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270170638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270170638">(Feb 01 2022 at 08:49)</a>:</h4>
<p>To beat this problem to death, the strategy seems to be that the human makes all the variable useless, and then a combination of <code>simp</code> and <code>rfl</code> should solve your problems.</p>



<a name="270170819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270170819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270170819">(Feb 01 2022 at 08:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270170579">said</a>:</p>
<blockquote>
<p>Oh I see -- you're using the fact that <code>simpa</code> tries <code>refl</code> whereas <code>simp</code> doesn't? Or tries it harder, or something?</p>
</blockquote>
<p>I do not really know what <code>simpa</code> does in this case that <code>simp</code> does not, but it seems to try some form of <code>rfl</code> after doing its simplifications.</p>



<a name="270171383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270171383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270171383">(Feb 01 2022 at 08:54)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">ℕ</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="c1">-- fails</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="c1">-- works</span>
</code></pre></div>
<p><code>simp</code> knows <code>eq_self_iff_true</code> but <code>eq_self_iff_true</code> won't trigger on <code>X = ℕ</code> because <code>simp</code> won't unfold semireducible definitions. I only learnt this recently (when writing my course notes). We all say "rw works up to syntactic equality" but that's not quite true. <code>rw</code> will unfold reducible definitions but will leave semireducible ones alone, and <code>simp</code> inherits this behaviour. The default reducibility of a definition is semireducible. The <code>erw</code> tactic will unfold semireducible definitions too.</p>



<a name="270171477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270171477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270171477">(Feb 01 2022 at 08:55)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">ℕ</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="c1">-- works</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="c1">-- fails lol</span>
</code></pre></div>
<p>Is that a bug in <code>simpa</code>??</p>



<a name="270171535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270171535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270171535">(Feb 01 2022 at 08:56)</a>:</h4>
<p>what are you guys doing to my baby</p>



<a name="270171550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270171550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270171550">(Feb 01 2022 at 08:56)</a>:</h4>
<p>that's not how you use <code>simpa</code></p>



<a name="270171579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270171579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270171579">(Feb 01 2022 at 08:56)</a>:</h4>
<p>That was why I was so surprised Damiano was using it in the first place!</p>



<a name="270171615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270171615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270171615">(Feb 01 2022 at 08:56)</a>:</h4>
<p>It's not at all the intended usage; he was using it to do <code>simp, refl</code></p>



<a name="270171874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270171874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270171874">(Feb 01 2022 at 08:59)</a>:</h4>
<p>aha,<code>simpa</code> uses <code>assumption &lt;|&gt; trivial</code> once it's done its simp work</p>



<a name="270171910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270171910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270171910">(Feb 01 2022 at 08:59)</a>:</h4>
<p>and <code>trivial</code> does several things, including <code>refl</code></p>



<a name="270172104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270172104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270172104">(Feb 01 2022 at 09:00)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> the point about <code>simpa</code> is that it's supposed to reduce the goal to an (also simplified) assumption. That's why I initially said "doesn't simp work?" because as far as I could see there were no assumptions!</p>



<a name="270172237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270172237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270172237">(Feb 01 2022 at 09:01)</a>:</h4>
<p>I think <code>simpa</code> should be more aggressive about complaining when you aren't using it on an assumption</p>



<a name="270172310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270172310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270172310">(Feb 01 2022 at 09:02)</a>:</h4>
<p>You should just write <code>simp; trivial</code> if that's what you want</p>



<a name="270172312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270172312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270172312">(Feb 01 2022 at 09:02)</a>:</h4>
<p>maybe rename it to <code>simpA</code> <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="270172359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270172359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270172359">(Feb 01 2022 at 09:02)</a>:</h4>
<p>Ok, I did not know that I was abusing the <code>a</code> in <code>simpa</code> so much!  <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="270172378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270172378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270172378">(Feb 01 2022 at 09:02)</a>:</h4>
<p><code>A</code> for Aggressively Asserting Assumptions.</p>



<a name="270172457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270172457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270172457">(Feb 01 2022 at 09:03)</a>:</h4>
<p>well it can do like <code>ring</code> and succeed but passive-aggressively say <code>Try this: simp; trivial</code>, knowing that you can't check in a proof that prints stuff to mathlib</p>



<a name="270172484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270172484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270172484">(Feb 01 2022 at 09:03)</a>:</h4>
<p>If I had started with this proof</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">induction_12dvd4expnp1p20</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">12</span> <span class="bp">∣</span> <span class="mi">4</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">20</span> <span class="o">:=</span>
<span class="n">dvd_trans</span> <span class="o">(</span><span class="n">mul_dvd_mul_left</span> <span class="mi">4</span> <span class="o">((</span><span class="n">zmod.nat_coe_zmod_eq_zero_iff_dvd</span> <span class="o">(</span><span class="mi">4</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">5</span><span class="o">)</span> <span class="mi">3</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span>
  <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">four_eq_one</span><span class="o">])))</span> <span class="n">dvd_rfl</span>
</code></pre></div>
<p>people may not have noticed the rough behaviour on <code>simpa</code>. <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="270172581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270172581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270172581">(Feb 01 2022 at 09:04)</a>:</h4>
<p>I've used <code>simpa</code> for <code>simp; refl</code> a lot too. It's very handy</p>



<a name="270172864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270172864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270172864">(Feb 01 2022 at 09:06)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">induction_12dvd4expnp1p20</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">12</span> <span class="bp">∣</span> <span class="mi">4</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">20</span> <span class="o">:=</span>
<span class="n">dvd_trans</span> <span class="o">(</span><span class="n">mul_dvd_mul_left</span> <span class="mi">4</span> <span class="o">((</span><span class="n">zmod.nat_coe_zmod_eq_zero_iff_dvd</span> <span class="o">(</span><span class="mi">4</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">5</span><span class="o">)</span> <span class="mi">3</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span>
  <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">four_eq_one</span><span class="o">]</span><span class="bp">;</span> <span class="n">trivial</span><span class="o">)))</span> <span class="n">dvd_rfl</span>
</code></pre></div>
<p>no <code>simpa</code>s were abused in this proof.</p>



<a name="270173321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270173321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270173321">(Feb 01 2022 at 09:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270169219">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270168772">said</a>:</p>
<blockquote>
<p>You could try! I don't know the naming convention well enough to know whether it's <code>left</code> or <code>right</code>, and it should perhaps be an iff. We might have it; I just couldn't find it. Nice proof!</p>
</blockquote>
<p>What's the procedure for checking? I've looked here so far and I didn't see it on a first look over: <a href="https://leanprover-community.github.io/mathlib_docs/data/nat/modeq.html#nat.modeq">https://leanprover-community.github.io/mathlib_docs/data/nat/modeq.html#nat.modeq</a></p>
</blockquote>
<p>see <a href="https://leanprover-community.github.io/mathlib_docs/find/coprime_add_mul_right_right">docs#coprime_add_mul_right_right</a> for an example of how we did naming conventions for something similar in the past. In that situation there were 8 different lemma possibilities,  here there should only be 4.</p>



<a name="270176688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270176688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270176688">(Feb 01 2022 at 09:34)</a>:</h4>
<p>Maybe <code>simp</code> should try <code>refl</code> at the end.</p>



<a name="270180688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270180688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270180688">(Feb 01 2022 at 10:03)</a>:</h4>
<p><del>If <code>simp</code> tried <code>refl</code> would the proof above no longer need the call to <code>four_eq_one</code>?</del><br>
I tried and removing the explicit <code>four_eq_one</code> does not make <code>simp; refl</code> work (nor <code>simp; trivial</code>).</p>



<a name="270182403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270182403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270182403">(Feb 01 2022 at 10:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270176688">said</a>:</p>
<blockquote>
<p>Maybe <code>simp</code> should try <code>refl</code> at the end.</p>
</blockquote>
<p>Wouldn't this break all the proofs that end with <code>simp, refl</code>?</p>



<a name="270184097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270184097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270184097">(Feb 01 2022 at 10:26)</a>:</h4>
<p>It certainly would, but I think that the question implicitly suggested to fix all the resulting issues.  It would be quite a major golf!</p>



<a name="270184266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270184266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270184266">(Feb 01 2022 at 10:28)</a>:</h4>
<p>Lower bound:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rg</span> <span class="s2">"simp[,;] refl"</span> <span class="bp">|</span> <span class="n">wc</span> <span class="bp">-</span><span class="n">l</span>
<span class="mi">91</span>
</code></pre></div>
<p>This doesn't count proofs of the form</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">simp</span><span class="o">,</span>
<span class="n">refl</span>
</code></pre></div>
<p>that span 2 lines.</p>



<a name="270184338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270184338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270184338">(Feb 01 2022 at 10:28)</a>:</h4>
<p>Nor the ones that have <code>simp [lemmas][,;] refl</code> <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="270184396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270184396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270184396">(Feb 01 2022 at 10:29)</a>:</h4>
<p>Also, I imagine that the abusive <code>simpa</code> proofs would fail, since <code>simp</code> would have worked...</p>



<a name="270184781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270184781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270184781">(Feb 01 2022 at 10:32)</a>:</h4>
<p>Maybe <code>simp</code> should try <code>refl</code> at the end, and then if it closes the goal, monkeypatch <code>refl</code> into a noop so that it is ignored <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="270184922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270184922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270184922">(Feb 01 2022 at 10:34)</a>:</h4>
<p>(just kidding of course)</p>



<a name="270188102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270188102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270188102">(Feb 01 2022 at 10:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270176688">said</a>:</p>
<blockquote>
<p>Maybe <code>simp</code> should try <code>refl</code> at the end.</p>
</blockquote>
<p>Or at least <code>refl</code> with reducible transparency (like how <code>rw</code> works, I think?)<br>
I always find it funny when <code>simp</code> simplifies some complicated goal down to <code>0 = 0</code> or something and then gets stuck</p>



<a name="270188952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270188952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270188952">(Feb 01 2022 at 11:03)</a>:</h4>
<p><code>simp</code> should call <code>eq_self_iff_true</code> on things like <code>a = a</code> and solve it, which I suppose is quite similar to calling <code>refl</code> with redicible transparency?</p>



<a name="270191977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270191977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270191977">(Feb 01 2022 at 11:24)</a>:</h4>
<p>What does <code>simp [rfl]</code> do?</p>



<a name="270206735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270206735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270206735">(Feb 01 2022 at 13:15)</a>:</h4>
<p>Note that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>
</code></pre></div>
<p>works.  Squeezing you obtain <code>simp only [eq_self_iff_true]</code>.  So, I think that <code>simp</code> already uses <code>eq_self_iff_true</code>, at least sometimes.</p>



<a name="270206874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270206874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270206874">(Feb 01 2022 at 13:16)</a>:</h4>
<p>In the specific example at hand, without the extra <code>refl</code>, the outcome of <code>simp</code> is to leave <code>1 + 5 = 0</code>, where all the numbers are in <code>zmod 3</code>.</p>



<a name="270221418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270221418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270221418">(Feb 01 2022 at 14:43)</a>:</h4>
<p>It shouldn't do refl automatically. In some cases, those refl can be really heavy. Would you imagine it does refl after each simp rewrite, or just at the end? Even if it's just at the end, that means when I'm developing a proof and want to do the simp to squeeze_simp to simp only development step in the middle of a proof, I might trigger really expensive refls that fail anyway.</p>



<a name="270223635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270223635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270223635">(Feb 01 2022 at 14:56)</a>:</h4>
<p>I agree <code>simp</code> shouldn't do a "full" <code>refl</code>. Am I misremembering which kind of triviality <code>simp</code> likes to get stuck on?</p>



<a name="270368849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270368849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henry Pearson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270368849">(Feb 02 2022 at 11:24)</a>:</h4>
<p>Hi, I've written a formalisation of avl trees and I am now trying to build some basic theorems for it. My first step was trying to show that well formed trees are closed under all of the given definitions of operations, but this requires quite specific case analysis, so I've ended up with some quite complex tactic states (which lean helps with)! <br>
My issue is now that lean fails to apply the rw tactic in one case and I can't  seem to work out why. The relevant parts of the tactic state are:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">t_val</span> <span class="o">:</span> <span class="n">α</span>
<span class="n">t_right_left</span> <span class="o">:</span> <span class="n">avlnode</span> <span class="n">α</span>
<span class="n">t_right_val</span> <span class="o">:</span> <span class="n">α</span>
<span class="n">t_right_right</span> <span class="o">:</span> <span class="n">avlnode</span> <span class="n">α</span>

<span class="bp">⊢</span> <span class="o">(((</span><span class="n">nil.node</span> <span class="n">val</span> <span class="n">nil</span><span class="o">)</span><span class="bp">.</span><span class="n">node</span> <span class="n">t_val</span> <span class="n">t_right_left</span><span class="o">)</span><span class="bp">.</span><span class="n">node</span> <span class="n">t_right_val</span> <span class="n">t_right_right</span><span class="o">)</span><span class="bp">.</span><span class="n">balance_factor</span> <span class="bp">≤</span> <span class="mi">1</span>
</code></pre></div>
<p>Relevant definitions are:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">avlnode</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">nil</span>                                               <span class="o">:</span> <span class="n">avlnode</span>
  <span class="bp">|</span> <span class="n">node</span> <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">avlnode</span><span class="o">)</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">avlnode</span><span class="o">)</span> <span class="o">:</span> <span class="n">avlnode</span>

<span class="c">/-</span><span class="cm"> gives the balance factor of a node -/</span>
<span class="kd">def</span> <span class="n">balance_factor</span> <span class="o">:</span> <span class="n">avlnode</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">int</span>
  <span class="bp">|</span> <span class="n">nil</span>              <span class="o">:=</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">node</span> <span class="n">nil</span> <span class="n">_</span> <span class="n">nil</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">node</span> <span class="n">nil</span> <span class="n">_</span> <span class="n">r</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">depth</span> <span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">node</span> <span class="n">l</span> <span class="n">_</span> <span class="n">nil</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">-</span> <span class="o">(</span><span class="n">depth</span> <span class="n">l</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">node</span> <span class="n">l</span> <span class="n">_</span> <span class="n">r</span><span class="o">)</span>     <span class="o">:=</span> <span class="o">(</span><span class="n">depth</span> <span class="n">r</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">depth</span> <span class="n">l</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">depth</span> <span class="o">:</span> <span class="n">avlnode</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">int</span>
  <span class="bp">|</span> <span class="n">nil</span>              <span class="o">:=</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">node</span> <span class="n">nil</span> <span class="n">_</span> <span class="n">nil</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">node</span> <span class="n">l</span> <span class="n">_</span> <span class="n">r</span><span class="o">)</span>     <span class="o">:=</span> <span class="o">(</span><span class="n">int.max</span> <span class="o">(</span><span class="n">depth</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">depth</span> <span class="n">r</span><span class="o">))</span> <span class="bp">+</span> <span class="mi">1</span>
</code></pre></div>
<p>And the tactic that lean fails on is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rw</span> <span class="n">balance_factor</span><span class="o">,</span>
</code></pre></div>
<p>Any help would be much appreciated!!</p>



<a name="270369365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270369365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270369365">(Feb 02 2022 at 11:28)</a>:</h4>
<p>It's a bit hard to parse your goal (a good <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> would help a lot!) but I suspect that the problem is that <code>balance_factor</code> isn't quite compiled to the code you expect. Namely, I assume you want to use the rewrite rule <code>balance_factor (node l _ r)     := (depth r) - (depth l)</code>, right?</p>



<a name="270369636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270369636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270369636">(Feb 02 2022 at 11:31)</a>:</h4>
<p>However, the equation compiler will actually split <code>r</code> into a <code>nil</code> case (for the 4th line) and a <code>node</code> case (for the 5th line). So instead of <code>rw balance_factor</code> you should write <code>cases t_right_right; rw balance_factor</code>.</p>



<a name="270369952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270369952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henry Pearson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270369952">(Feb 02 2022 at 11:34)</a>:</h4>
<p>Ah I see - that is very helpful!!</p>



<a name="270369961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270369961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henry Pearson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270369961">(Feb 02 2022 at 11:34)</a>:</h4>
<p>Thanks a lot</p>



<a name="270448725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270448725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270448725">(Feb 02 2022 at 20:02)</a>:</h4>
<p>How can I do cases on if a number is irrational or not?</p>



<a name="270450236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270450236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270450236">(Feb 02 2022 at 20:13)</a>:</h4>
<p><code>by_cases irrational x</code></p>



<a name="270450893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270450893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270450893">(Feb 02 2022 at 20:18)</a>:</h4>
<p>It might be convenient to have a variant of <a href="https://leanprover-community.github.io/mathlib_docs/find/irrational_iff_ne_rational">docs#irrational_iff_ne_rational</a> for when a number is not irrational. That way you could more quickly split on this sort of <code>or</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">irrational_or_rational</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">irrational</span> <span class="n">x</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">classical.em</span> <span class="o">(</span><span class="n">irrational</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">irrational_iff_ne_rational</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="270451272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270451272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270451272">(Feb 02 2022 at 20:21)</a>:</h4>
<p>Yeah, I'm a bit disappointed to see that <code>irrational</code> is already the negation.</p>



<a name="270489079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270489079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270489079">(Feb 03 2022 at 01:52)</a>:</h4>
<p>I was trying to use the <code>by_cases irrational x</code> in the following proof, it works out but I'm having trouble proving the two different cases in it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">algebra_others_exirrpowirrrat</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">irrational</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">irrational</span> <span class="n">b</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">irrational</span> <span class="o">(</span><span class="n">a</span><span class="bp">^</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">sqrt_2</span> <span class="o">:=</span>  <span class="n">real.sqrt</span> <span class="mi">2</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">irrational</span> <span class="o">(</span><span class="n">sqrt_2</span><span class="bp">^</span><span class="n">sqrt_2</span><span class="o">),</span>
  <span class="o">{</span>
    <span class="k">have</span> <span class="n">h'</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">irrational</span> <span class="o">((</span><span class="n">sqrt_2</span><span class="bp">^</span><span class="n">sqrt_2</span><span class="o">)</span><span class="bp">^</span><span class="n">sqrt_2</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨(</span><span class="n">sqrt_2</span><span class="bp">^</span><span class="n">sqrt_2</span><span class="o">),</span> <span class="n">sqrt_2</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">irrational_sqrt_two</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩,</span>
  <span class="o">},</span>
  <span class="o">{</span>
     <span class="n">exact</span> <span class="o">⟨</span><span class="n">sqrt_2</span><span class="o">,</span> <span class="n">sqrt_2</span><span class="o">,</span> <span class="n">irrational_sqrt_two</span><span class="o">,</span> <span class="n">irrational_sqrt_two</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>Can someone help me get this to work?</p>



<a name="270492942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270492942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270492942">(Feb 03 2022 at 02:43)</a>:</h4>
<p>Use <code>let sqrt_2</code>, not <code>have sqrt_2</code></p>



<a name="270494706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270494706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270494706">(Feb 03 2022 at 03:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270492942">said</a>:</p>
<blockquote>
<p>Use <code>let sqrt_2</code>, not <code>have sqrt_2</code></p>
</blockquote>
<p>with the proof of <code>((sqrt_2^sqrt_2)^sqrt_2)</code> I tried using <code>dec_trivial</code> and <code>norm_num</code> to no avail. The proof for that really is that that whole thing will simplify to the number 2, which is not irrational. How would we prove that then?</p>



<a name="270495123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270495123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270495123">(Feb 03 2022 at 03:16)</a>:</h4>
<p>you should rewrite <code>((sqrt_2^sqrt_2)^sqrt_2) = sqrt_2^(sqrt_2*sqrt_2)</code> and then use the theorem that says <code>sqrt_2*sqrt_2 = 2</code></p>



<a name="270495138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270495138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270495138">(Feb 03 2022 at 03:17)</a>:</h4>
<p>the <code>let</code> is probably doing no favors here, you should just <code>open real</code> instead if you find it too verbose</p>



<a name="270496211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270496211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270496211">(Feb 03 2022 at 03:36)</a>:</h4>
<p>Is there a more direct way to prove <code>foo</code> here?</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.irrational</span>
<span class="kn">import</span> <span class="n">analysis.special_functions.pow</span>

<span class="kn">open</span> <span class="n">real</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sqrt</span> <span class="n">x</span> <span class="bp">^</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert_to</span> <span class="n">sqrt</span> <span class="n">x</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">transitivity</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">real.rpow_nat_cast</span><span class="o">,</span>
  <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">algebra_others_exirrpowirrrat</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">irrational</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">irrational</span> <span class="n">b</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">irrational</span> <span class="o">(</span><span class="n">a</span><span class="bp">^</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">irrational</span> <span class="o">(</span><span class="n">sqrt</span> <span class="mi">2</span><span class="bp">^</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">h'</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">irrational</span> <span class="o">((</span><span class="n">sqrt</span> <span class="mi">2</span><span class="bp">^</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">)</span><span class="bp">^</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">real.rpow_mul</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">foo</span><span class="o">,</span> <span class="n">irrational_iff_ne_rational</span><span class="o">],</span>
      <span class="n">use</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
      <span class="n">norm_num</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">real.sqrt_nonneg</span> <span class="mi">2</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">exact</span> <span class="o">⟨(</span><span class="n">sqrt</span> <span class="mi">2</span><span class="bp">^</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">),</span> <span class="n">sqrt</span> <span class="mi">2</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">irrational_sqrt_two</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">,</span> <span class="n">sqrt</span> <span class="mi">2</span><span class="o">,</span> <span class="n">irrational_sqrt_two</span><span class="o">,</span> <span class="n">irrational_sqrt_two</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span> <span class="o">}</span>
<span class="kd">end</span>
<span class="bp">````</span>
</code></pre></div>
</div></div>



<a name="270496530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270496530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270496530">(Feb 03 2022 at 03:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270496211">said</a>:</p>
<blockquote>
<p>Is there a more direct way to prove <code>foo</code> here?</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.irrational</span>
<span class="kn">import</span> <span class="n">analysis.special_functions.pow</span>

<span class="kn">open</span> <span class="n">real</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sqrt</span> <span class="n">x</span> <span class="bp">^</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert_to</span> <span class="n">sqrt</span> <span class="n">x</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">transitivity</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">real.rpow_nat_cast</span><span class="o">,</span>
  <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">algebra_others_exirrpowirrrat</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">irrational</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">irrational</span> <span class="n">b</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">irrational</span> <span class="o">(</span><span class="n">a</span><span class="bp">^</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">irrational</span> <span class="o">(</span><span class="n">sqrt</span> <span class="mi">2</span><span class="bp">^</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">h'</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">irrational</span> <span class="o">((</span><span class="n">sqrt</span> <span class="mi">2</span><span class="bp">^</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">)</span><span class="bp">^</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">real.rpow_mul</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">foo</span><span class="o">,</span> <span class="n">irrational_iff_ne_rational</span><span class="o">],</span>
      <span class="n">use</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
      <span class="n">norm_num</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">real.sqrt_nonneg</span> <span class="mi">2</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">exact</span> <span class="o">⟨(</span><span class="n">sqrt</span> <span class="mi">2</span><span class="bp">^</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">),</span> <span class="n">sqrt</span> <span class="mi">2</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">irrational_sqrt_two</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">,</span> <span class="n">sqrt</span> <span class="mi">2</span><span class="o">,</span> <span class="n">irrational_sqrt_two</span><span class="o">,</span> <span class="n">irrational_sqrt_two</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p>What if we first simplify the stack of powers to 2, then use </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">int.not_irrational</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">¬</span><span class="n">irrational</span> <span class="bp">↑</span><span class="n">m</span>
</code></pre></div>



<a name="270497330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270497330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270497330">(Feb 03 2022 at 03:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270495123">said</a>:</p>
<blockquote>
<p>you should rewrite <code>((sqrt_2^sqrt_2)^sqrt_2) = sqrt_2^(sqrt_2*sqrt_2)</code> and then use the theorem that says <code>sqrt_2*sqrt_2 = 2</code></p>
</blockquote>
<p>Do you know the lame of the lemma  for that first part, I've been having trouble finding it</p>



<a name="270497569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270497569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270497569">(Feb 03 2022 at 04:00)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/real.rpow_mul">docs#real.rpow_mul</a></p>



<a name="270498583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270498583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270498583">(Feb 03 2022 at 04:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270497569">said</a>:</p>
<blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/real.rpow_mul">docs#real.rpow_mul</a></p>
</blockquote>
<p>I'm working on that now:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">basic</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="mi">2</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
 <span class="n">norm_num</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">z</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">irrational</span> <span class="o">((</span><span class="n">sqrt</span> <span class="mi">2</span><span class="bp">^</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">)</span><span class="bp">^</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">rw</span> <span class="bp">←</span> <span class="o">(</span><span class="n">rpow_mul</span> <span class="o">(</span><span class="n">sqrt_nonneg</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">))</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">rw</span> <span class="bp">←</span> <span class="o">(</span><span class="n">sqrt_mul</span> <span class="n">basic</span> <span class="mi">2</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">sqrt_mul_self</span> <span class="n">basic</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">sq_sqrt</span> <span class="n">basic</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>that last rw tactic doesn't seem to work though, and I can't figure out why, it gives me this goal state:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kd">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="n">sqrt</span> <span class="mi">2</span> <span class="bp">^</span> <span class="mi">2</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">irrational</span> <span class="o">(</span><span class="n">sqrt</span> <span class="mi">2</span> <span class="bp">^</span> <span class="mi">2</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="n">false</span>
</code></pre></div>



<a name="270498680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270498680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270498680">(Feb 03 2022 at 04:19)</a>:</h4>
<p>That's where the <code>foo</code> lemma I was asking about came from -- I'd run into the same issue.</p>



<a name="270498697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270498697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270498697">(Feb 03 2022 at 04:19)</a>:</h4>
<p>Ohh ok.</p>



<a name="270498703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270498703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270498703">(Feb 03 2022 at 04:19)</a>:</h4>
<p>The exponent needs to be a nat for that lemma, but it's a real</p>



<a name="270498710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270498710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270498710">(Feb 03 2022 at 04:19)</a>:</h4>
<p>Can't we make it into one?</p>



<a name="270498778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270498778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270498778">(Feb 03 2022 at 04:20)</a>:</h4>
<p>That's what I did in the <code>foo</code> lemma, and my question is whether there's a simpler way to do this.</p>



<a name="270498822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270498822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270498822">(Feb 03 2022 at 04:21)</a>:</h4>
<p>It's likely I just don't know my way around Lean's reals, but maybe it's a random oversight that there's no direct lemma yet.</p>



<a name="270498902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270498902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270498902">(Feb 03 2022 at 04:22)</a>:</h4>
<p>I get your reasoning more now</p>



<a name="270500184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270500184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270500184">(Feb 03 2022 at 04:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270498703">said</a>:</p>
<blockquote>
<p>The exponent needs to be a nat for that lemma, but it's a real</p>
</blockquote>
<p>I learned how to do this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">basic_2</span> <span class="o">:</span> <span class="o">(</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">)</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">sqrt</span> <span class="mi">2</span><span class="o">)</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">norm_cast</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>after that, we can use the lemma. It feels hacky but it does work.</p>



<a name="270517136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270517136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270517136">(Feb 03 2022 at 08:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270496211">said</a>:</p>
<blockquote>
<p>Is there a more direct way to prove <code>foo</code> here?</p>
</blockquote>
<p>This also works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sqrt</span> <span class="n">x</span> <span class="bp">^</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">sqrt</span> <span class="n">x</span> <span class="bp">^</span> <span class="o">((</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">real.rpow_nat_cast</span><span class="o">,</span> <span class="n">sq_sqrt</span> <span class="n">h</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">exact_mod_cast</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="270549140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270549140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hossam Karim <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270549140">(Feb 03 2022 at 13:34)</a>:</h4>
<p>I am learning lean and trying to prove the associativity of <code>++</code> on <code>List</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">xs</span> <span class="n">ys</span> <span class="n">zs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">a</span><span class="o">):</span>
  <span class="n">xs</span> <span class="bp">++</span> <span class="o">(</span><span class="n">ys</span> <span class="bp">++</span> <span class="n">zs</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">xs</span> <span class="bp">++</span> <span class="n">ys</span><span class="o">)</span> <span class="bp">++</span> <span class="n">zs</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">xs</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">h</span> <span class="n">t</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">ih</span><span class="o">]</span>
</code></pre></div>
<p>Now lean complains that it cannot do the rewrite:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">tactic</span> <span class="bp">'</span><span class="n">rewrite'</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kd">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="n">t</span> <span class="bp">++</span> <span class="o">(</span><span class="n">ys</span> <span class="bp">++</span> <span class="n">zs</span><span class="o">)</span>
<span class="n">case</span> <span class="n">cons</span>
<span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="n">u.246</span>
<span class="n">ys</span> <span class="n">zs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">a</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">a</span>
<span class="n">t</span> <span class="o">:</span> <span class="n">List</span> <span class="n">a</span>
<span class="n">ih</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">++</span> <span class="o">(</span><span class="n">ys</span> <span class="bp">++</span> <span class="n">zs</span><span class="o">)</span> <span class="bp">=</span> <span class="n">t</span> <span class="bp">++</span> <span class="n">ys</span> <span class="bp">++</span> <span class="n">zs</span>
<span class="bp">⊢</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="bp">++</span> <span class="o">(</span><span class="n">ys</span> <span class="bp">++</span> <span class="n">zs</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="bp">++</span> <span class="n">ys</span> <span class="bp">++</span> <span class="n">zs</span>
</code></pre></div>
<p>Although my understanding is that <code>t ++ (ys ++ zs) </code> can be rewritten in the goal. Am I missing something here?</p>



<a name="270549909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270549909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270549909">(Feb 03 2022 at 13:40)</a>:</h4>
<p>I think the brackets aren't where you think they are, if you hover over the info-view in vscode the highlighting will show that the goal is really like <code>⊢ (h :: t) ++ (ys ++ zs) = (h :: t) ++ ys ++ zs</code></p>



<a name="270550079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270550079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270550079">(Feb 03 2022 at 13:41)</a>:</h4>
<p>The lemma <code>List.cons_append</code> will help you finish the proof from here though</p>



<a name="270550175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270550175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hossam Karim <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270550175">(Feb 03 2022 at 13:42)</a>:</h4>
<p>Understood. Thanks a lot <span class="user-mention" data-user-id="127136">@Alex J. Best</span></p>



<a name="270602911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270602911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270602911">(Feb 03 2022 at 19:19)</a>:</h4>
<p>I'm working through this <code>calc</code> block, so far everything seems good aside from the two <code>ring_nf</code> blocks which are complaining to me:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">induction_sumkexp3eqsumksq</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">k</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">symmetry</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">j</span> <span class="n">IH</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="k">calc</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j.succ</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="o">((</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="bp">+</span> <span class="n">j</span> <span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">finset.sum_range_succ</span>  <span class="c1">-- rewrite summation</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="bp">*</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">add_sq</span> <span class="n">_</span> <span class="n">_</span> <span class="c1">-- (a + b)^2</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">finset.sum_range_id</span> <span class="n">j</span> <span class="c1">-- sum = j*(j-1)/2</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="bp">^</span><span class="mi">3</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">IH</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="bp">^</span><span class="mi">3</span><span class="o">)</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">ring_nf</span> <span class="c1">-- 2 * ( ... )/2 = ( ... )</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="bp">^</span><span class="mi">3</span><span class="o">)</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">3</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">ring_nf</span> <span class="c1">-- (j +1)^2 (j+1) = (j+1)^3</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j.succ</span><span class="o">,</span> <span class="n">k</span><span class="bp">^</span><span class="mi">3</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">finset.sum_range_succ</span><span class="o">,</span> <span class="c1">-- by the definition of summation</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>any tips on which tactics I should be using there?</p>



<a name="270603164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270603164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270603164">(Feb 03 2022 at 19:21)</a>:</h4>
<p>I simply get "tactic failed, there are unsolved goals": <br>
<a href="/user_uploads/3121/TEgb6pyo6nWCT-UTds9T-xoB/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/TEgb6pyo6nWCT-UTds9T-xoB/image.png" title="image.png"><img src="/user_uploads/3121/TEgb6pyo6nWCT-UTds9T-xoB/image.png"></a></div>



<a name="270604099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270604099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270604099">(Feb 03 2022 at 19:28)</a>:</h4>
<p>The problem with this step is that it actually requires an argument, as this is nat division cancellation requires that <code>j*(j-1)</code> is even, which of course it is, but even that requires a short argument, I doubt there is any tactic in mathlib that will just do this step. I recommend you break this step out as a separate lemma</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">aux</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="270605018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270605018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270605018">(Feb 03 2022 at 19:34)</a>:</h4>
<p>So my aim with this new lemma would be to use this right? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">div_mul_cancel</span> <span class="o">{</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">}</span> <span class="o">[</span><span class="n">group_with_zero</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">a</span> <span class="bp">/</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span>
</code></pre></div>



<a name="270605290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270605290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270605290">(Feb 03 2022 at 19:36)</a>:</h4>
<p>Unfortunately not, nat division is not group with zero division, you probably need <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.mul_div_cancel'">docs#nat.mul_div_cancel'</a></p>



<a name="270605409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270605409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270605409">(Feb 03 2022 at 19:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270604099">said</a>:</p>
<blockquote>
<p>The problem with this step is that it actually requires an argument, as this is nat division cancellation requires that <code>j*(j-1)</code> is even, which of course it is, but even that requires a short argument, I doubt there is any tactic in mathlib that will just do this step. I recommend you break this step out as a separate lemma</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">aux</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Oh and your reasoning here is that division is defined as this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="kd">def</span> <span class="n">nat.div</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">ℕ</span>
</code></pre></div>
<p>so you're not allowed to divide the natural 1 by the natural 2, because that would create something that's not a natural right?</p>



<a name="270605545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270605545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270605545">(Feb 03 2022 at 19:38)</a>:</h4>
<p>Note that this is the cost of totalizing <code>/</code>, if <code>/</code> took a proof of divisibility as an argument, then the proof would be contained in the statement of <code>finset.sum_range_succ</code> and then reasoning like the kind you are doing here becomes automatable by a tactic.</p>



<a name="270606155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270606155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270606155">(Feb 03 2022 at 19:42)</a>:</h4>
<p>Yes <span class="user-mention" data-user-id="367659">@ccn</span>, lean gets around this by definition nat division to be the floor of the actual value, and in the cases where you have divisibility you have to often manually supply this fact</p>



<a name="270606378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270606378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270606378">(Feb 03 2022 at 19:44)</a>:</h4>
<p>I see</p>



<a name="270606467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270606467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270606467">(Feb 03 2022 at 19:44)</a>:</h4>
<p>This would be the theorem I'm looking for right? (<a href="https://leanprover-community.github.io/mathlib_docs/find/nat.even_succ">docs#nat.even_succ</a>)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="kd">theorem</span> <span class="n">nat.even_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span>
<span class="n">even</span> <span class="n">n.succ</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">even</span> <span class="n">n</span>
</code></pre></div>
<p>or is there one that's even closer?</p>



<a name="270606510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270606510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270606510">(Feb 03 2022 at 19:45)</a>:</h4>
<p>In general its best to avoid introducing division as much as possible, it looks like in this case using <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_range_id_mul_two">docs#finset.sum_range_id_mul_two</a> instead of finset.sum_range_id a few lines above would save you a lot of work</p>



<a name="270607493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270607493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270607493">(Feb 03 2022 at 19:51)</a>:</h4>
<p>Thanks Alex I always learn a lot from you</p>



<a name="270607642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270607642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270607642">(Feb 03 2022 at 19:52)</a>:</h4>
<p>One last thing, the calc block is still having an issue with the last <code>ring_nf</code> here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="k">calc</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j.succ</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="o">((</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="bp">+</span> <span class="n">j</span> <span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">finset.sum_range_succ</span>  <span class="c1">-- rewrite summation</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="bp">*</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">add_sq</span> <span class="n">_</span> <span class="n">_</span> <span class="c1">-- (a + b)^2</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span>  <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">ring</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="o">(</span><span class="n">j</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="bp">*</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">finset.sum_range_id_mul_two</span> <span class="n">j</span> <span class="c1">-- sum = j*(j-1)/2</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="bp">^</span><span class="mi">3</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">j</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="bp">*</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">IH</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="bp">^</span><span class="mi">3</span><span class="o">)</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">j</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">ring_nf</span> <span class="c1">-- 2 * ( ... )/2 = ( ... )</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="bp">^</span><span class="mi">3</span><span class="o">)</span> <span class="bp">+</span> <span class="n">j</span><span class="bp">^</span><span class="mi">3</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">ring_nf</span> <span class="c1">-- (j +1)^2 (j+1) = (j+1)^3</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">j.succ</span><span class="o">,</span> <span class="n">k</span><span class="bp">^</span><span class="mi">3</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">finset.sum_range_succ</span><span class="o">,</span> <span class="c1">-- by the definition of summation</span>
</code></pre></div>
<p>Do you know why it can't do this one?</p>



<a name="270607791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270607791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270607791">(Feb 03 2022 at 19:53)</a>:</h4>
<p>Wouldn't all it have to do <code>j^2 * (j - 1) + j^2 = j^2 *( j - 1 + 1) = j^2 * j = j^3</code>, can it not handle that?</p>



<a name="270608431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270608431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270608431">(Feb 03 2022 at 19:57)</a>:</h4>
<p>This is due to natural number subtraction being a bit tricky (similar to division) the possibility that <code>j = 0</code> in which case <code>j-1</code> is also 0, but this is not usual in rings.<br>
Splitting on those cases seems to work though with thisa instead</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">by</span> <span class="n">cases</span> <span class="n">j</span><span class="bp">;</span> <span class="n">norm_num</span><span class="bp">;</span> <span class="n">ring_nf</span>
</code></pre></div>



<a name="270609408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270609408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270609408">(Feb 03 2022 at 20:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270608431">said</a>:</p>
<blockquote>
<p>This is due to natural number subtraction being a bit tricky (similar to division) the possibility that <code>j = 0</code> in which case <code>j-1</code> is also 0, but this is not usual in rings.<br>
Splitting on those cases seems to work though with thisa instead</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">by</span> <span class="n">cases</span> <span class="n">j</span><span class="bp">;</span> <span class="n">norm_num</span><span class="bp">;</span> <span class="n">ring_nf</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I see. When you do that type of syntax does that mean in case one, norm_num can solve it and in the second case ring_nf can solve it?</p>



<a name="270609896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270609896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270609896">(Feb 03 2022 at 20:07)</a>:</h4>
<p>It just means try <code>norm_num</code> on all goals, then try <code>ring_nf</code> on all remaining goals. It has the same effect in the end as what you said except the second goal gets <code>norm_num</code> then <code>ring_nf</code> applied</p>



<a name="270610017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270610017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270610017">(Feb 03 2022 at 20:08)</a>:</h4>
<p>The syntax for what you said is <code>by cases j; [norm_num, ring_nf]</code>, and in fact it does work in this case too</p>



<a name="270610626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270610626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270610626">(Feb 03 2022 at 20:13)</a>:</h4>
<p>I think that also makes sense because in the first case it's just a whole bunch of zero's being multiplied and the second case there's at most one zero there right?</p>
<p>Also was this causing a problem (having both j and j-1 as zero) because a ring can't have two zeros'?</p>



<a name="270611083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270611083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270611083">(Feb 03 2022 at 20:17)</a>:</h4>
<p>The lemma <code>m - n + n = m</code> is always true in <code>ring</code>s and is true in nat when <code>m &gt;= n</code>. But as nat is not a ring (only a semiring, for this reason) <code>ring_nf</code> doesn't know it can apply that lemma (and even if it did it would have to find a way to prove the condition. By doing cases we get one case where everything is zero and similifies and another one where the subtraction simplifies with succ and dissapears</p>



<a name="270782481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270782481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270782481">(Feb 04 2022 at 22:36)</a>:</h4>
<p>So I'm looking to prove this theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">induction_pprime_pdvdapowpma</span>
  <span class="o">(</span><span class="n">p</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">nat.prime</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p</span> <span class="bp">∣</span> <span class="o">(</span><span class="n">a</span><span class="bp">^</span><span class="n">p</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I've come up with the proof on paper, which is first change what we want to prove to <code>a^p - a ≡ 0 (mod p)</code> (since it's equivalent)  then note that from fermats little theorem we have <code>a^(p-1) ≡ 1 (mod p)</code> and then to re-write <code>a^p = a^(p-1) * a</code>, use that fact to go from <code>a^p - a ≡ 0 (mod p)</code> to <code>a^(p-1) * a - a ≡ 0 (mod p)</code> to <code>1 * a - a ≡ 0 (mod p)</code> to <code>0 ≡ 0 (mod p)</code> which is easy to prove.</p>
<p>I've done some research on the main theorem (fermats little theorem) and found this theorem </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">section</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">group_with_zero</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">pow_card_sub_one_eq_one</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">^</span> <span class="o">(</span><span class="n">q</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">calc</span> <span class="n">a</span> <span class="bp">^</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">K</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">units.mk0</span> <span class="n">a</span> <span class="n">ha</span> <span class="bp">^</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">K</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">K</span><span class="bp">ˣ</span><span class="o">)</span> <span class="o">:</span>
    <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">units.coe_pow</span><span class="o">,</span> <span class="n">units.coe_mk0</span><span class="o">]</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">classical</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">fintype.card_units</span><span class="o">,</span> <span class="n">pow_card_eq_one</span><span class="o">],</span> <span class="n">refl</span>
</code></pre></div>
<p>(Note I don't think this is the same as the one you find on mathlib today: <a href="https://leanprover-community.github.io/mathlib_docs/field_theory/finite/basic.html#zmod.pow_card_sub_one_eq_one">https://leanprover-community.github.io/mathlib_docs/field_theory/finite/basic.html#zmod.pow_card_sub_one_eq_one</a> because the project I'm working on uses a different version).</p>
<p>I'm a little confused on how to call this theorem, but it would be great if someone could help me use it to prove <code>a^(p-1) = 1</code> mod p .</p>
<p>Thanks</p>



<a name="270791117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270791117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270791117">(Feb 05 2022 at 00:21)</a>:</h4>
<p><span class="user-mention" data-user-id="367659">@ccn</span> re your earlier question: I find these much easier if you just work over a field instead:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">theorem</span> <span class="n">induction_sumkexp3eqsumksq</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">k</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">))</span><span class="bp">^</span><span class="mi">2</span><span class="o">,</span>
    <span class="n">assumption_mod_cast</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">))</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">finset.sum_range_succ</span><span class="o">,</span> <span class="n">hd</span><span class="o">],</span>
      <span class="n">ring</span> <span class="o">}</span>
  <span class="o">},</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span> <span class="n">clear</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">j</span> <span class="n">IH</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">finset.sum_range_succ</span><span class="o">,</span> <span class="n">IH</span><span class="o">],</span>
    <span class="n">ring</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="270791218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270791218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270791218">(Feb 05 2022 at 00:23)</a>:</h4>
<p>Thanks for the new view on it! It looks cleaner</p>



<a name="270914619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270914619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270914619">(Feb 06 2022 at 22:06)</a>:</h4>
<p>I've decided I'd like to try solving some topology exercise in lean:</p>
<p>I'm going to start with this first question I've highlighted here,</p>
<p><a href="/user_uploads/3121/eAaLI-NUdlNrUF2Cow2A17H0/image.png">image.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/eAaLI-NUdlNrUF2Cow2A17H0/image.png" title="image.png"><img src="/user_uploads/3121/eAaLI-NUdlNrUF2Cow2A17H0/image.png"></a></div><p>I've been trying to understand the docs for topology and I got it up to this point:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.basic</span>

<span class="kd">theorem</span> <span class="n">open_set_for_each</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">topological_space</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">⊂</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">U</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">U</span> <span class="bp">⊂</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_open</span> <span class="n">X</span> <span class="n">U</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="kd">end</span>
</code></pre></div>
<p>In know there are some things that are rough with this theorem so I'm hoping I can get some tips to fix it up (since it doesn't even compile), thanks!</p>



<a name="270914653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270914653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270914653">(Feb 06 2022 at 22:07)</a>:</h4>
<p>Maybe you want to read the error message and deal with it. What is it?</p>



<a name="270914759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270914759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270914759">(Feb 06 2022 at 22:09)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">topological_spaces.lean</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span><span class="mi">77</span>
<span class="n">don't</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="n">context</span><span class="o">:</span>
<span class="n">X</span> <span class="o">:</span> <span class="bp">⁇</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="bp">⁇</span> <span class="bp">⊂</span> <span class="n">X</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="bp">⁇</span><span class="o">,</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="bp">⁇</span>
<span class="bp">⊢</span> <span class="kt">Type</span> <span class="bp">?</span>
<span class="n">topological_spaces.lean</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span><span class="mi">94</span>
<span class="n">unknown</span> <span class="n">identifier</span> <span class="sc">'A'</span>
<span class="n">topological_spaces.lean</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span><span class="mi">109</span>
<span class="n">unknown</span> <span class="n">identifier</span> <span class="sc">'U'</span>
</code></pre></div>



<a name="270914769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270914769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270914769">(Feb 06 2022 at 22:09)</a>:</h4>
<p>When it says <code>unable to synthesize placeholder</code> what exactly does that mean?</p>



<a name="270914816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270914816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270914816">(Feb 06 2022 at 22:10)</a>:</h4>
<p>So Lean is saying "what the heck is this A that you just randomly started talking about without ever mentioning its type?"</p>



<a name="270914830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270914830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270914830">(Feb 06 2022 at 22:10)</a>:</h4>
<p>and judging by the tactic state it doesn't know what X is either</p>



<a name="270914846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270914846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270914846">(Feb 06 2022 at 22:11)</a>:</h4>
<p>Why don't you take a look at the topology workshop I did in my formalising mathematics course last year?</p>



<a name="270914917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270914917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270914917">(Feb 06 2022 at 22:12)</a>:</h4>
<p>Ok, I'll try to understand the docs a little more <code>The main definition is the type class topological space α which endows a type α with a topology.</code> So pretty much I just want <code>X</code> to be some arbitrary set, and then the topology is a collection of subsets of <code>X</code> with those properties</p>



<a name="270914925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270914925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270914925">(Feb 06 2022 at 22:13)</a>:</h4>
<p>So my <code>type a</code> should be <code>X</code> right?</p>



<a name="270914931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270914931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270914931">(Feb 06 2022 at 22:13)</a>:</h4>
<p>No, you want X to be a type. Lean does type theory.</p>



<a name="270914946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270914946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270914946">(Feb 06 2022 at 22:13)</a>:</h4>
<p>Ah right, no sets...</p>



<a name="270914998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270914998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270914998">(Feb 06 2022 at 22:14)</a>:</h4>
<p>There's how to do basic topology <a href="https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/master/src/week_4/Part_C_topology.lean">https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/master/src/week_4/Part_C_topology.lean</a></p>



<a name="270915027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270915027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270915027">(Feb 06 2022 at 22:15)</a>:</h4>
<p>and there's the blog post explaining what's going on in that Lean file <a href="https://xenaproject.wordpress.com/2021/02/10/formalising-mathematics-workshop-4/">https://xenaproject.wordpress.com/2021/02/10/formalising-mathematics-workshop-4/</a></p>



<a name="270915095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270915095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270915095">(Feb 06 2022 at 22:16)</a>:</h4>
<p>Ok, I will check those out right now. One thing I want to get out of the way first though, if I want to say <code>collection of subsets of X</code> in type theory, what would be the type of that?</p>



<a name="270915119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270915119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270915119">(Feb 06 2022 at 22:16)</a>:</h4>
<p><code>set (set X)</code></p>



<a name="270915138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270915138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270915138">(Feb 06 2022 at 22:17)</a>:</h4>
<p>Checkout the the definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/topological_space">docs#topological_space</a></p>



<a name="270920541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270920541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270920541">(Feb 07 2022 at 00:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/270914998">said</a>:</p>
<blockquote>
<p>There's how to do basic topology <a href="https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/master/src/week_4/Part_C_topology.lean">https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/master/src/week_4/Part_C_topology.lean</a></p>
</blockquote>
<p>I started working through this repo a little bit, so now I have a new question, at one point in the groups file, we had defined the following</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">mul_one</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">mul_eq_of_eq_inv_mul</span><span class="o">,</span>
  <span class="n">symmetry</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mul_left_inv</span> <span class="n">a</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">mul_right_inv</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">mul_eq_of_eq_inv_mul</span><span class="o">,</span>
  <span class="n">symmetry</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mul_one</span> <span class="n">a</span><span class="bp">⁻¹</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">one_mul</span> <span class="n">mul_left_inv</span> <span class="n">mul_assoc</span>
</code></pre></div>
<p>Then later in the file you supply this proof</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">inv_mul_cancel_left</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="c1">-- the simplifier wouldn't do it that way</span>
                  <span class="c1">-- so we have to do it manually</span>
  <span class="n">simp</span><span class="o">,</span> <span class="c1">-- simplifier takes it from here,</span>
        <span class="c1">-- rewriting a⁻¹ * a to 1 and then 1 * b to b</span>
<span class="kd">end</span>
</code></pre></div>
<p>The simplifier can't do this because when it has lemmas of the form <code>A = B</code> then it is only allowed to replace A's with B's, so with <code>mul_assoc : ∀ (a b c : G), a * b * c = a * (b * c)</code><br>
it couldn't have helped us in that lemma due to this reason, so that's why we need the initial rewrite? If we had the other version of <code>mul_assoc</code> where LHS is swapped with RHS it would be a problem because the simplifier would get caught in a loop right?</p>



<a name="270941221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/270941221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#270941221">(Feb 07 2022 at 07:26)</a>:</h4>
<p>Right -- with these proofs at the beginning of the theory you are often rewriting in both directions and you can't have both A=B and B=A as simp lemmas</p>



<a name="271031179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271031179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271031179">(Feb 07 2022 at 19:39)</a>:</h4>
<p>What is the section of the docs which has the definitions for infinite summations and products?</p>



<a name="271032096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271032096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271032096">(Feb 07 2022 at 19:46)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/tsum">docs#tsum</a> (found it by looking at <a href="https://leanprover-community.github.io/undergrad.html">https://leanprover-community.github.io/undergrad.html</a>)</p>



<a name="271034544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271034544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271034544">(Feb 07 2022 at 20:04)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/tprod">docs#tprod</a></p>



<a name="271034585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271034585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271034585">(Feb 07 2022 at 20:04)</a>:</h4>
<p>Oh maybe it's this? <a href="https://leanprover-community.github.io/mathlib_docs/data/tprod.html#list.tprod">https://leanprover-community.github.io/mathlib_docs/data/tprod.html#list.tprod</a></p>



<a name="271034598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271034598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271034598">(Feb 07 2022 at 20:04)</a>:</h4>
<p>unlucky</p>



<a name="271034646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271034646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271034646">(Feb 07 2022 at 20:04)</a>:</h4>
<p>I'm just trying to write this: <a href="/user_uploads/3121/l7ldmOGUZVTx685mXJrwm6cH/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/l7ldmOGUZVTx685mXJrwm6cH/image.png" title="image.png"><img src="/user_uploads/3121/l7ldmOGUZVTx685mXJrwm6cH/image.png"></a></div>



<a name="271034824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271034824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271034824">(Feb 07 2022 at 20:06)</a>:</h4>
<p>right, <code>tprod</code> definitely seems like a thing that should exist but I don't know if it does</p>



<a name="271034960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271034960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271034960">(Feb 07 2022 at 20:07)</a>:</h4>
<p>Oops</p>



<a name="271035074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271035074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271035074">(Feb 07 2022 at 20:08)</a>:</h4>
<p>Take logs, use tsum, and then exp? <span aria-label="blush" class="emoji emoji-1f60a" role="img" title="blush">:blush:</span></p>



<a name="271035205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271035205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271035205">(Feb 07 2022 at 20:09)</a>:</h4>
<p>Presumably if one of the terms in a general product is 0 then the classical convention that the product "diverges to zero" can be replaced with lean's convention that it converges to a junk value, namely zero.</p>



<a name="271189668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271189668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271189668">(Feb 08 2022 at 20:56)</a>:</h4>
<p>I recall that in order to say that <code>a</code> is the largest number satisfying a proposition <code>P</code> we could write <code>∀ x, a &lt; x → ¬ P(x)</code> Is that the way we would write it in lean as well, or is there a faster way?</p>



<a name="271190049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271190049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271190049">(Feb 08 2022 at 20:59)</a>:</h4>
<p>What about <a href="https://leanprover-community.github.io/mathlib_docs/find/is_greatest">docs#is_greatest</a>?</p>



<a name="271191567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271191567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271191567">(Feb 08 2022 at 21:10)</a>:</h4>
<p><span class="user-mention" data-user-id="367659">@ccn</span> in your formula, there is a missing assumption: you presumably want ˋP aˋ to also hold!  (Note that ˋis_greatestˋ includes this.)<br>
[My backticks appear to have broken.]</p>



<a name="271195319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271195319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271195319">(Feb 08 2022 at 21:43)</a>:</h4>
<p>I haven't worked with sets much in lean, could someone show me how we can use <code>is_greatest</code> to prove something simple like a theorem which proves that <code>3</code> is the largest odd integer less than <code>5</code> ?</p>



<a name="271195499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271195499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271195499">(Feb 08 2022 at 21:44)</a>:</h4>
<p>does this work?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">is_greatest</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">|</span> <span class="n">odd</span> <span class="n">x</span> <span class="bp">/\</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">5</span><span class="o">}</span> <span class="mi">3</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
</code></pre></div>



<a name="271195605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271195605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271195605">(Feb 08 2022 at 21:45)</a>:</h4>
<p>Yeah it does make sense, thanks I see how to use it now!</p>



<a name="271201921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271201921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271201921">(Feb 08 2022 at 22:37)</a>:</h4>
<p>I want to make a statement for <code>a_1, ... ,a_n</code> which are real numbers where <code>∑ k in finset.range n, a_k = ...</code> what's the best way to go about that?</p>



<a name="271201951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271201951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271201951">(Feb 08 2022 at 22:38)</a>:</h4>
<p>So far I've only had a finite number of parameters to my theorems/functions</p>



<a name="271211477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271211477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271211477">(Feb 09 2022 at 00:05)</a>:</h4>
<p>Where did you get your various a_'s from? There's probably a better way to phrase what you want than just having 1 to n.</p>



<a name="271219075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271219075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271219075">(Feb 09 2022 at 01:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/271211477">said</a>:</p>
<blockquote>
<p>Where did you get your various a_'s from? There's probably a better way to phrase what you want than just having 1 to n.</p>
</blockquote>
<p>Trying to write this out: <a href="/user_uploads/3121/WkBQ9_vJFVAAT5HVokrMFqv1/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/WkBQ9_vJFVAAT5HVokrMFqv1/image.png" title="image.png"><img src="/user_uploads/3121/WkBQ9_vJFVAAT5HVokrMFqv1/image.png"></a></div>



<a name="271219184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271219184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271219184">(Feb 09 2022 at 01:34)</a>:</h4>
<p>I guess the lean way to state that is with an indexing set <code>{ι : Type*} [fintype ι]</code> and two functions <code>a b : ι → ℝ</code> (E: thanks Kyle!)</p>



<a name="271219525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271219525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271219525">(Feb 09 2022 at 01:40)</a>:</h4>
<p>(small typo: it should be <code>[fintype ι]</code>)</p>



<a name="271219811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271219811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271219811">(Feb 09 2022 at 01:44)</a>:</h4>
<p>I tried that out, but I'm getting still some issue: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">theorem</span> <span class="n">cauchy</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">l</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="n">i</span><span class="o">)</span> <span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">≤</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">a</span> <span class="n">i</span><span class="o">)</span> <span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">b</span> <span class="n">i</span><span class="o">)</span> <span class="bp">^</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div>



<a name="271219823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271219823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271219823">(Feb 09 2022 at 01:44)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">a</span> <span class="n">i</span>
<span class="n">term</span>
  <span class="n">i</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">ℕ</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">l</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span>
</code></pre></div>



<a name="271219879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271219879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271219879">(Feb 09 2022 at 01:45)</a>:</h4>
<p>So the finset.range thing is wrong because it 's producing a  natural number?</p>



<a name="271219909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271219909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271219909">(Feb 09 2022 at 01:46)</a>:</h4>
<p>It's like I need to produce n distinct indices</p>



<a name="271220122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271220122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271220122">(Feb 09 2022 at 01:48)</a>:</h4>
<p><code>Σ i :  ι, a i</code> (also I'm writing ι for iota instead of <code>l</code> but it doesn't matter ;b)</p>



<a name="271220145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271220145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271220145">(Feb 09 2022 at 01:48)</a>:</h4>
<p>you're trying to plug in a nat to a function that doesn't take nats</p>



<a name="271334841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271334841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271334841">(Feb 09 2022 at 19:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/271220122">said</a>:</p>
<blockquote>
<p><code>Σ i :  ι, a i</code> (also I'm writing ι for iota instead of <code>l</code> but it doesn't matter ;b)</p>
</blockquote>
<p>Ah ok, I understand it now. And this represents the same thing as the cauchy inequality because the <code>l</code> is a <code>fintype</code> so it can be labelled 1 to n, for some n ?</p>



<a name="271341128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271341128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271341128">(Feb 09 2022 at 20:16)</a>:</h4>
<p>Yes, but also you never need to. On paper, we think of sums as an iterative process. We take the first element, add the second, the third...</p>



<a name="271341279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271341279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271341279">(Feb 09 2022 at 20:18)</a>:</h4>
<p>This is not at all what's done in mathlib. Instead, we sum in all orders at once, and commutativity of addition tells us that we always ended up with the same result.</p>



<a name="271341351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271341351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271341351">(Feb 09 2022 at 20:18)</a>:</h4>
<p>So we can get from "sum of elements of a list" to "sum of elements of a set".</p>



<a name="271341447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271341447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271341447">(Feb 09 2022 at 20:20)</a>:</h4>
<p>In practice, the VM chooses an arbitrary order to do the calculation, but that's not so important to the <em>concept</em>.</p>



<a name="271375590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271375590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271375590">(Feb 10 2022 at 01:42)</a>:</h4>
<p>If I have a polynomial like <code>(x^2  + 1) * (x^2 + 3) = x^4 + 4^2 + 3</code> (but assume I was just given <code>x^4 + 4^2 + 3</code>),  I want to talk about the product of all the complex roots of that polynomial (so in that case <code>+-i and  +-sqrt(3)*i</code>), is there a way to get this product in general from a polynomail using lean?</p>



<a name="271376273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271376273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271376273">(Feb 10 2022 at 01:53)</a>:</h4>
<p>I found this which gives me the roots: <a href="https://leanprover-community.github.io/mathlib_docs_demo/data/polynomial/ring_division.html#polynomial.roots">https://leanprover-community.github.io/mathlib_docs_demo/data/polynomial/ring_division.html#polynomial.roots</a></p>



<a name="271376355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271376355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271376355">(Feb 10 2022 at 01:54)</a>:</h4>
<p>Now I need to somehow filter out the complex ones and multiply them all together...</p>



<a name="271376490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271376490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271376490">(Feb 10 2022 at 01:56)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.prod">docs#multiset.prod</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.filter">docs#multiset.filter</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/complex.im">docs#complex.im</a> may be helpful</p>



<a name="271378265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271378265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271378265">(Feb 10 2022 at 02:22)</a>:</h4>
<p>So your suggestion is to check if <code>complex.im r</code> is non-zero (where r is the root is non-zero)  as a way to filter the roots right?</p>



<a name="271378332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271378332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271378332">(Feb 10 2022 at 02:23)</a>:</h4>
<p>Is it possible to define a polynomial like <code>x^4 + 4x^2 + 3</code> and then get it's roots in lean, or is it just on arbitrary polynomials?</p>



<a name="271378739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271378739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271378739">(Feb 10 2022 at 02:30)</a>:</h4>
<p>If it's a specific polynomial you can just factor it</p>



<a name="271378998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271378998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271378998">(Feb 10 2022 at 02:35)</a>:</h4>
<p>I think I found a way to do it, if I start with a specific polynomial <code>P</code>, than I can do <code>{x : ℂ | P(x) = 0}</code> to get the complex roots...</p>



<a name="271380092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271380092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271380092">(Feb 10 2022 at 02:56)</a>:</h4>
<p>For doing a <code>finset</code> prod, is this the cleanest way you know of <code>finset.prod {1, 2, 3} (λ x, x) = 6</code>?</p>



<a name="271382932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271382932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Landsberg <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271382932">(Feb 10 2022 at 03:46)</a>:</h4>
<p>(deleted)</p>



<a name="271382951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271382951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Landsberg <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271382951">(Feb 10 2022 at 03:47)</a>:</h4>
<p>(deleted)</p>



<a name="271412213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271412213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271412213">(Feb 10 2022 at 10:30)</a>:</h4>
<p>For small numbers, you can just let it directly compute:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">finset.prod</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">6</span> <span class="o">:=</span>
<span class="n">rfl</span>
</code></pre></div>



<a name="271412964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271412964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271412964">(Feb 10 2022 at 10:37)</a>:</h4>
<p>For larger computations, the <code>norm_num</code> tactic is usually faster. There are enough lemmas available here that you can just replace <code>rfl</code> with <code>by norm_num</code>.</p>



<a name="271413960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271413960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271413960">(Feb 10 2022 at 10:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/271378998">said</a>:</p>
<blockquote>
<p>I think I found a way to do it, if I start with a specific polynomial <code>P</code>, than I can do <code>{x : ℂ | P(x) = 0}</code> to get the complex roots...</p>
</blockquote>
<p>just remember that Lean will also give you the real roots in this too :) also you'll want to use a multiset if you want to count the roots with multiplicity</p>



<a name="271495375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271495375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271495375">(Feb 10 2022 at 21:15)</a>:</h4>
<p>Is there an easy way to talk about the sum of the digits of a number in lean?</p>



<a name="271496089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271496089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271496089">(Feb 10 2022 at 21:20)</a>:</h4>
<p>Use <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.to_digits">docs#nat.to_digits</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/list.sum">docs#list.sum</a></p>



<a name="271498916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271498916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271498916">(Feb 10 2022 at 21:42)</a>:</h4>
<p>Given a specific polynomial like <code>83x^4 + -3x^3 + 238x^2 + 99999x + 42</code> how do I get lean to talk about the cofficient on the term <code>x^2</code> ?</p>



<a name="271499277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271499277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271499277">(Feb 10 2022 at 21:43)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.coeff">docs#polynomial.coeff</a> ?</p>



<a name="271501681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271501681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271501681">(Feb 10 2022 at 22:02)</a>:</h4>
<p>Yeah that would work,  I'm trying to figure out how to define <code>83x^4 + -3x^3 + 238x^2 + 99999x + 42</code> as a specific polynomial so I can use the <code>.coeff</code> is that even possible?</p>



<a name="271501947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271501947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271501947">(Feb 10 2022 at 22:04)</a>:</h4>
<p>Yes of course. You can use <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.C">docs#polynomial.C</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.X">docs#polynomial.X</a></p>



<a name="271535287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271535287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reuben Dunn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271535287">(Feb 11 2022 at 06:04)</a>:</h4>
<p>Hello all! I'm new here, and I'm a beginner in this field. I was wondering if there's somewhere appropriate for me to post "stupid" questions about basic concepts in automated theorem proving and proof verification, which might not be about Lean specifically. I don't want to spam this community with topics that aren't relevant, but I'm not sure where the best place for that type of thing is.</p>



<a name="271535707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271535707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271535707">(Feb 11 2022 at 06:12)</a>:</h4>
<p><span class="user-mention" data-user-id="478207">@Reuben Dunn</span> You might want to try out the brand new <a href="https://proofassistants.stackexchange.com/">https://proofassistants.stackexchange.com/</a></p>



<a name="271535927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271535927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reuben Dunn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271535927">(Feb 11 2022 at 06:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/271535707">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="478207">Reuben Dunn</span> You might want to try out the brand new <a href="https://proofassistants.stackexchange.com/">https://proofassistants.stackexchange.com/</a></p>
</blockquote>
<p>Awesome, that looks right up my alley. I'm surprised because I tried searching for something like that recently and didn't find this! So it really is brand new.</p>



<a name="271536540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271536540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271536540">(Feb 11 2022 at 06:27)</a>:</h4>
<p>That's not to say that such questions are off topic here though</p>



<a name="271581051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271581051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271581051">(Feb 11 2022 at 14:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/271535707">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="478207">Reuben Dunn</span> You might want to try out the brand new <a href="https://proofassistants.stackexchange.com/">https://proofassistants.stackexchange.com/</a></p>
</blockquote>
<p>Is this appropriate for questions relating to proving specific statements and questions relating to mathlib?</p>



<a name="271585077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271585077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271585077">(Feb 11 2022 at 14:35)</a>:</h4>
<p>I don't know... I guess that's being worked out during the current beta phase...</p>



<a name="271585294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271585294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271585294">(Feb 11 2022 at 14:37)</a>:</h4>
<p>There's also this thing: <a href="https://proofassistants.meta.stackexchange.com/">https://proofassistants.meta.stackexchange.com/</a></p>



<a name="271585373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271585373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271585373">(Feb 11 2022 at 14:37)</a>:</h4>
<p>Which you can ask that question on if you want some assurance -- but yeah you could just ask it if you're more comfortable there and if someone closes it big deal.</p>



<a name="271600186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271600186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271600186">(Feb 11 2022 at 16:23)</a>:</h4>
<p>Whether or not it's appropriate for PASE, if it's a question specifically about mathlib you might get an answer more quickly by asking here on Zulip.</p>



<a name="271853711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271853711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271853711">(Feb 14 2022 at 16:45)</a>:</h4>
<p>I want to write a summation like <a href="/user_uploads/3121/oO3gJpTsWDUYeSbvTWIu6c-d/image.png">image.png</a> in lean, how can I do it?</p>
<div class="message_inline_image"><a href="/user_uploads/3121/oO3gJpTsWDUYeSbvTWIu6c-d/image.png" title="image.png"><img src="/user_uploads/3121/oO3gJpTsWDUYeSbvTWIu6c-d/image.png"></a></div>



<a name="271853944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271853944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271853944">(Feb 14 2022 at 16:47)</a>:</h4>
<p>You can use <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum">docs#finset.sum</a>, which has <code>\sum</code> notation if you add <code>open_locale big_operators</code></p>



<a name="271854023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271854023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271854023">(Feb 14 2022 at 16:47)</a>:</h4>
<p>I'm thinking I'll have to do a double summation like <code>∑ i in finset.range n, ∑ j in {k : ℕ | i + k = n}, ...</code> would that be best?</p>



<a name="271854097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271854097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271854097">(Feb 14 2022 at 16:48)</a>:</h4>
<p>So your example would look something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="k">then</span> <span class="n">some_function</span> <span class="n">i</span> <span class="n">j</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>



<a name="271854174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271854174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271854174">(Feb 14 2022 at 16:48)</a>:</h4>
<p>Are those first two little <code>n</code>'s supposed to be the <code>N</code> ?</p>



<a name="271854587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271854587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271854587">(Feb 14 2022 at 16:52)</a>:</h4>
<p>nevermind, I found <code>fin</code> in the docs now.</p>



<a name="271854627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271854627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271854627">(Feb 14 2022 at 16:52)</a>:</h4>
<p>thanks Anne!</p>



<a name="271854878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271854878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271854878">(Feb 14 2022 at 16:53)</a>:</h4>
<p>It would be neat if we could add <code>(h : i + j = n)</code> as indices to our sum, rather than having to use an if-then-else, but apparently <code>fintype</code> is defined only for <code>Type</code>s, not <code>Prop</code>s. :(</p>



<a name="271855608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271855608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271855608">(Feb 14 2022 at 16:58)</a>:</h4>
<p>That bound is known as <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.nat.antidiagonal">docs#finset.nat.antidiagonal</a></p>



<a name="271855657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271855657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271855657">(Feb 14 2022 at 16:58)</a>:</h4>
<p>I had to write the if statement like <code>if  (i + j : ℕ) = n then some_function i j else 0</code> (without the h)</p>



<a name="271856071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271856071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271856071">(Feb 14 2022 at 17:01)</a>:</h4>
<p>I had just been using it for</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">fib_eq_sum_choose_antidiagonal</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span>
  <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">fib</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">p</span> <span class="k">in</span> <span class="n">finset.nat.antidiagonal</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat.choose</span> <span class="n">p.1</span> <span class="n">p.2</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="271856190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271856190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271856190">(Feb 14 2022 at 17:02)</a>:</h4>
<p>I think you can also use it like: <code>∑ i j in (finset.nat.antidiagonal n), something i j</code></p>



<a name="271905677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/271905677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#271905677">(Feb 14 2022 at 23:41)</a>:</h4>
<p>I don't think that you can use it this way.</p>



<a name="272061221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272061221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272061221">(Feb 16 2022 at 01:01)</a>:</h4>
<p>Is there an easy way to get the units place of a real number?, so far Ive found <code>nat.to_digits</code> but that's only for naturals, any idea on what I can use there?</p>



<a name="272062105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272062105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272062105">(Feb 16 2022 at 01:15)</a>:</h4>
<p>Do you mean the floor (not the unit place for negative reals)? <a href="https://leanprover-community.github.io/mathlib_docs/find/int.floor">docs#int.floor</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.floor">docs#nat.floor</a> depending on your use.</p>



<a name="272062768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272062768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272062768">(Feb 16 2022 at 01:24)</a>:</h4>
<p>Yeah what I know is that the number is a positive real like<code> 128.232323...</code> and I want to get the ones place to get the answer <code>8</code></p>



<a name="272062808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272062808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272062808">(Feb 16 2022 at 01:25)</a>:</h4>
<p>When I try this out <code>#eval nat.floor (3.2 : ℝ)</code> I just get </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">code</span> <span class="n">generation</span> <span class="n">failed</span><span class="o">,</span> <span class="n">VM</span> <span class="n">does</span> <span class="n">not</span> <span class="k">have</span> <span class="n">code</span> <span class="n">for</span> <span class="bp">'</span><span class="n">classical.choice'</span>
</code></pre></div>



<a name="272063058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272063058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272063058">(Feb 16 2022 at 01:29)</a>:</h4>
<p>Reals aren't computable, so <code>#eval</code> won't work for that</p>



<a name="272063172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272063172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272063172">(Feb 16 2022 at 01:30)</a>:</h4>
<p><code>norm_num</code> should probably know how to compute this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">nat.floor</span> <span class="o">(</span><span class="mi">3</span><span class="bp">.</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">norm_num</span><span class="o">,</span> <span class="c1">-- should work</span>
<span class="kd">end</span>
</code></pre></div>



<a name="272063281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272063281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272063281">(Feb 16 2022 at 01:32)</a>:</h4>
<p>This works though:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">nat.floor</span> <span class="o">(</span><span class="mi">3</span><span class="bp">.</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">nat.floor_eq_iff</span><span class="bp">;</span> <span class="n">norm_num</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="272063473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272063473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272063473">(Feb 16 2022 at 01:35)</a>:</h4>
<p>So what you want is <code>nat.floor x % 10</code></p>



<a name="272074509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272074509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272074509">(Feb 16 2022 at 05:12)</a>:</h4>
<p>Thanks that works well!</p>



<a name="272074580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272074580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272074580">(Feb 16 2022 at 05:14)</a>:</h4>
<p>If I wanted to figure out the number of terms after simplification of the expansion of <code>(8* x^2 + 4 * x* y + 3 * y^2)^n</code> would there be a nice way to do it in lean?</p>



<a name="272086310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272086310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272086310">(Feb 16 2022 at 08:34)</a>:</h4>
<p>It's 2n+1, you don't need lean. What's your actual question? Is n a variable? Do you want a formula or an algorithm etc</p>



<a name="272187880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272187880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272187880">(Feb 16 2022 at 22:23)</a>:</h4>
<p>I'm trying to state and then prove that it's equal to that in lean, so I'm having trouble writing the statement I'm trying to prove</p>



<a name="272189935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272189935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272189935">(Feb 16 2022 at 22:43)</a>:</h4>
<p>I guess there would be a way to do this. A polynomial is stored as a function with finite support and you just want to count the size of the support.</p>



<a name="272190625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272190625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272190625">(Feb 16 2022 at 22:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.mv_polynomial</span>

<span class="kd">def</span> <span class="n">card_support</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">delta</span> <span class="n">mv_polynomial</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">delta</span> <span class="n">add_monoid_algebra</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span> <span class="c1">-- f is now a finsupp</span>
  <span class="n">exact</span> <span class="n">f.support.card</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>There's probably a more idiomatic way to do it.</p>



<a name="272190741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272190741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272190741">(Feb 16 2022 at 22:50)</a>:</h4>
<p>Ah ok, thanks for showing me that!</p>



<a name="272191585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272191585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272191585">(Feb 16 2022 at 22:59)</a>:</h4>
<p>It looks like <code>f.support.card</code> works without all that unfolding.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">card_support</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">f.support.card</span>
</code></pre></div>



<a name="272192134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272192134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272192134">(Feb 16 2022 at 23:03)</a>:</h4>
<p>Oh great! <code>mv_polynomial.support</code> exists :-)</p>



<a name="272198062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272198062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272198062">(Feb 17 2022 at 00:14)</a>:</h4>
<p>So I've been experimenting with the multivariable polynomial API, and I've figured some things out, but I'm having trouble understanding how to evaluate them properly, my first try was this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">trying_it</span>
  <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">4</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span><span class="o">:</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">X</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">X</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">X</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">X</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:</span>
   <span class="n">P.eval</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="bp">=</span> <span class="mi">10</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>I think my problem is that I don't fully understand the definitions together:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">mv_polynomial.eval</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
<span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">R</span>
</code></pre></div>
<p>I don't really understand what  <code>R →+* R</code> means (the + and *) , but if I understand that right, I first need to build some type of function which maps from sigma into the real numbers (for my case), so that function encodes my <code>1 2 3 4</code> ? Is that right?</p>



<a name="272198124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272198124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272198124">(Feb 17 2022 at 00:15)</a>:</h4>
<p>Also is it correct to say that sigma is acting like an index set/index type ? <a href="/user_uploads/3121/SH0wbTQbsKGiaC5gzPC6Tk_0/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/SH0wbTQbsKGiaC5gzPC6Tk_0/image.png" title="image.png"><img src="/user_uploads/3121/SH0wbTQbsKGiaC5gzPC6Tk_0/image.png"></a></div>



<a name="272198296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272198296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272198296">(Feb 17 2022 at 00:17)</a>:</h4>
<p><code>P.eval 1 2 3 4</code> seems very optimistic to me</p>



<a name="272198366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272198366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272198366">(Feb 17 2022 at 00:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">Callum Cassidy-Nolan</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20Proving.20Questions/near/272198062">said</a>:</p>
<blockquote>
<p>I don't really understand what  <code>R →+* R</code> means (the + and *) , but if I understand that right, I first need to build some type of function which maps from sigma into the real numbers (for my case), so that function encodes my <code>1 2 3 4</code> ? Is that right?</p>
</blockquote>
<p>Yes, that's <code>f</code></p>



<a name="272198443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272198443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272198443">(Feb 17 2022 at 00:19)</a>:</h4>
<p>I think you could use <a href="https://leanprover-community.github.io/mathlib_docs/data/matrix/notation.html">https://leanprover-community.github.io/mathlib_docs/data/matrix/notation.html</a> for this</p>



<a name="272198558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272198558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272198558">(Feb 17 2022 at 00:20)</a>:</h4>
<p>Your <code>σ</code> is <code>fin 4</code></p>



<a name="272206645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272206645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272206645">(Feb 17 2022 at 02:26)</a>:</h4>
<p>"mv_polynomial.eval ![1, 2, 3, 4] P" if you import finvec notation</p>



<a name="272273921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272273921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272273921">(Feb 17 2022 at 15:15)</a>:</h4>
<p>If I have an <code>ite (i=j) 1 0</code> built up from using <code>classical</code> to get decidability on the type of <code>i</code>, is there a way I can compare it to an <code>ite (i=j) 1 0</code> built from using an instance like <code>[decidable (i=j)]</code>?</p>



<a name="272274182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272274182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272274182">(Feb 17 2022 at 15:17)</a>:</h4>
<p>The <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#congr">tactic#congr</a> family might help here</p>



<a name="272274222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272274222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272274222">(Feb 17 2022 at 15:17)</a>:</h4>
<p>Nice! That did it. Thanks a ton!</p>



<a name="272276252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272276252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272276252">(Feb 17 2022 at 15:32)</a>:</h4>
<p>usually this means that a lemma statement went wrong somewhere</p>



<a name="272276315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272276315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272276315">(Feb 17 2022 at 15:32)</a>:</h4>
<p>so, if you don't mind me asking, does the <code>classical</code> ite come from your code or mathlib?</p>



<a name="272279945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272279945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272279945">(Feb 17 2022 at 15:55)</a>:</h4>
<p>It came from my code. I introduced a <code>open_locale classical</code> because the linter told me to replace all instances of <code>[decidable_eq]</code> with <code>classical</code> in the proof</p>



<a name="272280689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272280689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272280689">(Feb 17 2022 at 16:00)</a>:</h4>
<p>Okay, I figured out what was probably wrong. I had first inserted <code>classical</code>s in the tactics of proofs on an as-needed basis, but later decided to just <code>open_locale classical</code>, but in this one proof I had forgotten to take out the <code>classical</code> tactic.</p>



<a name="272313375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272313375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272313375">(Feb 17 2022 at 19:52)</a>:</h4>
<p>the two are not interchangeable. open_locale classical changes the statements of all your definitions and lemmas. classical as the tactic only changes the proofs.</p>



<a name="272313553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272313553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272313553">(Feb 17 2022 at 19:53)</a>:</h4>
<p>You want the latter, not the former. The former restricts your definitions and lemmas to be only valid over things that are classically defined, instead of things that are either classically or decidably defined.</p>



<a name="272313647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272313647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272313647">(Feb 17 2022 at 19:54)</a>:</h4>
<p>Whether or not you rely on decidability inside the proof doesn't matter for the proof itself, which is what the "classical" tactic does.</p>



<a name="272316474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272316474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272316474">(Feb 17 2022 at 20:12)</a>:</h4>
<p>Ah, I see. So if I have a term-mode proof, should I turn it into a tactic-mode proof so that I can hit it with the <code>classical</code> tactic?</p>



<a name="272316833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272316833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272316833">(Feb 17 2022 at 20:15)</a>:</h4>
<p>Separately, doing this breaks the statements of some theorems with <code>ite</code> in them, is there a way to fix that without putting in <code>[decidable_eq]</code>s into the hypothesis?</p>



<a name="272317002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272317002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272317002">(Feb 17 2022 at 20:17)</a>:</h4>
<p>The way to fix them <em>is</em> to add <code>decidable_eq</code> hypotheses.</p>



<a name="272317189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272317189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272317189">(Feb 17 2022 at 20:18)</a>:</h4>
<p>Okay, previously having <code>decidable_eq</code> in the hypothesis got the mathlib linter mad at me. Is there a way to tell which <code>decidable_eq</code>s are okay to have? Is it exactly when you need it to make the theorem statement work?</p>



<a name="272318637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272318637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272318637">(Feb 17 2022 at 20:31)</a>:</h4>
<p>Yes, exactly! <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="272318911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272318911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272318911">(Feb 17 2022 at 20:34)</a>:</h4>
<p>The idea is that the decidable instances appearing in the type should be general while the ones appearing in the proof can be whatever. And you want to have as few decidability hypotheses as possible, so any that doesn't appear in the type should be declared in the proof.</p>



<a name="272319050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272319050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272319050">(Feb 17 2022 at 20:35)</a>:</h4>
<p>Note the difference between <code>def</code> and <code>lemma</code> here. Because <code>lemma</code> forgets the proof as soon as it's done, you can poison it with <code>classical</code> as much as you want. If you do that in a definition however, you'll make it noncomputable.</p>



<a name="272319123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272319123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272319123">(Feb 17 2022 at 20:36)</a>:</h4>
<p>More details: an if-then-else that branches on a condition P must have that P is decidable! Otherwise you can't actually consider the two branches</p>



<a name="272319170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272319170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272319170">(Feb 17 2022 at 20:36)</a>:</h4>
<p>Ah nice! This makes so much sense. Thank you all for the explanation.</p>



<a name="272319358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272319358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272319358">(Feb 17 2022 at 20:38)</a>:</h4>
<p>I should also add that usually some goals within a <code>def</code> are proofs, and those behave just as in a <code>lemma</code>, so you can classical-poison them as much as you want even though they are "part of a <code>def</code>".</p>



<a name="272319406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272319406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272319406">(Feb 17 2022 at 20:38)</a>:</h4>
<p>The important distinction is Type-valued vs Prop-valued goal.</p>



<a name="272319559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272319559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Packer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272319559">(Feb 17 2022 at 20:40)</a>:</h4>
<p>Right! So if I want a Prop, then I do the <code>classical</code> tactic, and if I want to make a (computable) definition, then I should use <code>decidable_eq</code>.<br>
(And I should never use <code>open_locale classical</code>?)</p>



<a name="272319895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272319895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272319895">(Feb 17 2022 at 20:43)</a>:</h4>
<p><code>open_locale classical</code> is the mathematician's cheat code. Short term gain, long-earned pain.</p>



<a name="272320459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272320459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272320459">(Feb 17 2022 at 20:48)</a>:</h4>
<p>I wish finsupp could be fixed :(</p>



<a name="272321999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272321999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272321999">(Feb 17 2022 at 21:01)</a>:</h4>
<p>Couldn't we follow the same idea as for <code>dfinsupp</code>? There it seems to work well.</p>



<a name="272388533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272388533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272388533">(Feb 18 2022 at 11:09)</a>:</h4>
<p>What’s wrong with <code>finsupp</code>? Is it just that the use of <code>open_locale classical</code> would be a big chore to unwind?</p>



<a name="272399443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272399443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272399443">(Feb 18 2022 at 13:11)</a>:</h4>
<p>No, not quite. It would indeed be a big chore to unwind, but mostly the definition of <code>finsupp</code> is such that it requires an awful lot of decidability. <code>dfinsupp</code> circumvents the problem by having a more flexible representation of the support.</p>



<a name="272409676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272409676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272409676">(Feb 18 2022 at 14:43)</a>:</h4>
<p>What's wrong with <code>finsupp</code> is that it's hard for mathematicians to use because it's constructive and mathematicians have no idea what decidable equality means because in maths it's an axiom. In fact nobody likes <code>finsupp</code> because it's too constructive for the classical people and somehow not constructive enough for the constructive people, is my understanding of it (I remember Reid bashing it from a constructivist point of view at some point in the past). One day I'll write a purely classical finsupp :-) It's just f : X -&gt; Y and the hypothesis that the preimage of univ - 0 is set.finite.</p>



<a name="272409877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272409877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272409877">(Feb 18 2022 at 14:45)</a>:</h4>
<p>the main reason I care about it is that currently we have to do <a href="https://github.com/leanprover-community/mathlib/blob/3e6439cd7e04a883c6f71605e3eb333d7623af07/src/data/nat/factorization.lean#L257">ugly hacks</a> to make the <code>nat</code> multiplicative inductions computable; I don't much care mathematically but it just seems to me that they should be computable in principle</p>



<a name="272410227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272410227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272410227">(Feb 18 2022 at 14:48)</a>:</h4>
<p>So there in your link is the claim that <code>finsupp is noncomputable</code>, and yet it uses <code>finset</code> instead of <code>set.finite</code> so it's not classical either.</p>



<a name="272412350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272412350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272412350">(Feb 18 2022 at 15:04)</a>:</h4>
<p>Yeah <code>finsupp</code> is actually wrong in multiple ways, if you're expecting <code>finsupp X R</code> to be the free <code>R</code>-module on <code>X</code>.</p>



<a name="272412991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272412991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272412991">(Feb 18 2022 at 15:09)</a>:</h4>
<p><code>dfinsupp</code> is also wrong, but less so.</p>



<a name="272563452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563452">(Feb 20 2022 at 03:56)</a>:</h4>
<p>I've just written out this question : </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.basic</span>

<span class="kd">theorem</span> <span class="n">open_set_for_each</span>
  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">U</span> <span class="bp">⊂</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_open</span> <span class="n">A</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>When I look at the topology api I see this: <a href="/user_uploads/3121/WJ3mXdGYyDIs1pc_0fTImo-9/image.png">image.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/WJ3mXdGYyDIs1pc_0fTImo-9/image.png" title="image.png"><img src="/user_uploads/3121/WJ3mXdGYyDIs1pc_0fTImo-9/image.png"></a></div><p>How does <code>is_open</code> know I'm talking about X ?</p>
<p>Also, what does it mean when I write <code>X : Type</code> ? Am I just stating that it's an aribitrary type? I have trouble understanding <code>Type u</code> and all that stuff.</p>



<a name="272563477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563477">(Feb 20 2022 at 03:57)</a>:</h4>
<p>When writing code for mathlib you usually want to use <code>X : Type*</code> instead of <code>X : Type</code></p>



<a name="272563527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563527">(Feb 20 2022 at 03:58)</a>:</h4>
<p><code>X : Type</code> means <code>X</code> is a type in the lowest universe; <code>X : Type*</code> means <code>X</code> is a type in any universe</p>



<a name="272563554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563554">(Feb 20 2022 at 03:59)</a>:</h4>
<p>you don't need to know much about universes other than to know there is more than one and so <code>X : Type</code> is putting a restriction on users of your theorem. In 98% of cases you can just write <code>Type*</code> instead of <code>Type</code> and pay no more heed to it</p>



<a name="272563685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563685">(Feb 20 2022 at 04:00)</a>:</h4>
<p>I am a little curious about the universes, I'm not sure what those are but I know that there are different type levels, like <code>Type 0</code>, <code>Type 1</code> and so on, why are there so many?</p>



<a name="272563705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563705">(Feb 20 2022 at 04:01)</a>:</h4>
<p>Also what is the difference between <code>X : Type*</code> and <code>X : Type u</code></p>



<a name="272563719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563719">(Feb 20 2022 at 04:01)</a>:</h4>
<p>Ideally there would be only one universe, the type of all types. Unfortunately Russell and Girard proved this is inconsistent, so the type of all types has to live in a bigger type</p>



<a name="272563731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563731">(Feb 20 2022 at 04:01)</a>:</h4>
<p>So in lean <code>Type 0 : Type 1</code> and <code>Type 1 : Type 2</code> and so on</p>



<a name="272563775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563775">(Feb 20 2022 at 04:02)</a>:</h4>
<p>You will almost never see the higher universes show up in practice, but they are theoretically important</p>



<a name="272563796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563796">(Feb 20 2022 at 04:03)</a>:</h4>
<p><code>X : Type*</code> is the same as <code>X : Type _</code>, which is to say X has Type "lean figure it out"</p>



<a name="272563800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563800">(Feb 20 2022 at 04:03)</a>:</h4>
<p>Ok, so the goal is that we want to say that <code>X</code> is an arbitrary type, but there's no type we can put on the underscore <code>X : _</code> to make that happen (based on Russel and Girard) ?</p>



<a name="272563818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563818">(Feb 20 2022 at 04:03)</a>:</h4>
<p>usually it will end up being a universe variable, so you get <code>X : Type u</code> with <code>u</code> being a universe parameter to the theorem</p>



<a name="272563859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563859">(Feb 20 2022 at 04:04)</a>:</h4>
<p>So instead we build a tower of types that are increasing and then let it be one of the levels in the tower?</p>



<a name="272563868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563868">(Feb 20 2022 at 04:04)</a>:</h4>
<p>Right, we get a family of theorems, one for each universe we want to instantiate X to</p>



<a name="272563913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563913">(Feb 20 2022 at 04:04)</a>:</h4>
<p>Do we ever use specific levels?</p>



<a name="272563918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563918">(Feb 20 2022 at 04:04)</a>:</h4>
<p>it seems like we have infinite of them just to solve the paradox.</p>



<a name="272563944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563944">(Feb 20 2022 at 04:05)</a>:</h4>
<p>Concrete types usually have the lowest possible level we can assign to them. So for example <code>nat : Type 0</code></p>



<a name="272563954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563954">(Feb 20 2022 at 04:05)</a>:</h4>
<p>What would have gone wrong if we did <code>nat : Type *</code> ?</p>



<a name="272563965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272563965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272563965">(Feb 20 2022 at 04:05)</a>:</h4>
<p>and if <code>A : Type u</code> and <code>B : Type v</code> then <code>A ⊕ B : Type (max u v)</code></p>



<a name="272564043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564043">(Feb 20 2022 at 04:07)</a>:</h4>
<p>If we did <code>nat : Type u</code>, then it wouldn't really be one type, it would be a family of types, denoted <code>nat.{u} : Type u</code>. This is fine, but lean will often not be able to solve for <code>u</code> when you use <code>nat</code> in a theorem so users will have to pay closer attention to the universes</p>



<a name="272564065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564065">(Feb 20 2022 at 04:07)</a>:</h4>
<p>So <code>Type u</code> is the type of families of <code>Type u</code> ??</p>



<a name="272564112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564112">(Feb 20 2022 at 04:08)</a>:</h4>
<p>so as a result, this technique is generally reserved to cases where universes really are important, like <code>ordinal.{u}</code> and <code>cardinal.{u}</code>, or they might be available as variants of an existing definition, for example <code>empty : Type 0</code> and <code>pempty.{u} : Type u</code></p>



<a name="272564117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564117">(Feb 20 2022 at 04:08)</a>:</h4>
<p><code>Type u</code> is the type of all types in universe u</p>



<a name="272564129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564129">(Feb 20 2022 at 04:09)</a>:</h4>
<p><code>Type u</code> is equal to <code>Sort (u+1)</code>, which extends the universe hierarchy one step downward to the universe <code>Prop = Sort 0</code>, which is special in a few ways</p>



<a name="272564132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564132">(Feb 20 2022 at 04:09)</a>:</h4>
<p>So then <code>nat : Type u</code> makes <code>nat</code> a type in universe <code>u</code>?</p>



<a name="272564196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564196">(Feb 20 2022 at 04:10)</a>:</h4>
<p>You mean in the definition? Normally if you write <code>nat : Type u</code> you get a type error because <code>nat</code> doesn't have type <code>Type u</code>, it has type <code>Type 0</code></p>



<a name="272564212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564212">(Feb 20 2022 at 04:10)</a>:</h4>
<p>if you put that in the definition then it would become a family of types <code>nat.{u}</code> as mentioned, so you would have <code>nat.{0} : Type 0</code>, <code>nat.{1} : Type 1</code> and so on</p>



<a name="272564231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564231">(Feb 20 2022 at 04:11)</a>:</h4>
<p>Ok, and since we only need one version of the naturals we just do <code>nat : Type 0</code> ?</p>



<a name="272564233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564233">(Feb 20 2022 at 04:11)</a>:</h4>
<p>exactly</p>



<a name="272564246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564246">(Feb 20 2022 at 04:11)</a>:</h4>
<p>Would integers also reside in <code>Type 0</code> ?</p>



<a name="272564249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564249">(Feb 20 2022 at 04:11)</a>:</h4>
<p>yep</p>



<a name="272564250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564250">(Feb 20 2022 at 04:11)</a>:</h4>
<p>Or would it be a larger number?</p>



<a name="272564289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564289">(Feb 20 2022 at 04:12)</a>:</h4>
<p>Oh ok</p>



<a name="272564296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564296">(Feb 20 2022 at 04:12)</a>:</h4>
<p>it is occasionally technically useful to have a copy of the natural numbers in higher universes, and we use <code>ulift.{u v} : Type u -&gt; Type (max u v)</code> for that</p>



<a name="272564315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564315">(Feb 20 2022 at 04:13)</a>:</h4>
<p>I understand why we needed infinite types, because of the paradox, but what are the point of the <code>Sort</code>'s ?</p>



<a name="272564324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564324">(Feb 20 2022 at 04:13)</a>:</h4>
<p>Some theorems are true for both <code>Prop</code> and <code>Type u</code></p>



<a name="272564335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564335">(Feb 20 2022 at 04:13)</a>:</h4>
<p>and it is useful to be able to prove them only once and have the theorem apply in both contexts</p>



<a name="272564336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564336">(Feb 20 2022 at 04:14)</a>:</h4>
<p>Why do we need both ?</p>



<a name="272564383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564383">(Feb 20 2022 at 04:14)</a>:</h4>
<p>why have propositions? or why have types? Both are useful</p>



<a name="272564391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564391">(Feb 20 2022 at 04:14)</a>:</h4>
<p>obviously we need <code>nat</code> and we need <code>2 + 2 = 4</code></p>



<a name="272564395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564395">(Feb 20 2022 at 04:14)</a>:</h4>
<p>So it's to do with the types as propositions mindset thing right?</p>



<a name="272564398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564398">(Feb 20 2022 at 04:14)</a>:</h4>
<p>yeah, basically</p>



<a name="272564416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564416">(Feb 20 2022 at 04:15)</a>:</h4>
<p>So why not set them equal? Like : <code>Type u</code> is equal to <code>Sort u</code> if they represent the same thing?</p>



<a name="272564475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564475">(Feb 20 2022 at 04:16)</a>:</h4>
<p>That's the way it used to be, but inductive types that have type <code>Sort u</code> are really badly behaved so we usually have them in <code>Type u</code> or <code>Prop</code></p>



<a name="272564489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564489">(Feb 20 2022 at 04:16)</a>:</h4>
<p>I suppose we could write <code>Sort (u+1)</code> but that's a really common case</p>



<a name="272564496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564496">(Feb 20 2022 at 04:17)</a>:</h4>
<p>and <code>Type = Type 0</code> is especially common since it's the type of all your favorite types</p>



<a name="272564505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564505">(Feb 20 2022 at 04:17)</a>:</h4>
<p>Ok, so it's due to some implementation thing in Lean not due to some conceptual thing like, <code>we need infinite types to dodge the paradox</code> ?</p>



<a name="272564573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564573">(Feb 20 2022 at 04:18)</a>:</h4>
<p>No this is just a design question. Coq does it differently, there is no <code>Sort</code> but there is <code>Prop</code>, <code>Set</code> and <code>Type u</code> and don't ask me why they need two base universes</p>



<a name="272564578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564578">(Feb 20 2022 at 04:18)</a>:</h4>
<p>oh and <code>SProp</code></p>



<a name="272564600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564600">(Feb 20 2022 at 04:19)</a>:</h4>
<p>Agda has <code>Prop u</code> and <code>Type u</code> IIRC</p>



<a name="272564652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564652">(Feb 20 2022 at 04:20)</a>:</h4>
<p>Ok, I think I came out of this understanding a little more (at least why there are infinite of them).</p>



<a name="272564656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564656">(Feb 20 2022 at 04:20)</a>:</h4>
<p>Thank you</p>



<a name="272564667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564667">(Feb 20 2022 at 04:21)</a>:</h4>
<p>Oh and of course ZFC just has one universe</p>



<a name="272564677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564677">(Feb 20 2022 at 04:21)</a>:</h4>
<p>Because everything is a set?</p>



<a name="272564681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564681">(Feb 20 2022 at 04:21)</a>:</h4>
<p>everything except the set of all sets</p>



<a name="272564685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564685">(Feb 20 2022 at 04:21)</a>:</h4>
<p>there are sets and classes and some classes can't be sets</p>



<a name="272564688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564688">(Feb 20 2022 at 04:21)</a>:</h4>
<p>That doesn't exist right?</p>



<a name="272564740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564740">(Feb 20 2022 at 04:22)</a>:</h4>
<p>and the universe itself is one of them</p>



<a name="272564776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564776">(Feb 20 2022 at 04:22)</a>:</h4>
<p>so roughly speaking ZFC loses the type theory ability to say that everything expressible in the system has some type</p>



<a name="272564786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564786">(Feb 20 2022 at 04:23)</a>:</h4>
<p>that's what really forces the infinite hierarchy</p>



<a name="272564790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564790">(Feb 20 2022 at 04:23)</a>:</h4>
<p>Right</p>



<a name="272564858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564858">(Feb 20 2022 at 04:24)</a>:</h4>
<p>Using types we still can't say "a : &lt;type of all types&gt;", but we can say <code>a : Type*</code> to say that it resides in of the layers which is equivalent ?</p>



<a name="272564888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564888">(Feb 20 2022 at 04:25)</a>:</h4>
<p>Well, <code>Type*</code> isn't really a type, it's notation for <code>Type &lt;something that lean will deduce from context&gt;</code></p>



<a name="272564943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564943">(Feb 20 2022 at 04:26)</a>:</h4>
<p>What about in a situation like this: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">open_set_for_each</span>
  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">),</span> <span class="n">is_open</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">U</span> <span class="bp">⊂</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_open</span> <span class="n">A</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="272564956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564956">(Feb 20 2022 at 04:26)</a>:</h4>
<p>If you say <code>X : Type*</code> in an assumption, then lean will deduce that you want it to live in a universe named by a fresh universe variable</p>



<a name="272564968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272564968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272564968">(Feb 20 2022 at 04:27)</a>:</h4>
<p>so lean turns your theorem into</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">open_set_for_each.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span>
  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">),</span> <span class="n">is_open</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">U</span> <span class="bp">⊂</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_open</span> <span class="n">A</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="272565014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565014">(Feb 20 2022 at 04:27)</a>:</h4>
<p>(the lean 3 syntax for that is actually a little different BTW, <code>theorem {u} open_set_for_each</code>, but this is weird and has been changed to be the sensible thing in lean 4)</p>



<a name="272565054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565054">(Feb 20 2022 at 04:28)</a>:</h4>
<p>And the only way we can actually use that theorem is by specifying an <em>actual</em> number ?</p>



<a name="272565061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565061">(Feb 20 2022 at 04:28)</a>:</h4>
<p>no, we can specify a universe expression as well</p>



<a name="272565080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565080">(Feb 20 2022 at 04:29)</a>:</h4>
<p>What would that look like?</p>



<a name="272565086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565086">(Feb 20 2022 at 04:29)</a>:</h4>
<p>for example if you are proving some other theorem with a <code>{u}</code> in it then you might use <code>open_set_for_each.{u}</code>, or maybe <code>open_set_for_each.{u+1}</code> or <code>open_set_for_each.{max u 3}</code></p>



<a name="272565098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565098">(Feb 20 2022 at 04:29)</a>:</h4>
<p>lean is very good at figuring the right indexes out so you almost never have to specify</p>



<a name="272565100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565100">(Feb 20 2022 at 04:29)</a>:</h4>
<p>In that situation is <code>u : nat</code> ?</p>



<a name="272565167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565167">(Feb 20 2022 at 04:30)</a>:</h4>
<p>not exactly. You can think of it that way, it represents a natural number, but not in a way that lean itself has access to. You can't write <code>def foo (n : nat) : Type n := ...</code></p>



<a name="272565184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565184">(Feb 20 2022 at 04:31)</a>:</h4>
<p>So how do I say <code>u</code> is a universe variable thing?</p>



<a name="272565193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565193">(Feb 20 2022 at 04:31)</a>:</h4>
<p>This is also on pain of contradiction, because if such a <code>foo</code> existed then the type of <code>foo</code> itself would have to live in <code>Type ω</code></p>



<a name="272565241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565241">(Feb 20 2022 at 04:32)</a>:</h4>
<p>You use <code>universe(s) u</code>  to declare universe variables, analogous to <code>variable(s) n : nat</code> statements</p>



<a name="272565275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565275">(Feb 20 2022 at 04:33)</a>:</h4>
<p>and to declare universe variables in a theorem statement you put the names in braces <em>before</em> the theorem name, like this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">open_set_for_each</span>
  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">),</span> <span class="n">is_open</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">U</span> <span class="bp">⊂</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_open</span> <span class="n">A</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="272565338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565338">(Feb 20 2022 at 04:34)</a>:</h4>
<p>Or you can use <code>Type*</code> which implicitly declares an anonymous universe variable for the statement</p>



<a name="272565373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565373">(Feb 20 2022 at 04:35)</a>:</h4>
<p>Another trick I like is to just use <code>(X)</code> which declares <code>X : Sort*</code>, which lean will solve to <code>Sort u</code> or <code>Prop</code> or <code>Type u</code> as appropriate based on how it is used</p>



<a name="272565408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20Proving%20Questions/near/272565408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20Proving.20Questions.html#272565408">(Feb 20 2022 at 04:36)</a>:</h4>
<p>it's short and very difficult to get wrong</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
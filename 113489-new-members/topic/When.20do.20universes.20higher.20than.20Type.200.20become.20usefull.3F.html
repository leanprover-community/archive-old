---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html">When do universes higher than Type 0 become usefull?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="262787792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262787792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes C. Mayer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262787792">(Nov 26 2021 at 11:42)</a>:</h4>
<p>I was wondering when you would use the type universes in LEAN, that are above Type 0. It seems that normally the return type of a function would be something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">def</span> <span class="n">uni</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">imax</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>So if you only have definitions that look like this, and you only ever use types that are in <code>Type 0</code>, then you would never get any term of type higher than <code>Type 0</code>. So is having these universes just a way to avoid <a href="https://en.wikipedia.org/wiki/System_U?oldformat=true#Girard's_paradox">Girad's paradox</a> (I don't really get the paradox though). Or is there some practical relevance, in the sense that you can do something with the type universes. Or would you basically just ignore them usually.</p>



<a name="262788601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262788601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262788601">(Nov 26 2021 at 11:52)</a>:</h4>
<p>I'm not sure it'll help much in your understanding of girard's paradox, but <a href="#narrow/stream/113488-general/topic/Type.20in.20type/near/233041033">here</a>'s a thread about it and <a href="https://github.com/leanprover-community/mathlib/blob/2be593d90712ec763811f8fe4db7b66f33461cae/src/logic/girard.lean">here</a> is the mathlib formalization.</p>
<p>Furthermore, I think in LTE there's things in <code>Type 1</code> and maybe even <code>Type 2</code> (see condensed/Ab.lean,  there they consider a topological commutative additive group living in Type 1 or above) just naturally, stemming from the idea that the set of all sets isn't a set, but sometimes we want to consider these sorts of things in category theory (c.f. locally small categories and so on); I think Kevin was talking yesterday about how Lean is slightly weaker than some axioms usually used for algebraic geometry (grothendieck-universe related).</p>



<a name="262788898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262788898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262788898">(Nov 26 2021 at 11:56)</a>:</h4>
<p>For standard undergraduate mathematics you can just use <code>Type</code>, and indeed when teaching I do typically just use <code>Type</code>. My mental model of things is that <code>Type 1</code> and higher are only there because one of the rules of type theory is that everything has to have a type, so <code>Type</code> has to have a type and there you go.</p>



<a name="262790987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262790987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes C. Mayer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262790987">(Nov 26 2021 at 12:18)</a>:</h4>
<p>Ok, so I updated towards that types that live in universes above <code>Type 0</code> are probably useful sometimes, but that you don't need it most of the time.</p>



<a name="262793498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262793498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262793498">(Nov 26 2021 at 12:49)</a>:</h4>
<p>For thousands of years mathematicians got by without categories, but now we use them a lot, and many categories are too large to be sets (e.g. the category of all sets isn't a set, and this corresponds to the fact that the category of all types does't live in <code>Type</code> in Lean). So if you want to do categories then universes suddenly become much more important.</p>



<a name="262819547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262819547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262819547">(Nov 26 2021 at 17:20)</a>:</h4>
<p>A natural way the higher type universes appears is if you work with an indexed family of types (<code>α : I → Type</code> with <code>I : Type</code>) then <code>α</code> is a <code>Type 1</code>.  A family of elements of this is a function <code>x : Π (i : I), α i</code>, and <code>Π (i : I), α i</code> is just a <code>Type</code> though.</p>
<p>You can get around <code>Type 1</code> by deciding your indexed family of types can all be regarded as being subsets of some fixed type (have <code>α : I → set β</code> for some <code>β : Type</code>), since then <code>α</code> is a <code>Type</code> rather than a <code>Type 1</code>.  You can still form <code>Π (i : I), α i</code>, where <code>α i</code> is using the implicit coercion from <code>set</code> to <code>subtype</code>, and this function type is still in <code>Type</code>.</p>



<a name="262820247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262820247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262820247">(Nov 26 2021 at 17:29)</a>:</h4>
<p>One place indexed families show up is in recursors, like <code>nat.rec</code>.  If you specialize the motive of <code>nat.rec</code> to be an indexed family of <code>Type</code>s, then <code>nat.rec</code> is a <code>Type 1</code>, though as soon as you give it the motive argument it's back to being a <code>Type</code>.</p>



<a name="262833821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262833821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Reichelt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262833821">(Nov 26 2021 at 20:47)</a>:</h4>
<p>Here is a beginner-friendly special case. Consider a structure like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">group</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">...</span>
</code></pre></div>
<p>Then <code>group</code> has type <code>Type 1</code>.<br>
(While this matches the standard way of defining a group in mathematics, it's not the standard way in Lean though.)</p>



<a name="262833905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262833905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262833905">(Nov 26 2021 at 20:48)</a>:</h4>
<p>That is essentially the way the category <a href="https://leanprover-community.github.io/mathlib_docs/find/Group">docs#Group</a> of groups is defined though. Except they allow <code>\alpha : Type u</code> so the category ends up having type <code>Type u+1</code></p>



<a name="262834101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262834101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262834101">(Nov 26 2021 at 20:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F/near/262819547">said</a>:</p>
<blockquote>
<p>A natural way the higher type universes appears is if you work with an indexed family of types (<code>α : I → Type</code> with <code>I : Type</code>) then <code>α</code> is a <code>Type 1</code>.  A family of elements of this is a function <code>x : Π (i : I), α i</code>, and <code>Π (i : I), α i</code> is just a <code>Type</code> though.</p>
</blockquote>
<p>I'm confused by this example. Aren't <code>α</code> and <code>Π (i : I), α i</code> "the same type"?</p>



<a name="262834222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262834222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262834222">(Nov 26 2021 at 20:54)</a>:</h4>
<p>Only up to funext, no?</p>



<a name="262834314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262834314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262834314">(Nov 26 2021 at 20:56)</a>:</h4>
<p>Yes, but how come that change the universe it lives in?</p>



<a name="262835216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262835216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262835216">(Nov 26 2021 at 21:14)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> In normal math notation, <code>α</code> is giving an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>-indexed family of sets <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><msub><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(X_i)_{i\in I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1774em;"><span></span></span></span></span></span></span></span></span></span>, and a term <code>x : Π (i : I), α i</code> is regarded as an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>-indexed family of elements <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><msub><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(x_i)_{i\in I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1774em;"><span></span></span></span></span></span></span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i\in X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">i\in I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>.</p>



<a name="262835298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262835298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262835298">(Nov 26 2021 at 21:15)</a>:</h4>
<p>I usually have to think through how it's <code>α : Π (i : I), Type</code> versus <code>x : Π (i : I), α i</code>.</p>



<a name="262835393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262835393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262835393">(Nov 26 2021 at 21:18)</a>:</h4>
<p>I didn't mean <code>x : Π (i : I), α i</code>, but <code>Π (i : I), α i</code> itself. <code>(Π (i : I), α i) i</code> and <code>α i</code>  are "equal" for all <code>i</code>, so why aren't <code>Π (i : I), α i</code> and <code>α</code> "equal"?</p>



<a name="262835565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262835565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262835565">(Nov 26 2021 at 21:21)</a>:</h4>
<p><span class="user-mention" data-user-id="198266">@Sebastian Reichelt</span> Interestingly, even if you do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">...</span>
</code></pre></div>
<p>then <code>group</code> is a function <code>Type -&gt; Type</code>, which is a <code>Type 1</code>.  If you want to prove things about type constructors like <code>group</code>, then it's nice having these higher type universes.  (A Haskeller-friendly example is the <code>monad</code> typeclass, which requires having an argument from a higher universe.)</p>



<a name="262835674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262835674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262835674">(Nov 26 2021 at 21:23)</a>:</h4>
<p>Pi is not lambda</p>



<a name="262835727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262835727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262835727">(Nov 26 2021 at 21:24)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Oh, I see, I think my brain tried to correct the types without me noticing (since <code>α</code> is a function so isn't a type).  In the dependent type theory Lean uses, pi types and functions are considered to be different -- I don't really understand exactly why.</p>
<p>In Automath, pis are encoded as lambdas, and there's some rule that says lambdas may be regarded as types.</p>



<a name="262835777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262835777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262835777">(Nov 26 2021 at 21:25)</a>:</h4>
<p>Ah so they are morally equal but not Lean-equal? I guess that's an answer.</p>



<a name="262835867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262835867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262835867">(Nov 26 2021 at 21:26)</a>:</h4>
<p>I think it's more like they are morally different but it is possible to treat them as the same--I've heard about this before, but it seems deeply weird to me</p>



<a name="262835945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262835945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262835945">(Nov 26 2021 at 21:28)</a>:</h4>
<p>One is a family of sets, the other is the cartesian product of that family, which is another set</p>



<a name="262836056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262836056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262836056">(Nov 26 2021 at 21:30)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I think the universe levels still sort of work out. We have that <code>α : Π (i : I), Type : Type 1</code> and <code>Π (i : I), α i : Type : Type 1</code>, right? So <code>α</code> "as a type" is inside <code>Type</code>.</p>



<a name="262836060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262836060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262836060">(Nov 26 2021 at 21:30)</a>:</h4>
<p>huh, they don't even live in the same universe:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="bp">==</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">--universe error</span>
</code></pre></div>



<a name="262836088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262836088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262836088">(Nov 26 2021 at 21:31)</a>:</h4>
<p>Hmm</p>



<a name="262836093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262836093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262836093">(Nov 26 2021 at 21:31)</a>:</h4>
<p>(deleted)</p>



<a name="262836166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262836166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262836166">(Nov 26 2021 at 21:33)</a>:</h4>
<p>What do you mean? I see a very specific issue for, say, u=7 v=2.</p>



<a name="262836267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262836267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262836267">(Nov 26 2021 at 21:34)</a>:</h4>
<p>Oh, I meant for just the u=0, v=0 case. Edit: actually, heq is ok here; need to work on my intuition here it seems (and heq is for things that agree at two levels up).</p>



<a name="262837369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262837369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262837369">(Nov 26 2021 at 21:58)</a>:</h4>
<p>It turns out you can make a <code>has_coe_to_sort</code> to sort of add a rule that lambdas can be used as pi types:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">has_coe_to_sort</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">⟩</span>

<span class="c1">-- the family of types for vectors of various lengths</span>
<span class="kd">def</span> <span class="n">α</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">vector</span> <span class="n">ℤ</span> <span class="n">n</span>

<span class="c1">-- the family of elements of those types of constant-0 vectors</span>
<span class="kd">def</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">vector.repeat</span> <span class="mi">0</span> <span class="n">n</span>
</code></pre></div>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>: and there's a "proof" that <code>Π (i : I), α i</code> and <code>α</code> are the same:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">rfl</span>
</code></pre></div>
<p>("proof" is in quotes because this is just the definition of the coercion.)</p>



<a name="262838407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262838407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262838407">(Nov 26 2021 at 22:13)</a>:</h4>
<p>Interesting!</p>



<a name="262838578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262838578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262838578">(Nov 26 2021 at 22:16)</a>:</h4>
<p>It's curious how with <code>{ι : Type u} {α : ι → Type v}</code>,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">α</span> <span class="n">i</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span>
</code></pre></div>
<p>but</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">α</span>              <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span>     <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span>
</code></pre></div>
<p>The universes <code>Type (max (u+1) (v+1))</code> and <code>Type (max u (v+1))</code> coincide when <code>u &lt;= v</code>, but when <code>α</code> is indexing with "too big" of a type, then the pi type is in a sense in a bigger universe than <code>α</code>. Why is this?</p>



<a name="262838999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262838999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262838999">(Nov 26 2021 at 22:24)</a>:</h4>
<p>Yes, this was the thing that was so mysterious to me.</p>



<a name="262839014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262839014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262839014">(Nov 26 2021 at 22:25)</a>:</h4>
<p>I was going to say morally α can't be injective if the index set is too big but knowing set theory it's probably independent</p>



<a name="262839105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262839105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262839105">(Nov 26 2021 at 22:26)</a>:</h4>
<p><code>ι</code> being in a big universe doesn't mean it's big, right? After all we can always ulift anything we want.</p>



<a name="262839404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/When%20do%20universes%20higher%20than%20Type%200%20become%20usefull%3F/near/262839404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/When.20do.20universes.20higher.20than.20Type.200.20become.20usefull.3F.html#262839404">(Nov 26 2021 at 22:33)</a>:</h4>
<p>OK, but let's say that <code>α</code> isn't small for any universe less than it's in, then</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
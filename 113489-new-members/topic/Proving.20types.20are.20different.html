---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Proving.20types.20are.20different.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html">Proving types are different</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="233009309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233009309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233009309">(Apr 03 2021 at 14:14)</a>:</h4>
<p>How can I, in general, prove this sort of statements?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">unit</span> <span class="bp">×</span> <span class="n">unit</span><span class="o">)</span> <span class="bp">≠</span> <span class="n">unit</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>or </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">≠</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>My guess is that in general, no two inductive types are equal, is that the case?</p>



<a name="233010183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233010183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233010183">(Apr 03 2021 at 14:31)</a>:</h4>
<p>I think Lean is consistent with the assertion that two types are equal iff they have the same cardinality (?). So you can't prove either of these</p>



<a name="233011295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233011295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233011295">(Apr 03 2021 at 14:53)</a>:</h4>
<p>Right, the only proofs I've seen about types are ones that prove they can't be equal due to different cardinalities</p>



<a name="233011382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233011382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233011382">(Apr 03 2021 at 14:55)</a>:</h4>
<p>Or ones that prove indexed families are equal given their indices are equal, such as <code>list A = list B</code> if <code>A = B</code></p>



<a name="233011732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233011732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233011732">(Apr 03 2021 at 15:01)</a>:</h4>
<p>Lean could be set up with <code>int</code> defined to be equal to <code>nat</code> but with a different zero, one, addition and multiplication. Similarly <code>prod</code> could be set up in such a way that <code>prod X unit</code> is definitionally equal to <code>X</code>. Asking if two types are distinct is asking the wrong kind of question, because it depends on what is going on under the hood.</p>



<a name="233012094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233012094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233012094">(Apr 03 2021 at 15:07)</a>:</h4>
<p>Oh, interesting, I didn't know that, thank you all for the clarifications</p>



<a name="233012280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233012280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233012280">(Apr 03 2021 at 15:10)</a>:</h4>
<p>In my nonformal opinion, <code>unit x unit</code> is equal to <code>unit</code>.</p>



<a name="233012296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233012296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233012296">(Apr 03 2021 at 15:10)</a>:</h4>
<p>(both are "the" terminal type)</p>



<a name="233016358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233016358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233016358">(Apr 03 2021 at 16:22)</a>:</h4>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span> where does this notion of equality come from?<br>
So far I've only heard that types are <em>definitionally</em> equal if they are beta-reducible to each other in the context of CiC (I'm guessing this is only vaguely accurate).</p>



<a name="233016363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233016363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233016363">(Apr 03 2021 at 16:22)</a>:</h4>
<p>For sure a category has only one terminal type up to unique isomorphism. However if you believe that it has one terminal type up to equality then I guess you're doing HoTT -- this is what Voevodsky believed.</p>



<a name="233016396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233016396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233016396">(Apr 03 2021 at 16:24)</a>:</h4>
<p><span class="user-mention" data-user-id="372804">@Marcus Rossel</span>  David (and Horatiu, in their question) is talking about Lean's <code>eq</code>, which I think some people call structural equality. It's an inductively defined proposition, which is weaker than definitional equality.</p>



<a name="233016903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233016903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233016903">(Apr 03 2021 at 16:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> what I'm wondering is, since <code>eq</code> is defined as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">eq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">eq</span> <span class="n">a</span>
</code></pre></div>
<p>... how can we show anything to be equal that is not already definitionally equal? With <code>n + 0 = n</code> I guess it makes sense intuitively, as we can just unfold the definition of addition and then get definitionally equal terms. But with <code>nat = int</code> I don't see how this would work.</p>



<a name="233017010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233017010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233017010">(Apr 03 2021 at 16:35)</a>:</h4>
<p>You should think about the <code>0 + n = n</code> example. For any explicit natural number like <code>37</code>, <code>0 + 37 = 37</code> is definitionally true. But if <code>n : nat</code> is arbitrary then<code>0 + n = n</code> is not definitional because you cannot unfold either side any more.</p>



<a name="233017039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233017039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233017039">(Apr 03 2021 at 16:35)</a>:</h4>
<p><code>nat = int</code> is not provable or disprovable in Lean, because it's "false" but the system has no way of expressing the reason it's false.</p>



<a name="233017116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233017116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233017116">(Apr 03 2021 at 16:37)</a>:</h4>
<p>You can show things to be equal which aren't definitionally equal because the conclusion of <code>nat.rec</code> is <code>forall n, C n</code> and if <code>C n</code> is <code>0 + n = n</code> then your proof involves an irreducible constant <code>nat.rec</code>.</p>



<a name="233017223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233017223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233017223">(Apr 03 2021 at 16:39)</a>:</h4>
<p>I think I misunderstand what is meant by "Lean is consistent with the assertion that two types are equal iff they have the same cardinality". Does this mean that all types of equal cardinality are equal?</p>



<a name="233017298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233017298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233017298">(Apr 03 2021 at 16:40)</a>:</h4>
<p>No, it means the weaker statement that if you have two types of the same cardinality then it is not possible to prove that they are unequal. <code>nat = int</code> in Lean is undecidable (assuming that Lean has no bugs and that Lean's dependent type theory is consistent).</p>



<a name="233017320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233017320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233017320">(Apr 03 2021 at 16:41)</a>:</h4>
<p>Had the designers done things in a different way (defining int to be a type wrapper for nat), then it could have been provable.</p>



<a name="233017384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233017384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233017384">(Apr 03 2021 at 16:42)</a>:</h4>
<p>Ahhh ok, thanks Kevin :)</p>



<a name="233017486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233017486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233017486">(Apr 03 2021 at 16:44)</a>:</h4>
<p>Actually I am slightly overstepping the mark -- I do not actually know how to prove (on paper) that it is impossible to prove <code>nat = int</code> in Lean with the current definitions of nat and int.</p>



<a name="233017524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233017524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233017524">(Apr 03 2021 at 16:46)</a>:</h4>
<p>I could be mistaken, but I think each time we declare an inductive type in Lean we’re effectively adding a bunch of new axioms to the system. Somehow this makes the undecidability of <code>nat = int</code> less surprising to me.</p>



<a name="233017530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233017530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233017530">(Apr 03 2021 at 16:46)</a>:</h4>
<p>Why doesn't <code>foo = bar</code> for heterogeneous types invoke some typeclass, and for nat and int one that says "no we're not equal" in a sense other than definitional equality</p>



<a name="233038591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20types%20are%20different/near/233038591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20types.20are.20different.html#233038591">(Apr 03 2021 at 22:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Proving.20types.20are.20different/near/233017486">said</a>:</p>
<blockquote>
<p>Actually I am slightly overstepping the mark -- I do not actually know how to prove (on paper) that it is impossible to prove <code>nat = int</code> in Lean with the current definitions of nat and int.</p>
</blockquote>
<p>There is another model for lean to help with this. If the "minimal model" is the one where types are cardinals and you define all the core inductive constants by bijecting the obvious definition to its cardinal, the "maximal model" is the one where types are "codes" that represent the way the type was constructed. You can think of the set of codes as being an inductive type with constructors <code>pi : code -&gt; code -&gt; code</code>, <code>univ : nat -&gt; code</code>, and <code>mu : nat -&gt; inductive_spec -&gt; list code -&gt; code</code>, where the nat parameter in <code>mu</code> is an arbitrary disambiguator so that even if two inductives have the same specification, you can still make countably many distinct copies of it. That way, <code>nat</code> and <code>int</code> have different disambiguators (and different specifications), so they are not equal.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Provably.20equal.20types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html">Provably equal types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="224416190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224416190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Brünjes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224416190">(Jan 29 2021 at 00:31)</a>:</h4>
<p>I have a family of types layer : \N -&gt; Type and a family of functions f i k : layer i -&gt; layer (i + k), for which I would like to show that it is transitive in the sense of f i (k + l) = f (i + k) l \o f i k. The problem is that this doesn't even type-check, because layer (i + (k + l)) and layer (i + k + l) are not definitionally equal. I can formulate my lemma using heterogenous equality, but I can't prove it.</p>
<p>Maybe it's necessary to understand how f is defined: I have a function step : layer n -&gt; layer (n + 1), and I define f via induction on k, using step.</p>
<p>Anyway, when I try to prove my lemma, I get stuck when I try to use f i (k + l)l x == f (i + k) l (f i k x) to conclude that step (f i (k + l) x) == step (f (i + k) l (f i k x)). I have tried various "congruence" lemmas like congr_arg_heq, but nothing works so far.</p>
<p>A hint would be highly appreciated!</p>



<a name="224416279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224416279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224416279">(Jan 29 2021 at 00:32)</a>:</h4>
<p>Yes, this is problematic in dependent type theory.</p>



<a name="224416368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224416368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224416368">(Jan 29 2021 at 00:33)</a>:</h4>
<p>One trick is to make the sigma type Sigma n, layer n and define define functions parametrised just by k from this sigma type to itself.</p>



<a name="224416436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224416436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224416436">(Jan 29 2021 at 00:34)</a>:</h4>
<p>One can also battle through the heq proof, but you should probably post a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> for this</p>



<a name="224416533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224416533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Brünjes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224416533">(Jan 29 2021 at 00:35)</a>:</h4>
<p>Thank you very much for the Sigma type idea - I'll give it a spin. If that won't work, I'll consider posting a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>.</p>



<a name="224416649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224416649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224416649">(Jan 29 2021 at 00:37)</a>:</h4>
<p>There is an extensive thread about this issue <a href="#narrow/stream/116395-maths/topic/CDGAs/near/167848869">here</a></p>



<a name="224416855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224416855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Brünjes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224416855">(Jan 29 2021 at 00:40)</a>:</h4>
<p>I'll have a look - thanks again! <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="224417076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224417076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224417076">(Jan 29 2021 at 00:42)</a>:</h4>
<p>I struggle through the heq proof, other people come up with tidier heq solutions and then Mario uses sigma types and it comes out much better.</p>



<a name="224418760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224418760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224418760">(Jan 29 2021 at 01:04)</a>:</h4>
<p>I did some heq stuff very recently in <a href="https://github.com/leanprover-community/mathlib/tree/eric-wieser/direct_sum-ring">branch#eric-wieser/direct_sum-ring</a></p>



<a name="224418870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224418870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224418870">(Jan 29 2021 at 01:06)</a>:</h4>
<p>But found that actually sigma equality was better than heq for my use case, because proving that <code>(x : layer j) == (y : layer i)</code> doesn't hold on to the proof that <code>i = j</code> (as <code>layer</code> could be defined as a constant type for all indices)</p>



<a name="224420774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224420774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224420774">(Jan 29 2021 at 01:32)</a>:</h4>
<p>I had the almost the same setup and the exact same problem, and I'd thought about using sigma types, but I decided it was easier to use indexed families of sets instead.  You can convert this back into an indexed family of types in the end if you need it.  One difference, though, was that I was specifically dealing with indexed families of finite types, so there were some reasons an indexed family of <code>finset</code>s was more convenient.</p>
<p>Here's how I encoded the family:<br>
<a href="https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/konig2.lean#L11">https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/konig2.lean#L11</a></p>



<a name="224422379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224422379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Brünjes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224422379">(Jan 29 2021 at 01:57)</a>:</h4>
<p>Thanks a lot for those hints!</p>



<a name="224422538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Provably%20equal%20types/near/224422538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Brünjes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Provably.20equal.20types.html#224422538">(Jan 29 2021 at 02:00)</a>:</h4>
<p>I managed to define my function for sigma types and also proved the desired "transitivity" property. Still struggling to translate that result back into the original heterogeneous equality - but I'm not sure I even need that. Maybe the statement on the level of sigma types is precisely what I really need...</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/subtypes.20.2F.20restrictions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.20.2F.20restrictions.html">subtypes / restrictions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="263121471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes%20/%20restrictions/near/263121471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.20.2F.20restrictions.html#263121471">(Nov 30 2021 at 09:52)</a>:</h4>
<p>I tried to find a proof that a restriction of an injective map is injective <em>by library_search</em> but didn't succeed.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">function.injective</span> <span class="o">(</span><span class="n">set.restrict</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">subtype.ext_val</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>By the way, I wonder, in the situation of a map <code>fin n.succ \to \alpha</code> how one should get its restriction to <code>fin n</code>. <br>
Maybe it is better to do just by composition with <code>fin.cast_le (nat.le_succ n)</code> (it saves a quantifier).</p>



<a name="263121549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes%20/%20restrictions/near/263121549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.20.2F.20restrictions.html#263121549">(Nov 30 2021 at 09:53)</a>:</h4>
<p>I would certainly use the composition</p>



<a name="263121567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes%20/%20restrictions/near/263121567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.20.2F.20restrictions.html#263121567">(Nov 30 2021 at 09:53)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.vec_tail">docs#matrix.vec_tail</a>?</p>



<a name="263123217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes%20/%20restrictions/near/263123217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.20.2F.20restrictions.html#263123217">(Nov 30 2021 at 10:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/subtypes.20.2F.20restrictions/near/263121549">said</a>:</p>
<blockquote>
<p>I would certainly use the composition</p>
</blockquote>
<p>Which means, by the way, that good writing in Lean  probably requires thinking categorically.</p>



<a name="263123346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes%20/%20restrictions/near/263123346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.20.2F.20restrictions.html#263123346">(Nov 30 2021 at 10:09)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> There's certainly a tendency towards that. Type theory nudges you in that direction.</p>



<a name="263123981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes%20/%20restrictions/near/263123981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.20.2F.20restrictions.html#263123981">(Nov 30 2021 at 10:16)</a>:</h4>
<p>I’m curious : does <code>hf.comp subtype.coe_injective</code> work as a proof of your example ?</p>



<a name="263124916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes%20/%20restrictions/near/263124916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.20.2F.20restrictions.html#263124916">(Nov 30 2021 at 10:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="268315">Anatole Dedecker</span> <a href="#narrow/stream/113489-new-members/topic/subtypes.20.2F.20restrictions/near/263123981">said</a>:</p>
<blockquote>
<p>I’m curious : does <code>hf.comp subtype.coe_injective</code> work as a proof of your example ?</p>
</blockquote>
<p>Yes !</p>



<a name="263127897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes%20/%20restrictions/near/263127897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.20.2F.20restrictions.html#263127897">(Nov 30 2021 at 10:56)</a>:</h4>
<p>So in fact <code>set.restrict</code> is already the composition with <code>coe</code></p>



<a name="263129917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtypes%20/%20restrictions/near/263129917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtypes.20.2F.20restrictions.html#263129917">(Nov 30 2021 at 11:16)</a>:</h4>
<p>I see. In fact, to propose a mwe, I had simplified my own stuff where s was a <code>set.range</code> of an injective map (<code>nat.cast_le _</code>), hence the simplification. As Johan wrote, it is probably better to compose explicitly with <code>coe</code> in my case.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
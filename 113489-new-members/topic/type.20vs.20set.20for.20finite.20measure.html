---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html">type vs set for finite measure</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="208768265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208768265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208768265">(Sep 02 2020 at 01:02)</a>:</h4>
<p>I'm not sure if I want </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">F</span> <span class="o">(</span><span class="n">X</span><span class="o">:</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">):</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">nnreal</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">}</span> <span class="o">:=</span>
<span class="bp">λ</span><span class="n">x</span><span class="o">,</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">p</span> <span class="o">{</span><span class="n">ω</span> <span class="bp">|</span> <span class="n">X</span> <span class="n">ω</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span>
<span class="k">in</span> <span class="bp">⟨</span> <span class="n">y</span><span class="bp">.</span><span class="n">to_nnreal</span><span class="o">,</span> <span class="n">sorry</span> <span class="bp">⟩</span>
</code></pre></div>


<p>or to define a type <code>{x : nnreal // x ≤ 1}</code> and use that instead. Either way I don't know how to use the <a href="https://leanprover-community.github.io/mathlib_docs/measure_theory/measure_space.html#measure_theory.probability_measure">definition</a> to show that p &lt;=1.</p>
<p>Context is</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span><span class="bp">.</span><span class="n">intervals</span>
<span class="kn">import</span> <span class="n">measure_theory</span><span class="bp">.</span><span class="n">measure_space</span>


<span class="kn">open</span> <span class="n">measure_theory</span>


<span class="n">open_locale</span> <span class="n">big_operators</span>


<span class="n">noncomputable</span> <span class="n">theory</span>


<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="err">Ω</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">measure</span> <span class="err">Ω</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_measure</span> <span class="n">p</span><span class="o">]</span>


<span class="n">def</span> <span class="n">F</span> <span class="o">(</span><span class="n">X</span><span class="o">:</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">):</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">nnreal</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">}</span> <span class="o">:=</span>
<span class="bp">λ</span><span class="n">x</span><span class="o">,</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">p</span> <span class="o">{</span><span class="n">ω</span> <span class="bp">|</span> <span class="n">X</span> <span class="n">ω</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span>
<span class="k">in</span> <span class="bp">⟨</span> <span class="n">y</span><span class="bp">.</span><span class="n">to_nnreal</span><span class="o">,</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="c1">-- y: ennreal := ⇑p {ω : Ω | X ω ≤ x}</span>
<span class="c1">-- ⊢ y.to_nnreal ≤ 1</span>
<span class="kn">end</span>
<span class="bp">⟩</span>
</code></pre></div>



<a name="208768433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208768433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208768433">(Sep 02 2020 at 01:05)</a>:</h4>
<p>e.g. <code>unfold</code> doesn't seem to work on <code>structure</code>s so idk how to expand the <code>set.univ = 1</code></p>



<a name="208784925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208784925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208784925">(Sep 02 2020 at 06:35)</a>:</h4>
<p>There is Icc 0 1 for the interval [0,1].</p>



<a name="208784991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208784991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208784991">(Sep 02 2020 at 06:36)</a>:</h4>
<p>How should I think about "do I want a type or a set"?</p>



<a name="208785021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208785021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208785021">(Sep 02 2020 at 06:37)</a>:</h4>
<p>You want a type</p>



<a name="208785035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208785035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208785035">(Sep 02 2020 at 06:37)</a>:</h4>
<p>They're a more primitive notion</p>



<a name="208785104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208785104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208785104">(Sep 02 2020 at 06:38)</a>:</h4>
<p>Of course I'm being a bit silly here. You want a set if you want to do intersections, unions etc</p>



<a name="208785158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208785158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208785158">(Sep 02 2020 at 06:39)</a>:</h4>
<p>But the target of a function had better be a type. There's a coercion from sets to types though, and if you keep your head it's not hard to use. A term of type weird up arrow s is a pair consisting of a term of type X and a proof that it's an element of s</p>



<a name="208785678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208785678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208785678">(Sep 02 2020 at 06:49)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">probability</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">interval</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">_</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Icc</span> <span class="mi">0</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">in</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">_</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">interval</span> <span class="o">}</span>
</code></pre></div>


<p>Do I want in the <code>_</code> real/nnreal/ennreal/complex/doesn't matter?</p>



<a name="208786400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208786400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208786400">(Sep 02 2020 at 07:00)</a>:</h4>
<p>anyway that leaves me with </p>
<div class="codehilite"><pre><span></span><code><span class="n">y</span><span class="o">:</span> <span class="n">ennreal</span> <span class="o">:=</span> <span class="err">⇑</span><span class="n">p</span> <span class="o">{</span><span class="n">ω</span> <span class="o">:</span> <span class="err">Ω</span> <span class="bp">|</span> <span class="n">X</span> <span class="n">ω</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span>
<span class="err">⊢</span> <span class="err">↑</span><span class="o">(</span><span class="n">y</span><span class="bp">.</span><span class="n">to_nnreal</span><span class="o">)</span> <span class="bp">≤</span> <span class="mi">1</span>
</code></pre></div>


<p>but I can't <code>unfold probability_measure at p</code> to get the <code>&lt;= 1</code>, is there a similar thing to <code>unfold</code> but for <code>structure</code>s?</p>



<a name="208786474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208786474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208786474">(Sep 02 2020 at 07:01)</a>:</h4>
<p><del>#mwe</del> (sorry)</p>



<a name="208786544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208786544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208786544">(Sep 02 2020 at 07:02)</a>:</h4>
<p>see above</p>



<a name="208786684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208786684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208786684">(Sep 02 2020 at 07:04)</a>:</h4>
<p>(updated)</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span><span class="bp">.</span><span class="n">intervals</span>
<span class="kn">import</span> <span class="n">measure_theory</span><span class="bp">.</span><span class="n">measure_space</span>


<span class="kn">open</span> <span class="n">measure_theory</span> <span class="n">set</span>


<span class="n">open_locale</span> <span class="n">big_operators</span>


<span class="n">noncomputable</span> <span class="n">theory</span>


<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="err">Ω</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">measure</span> <span class="err">Ω</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_measure</span> <span class="n">p</span><span class="o">]</span>


<span class="n">def</span> <span class="n">probability</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">interval</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Icc</span> <span class="mi">0</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">in</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">interval</span> <span class="o">}</span>


<span class="n">def</span> <span class="n">F</span> <span class="o">(</span><span class="n">X</span><span class="o">:</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">):</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">probability</span> <span class="o">:=</span>
<span class="bp">λ</span><span class="n">x</span><span class="o">,</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">p</span> <span class="o">{</span><span class="n">ω</span> <span class="bp">|</span> <span class="n">X</span> <span class="n">ω</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span>
<span class="k">in</span> <span class="bp">⟨</span> <span class="n">y</span><span class="bp">.</span><span class="n">to_nnreal</span><span class="o">,</span>
<span class="k">begin</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
<span class="bp">⟩</span>
</code></pre></div>



<a name="208786979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208786979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208786979">(Sep 02 2020 at 07:09)</a>:</h4>
<p>The API for <code>probability_measure</code> seems to be basically nonexistent. Someone should fix this!</p>



<a name="208786999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208786999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208786999">(Sep 02 2020 at 07:09)</a>:</h4>
<p>At the moment it looks like you have argue that the measure is at most the measure of <code>set.univ</code>, which is then equal to one.</p>



<a name="208787004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208787004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208787004">(Sep 02 2020 at 07:10)</a>:</h4>
<p>Obviously there should be a one-step lemma saying exactly that.</p>



<a name="208787365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208787365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208787365">(Sep 02 2020 at 07:15)</a>:</h4>
<p>Note that it is probably a bad idea to let the probability take value in the set <code>[0, 1]</code>, because we keep adding or subtracting probabilities in proofs, and this type doesn't have an addition nor a subtraction. Why not simply use the real-valued function?</p>



<a name="208787585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208787585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208787585">(Sep 02 2020 at 07:18)</a>:</h4>
<p>sometimes I will want to use that the value is &lt;= 1, so I could put that into the type and then it would be readily available</p>



<a name="208787741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208787741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208787741">(Sep 02 2020 at 07:20)</a>:</h4>
<p>e.g. next I want to say the right-hand limit of the distribution function is 1. it seems convenient to know that it's increasing and  &lt;=1. Is that the wrong way to go?</p>



<a name="208787962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208787962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208787962">(Sep 02 2020 at 07:24)</a>:</h4>
<p>Just have a separate lemma that it is at most one. Bundling that into a subtype doesn't seem to gain much.</p>



<a name="208790251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208790251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208790251">(Sep 02 2020 at 07:51)</a>:</h4>
<p>What do <code>h</code> and <code>H</code> mean?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span><span class="bp">.</span><span class="n">intervals</span>
<span class="kn">import</span> <span class="n">measure_theory</span><span class="bp">.</span><span class="n">measure_space</span>


<span class="kn">open</span> <span class="n">measure_theory</span> <span class="n">set</span>


<span class="n">open_locale</span> <span class="n">big_operators</span>


<span class="n">noncomputable</span> <span class="n">theory</span>


<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="err">Ω</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">measure</span> <span class="err">Ω</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_measure</span> <span class="n">p</span><span class="o">]</span>


<span class="kn">lemma</span> <span class="n">probability_1</span> <span class="o">:</span> <span class="n">p</span> <span class="n">univ</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">F</span> <span class="o">(</span><span class="n">X</span><span class="o">:</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ennreal</span> <span class="o">:=</span>
<span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="o">{</span><span class="n">ω</span> <span class="bp">|</span> <span class="n">X</span> <span class="n">ω</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span>


<span class="kn">lemma</span> <span class="n">F_le_1</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span> <span class="n">p</span> <span class="n">X</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">x</span> <span class="n">pr</span> <span class="n">h</span><span class="o">,</span>
<span class="c1">-- tactic failed, there are unsolved goals</span>
<span class="c1">-- state:</span>
<span class="c1">-- Ω : Type u_1,</span>
<span class="c1">-- _inst_1 : measurable_space Ω,</span>
<span class="c1">-- p : measure Ω,</span>
<span class="c1">-- _inst_2 : probability_measure p,</span>
<span class="c1">-- X : Ω → ℝ,</span>
<span class="c1">-- x : ℝ,</span>
<span class="c1">-- pr : nnreal,</span>
<span class="c1">-- h : pr ∈ 1 x</span>
<span class="c1">-- ⊢ ∃ (b : nnreal) (H : b ∈ F p X x), b ≤ pr</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208880304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208880304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208880304">(Sep 02 2020 at 20:08)</a>:</h4>
<p>How can I solve this using <a href="https://leanprover-community.github.io/mathlib_docs/measure_theory/measure_space.html#measure_theory.probability_measure"><code>measure_univ</code></a>?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span><span class="bp">.</span><span class="n">intervals</span>
<span class="kn">import</span> <span class="n">measure_theory</span><span class="bp">.</span><span class="n">measure_space</span>


<span class="kn">open</span> <span class="n">measure_theory</span> <span class="n">set</span>


<span class="n">open_locale</span> <span class="n">big_operators</span>


<span class="n">noncomputable</span> <span class="n">theory</span>


<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="err">Ω</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">measure</span> <span class="err">Ω</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_measure</span> <span class="n">p</span><span class="o">]</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">p</span> <span class="n">univ</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="208880693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208880693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208880693">(Sep 02 2020 at 20:11)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="n">p</span> <span class="n">univ</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">measure_univ</span>
</code></pre></div>



<a name="208881239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208881239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208881239">(Sep 02 2020 at 20:15)</a>:</h4>
<p>You can find this by trying <code>by library_search</code> and following whatever advice it gives you, or by looking at the type of <code>measure_univ</code> and noticing it has no explicit argument: the fact that the measure is a probability measure is an assumption written between <code>[...]</code>, which means that Lean will check this assumption all by itself (through a process called typeclass inference that you don't need to understand when you start with Lean).</p>



<a name="208881446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208881446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208881446">(Sep 02 2020 at 20:17)</a>:</h4>
<p>Oh oops, not sure how I missed that.</p>



<a name="208881845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208881845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208881845">(Sep 02 2020 at 20:20)</a>:</h4>
<p>any idea what <code>h : pr ∈ 1 x</code> means in the above snippet? what is <code>1 x</code>? it looks like <code>1</code> is somehow a set-returning function...</p>



<a name="208882179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208882179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208882179">(Sep 02 2020 at 20:23)</a>:</h4>
<p>What made you think <code>intros x pr h</code> was a good idea?</p>



<a name="208882195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208882195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208882195">(Sep 02 2020 at 20:23)</a>:</h4>
<p>It looks like you've opened up the definition of <code>ennreal</code></p>



<a name="208882323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208882323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208882323">(Sep 02 2020 at 20:24)</a>:</h4>
<p>I didn't know what else to do, and <code>hint</code> suggested it</p>



<a name="208882401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208882401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208882401">(Sep 02 2020 at 20:24)</a>:</h4>
<p>I would unsuggest it</p>



<a name="208882462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208882462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208882462">(Sep 02 2020 at 20:25)</a>:</h4>
<p>ok</p>



<a name="208882471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208882471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208882471">(Sep 02 2020 at 20:25)</a>:</h4>
<p>Your goal is to prove an inequality--<code>intros</code> isn't a logical step unless you know what that inequality really means.</p>



<a name="208882719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208882719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208882719">(Sep 02 2020 at 20:27)</a>:</h4>
<p>presumably the argument you want is that whatever set we're taking the probability of, it's contained in <code>univ</code>, which has measure 1, so the original probability is at most 1</p>



<a name="208882738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208882738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208882738">(Sep 02 2020 at 20:27)</a>:</h4>
<p>really, it should be a lemma that already exists</p>



<a name="208890965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20vs%20set%20for%20finite%20measure/near/208890965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20vs.20set.20for.20finite.20measure.html#208890965">(Sep 02 2020 at 21:35)</a>:</h4>
<p>Is that lemma <a href="https://leanprover-community.github.io/mathlib_docs/measure_theory/measure_space.html#measure_theory.measure_lt_top"><code>measure_lt_top</code></a>?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/use.20lemma.20in.20definition.20of.20class.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/use.20lemma.20in.20definition.20of.20class.html">use lemma in definition of class</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="291150653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/use%20lemma%20in%20definition%20of%20class/near/291150653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Raphael Appenzeller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/use.20lemma.20in.20definition.20of.20class.html#291150653">(Jul 28 2022 at 07:45)</a>:</h4>
<p>I have a definition of an interval <code>[a, b]</code> (with values in <code>\Z</code>). I then prove that <code>a \in [a , b]</code> and <code>b \in [a , b]</code>. I would then like to define a class which consists of a map <code>to_fun : [a , b] \to X</code> and two points <code>p q : X</code> such that <code>to_fun a = p</code> and <code>to_fun b = q</code>. The problem is that in the definition of the class Lean does not know that <code>a, b \in [a, b]</code>. Can I somehow tell Lean to use my two lemmas? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">my_interval_a_b</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span>  <span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">t</span> <span class="o">:</span> <span class="n">ℤ</span>  <span class="bp">|</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">t</span> <span class="bp">∧</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">}</span>
<span class="kd">lemma</span> <span class="n">a_in_my_interval_a_b</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span><span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">my_interval_a_b</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
<span class="kd">lemma</span> <span class="n">b_in_my_interval_a_b</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span><span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">my_interval_a_b</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
<span class="kd">class</span> <span class="n">my_map_interval_X</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">my_interval_a_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">fro</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)</span> <span class="c1">-- here is the problem</span>
<span class="o">(</span><span class="n">tos</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">q</span><span class="o">)</span>
</code></pre></div>



<a name="291150870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/use%20lemma%20in%20definition%20of%20class/near/291150870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/use.20lemma.20in.20definition.20of.20class.html#291150870">(Jul 28 2022 at 07:48)</a>:</h4>
<p>The first sorry is solved by</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">le_of_eq</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
</code></pre></div>
<p>or simply <code>λ h, ⟨le_of_eq rfl, h⟩</code> (without <code>begin ... end</code>).<br>
I'm sure you can work out the second one!</p>



<a name="291151006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/use%20lemma%20in%20definition%20of%20class/near/291151006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/use.20lemma.20in.20definition.20of.20class.html#291151006">(Jul 28 2022 at 07:50)</a>:</h4>
<p>If you use the mathlib interval you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/set.right_mem_Icc">docs#set.right_mem_Icc</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/set.left_mem_Icc">docs#set.left_mem_Icc</a>.</p>



<a name="291151341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/use%20lemma%20in%20definition%20of%20class/near/291151341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Raphael Appenzeller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/use.20lemma.20in.20definition.20of.20class.html#291151341">(Jul 28 2022 at 07:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/113489-new-members/topic/use.20lemma.20in.20definition.20of.20class/near/291150870">said</a>:</p>
<blockquote>
<p>The first sorry is solved by</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">le_of_eq</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
</code></pre></div>
<p>or simply <code>λ h, ⟨le_of_eq rfl, h⟩</code> (without <code>begin ... end</code>).<br>
I'm sure you can work out the second one!</p>
</blockquote>
<p>Thanks! I indeed already have proofs for the lemmas, but decided not to include them for simplicity. My question is about defining the class.</p>



<a name="291152478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/use%20lemma%20in%20definition%20of%20class/near/291152478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/use.20lemma.20in.20definition.20of.20class.html#291152478">(Jul 28 2022 at 08:08)</a>:</h4>
<p>I'm not at lean right now but just to say that this looks like it should be a structure, not a class. With a class you're expected to have at most one instance, with a funny name like <code>_inst_37</code>, for every triple X, a, b. Is this what you want? And note that you shouldn't reinvent the wheel for intervals, just use <code>Icc</code> where you have a bunch of lemmas already (like all the obvious inclusions).</p>
<p>With regard to your actual question, the type of a is <code>int</code> and the type of <code>my_interval_a_b a b</code> is <code>set int</code> (not <code>Type*</code>) so it doesn't even make sense to ask that a has type <code>my_interval_a_b a b</code>. If you look at how lean is interpreting it you'll probably see one of those funny up-arrows which mean "I'm promoting this term to a type because it's the only way I can make sense of things". Did you want your original interval to be a type rather than a term? As it is you can refer to the term of type <code>\(whatever the right up arrow is) my_interval_a_b a b</code> corresponding to a by the pair <code>\&lt;a, ha\&gt;</code> where <code>ha</code> is a proof that a is in your interval. Sorry not to be more coherent but it seems that there's a bunch of sleeping teenagers in the room where my computer is...</p>



<a name="291153142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/use%20lemma%20in%20definition%20of%20class/near/291153142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/use.20lemma.20in.20definition.20of.20class.html#291153142">(Jul 28 2022 at 08:16)</a>:</h4>
<p>Sorry for not reading the question carefully. This is what you can do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kd">def</span> <span class="n">my_interval_a_b</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">|</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">t</span> <span class="bp">∧</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">}</span>
<span class="kd">lemma</span> <span class="n">a_in_my_interval_a_b</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">my_interval_a_b</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">le_of_eq</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>
<span class="kd">lemma</span> <span class="n">b_in_my_interval_a_b</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">my_interval_a_b</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">h</span><span class="o">,</span> <span class="n">le_of_eq</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">structure</span> <span class="n">my_map_interval_X</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">my_interval_a_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">fro</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">a_in_my_interval_a_b</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)</span>
<span class="o">(</span><span class="n">tos</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">b_in_my_interval_a_b</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">=</span> <span class="n">q</span><span class="o">)</span>
</code></pre></div>



<a name="291153290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/use%20lemma%20in%20definition%20of%20class/near/291153290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/use.20lemma.20in.20definition.20of.20class.html#291153290">(Jul 28 2022 at 08:18)</a>:</h4>
<p><code>my_interval_a_b a b</code> is coerced to a type using <a href="https://leanprover-community.github.io/mathlib_docs/find/set.has_coe_to_sort">docs#set.has_coe_to_sort</a>, once you import data.set.basic. It's common to use sets as types in mathlib, for example in <a href="https://leanprover-community.github.io/mathlib_docs/find/unit_interval.coe_eq_zero">docs#unit_interval.coe_eq_zero</a> etc.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
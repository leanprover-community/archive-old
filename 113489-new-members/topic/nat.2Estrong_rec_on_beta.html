---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html">nat.strong_rec_on_beta</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="193703897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193703897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193703897">(Apr 12 2020 at 09:45)</a>:</h4>
<p>How do I prove this?</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_beta</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">ih</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span> <span class="n">n</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ih</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">hmn</span><span class="o">,</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span> <span class="n">m</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">m</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>



<a name="193703947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193703947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193703947">(Apr 12 2020 at 09:46)</a>:</h4>
<p>Induction?</p>



<a name="193704457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193704457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193704457">(Apr 12 2020 at 10:00)</a>:</h4>
<p>nat.strong_rec_on is defined using this auxiliary lemma saying that if <code>(ih : ∀ n, (∀ m, m &lt; n → p m) → p n)</code> then <code>∀ n m, m &lt; n → p m</code>.</p>



<a name="193708176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193708176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193708176">(Apr 12 2020 at 11:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">strong_rec_on</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">suffices</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">m</span><span class="o">,</span> <span class="k">from</span> <span class="n">this</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">n</span> <span class="o">(</span><span class="n">lt_succ_self</span> <span class="bp">_</span><span class="o">),</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">n</span><span class="o">,</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span><span class="n">intros</span> <span class="n">m</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">exact</span> <span class="n">absurd</span> <span class="n">h₁</span> <span class="o">(</span><span class="n">not_lt_zero</span> <span class="bp">_</span><span class="o">)},</span>
    <span class="o">{</span><span class="n">intros</span> <span class="n">m</span> <span class="n">h₁</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">or</span><span class="bp">.</span><span class="n">by_cases</span> <span class="o">(</span><span class="n">lt_or_eq_of_le</span> <span class="o">(</span><span class="n">le_of_lt_succ</span> <span class="n">h₁</span><span class="o">)),</span>
        <span class="o">{</span><span class="n">intros</span><span class="o">,</span> <span class="n">apply</span> <span class="n">ih</span><span class="o">,</span> <span class="n">assumption</span><span class="o">},</span>
        <span class="o">{</span><span class="n">intros</span><span class="o">,</span> <span class="n">subst</span> <span class="n">m</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span> <span class="bp">_</span> <span class="n">ih</span><span class="o">}}</span>
<span class="kn">end</span>
</pre></div>



<a name="193708178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193708178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193708178">(Apr 12 2020 at 11:01)</a>:</h4>
<p>this is the definition of <code>nat.strong_rec_on</code> in core</p>



<a name="193708183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193708183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193708183">(Apr 12 2020 at 11:01)</a>:</h4>
<p>the tactics aren't the problem; the <code>subst</code> is</p>



<a name="193709204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709204">(Apr 12 2020 at 11:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">open</span> <span class="n">nat</span>

<span class="n">def</span> <span class="n">strong_rec_on_aux</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">h₁</span> <span class="o">(</span><span class="n">not_lt_zero</span> <span class="bp">_</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">ih</span> <span class="n">m</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">by_cases</span> <span class="o">(</span><span class="n">lt_or_eq_of_le</span> <span class="o">(</span><span class="n">le_of_lt_succ</span> <span class="n">h₁</span><span class="o">))</span>
    <span class="o">(</span><span class="n">ih</span> <span class="bp">_</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">h₁</span><span class="o">,</span> <span class="k">by</span> <span class="n">subst</span> <span class="n">m</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">h</span> <span class="bp">_</span> <span class="n">ih</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">strong_rec_on_aux_succ</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="n">h₁</span><span class="o">):</span>
<span class="n">strong_rec_on_aux</span> <span class="n">h</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">m</span> <span class="n">h₁</span> <span class="bp">=</span>
  <span class="n">or</span><span class="bp">.</span><span class="n">by_cases</span> <span class="o">(</span><span class="n">lt_or_eq_of_le</span> <span class="o">(</span><span class="n">le_of_lt_succ</span> <span class="n">h₁</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">strong_rec_on_aux</span> <span class="n">h</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">hmn</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">h₁</span><span class="o">,</span> <span class="k">by</span> <span class="n">subst</span> <span class="n">m</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">h</span> <span class="bp">_</span> <span class="o">(</span><span class="n">strong_rec_on_aux</span> <span class="n">h</span> <span class="bp">_</span><span class="o">))</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_beta_aux</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">h</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span> <span class="n">n</span> <span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span>
  <span class="o">(</span><span class="n">strong_rec_on_aux</span> <span class="n">h</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">n</span> <span class="o">(</span><span class="n">lt_succ_self</span> <span class="bp">_</span><span class="o">))</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_beta</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">h</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span> <span class="n">n</span> <span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span>
    <span class="n">h</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">hmn</span><span class="o">,</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span> <span class="n">m</span> <span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="n">m</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_beta_aux</span><span class="o">,</span>
    <span class="n">strong_rec_on_aux_succ</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">by_cases</span><span class="o">,</span> <span class="n">dif_pos</span><span class="o">,</span> <span class="n">not_lt</span><span class="o">,</span> <span class="n">dif_neg</span><span class="o">],</span>
  <span class="n">congr</span><span class="o">,</span> <span class="n">funext</span> <span class="n">m</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">not_lt_zero</span> <span class="bp">_</span> <span class="n">h₁</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="o">(</span><span class="n">lt_or_eq_of_le</span> <span class="o">(</span><span class="n">le_of_lt_succ</span> <span class="n">h₁</span><span class="o">))</span> <span class="k">with</span> <span class="n">hmn</span> <span class="n">hmn</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="err">←</span> <span class="n">ih</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">strong_rec_on_aux_succ</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">by_cases</span><span class="o">,</span> <span class="n">hmn</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">m</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">strong_rec_on_aux_succ</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">by_cases</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>



<a name="193709266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709266">(Apr 12 2020 at 11:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> your definition is finally complete :-)</p>



<a name="193709268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709268">(Apr 12 2020 at 11:32)</a>:</h4>
<p>That took far too long</p>



<a name="193709275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709275">(Apr 12 2020 at 11:32)</a>:</h4>
<p>Is there a reason not to use <code>well_founded.fix</code> here?</p>



<a name="193709332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709332">(Apr 12 2020 at 11:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> hmm that's slightly different from my approach (which I haven't finished)</p>



<a name="193709417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709417">(Apr 12 2020 at 11:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">def</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">rec</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">h₁</span> <span class="err">$</span> <span class="n">nat</span><span class="bp">.</span><span class="n">not_lt_zero</span> <span class="bp">_</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">ih</span> <span class="n">m</span> <span class="n">h₁</span><span class="o">,</span>
<span class="n">or</span><span class="bp">.</span><span class="n">by_cases</span> <span class="o">(</span><span class="n">lt_or_eq_of_le</span> <span class="err">$</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_of_lt_succ</span> <span class="n">h₁</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="n">m</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">hmn</span><span class="o">,</span>
<span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">hmn</span><span class="bp">.</span><span class="n">symm</span> <span class="err">$</span> <span class="n">rec</span> <span class="n">n</span> <span class="n">ih</span>

<span class="kn">theorem</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_def</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">ih</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span> <span class="n">n</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="n">ih</span> <span class="bp">_</span> <span class="n">n</span><span class="bp">.</span><span class="n">lt_succ_self</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux</span> <span class="n">or</span><span class="bp">.</span><span class="n">by_cases</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">dif_neg</span> <span class="n">n</span><span class="bp">.</span><span class="n">lt_irrefl</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">dif_neg</span> <span class="n">n</span><span class="bp">.</span><span class="n">lt_irrefl</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">rfl</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span>
  <span class="n">split_ifs</span><span class="o">,</span> <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span> <span class="o">{</span> <span class="n">subst</span> <span class="n">h_1</span> <span class="o">},</span> <span class="o">{</span> <span class="n">refl</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux_eq</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">rec</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hmn</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux</span> <span class="n">n</span> <span class="n">rec</span> <span class="n">m</span> <span class="n">hmn</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span> <span class="n">rec</span> <span class="n">m</span> <span class="n">m</span><span class="bp">.</span><span class="n">lt_succ_self</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">hmn</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hmn</span> <span class="n">ih</span><span class="o">,</span> <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="err">←</span> <span class="n">ih</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux</span> <span class="n">or</span><span class="bp">.</span><span class="n">by_cases</span><span class="o">,</span> <span class="n">rw</span> <span class="n">dif_pos</span> <span class="o">(</span><span class="k">show</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">hmn</span><span class="o">)</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux_beta</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">rec</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="n">rec</span> <span class="n">n</span> <span class="n">n</span><span class="bp">.</span><span class="n">lt_succ_self</span> <span class="bp">=</span>
  <span class="n">rec</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span> <span class="n">rec</span> <span class="n">m</span> <span class="n">m</span><span class="bp">.</span><span class="n">lt_succ_self</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">change</span> <span class="n">or</span><span class="bp">.</span><span class="n">by_cases</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">=</span> <span class="bp">_</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">or</span><span class="bp">.</span><span class="n">by_cases</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">dif_neg</span> <span class="n">n</span><span class="bp">.</span><span class="n">lt_irrefl</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">rfl</span><span class="o">],</span>
  <span class="n">change</span> <span class="n">rec</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux</span> <span class="n">n</span> <span class="n">rec</span> <span class="n">m</span> <span class="n">hmn</span><span class="o">)</span> <span class="bp">=</span> <span class="n">rec</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span> <span class="n">rec</span> <span class="n">m</span> <span class="n">m</span><span class="bp">.</span><span class="n">lt_succ_self</span><span class="o">),</span>
  <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span> <span class="n">ext</span> <span class="n">m</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux_eq</span> <span class="n">n</span> <span class="n">rec</span> <span class="n">m</span> <span class="n">hmn</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_beta</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">rec</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span> <span class="n">n</span> <span class="n">rec</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">rec</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">hmn</span><span class="o">,</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span> <span class="n">m</span> <span class="n">rec</span> <span class="o">:</span> <span class="n">P</span> <span class="n">m</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">convert</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux_beta</span> <span class="n">n</span> <span class="n">rec</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_def</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">m</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_def</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>



<a name="193709420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709420">(Apr 12 2020 at 11:37)</a>:</h4>
<p>I first proved that the aux is independent of <code>n</code></p>



<a name="193709426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709426">(Apr 12 2020 at 11:37)</a>:</h4>
<p>the crucial lemma:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux_eq</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">rec</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hmn</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux</span> <span class="n">n</span> <span class="n">rec</span> <span class="n">m</span> <span class="n">hmn</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on_aux</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span> <span class="n">rec</span> <span class="n">m</span> <span class="n">m</span><span class="bp">.</span><span class="n">lt_succ_self</span> <span class="o">:=</span>
</pre></div>



<a name="193709484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709484">(Apr 12 2020 at 11:39)</a>:</h4>
<p>That's so crazy that it is in some sense deep. If you were to ask a mathematician to prove it they would of course say that it was trivial by induction. Is this assertion in some sense false?</p>



<a name="193709492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709492">(Apr 12 2020 at 11:40)</a>:</h4>
<p>I'm not even sure they would mention induction, they would just say it was trivial.</p>



<a name="193709537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709537">(Apr 12 2020 at 11:40)</a>:</h4>
<p>I'm actually suspicious because this is usually trivial in lean</p>



<a name="193709549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709549">(Apr 12 2020 at 11:41)</a>:</h4>
<p>Well go ahead and beat two of Imperial's finest ;-)</p>



<a name="193709607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709607">(Apr 12 2020 at 11:42)</a>:</h4>
<p>It's difficult because of how it's defined with the <code>suffices</code>.</p>



<a name="193709612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709612">(Apr 12 2020 at 11:42)</a>:</h4>
<p>what's the definition look like?</p>



<a name="193709613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709613">(Apr 12 2020 at 11:42)</a>:</h4>
<p>Perhaps a better question is to think about Patrick's original question.</p>



<a name="193709621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709621">(Apr 12 2020 at 11:43)</a>:</h4>
<p>Kenny posted the core def at the top</p>



<a name="193709678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709678">(Apr 12 2020 at 11:44)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">intervals</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">γ</span><span class="o">]</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">γ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">t</span><span class="o">,</span>  <span class="n">finite</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">P</span> <span class="n">c</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">u</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="err">&#39;&#39;</span> <span class="n">Iio</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>


<p>This was Patrick's question which started it all off. Kenny proposed an approach via the lemma in this thread.</p>



<a name="193709679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709679">(Apr 12 2020 at 11:44)</a>:</h4>
<p>Oh I see, so the <code>aux</code> that you both defined is that bit after the <code>suffices</code></p>



<a name="193709680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709680">(Apr 12 2020 at 11:44)</a>:</h4>
<p>yeah</p>



<a name="193709694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709694">(Apr 12 2020 at 11:45)</a>:</h4>
<p>I discovered this approach independently <a href="https://github.com/ImperialCollegeLondon/natural_number_game/blob/38a7adcdfdb18c49c87b37831736c8f15300d821/src/game/world10/level18a.lean#L289" title="https://github.com/ImperialCollegeLondon/natural_number_game/blob/38a7adcdfdb18c49c87b37831736c8f15300d821/src/game/world10/level18a.lean#L289">in NNG</a>.</p>



<a name="193709737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709737">(Apr 12 2020 at 11:46)</a>:</h4>
<p>but your thing is a Prop so proof is irrelevant</p>



<a name="193709740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709740">(Apr 12 2020 at 11:46)</a>:</h4>
<p>Right!</p>



<a name="193709741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709741">(Apr 12 2020 at 11:46)</a>:</h4>
<p>here the actual definitions matter</p>



<a name="193709744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709744">(Apr 12 2020 at 11:46)</a>:</h4>
<p>Yeah I'm well aware.</p>



<a name="193709748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709748">(Apr 12 2020 at 11:46)</a>:</h4>
<p>All the stuff proved by <code>nat.rec</code> is hidden from the user in NNG. I give them <code>zero_ne_succ</code> and <code>succ_inj</code> as axioms.</p>



<a name="193709755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709755">(Apr 12 2020 at 11:47)</a>:</h4>
<p>Recursion is much harder than induction in Lean.</p>



<a name="193709801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709801">(Apr 12 2020 at 11:48)</a>:</h4>
<p>NNG level 999: define a transfer tactic between mynat and nat, then use it to redo every level</p>



<a name="193709805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709805">(Apr 12 2020 at 11:48)</a>:</h4>
<p>If you can't do it in a begin/end block, I'm not interested ;-)</p>



<a name="193709809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709809">(Apr 12 2020 at 11:48)</a>:</h4>
<p>begin transfer end</p>



<a name="193709825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193709825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193709825">(Apr 12 2020 at 11:49)</a>:</h4>
<p>It is possible to make new definitions in the middle of a tactic, although I've never attempted to define a tactic and then use it all in one tactic block</p>



<a name="193710185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193710185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193710185">(Apr 12 2020 at 11:59)</a>:</h4>
<p>Looks like you can't:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">add_decl</span> <span class="o">(</span><span class="n">declaration</span><span class="bp">.</span><span class="n">defn</span>
    <span class="bp">`</span><span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">mytriv</span> <span class="o">[]</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span> <span class="n">unit</span><span class="o">)</span>
    <span class="bp">`</span><span class="o">(</span><span class="bp">`</span><span class="o">[</span><span class="n">trivial</span><span class="o">])</span>
    <span class="o">(</span><span class="n">reducibility_hints</span><span class="bp">.</span><span class="n">regular</span> <span class="mi">1</span> <span class="n">tt</span><span class="o">)</span> <span class="n">ff</span><span class="o">),</span>
  <span class="c1">-- mytriv  -- fails</span>
  <span class="c1">-- exact by mytriv  -- fails</span>
  <span class="o">(</span><span class="n">declaration</span><span class="bp">.</span><span class="n">value</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">get_decl</span> <span class="bp">`</span><span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">mytriv</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span><span class="o">,</span> <span class="c1">-- the declaration is there</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">to_expr</span> <span class="bp">```</span><span class="o">(</span><span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">mytriv</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">eval_expr&#39;</span> <span class="o">(</span><span class="n">tactic</span> <span class="n">unit</span><span class="o">),</span> <span class="c1">-- but I can&#39;t evaluate it</span>
<span class="kn">end</span>
</pre></div>



<a name="193710241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193710241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193710241">(Apr 12 2020 at 12:00)</a>:</h4>
<p>I think when you use <code>add_decl</code> it doesn't produce VM code for the declaration, so you can't use it immediately</p>



<a name="193710245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193710245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193710245">(Apr 12 2020 at 12:01)</a>:</h4>
<p>and after the proof is done, any changes to the environment are rolled back anyway</p>



<a name="193711666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193711666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193711666">(Apr 12 2020 at 12:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta/near/193709801" title="#narrow/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta/near/193709801">said</a>:</p>
<blockquote>
<p>NNG level 999: define a transfer tactic between mynat and nat, then use it to redo every level</p>
</blockquote>
<p>You mean like <a href="https://github.com/leanprover-community/mathlib/blob/a89be63540dd3ccab1f095f9d858a3db4747a386/test/transport/basic.lean#L54" title="https://github.com/leanprover-community/mathlib/blob/a89be63540dd3ccab1f095f9d858a3db4747a386/test/transport/basic.lean#L54">this</a>:</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">semiring_mynat</span> <span class="o">:</span> <span class="n">semiring</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">transport</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">semiring</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="kn">using</span> <span class="n">mynat_equiv</span>
</pre></div>



<a name="193711866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193711866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193711866">(Apr 12 2020 at 12:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span></p>



<a name="193718836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193718836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193718836">(Apr 12 2020 at 16:05)</a>:</h4>
<p>I don't understand the context here. But is the moral that one shouldn't use nat.strong_rec_on from core? Presumably this should do the job as well:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">strong_rec&#39;</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">P</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span> <span class="n">strong_rec&#39;</span> <span class="n">m</span><span class="o">)</span>

<span class="n">def</span> <span class="n">strong_rec_on&#39;</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">strong_rec&#39;</span> <span class="n">h</span> <span class="n">n</span>

<span class="kn">theorem</span> <span class="n">strong_rec_on_beta&#39;</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">h</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">strong_rec_on&#39;</span> <span class="n">n</span> <span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">hmn</span><span class="o">,</span> <span class="o">(</span><span class="n">strong_rec_on&#39;</span> <span class="n">m</span> <span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="n">m</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">strong_rec_on&#39;</span><span class="o">],</span> <span class="n">rw</span> <span class="n">strong_rec&#39;</span><span class="o">,</span> <span class="o">}</span>
</pre></div>



<a name="193720694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193720694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193720694">(Apr 12 2020 at 16:57)</a>:</h4>
<p><span class="user-mention" data-user-id="111433">@Alistair Tucker</span> You're version is much faster in the VM, but much slower in the kernel.</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="n">reduce</span> <span class="n">strong_rec&#39;</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="k">show</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="k">from</span> <span class="n">nat</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">n</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="mi">0</span> <span class="o">(</span><span class="n">succ_pos</span> <span class="bp">_</span><span class="o">)))</span>
  <span class="mi">1000</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span>
  <span class="mi">1000</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="k">show</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="k">from</span> <span class="n">nat</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">n</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="mi">0</span> <span class="o">(</span><span class="n">succ_pos</span> <span class="bp">_</span><span class="o">)))</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">strong_rec&#39;</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="k">show</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="k">from</span> <span class="n">nat</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">n</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="mi">0</span> <span class="o">(</span><span class="n">succ_pos</span> <span class="bp">_</span><span class="o">)))</span>
  <span class="mi">10000000</span> <span class="c1">--1.6ms</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">nat</span><span class="bp">.</span><span class="n">strong_rec_on</span>
  <span class="mi">10000000</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="k">show</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="k">from</span> <span class="n">nat</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">n</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="mi">0</span> <span class="o">(</span><span class="n">succ_pos</span> <span class="bp">_</span><span class="o">)))</span> <span class="c1">--timeout</span>
</pre></div>



<a name="193720750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193720750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193720750">(Apr 12 2020 at 16:58)</a>:</h4>
<p>I think the <code>#eval</code> times are an example of why Lean is so much better than Coq. Coq can't compile well-founded recursion nicely like Lean I heard.</p>



<a name="193720849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193720849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193720849">(Apr 12 2020 at 17:01)</a>:</h4>
<p>Be careful. I once said that lean was better than Coq and I've never heard the end of it</p>



<a name="193721084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193721084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193721084">(Apr 12 2020 at 17:07)</a>:</h4>
<p>I don't need to wait for 2 seconds in Coq for <code>ring</code> to finish</p>



<a name="193721488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193721488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193721488">(Apr 12 2020 at 17:18)</a>:</h4>
<p>I'm a bit lost in this thread (and haven't been here since morning). Is there a solution to my original issue somewhere?</p>



<a name="193721492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193721492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193721492">(Apr 12 2020 at 17:18)</a>:</h4>
<p>Also, about this VM vs kernel thing, which version is faster to prove stuff and never compute anything?</p>



<a name="193721495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193721495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193721495">(Apr 12 2020 at 17:18)</a>:</h4>
<p>I posted a solution in your thread which had a sorry for <code>nat.strong_rec_on_beta</code></p>



<a name="193721497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193721497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193721497">(Apr 12 2020 at 17:18)</a>:</h4>
<p>so Chris and I independently came up with proofs of it</p>



<a name="193721501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193721501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193721501">(Apr 12 2020 at 17:19)</a>:</h4>
<p>so you can fill in the sorry</p>



<a name="193721511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193721511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193721511">(Apr 12 2020 at 17:19)</a>:</h4>
<p>but it seems like redefining <code>strong_rec</code> makes it even shorter</p>



<a name="193721512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193721512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193721512">(Apr 12 2020 at 17:19)</a>:</h4>
<p>Ok, thanks for helping me to patch the pieces. I wonder how this ended up in the new members stream...</p>



<a name="193721516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat.strong_rec_on_beta/near/193721516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.2Estrong_rec_on_beta.html#193721516">(Apr 12 2020 at 17:19)</a>:</h4>
<p>because I asked here how to fill in the sorry</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
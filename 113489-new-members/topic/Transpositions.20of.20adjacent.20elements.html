---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html">Transpositions of adjacent elements</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="205794879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205794879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhangir Azerbayev <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205794879">(Aug 03 2020 at 13:42)</a>:</h4>
<p>Every transposition of <code>fin n</code> can be decomposed into transpositions of adjacent elements. <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> pointed out to me that, in some sense, mathlib already knows this, since <code>list.perm</code> has the constructor </p>
<div class="codehilite"><pre><span></span><code><span class="bp">|</span> <span class="n">swap</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uu</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="n">a_1</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">a_1</span> <span class="bp">::</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">l</span> <span class="bp">~</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">a_1</span> <span class="bp">::</span> <span class="n">l</span>
</code></pre></div>


<p>I want to extract from this either </p>
<ol>
<li>A lemma that says any <code>equiv.swap i j</code> with <code>i j : fin n</code> can be decomposed into a product of  an odd number of elements of the form <code>equiv.swap i (i+1)</code>, or</li>
<li>An induction principle similar to <code>equiv.perm.swap_induction_on</code>, which would say something like</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">P</span> <span class="mi">1</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span>
<span class="n">P</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">swap</span> <span class="n">i</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">f</span><span class="o">))</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">swap</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span>
</code></pre></div>


<p>or </p>
<div class="codehilite"><pre><span></span><code><span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">,</span> <span class="n">P</span> <span class="mi">1</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span>
<span class="n">P</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">swap</span> <span class="n">i</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">f</span><span class="o">))</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">f</span>
</code></pre></div>


<p>How could one prove this?</p>



<a name="205795137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205795137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205795137">(Aug 03 2020 at 13:44)</a>:</h4>
<p>Your definition of swap quoted above looks funny -- a should have type alpha surely</p>



<a name="205795276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205795276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205795276">(Aug 03 2020 at 13:45)</a>:</h4>
<p>swap says that [a,b,c,...] is related to [b,a,c,...]. It's part of the definition of a binary relation on lists</p>



<a name="205795368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205795368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205795368">(Aug 03 2020 at 13:46)</a>:</h4>
<p>I don't think the questions you're asking typecheck</p>



<a name="205795484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205795484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205795484">(Aug 03 2020 at 13:47)</a>:</h4>
<p>Oh sorry are there two swaps here?</p>



<a name="205795727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205795727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205795727">(Aug 03 2020 at 13:49)</a>:</h4>
<p>You can prove 1, assuming I've understood it correctly, directly by writing it as an explicit product of something like 2(j-i-1)+1 adjacent swaps</p>



<a name="205795987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205795987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhangir Azerbayev <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205795987">(Aug 03 2020 at 13:51)</a>:</h4>
<p>The definition I wrote is wrong, it's actually</p>
<div class="codehilite"><pre><span></span><code><span class="bp">|</span> <span class="n">swap</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">perm</span> <span class="o">(</span><span class="n">y</span><span class="bp">::</span><span class="n">x</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="bp">::</span><span class="n">y</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span>
</code></pre></div>


<p>The thing I wrote in my question is what shows up on the mathlib docs website (<a href="https://leanprover-community.github.io/mathlib_docs/data/list/perm.html#list.is_setoid">https://leanprover-community.github.io/mathlib_docs/data/list/perm.html#list.is_setoid</a>), which is different from what's in source code.</p>



<a name="205796098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205796098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205796098">(Aug 03 2020 at 13:52)</a>:</h4>
<p>Your induction principle might not quite be what you want because i+1 is random if n=i+1</p>



<a name="205796316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205796316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205796316">(Aug 03 2020 at 13:53)</a>:</h4>
<p><span class="user-mention" data-user-id="322237">@Kendall Frey</span> you're not the only one doing permutations of <code>fin n</code></p>



<a name="205798201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205798201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205798201">(Aug 03 2020 at 14:10)</a>:</h4>
<p>wait, don't tell me this is the next evolution stage of the <code>a</code> bug</p>



<a name="205798918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205798918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205798918">(Aug 03 2020 at 14:16)</a>:</h4>
<p>The only real problem is the <code>{α : Type uu}</code> part, right?</p>



<a name="205799673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205799673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205799673">(Aug 03 2020 at 14:23)</a>:</h4>
<p>no, the <code>a</code> and <code>a_1</code> binders have the wrong type</p>



<a name="205799907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205799907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205799907">(Aug 03 2020 at 14:25)</a>:</h4>
<p>which, incidentally, means we have found an entirely new kind of pollack inconsistency in lean</p>



<a name="205800093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205800093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205800093">(Aug 03 2020 at 14:26)</a>:</h4>
<p>oh neat</p>



<a name="205801271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205801271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205801271">(Aug 03 2020 at 14:36)</a>:</h4>
<p>Oh, the bug is in <code>doc_gen</code></p>



<a name="205801484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205801484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205801484">(Aug 03 2020 at 14:38)</a>:</h4>
<p>Here's a standalone version of the bug:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span><span class="bp">.</span><span class="n">perm</span>

<span class="kn">open</span> <span class="n">tactic</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">expr</span><span class="bp">.</span><span class="n">instantiate_pis</span> <span class="o">:</span> <span class="n">list</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">e&#39;</span><span class="bp">::</span><span class="n">es</span><span class="o">)</span> <span class="o">(</span><span class="n">expr</span><span class="bp">.</span><span class="n">pi</span> <span class="n">n</span> <span class="n">bi</span> <span class="n">t</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">expr</span><span class="bp">.</span><span class="n">instantiate_pis</span> <span class="n">es</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">instantiate_var</span> <span class="n">e&#39;</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span>        <span class="n">e</span>              <span class="o">:=</span> <span class="n">e</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">mk_const_with_params</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">declaration</span><span class="o">)</span> <span class="o">:</span> <span class="n">expr</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">lvls</span> <span class="o">:=</span> <span class="n">d</span><span class="bp">.</span><span class="n">univ_params</span><span class="bp">.</span><span class="n">map</span> <span class="n">level</span><span class="bp">.</span><span class="n">param</span> <span class="k">in</span>
<span class="n">expr</span><span class="bp">.</span><span class="n">const</span> <span class="n">d</span><span class="bp">.</span><span class="n">to_name</span> <span class="n">lvls</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">do</span>
  <span class="n">d</span> <span class="err">←</span> <span class="n">get_decl</span> <span class="bp">``</span><span class="n">list</span><span class="bp">.</span><span class="n">perm</span><span class="o">,</span>
  <span class="n">t</span> <span class="err">←</span> <span class="n">infer_type</span> <span class="o">(</span><span class="n">mk_const_with_params</span> <span class="n">d</span><span class="o">),</span>
  <span class="o">(</span><span class="n">locs</span><span class="o">,</span> <span class="bp">_</span><span class="o">)</span> <span class="err">←</span> <span class="n">mk_local_pis</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">trace</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">map</span> <span class="n">expr</span><span class="bp">.</span><span class="n">local_type</span> <span class="n">locs</span><span class="o">),</span> <span class="c1">-- [Type uu, list α, list α]</span>
  <span class="n">proj_tp</span> <span class="err">←</span> <span class="n">mk_const</span> <span class="bp">``</span><span class="n">list</span><span class="bp">.</span><span class="n">perm</span><span class="bp">.</span><span class="n">swap</span> <span class="bp">&gt;&gt;=</span> <span class="n">infer_type</span><span class="o">,</span>
  <span class="n">t</span> <span class="err">←</span> <span class="n">pis</span> <span class="n">locs</span> <span class="o">(</span><span class="n">proj_tp</span><span class="bp">.</span><span class="n">instantiate_pis</span> <span class="n">locs</span><span class="o">),</span>
  <span class="n">trace</span> <span class="n">t</span> <span class="c1">-- ∀ {α : Type uu} (a a_1 : list α) (l : list α), a_1 :: a :: l ~ a :: a_1 :: l</span>
</code></pre></div>



<a name="205801768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205801768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205801768">(Aug 03 2020 at 14:40)</a>:</h4>
<p>It looks like the code has assumed that the first three binders of <code>list.perm.swap</code> have types <code>[Type uu, list α, list α]</code> respectively</p>



<a name="205801858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205801858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205801858">(Aug 03 2020 at 14:41)</a>:</h4>
<p>in other words, it confused the indices of the inductive family <code>inductive list.perm {α : Type uu} : list α → list α → Prop</code> for parameters</p>



<a name="205827880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205827880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205827880">(Aug 03 2020 at 18:13)</a>:</h4>
<p>Back to the original point, Zhangir Chris and I knocked up the following in the live lean coding discord chat:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">perm</span><span class="bp">.</span><span class="n">sign</span>

<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">equiv</span>

<span class="kn">lemma</span> <span class="n">zhangir1</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hij</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)),</span>
<span class="n">L</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">swap</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">l</span> <span class="err">∈</span> <span class="n">L</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">h</span> <span class="o">:</span> <span class="n">k</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span>
 <span class="n">l</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">swap</span> <span class="n">k</span> <span class="bp">⟨</span><span class="n">k</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">wlog</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="kn">using</span> <span class="o">[</span><span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span> <span class="n">i</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">lt_trichotomy</span> <span class="n">i</span> <span class="n">j</span> <span class="k">with</span> <span class="n">h1</span> <span class="bp">|</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">h3</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">cc</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">}</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">j</span> <span class="k">with</span> <span class="n">j</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">i</span> <span class="k">with</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">clear</span> <span class="n">hij</span><span class="o">,</span>
    <span class="n">revert</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_induction</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">j</span> <span class="o">(</span><span class="k">show</span> <span class="n">i</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">hj</span><span class="o">,</span>
      <span class="k">let</span> <span class="n">L</span> <span class="o">:=</span> <span class="o">[</span><span class="n">swap</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hj</span><span class="bp">⟩</span><span class="o">],</span>
      <span class="n">use</span> <span class="n">L</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
      <span class="n">intros</span> <span class="n">l</span> <span class="n">hl</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">i</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hi</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">hj</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hl</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hl</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">clear</span> <span class="n">h1</span> <span class="n">j</span><span class="o">,</span>
      <span class="n">intros</span> <span class="n">j</span> <span class="n">hj</span> <span class="n">h</span> <span class="n">hj&#39;</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hjn</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">lt_trans</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">lt_succ_self</span> <span class="n">j</span><span class="o">)</span> <span class="n">hj&#39;</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">h</span> <span class="n">hjn</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">L</span><span class="o">,</span> <span class="n">hL1</span><span class="o">,</span> <span class="n">hL2</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="k">let</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">[</span><span class="n">swap</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hjn</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">j</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hj&#39;</span><span class="bp">⟩</span><span class="o">)]</span> <span class="bp">++</span> <span class="n">L</span> <span class="bp">++</span> <span class="o">[</span><span class="n">swap</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hjn</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">j</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hj&#39;</span><span class="bp">⟩</span><span class="o">)],</span>
      <span class="n">use</span> <span class="n">M</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">prod_append</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">prod_append</span><span class="o">,</span> <span class="n">hL1</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">prod_singleton</span><span class="o">],</span>
        <span class="n">rw</span> <span class="n">swap_comm</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">mk</span> <span class="n">i</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">j</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">_</span><span class="o">),</span>
        <span class="n">apply</span> <span class="n">perm</span><span class="bp">.</span><span class="n">swap_mul_swap_mul_swap</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">apply</span> <span class="n">ne_of_lt</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hj</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">apply</span> <span class="n">ne_of_lt</span><span class="o">,</span> <span class="k">show</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">}</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">intros</span> <span class="n">l</span> <span class="n">hl</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">mem_append</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">mem_append</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">mem_singleton</span><span class="o">]</span> <span class="n">at</span> <span class="n">hl</span><span class="o">,</span>
        <span class="n">rcases</span> <span class="n">hl</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">rfl</span> <span class="bp">|</span> <span class="n">hl</span><span class="bp">⟩</span> <span class="bp">|</span> <span class="n">rfl</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">use</span> <span class="n">fin</span><span class="bp">.</span><span class="n">mk</span> <span class="n">j</span> <span class="n">hjn</span><span class="o">,</span> <span class="n">use</span> <span class="n">hj&#39;</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">apply</span> <span class="n">hL2</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">use</span> <span class="n">fin</span><span class="bp">.</span><span class="n">mk</span> <span class="n">j</span> <span class="n">hjn</span><span class="o">,</span> <span class="n">use</span> <span class="n">hj&#39;</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">symmetry&#39;</span> <span class="n">at</span> <span class="n">hij</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">swap_comm</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">this</span> <span class="n">hij</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">zhangir2</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">P</span> <span class="mi">1</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">f</span> <span class="bp">*</span> <span class="n">swap</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">h1</span> <span class="n">IH</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">f</span><span class="bp">⁻¹</span><span class="o">),</span>
  <span class="n">suffices</span> <span class="n">hQ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span><span class="o">,</span> <span class="n">Q</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">convert</span> <span class="n">hQ</span> <span class="n">f</span><span class="bp">⁻¹</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">intro</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">perm</span><span class="bp">.</span><span class="n">swap_induction_on</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h1</span> <span class="o">},</span>
  <span class="n">intros</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span> <span class="n">hQ</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">P</span> <span class="o">(((</span><span class="n">swap</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">*</span> <span class="n">f</span><span class="o">)</span><span class="bp">⁻¹</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_inv_rev</span><span class="o">,</span> <span class="n">swap_inv</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">IH</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hQ</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205855537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205855537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205855537">(Aug 03 2020 at 22:38)</a>:</h4>
<p>Relatedly, why is <code>equiv.swap_apply_of_ne_of_ne</code> not a simp lemma?</p>



<a name="205856646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205856646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205856646">(Aug 03 2020 at 22:54)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.swap_apply_of_ne_of_ne/src">src#equiv.swap_apply_of_ne_of_ne</a></p>



<a name="205856675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205856675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205856675">(Aug 03 2020 at 22:55)</a>:</h4>
<p>(Just using the linkifier so I can see what it says.)</p>



<a name="205856689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205856689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205856689">(Aug 03 2020 at 22:55)</a>:</h4>
<p>Presumably because it seems unlikely the side conditions will be discharged by <code>simp</code>, so we wouldn't gain much.</p>



<a name="205856696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205856696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205856696">(Aug 03 2020 at 22:55)</a>:</h4>
<p><code>simp</code> is not much good at proving inequalities.</p>



<a name="205857003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205857003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205857003">(Aug 03 2020 at 22:59)</a>:</h4>
<p>Here's a short example where, if tagged <code>[simp]</code>, it's useful. But it's not that much of a hassle to just invoke it.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="n">R</span><span class="o">)</span>

<span class="n">def</span> <span class="n">swap_row</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">A</span> <span class="err">∘</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">swap</span> <span class="n">i</span> <span class="n">j</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">swap_row_def</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">swap_row</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">A</span> <span class="err">∘</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">swap</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">lemma</span> <span class="n">swap_row_symmetric</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">swap_row</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">swap_row</span> <span class="n">A</span> <span class="n">j</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">ext</span> <span class="n">ix</span> <span class="n">jx</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hj</span> <span class="o">:</span> <span class="o">(</span><span class="n">ix</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span><span class="bp">;</span>
  <span class="n">by_cases</span> <span class="n">hi</span> <span class="o">:</span> <span class="o">(</span><span class="n">ix</span> <span class="bp">=</span> <span class="n">i</span><span class="o">)</span><span class="bp">;</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hj</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">swap_apply_of_ne_of_ne</span><span class="o">]</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205857847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transpositions%20of%20adjacent%20elements/near/205857847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transpositions.20of.20adjacent.20elements.html#205857847">(Aug 03 2020 at 23:10)</a>:</h4>
<p>I think a general rule of thumb is that if in order to make <code>simp</code> use some particular lemma, you're going to need to jump through hoops providing additional facts to simp so it can apply, then it doesn't merit joining the standard <code>simp</code> set. Maybe another way to say the same thing is that you shouldn't have to "know about" individual <code>simp</code> lemmas to successfully use <code>simp</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
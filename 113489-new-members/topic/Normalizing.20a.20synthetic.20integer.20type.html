---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html">Normalizing a synthetic integer type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="237881669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237881669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237881669">(May 07 2021 at 19:57)</a>:</h4>
<p>I've created my own synthetic integer type (i.e. not derived from the natural numbers type). The problem with this version of the integers is that there are many redundant ways of encoding the same integer. I want to have a normalization function that takes an arbitrary integer of this type and reduces it to a normal or canonical form of either <code>succ (succ (succ ... zero ) )</code> or <code>pred (pred (pred ... zero))</code>. I'm finding this difficult to do in a pure functional way as someone novice at both Lean and functional programming in general. Any hints?  [Lean3].</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span>

<span class="kn">open</span> <span class="n">Int</span>
<span class="c1">-- This function can deal with integers encoded with alternating (succ (pred ...) ) but not forms like pred (pred (succ (succ zero )))</span>
<span class="kd">def</span> <span class="n">norm</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span> <span class="n">norm</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span> <span class="n">norm</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">norm</span> <span class="n">a</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pred</span> <span class="o">(</span><span class="n">norm</span> <span class="n">a</span><span class="o">)</span>

<span class="k">#reduce</span> <span class="n">norm</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">pred</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">pred</span> <span class="bp">$</span> <span class="n">zero</span> <span class="c1">-- zero</span>
<span class="k">#reduce</span> <span class="n">norm</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">pred</span> <span class="bp">$</span> <span class="n">pred</span> <span class="bp">$</span> <span class="n">zero</span> <span class="c1">-- zero.pred.succ.succ</span>
</code></pre></div>



<a name="237884716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237884716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237884716">(May 07 2021 at 20:21)</a>:</h4>
<p>this feels like the bracketing problem with DFAs (well formed bracketed expressions aren't a regular language). Not sure if the eqn compiler can do something powerful than a DFA? maybe with a <code>fuel</code> parameter, or well-founded recursion?</p>



<a name="237884723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237884723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237884723">(May 07 2021 at 20:21)</a>:</h4>
<p>Just to be clear -- this is not the integers, because succ(pred(0)) isn't equal to 0. Do you want to put an equivalence relation on this type and work with equivalence classes? Then you could get the integers on the nose.</p>



<a name="237884928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237884928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237884928">(May 07 2021 at 20:23)</a>:</h4>
<p>Once you have the actual integers, then you can define <code>simp</code> lemmas such as cl(succ(pred(x))=cl(x) and then the simplifier will be able to do the reduction for you.</p>



<a name="237885391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237885391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237885391">(May 07 2021 at 20:27)</a>:</h4>
<p>I doubt the equation compiler can match on subterms, so it won't be able to get to succ(succ(succ....(succ(pred(zero)))..) for an arbitrarily long string because it's matching from the left and it can only have finitely many rules. But the simplifier can do this -- but only with equalities and &lt;-&gt;s, so that's why I'm suggesting that you pass to the equivalence classes first.</p>



<a name="237885552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237885552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237885552">(May 07 2021 at 20:29)</a>:</h4>
<p>The fixed point of <code>norm</code> would work.</p>



<a name="237885608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237885608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237885608">(May 07 2021 at 20:29)</a>:</h4>
<p>but norm as it stands won't change s(s(p(0))) to s(0), so what exactly do you mean by this?</p>



<a name="237885800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237885800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237885800">(May 07 2021 at 20:30)</a>:</h4>
<p>You can define a function <code>Int -&gt; nat</code> that counts the number of <code>succ</code> and <code>pred</code>s in a term. Now iterate <code>norm</code> that many times on the term.</p>



<a name="237885827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237885827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237885827">(May 07 2021 at 20:31)</a>:</h4>
<p>don't the last two lines fix that Kevin?</p>



<a name="237885985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237885985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237885985">(May 07 2021 at 20:32)</a>:</h4>
<p><span class="user-mention" data-user-id="284160">@Eric Rodriguez</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#reduce</span> <span class="n">norm</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">pred</span> <span class="bp">$</span> <span class="n">pred</span> <span class="bp">$</span> <span class="n">zero</span> <span class="c1">-- zero.pred.succ.succ</span>
</code></pre></div>



<a name="237886087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237886087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237886087">(May 07 2021 at 20:33)</a>:</h4>
<p>You're right, it's better than I thought, but it's still not good enough. Maybe there is a trick then?</p>



<a name="237886622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237886622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237886622">(May 07 2021 at 20:37)</a>:</h4>
<p>Johan is right:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.function.iterate</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span>

<span class="kn">open</span> <span class="n">Int</span>

<span class="kd">def</span> <span class="n">rearr</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">rearr</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">norm</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">norm</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pred</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span> <span class="n">pred</span> <span class="o">(</span><span class="n">norm</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span> <span class="o">(</span><span class="n">norm</span> <span class="n">a</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span> <span class="o">(</span><span class="n">norm</span> <span class="n">a</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">count</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">-&gt;</span> <span class="n">int</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">count</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">-</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">count</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">count'</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">-&gt;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">count'</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">count'</span> <span class="n">a</span>

<span class="k">#reduce</span> <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">pred</span> <span class="bp">$</span> <span class="n">pred</span> <span class="bp">$</span> <span class="n">zero</span> <span class="k">in</span> <span class="n">norm</span><span class="bp">^</span><span class="o">[</span><span class="n">count'</span> <span class="n">x</span><span class="o">]</span> <span class="n">x</span> <span class="c1">-- zero.succ</span>
</code></pre></div>



<a name="237886753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237886753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237886753">(May 07 2021 at 20:38)</a>:</h4>
<p>the iteration operator is cool, i hadn't seen that before</p>



<a name="237887085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237887085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237887085">(May 07 2021 at 20:41)</a>:</h4>
<p>Of course it is mighty inefficient (-;</p>



<a name="237887147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237887147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237887147">(May 07 2021 at 20:42)</a>:</h4>
<p>I see, you have to apply norm more than once!</p>



<a name="237888372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237888372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237888372">(May 07 2021 at 20:53)</a>:</h4>
<p>Exercise for the reader: define a well_founded relation that will allow you to take the fixpoint of norm, so you don't have to rely on <code>count'</code>.</p>



<a name="237891831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237891831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237891831">(May 07 2021 at 21:20)</a>:</h4>
<p>I think this is a more elegant single pass solution:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">up</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">succ</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">down</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">pred</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">norm_aux</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">acc</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">norm_aux</span> <span class="o">(</span><span class="n">up</span> <span class="n">acc</span><span class="o">)</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">acc</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">norm_aux</span> <span class="o">(</span><span class="n">down</span> <span class="n">acc</span><span class="o">)</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">acc</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">acc</span>

<span class="kd">def</span> <span class="n">norm</span> <span class="o">:=</span> <span class="n">norm_aux</span> <span class="n">zero</span>

<span class="k">#reduce</span> <span class="n">norm</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">pred</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">pred</span> <span class="bp">$</span> <span class="n">zero</span> <span class="c1">-- zero</span>
<span class="k">#reduce</span> <span class="n">norm</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">succ</span> <span class="bp">$</span> <span class="n">pred</span> <span class="bp">$</span> <span class="n">pred</span> <span class="bp">$</span> <span class="n">zero</span> <span class="c1">-- zero.succ</span>
</code></pre></div>



<a name="237891947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237891947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237891947">(May 07 2021 at 21:21)</a>:</h4>
<p>The secret is that <code>acc</code> is actually an <code>int</code> in disguise: it is always either <code>succ^n zero</code> or <code>pred^n zero</code> because we consistently head-normalize it</p>



<a name="237892072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237892072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237892072">(May 07 2021 at 21:22)</a>:</h4>
<p>and this is linear time to boot</p>



<a name="237892607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/237892607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#237892607">(May 07 2021 at 21:27)</a>:</h4>
<p>Thanks, everyone!</p>



<a name="238057153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/238057153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#238057153">(May 09 2021 at 19:50)</a>:</h4>
<p>So if I use <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> 's <code>norm</code> function, then I can define a subtype like <code>def Int2 : Type := { x : Int // (norm x) = x }</code>  Would this be a suitable alternative to creating a quotient type? I'd have to prove the idempotence of <code>norm</code></p>



<a name="238057441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/238057441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#238057441">(May 09 2021 at 19:55)</a>:</h4>
<p>Yes, that would work. There are a couple ways you could express that proposition: it is also the set of <code>Int</code> values accessible by applying <code>up</code> and <code>down</code> to <code>zero</code> (it is easy to prove that <code>norm</code> produces elements in that subset), as well as the set of values of the form <code>succ^n zero</code> or <code>pred^n zero</code> (which would be a good starting point for proving isomorphism to <code>int</code>)</p>



<a name="238057702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/238057702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#238057702">(May 09 2021 at 19:59)</a>:</h4>
<p>If I label the conditions as (P1) <code>norm x = x</code> (P2) inductively generated by <code>up</code>,<code>down</code>,<code>zero</code> (P3) <code>succ^n zero</code> or <code>pred^n zero</code>, then there are the following lemmas:</p>
<ul>
<li><code>P2 (norm x)</code>, and more generally <code>P2 acc -&gt; P2 (norm_aux acc x)</code> (by induction on <code>x</code>), therefore P1 -&gt; P2</li>
<li><code>P3 x -&gt; P3 (up x), P3 (down x)</code> (by cases), therefore P2 -&gt; P3</li>
<li><code>norm (succ^n zero) = succ^n zero</code> (by induction on <code>n</code>) and similarly for pred, therefore P3 -&gt; P1</li>
</ul>



<a name="238057842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/238057842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#238057842">(May 09 2021 at 20:01)</a>:</h4>
<p>Therefore <code>norm</code> is idempotent because <code>P2 (norm x)</code> so by P1 <code>norm (norm x) = norm x</code></p>



<a name="238059902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/238059902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#238059902">(May 09 2021 at 20:37)</a>:</h4>
<p>You need more than idempotence of norm, you need to prove that norm gives rise to a set of representatives for the equivalence relation, i.e. a related to b iff norm(a)=norm(b) and a related to norm(a).</p>



<a name="238061473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/238061473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#238061473">(May 09 2021 at 21:01)</a>:</h4>
<p>Here, there is no explicit equivalence relation, it is just <code>norm a = norm b</code>. So the claim that <code>norm a</code> is related to <code>a</code> is just <code>norm (norm a) = norm a</code>, and a related to b iff norm a = norm b is true by definition</p>



<a name="238061808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/238061808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#238061808">(May 09 2021 at 21:06)</a>:</h4>
<p>Yeah on the surface this seems easier than making a setoid and quotient.</p>



<a name="238062521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/238062521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#238062521">(May 09 2021 at 21:18)</a>:</h4>
<p>Is it always possible to replace a quotient type with a subtype in this way?</p>



<a name="238062652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/238062652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#238062652">(May 09 2021 at 21:20)</a>:</h4>
<p>Oh, I guess that's <code>{x // (quot.mk r x).out = x}</code>, and <a href="https://leanprover-community.github.io/mathlib_docs/find/quot.out">docs#quot.out</a> is essentially the proof the answer is yes</p>



<a name="238062917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/238062917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#238062917">(May 09 2021 at 21:25)</a>:</h4>
<p>It's non-computable but yes</p>



<a name="238062935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/238062935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#238062935">(May 09 2021 at 21:25)</a>:</h4>
<p>You choose an element in each equivalence class</p>



<a name="242125899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/242125899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#242125899">(Jun 09 2021 at 20:34)</a>:</h4>
<p>I've been banging my head on this for a long time and I am just not competent enough yet to solve this in any reasonable amount of time.  Hoping someone can help. I'm trying to prove <code>is_norm (norm i)</code> using the <code>norm</code> function <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> made<br>
By staring at the definition, clearly <code>norm i</code> produces a <code>b_int</code> of the form <code>succ^n zero</code> or <code>pred^n zero</code> (but I dont know how to prove it) and both of these can be proven to be in normal form according to <code>is_norm</code>. </p>
<p>MWE in Lean4:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">b_int</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">b_int</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span>
<span class="bp">|</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span>

<span class="kn">open</span> <span class="n">b_int</span>

<span class="kd">def</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bool</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">is_norm</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">pred</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">is_norm</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">int</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">//</span> <span class="n">is_norm</span> <span class="n">x</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">up</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">succ</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">down</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">pred</span> <span class="n">a</span>

<span class="c1">-- 1st arg is constructed, 2nd is input</span>
<span class="kd">def</span> <span class="n">norm_aux</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=&gt;</span>
  <span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">a</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">norm_aux</span> <span class="o">(</span><span class="n">up</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">norm_aux</span> <span class="o">(</span><span class="n">down</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span>

<span class="kd">def</span> <span class="n">norm</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span> <span class="o">:=</span> <span class="n">norm_aux</span> <span class="n">zero</span>

<span class="k">#reduce</span> <span class="n">norm</span> <span class="n">zero.pred.pred.succ.succ.succ.pred.pred.pred</span> <span class="c1">-- pred (pred zero)</span>
<span class="k">#reduce</span> <span class="n">is_norm</span> <span class="bp">$</span> <span class="n">norm</span> <span class="n">zero.pred.pred.succ.succ.succ.pred.pred.pred</span> <span class="c1">-- true</span>

<span class="kd">theorem</span> <span class="n">is_norm_norm</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">norm</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">true</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="242129413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/242129413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#242129413">(Jun 09 2021 at 21:01)</a>:</h4>
<p>I sketched this proof above. Prove these lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">is_norm_up</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">up</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">theorem</span> <span class="n">is_norm_down</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">down</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">theorem</span> <span class="n">is_norm_norm_aux</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">norm_aux</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">theorem</span> <span class="n">is_norm_norm</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">norm</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="242153941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/242153941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#242153941">(Jun 10 2021 at 02:42)</a>:</h4>
<p>Thanks, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  ! I proved the first 3 lemmas, now working on <code>is_norm_norm</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">is_norm_up</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">up</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intros</span> <span class="n">h1</span>
  <span class="n">induction</span> <span class="n">a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">rfl</span><span class="bp">;</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">a</span> <span class="n">h2</span> <span class="bp">=&gt;</span>
    <span class="k">show</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">true</span><span class="bp">;</span>
    <span class="n">assumption</span><span class="bp">;</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="n">a</span> <span class="n">h3</span> <span class="bp">=&gt;</span>
    <span class="k">show</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">true</span><span class="bp">;</span>
    <span class="n">cases</span> <span class="n">a</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">rfl</span><span class="bp">;</span>
    <span class="bp">|</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">=&gt;</span>
      <span class="n">contradiction</span><span class="bp">;</span>
    <span class="bp">|</span> <span class="n">pred</span> <span class="n">a</span> <span class="bp">=&gt;</span>
      <span class="n">assumption</span><span class="bp">;</span>

<span class="kd">theorem</span> <span class="n">is_norm_down</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">down</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intros</span> <span class="n">h1</span>
  <span class="n">induction</span> <span class="n">a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">rfl</span><span class="bp">;</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">a</span> <span class="n">h2</span> <span class="bp">=&gt;</span>
    <span class="k">show</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">true</span><span class="bp">;</span>
    <span class="n">cases</span> <span class="n">a</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">rfl</span><span class="bp">;</span>
    <span class="bp">|</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">=&gt;</span>
      <span class="n">assumption</span>
    <span class="bp">|</span> <span class="n">pred</span> <span class="n">a</span> <span class="bp">=&gt;</span>
      <span class="n">contradiction</span><span class="bp">;</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="n">a</span> <span class="n">h3</span> <span class="bp">=&gt;</span>
    <span class="k">show</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">pred</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">true</span><span class="bp">;</span>
    <span class="n">assumption</span>


<span class="kd">theorem</span> <span class="n">norm_i_succ</span> <span class="o">:</span> <span class="n">norm</span> <span class="o">(</span><span class="n">i.succ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">norm_aux</span> <span class="n">zero.succ</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">theorem</span> <span class="n">norm_i</span> <span class="o">:</span> <span class="n">norm</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">norm_aux</span> <span class="n">zero</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">theorem</span> <span class="n">norm_aux_succ_i</span> <span class="o">:</span> <span class="n">norm_aux</span> <span class="n">zero</span> <span class="o">(</span><span class="n">succ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">norm_aux</span> <span class="n">zero.succ</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">theorem</span> <span class="n">norm_aux_succ_eq_up</span> <span class="o">:</span> <span class="n">norm_aux</span> <span class="n">a</span> <span class="o">(</span><span class="n">succ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">norm_aux</span> <span class="o">(</span><span class="n">up</span> <span class="n">a</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">theorem</span> <span class="n">norm_aux_pred_eq_down</span> <span class="o">:</span> <span class="n">norm_aux</span> <span class="n">a</span> <span class="o">(</span><span class="n">pred</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">norm_aux</span> <span class="o">(</span><span class="n">down</span> <span class="n">a</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">is_norm_norm_aux</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">norm_aux</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">h1</span> <span class="bp">=&gt;</span>
  <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span>
    <span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
    <span class="bp">|</span> <span class="n">succ</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">norm_aux_succ_eq_up</span><span class="o">]</span><span class="bp">;</span>
      <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">up</span> <span class="n">zero</span><span class="o">)</span> <span class="k">from</span> <span class="n">is_norm_up</span> <span class="n">h1</span>
      <span class="n">exact</span> <span class="n">is_norm_norm_aux</span> <span class="n">h2</span>
    <span class="bp">|</span> <span class="n">pred</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">norm_aux_pred_eq_down</span><span class="o">]</span><span class="bp">;</span>
      <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">down</span> <span class="n">zero</span><span class="o">)</span> <span class="k">from</span> <span class="n">is_norm_down</span> <span class="n">h1</span>
      <span class="n">exact</span> <span class="n">is_norm_norm_aux</span> <span class="n">h2</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">=&gt;</span>
    <span class="k">match</span> <span class="n">b</span><span class="o">,</span><span class="n">h1</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">zero</span><span class="o">,</span> <span class="n">h1</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="n">exact</span> <span class="n">is_norm_up</span> <span class="n">h1</span>
    <span class="bp">|</span> <span class="n">succ</span> <span class="n">b</span><span class="o">,</span> <span class="n">h1</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">norm_aux_succ_eq_up</span><span class="o">]</span><span class="bp">;</span>
      <span class="k">show</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">norm_aux</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">))</span> <span class="n">b</span><span class="o">)</span>
      <span class="n">exact</span> <span class="n">is_norm_norm_aux</span> <span class="n">h1</span>
    <span class="bp">|</span> <span class="n">pred</span> <span class="n">b</span><span class="o">,</span> <span class="n">h1</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">norm_aux_pred_eq_down</span><span class="o">]</span>
      <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">down</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">))</span> <span class="k">from</span> <span class="n">is_norm_down</span> <span class="n">h1</span>
      <span class="n">exact</span> <span class="n">is_norm_norm_aux</span> <span class="n">h2</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="n">a</span> <span class="bp">=&gt;</span>
    <span class="k">match</span> <span class="n">b</span><span class="o">,</span><span class="n">h1</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">zero</span><span class="o">,</span> <span class="n">h1</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="n">exact</span> <span class="n">is_norm_down</span> <span class="n">h1</span>
    <span class="bp">|</span> <span class="n">succ</span> <span class="n">b</span><span class="o">,</span> <span class="n">h1</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">norm_aux_succ_eq_up</span><span class="o">]</span><span class="bp">;</span>
      <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">up</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">))</span> <span class="k">from</span> <span class="n">is_norm_up</span> <span class="n">h1</span>
      <span class="n">exact</span> <span class="n">is_norm_norm_aux</span> <span class="n">h2</span>
    <span class="bp">|</span> <span class="n">pred</span> <span class="n">b</span><span class="o">,</span> <span class="n">h1</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">norm_aux_pred_eq_down</span><span class="o">]</span>
      <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">down</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">))</span> <span class="k">from</span> <span class="n">is_norm_down</span> <span class="n">h1</span>
      <span class="n">exact</span> <span class="n">is_norm_norm_aux</span> <span class="n">h2</span>
</code></pre></div>



<a name="242154010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/242154010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#242154010">(Jun 10 2021 at 02:44)</a>:</h4>
<p>Your proof of <code>is_norm_norm_aux</code> is suspiciously long. It should be: induction on <code>b</code> generalizing <code>a</code>, and then apply <code>h</code>, <code>IH (is_norm_up h)</code> and <code>IH (is_norm_down h)</code> in the three cases</p>



<a name="242154807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/242154807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#242154807">(Jun 10 2021 at 03:02)</a>:</h4>
<p>Yes... this is indeed quite a bit shorter , thanks again</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">is_norm_norm_aux</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">norm_aux</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h1</span>
  <span class="n">induction</span> <span class="n">b</span> <span class="n">generalizing</span> <span class="n">a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="n">h1</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">b</span> <span class="n">h2</span> <span class="bp">=&gt;</span>
    <span class="k">show</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">norm_aux</span> <span class="o">(</span><span class="n">up</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span><span class="o">)</span>
    <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">up</span> <span class="n">a</span><span class="o">)</span> <span class="k">from</span> <span class="n">is_norm_up</span> <span class="n">h1</span>
    <span class="n">exact</span> <span class="n">h2</span> <span class="n">h3</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="n">b</span> <span class="n">h2</span> <span class="bp">=&gt;</span>
    <span class="k">show</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">norm_aux</span> <span class="o">(</span><span class="n">down</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span><span class="o">)</span>
    <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">down</span> <span class="n">a</span><span class="o">)</span> <span class="k">from</span> <span class="n">is_norm_down</span> <span class="n">h1</span>
    <span class="n">exact</span> <span class="n">h2</span> <span class="n">h3</span>
</code></pre></div>



<a name="242155153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/242155153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#242155153">(Jun 10 2021 at 03:10)</a>:</h4>
<p>And it's done</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">is_norm_norm</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">norm</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
    <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">zero</span><span class="o">)</span> <span class="k">from</span> <span class="n">rfl</span>
    <span class="n">exact</span> <span class="n">is_norm_norm_aux</span> <span class="n">h1</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
    <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">is_norm</span> <span class="o">(</span><span class="n">zero</span><span class="o">)</span> <span class="k">from</span> <span class="n">rfl</span>
    <span class="n">exact</span> <span class="n">is_norm_norm_aux</span> <span class="n">h1</span>
</code></pre></div>



<a name="242155337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/242155337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#242155337">(Jun 10 2021 at 03:15)</a>:</h4>
<p>Thank you very much for the guidance <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> . I can finally sleep in peace (thinking about this has been keeping me up at night).</p>



<a name="242155384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/242155384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#242155384">(Jun 10 2021 at 03:16)</a>:</h4>
<p>for the last proof, you don't need a match at all</p>



<a name="242155385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/242155385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#242155385">(Jun 10 2021 at 03:16)</a>:</h4>
<p><code>is_norm_norm_aux rfl</code></p>



<a name="242155637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/242155637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#242155637">(Jun 10 2021 at 03:23)</a>:</h4>
<p>Oh right, even better. I really need to work on simplicity</p>



<a name="242174540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Normalizing%20a%20synthetic%20integer%20type/near/242174540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Normalizing.20a.20synthetic.20integer.20type.html#242174540">(Jun 10 2021 at 08:33)</a>:</h4>
<p>I think long proofs is fine when you're just learning. You need to experience the "goals accomplished" triumph :-)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
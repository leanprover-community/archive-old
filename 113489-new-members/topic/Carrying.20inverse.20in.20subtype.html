---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html">Carrying inverse in subtype</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="201231565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201231565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201231565">(Jun 18 2020 at 06:23)</a>:</h4>
<p>How do I encode a subtype of matrices that have inverses, and then utilize those inverses in a function? I've read the source for #doc/linear_algebra/special_linear_group and #doc/algebra/invertible for ideas on how it operates. I guess my current issue is how to provide a value I have instead of a <code>classical.some _</code>. I thought that my encoding would have <code>inv_mat</code>carry the parent with it. Is it better to encode <code>invertible_matrix</code> as a pair of matrices?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">matrix</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span>

<span class="n">def</span> <span class="n">invertible_matrix</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span> <span class="bp">//</span> <span class="bp">∃!</span> <span class="n">B</span><span class="o">,</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">}</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">inv_mat_unique</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="o">)</span> <span class="n">R</span><span class="o">}</span>
                     <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hC</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span><span class="n">one_mul</span> <span class="n">B</span><span class="o">,</span> <span class="bp">&lt;-</span><span class="n">hC</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">hB</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span>

<span class="kn">instance</span> <span class="n">coe_matrix</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">invertible_matrix</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="bp">.</span><span class="n">val</span><span class="bp">⟩</span>

<span class="c1">-- ... proving an existence of an inverse is noncomputable</span>
<span class="c1">-- ... because we do not construct it</span>
<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">inv_mat</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">invertible_matrix</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">choose</span> <span class="n">Ainv</span> <span class="n">hinv</span> <span class="kn">using</span> <span class="n">A</span><span class="bp">.</span><span class="n">property</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">Ainv</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">inv_mat_cancel_self</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">invertible_matrix</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">inv_mat</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">Ainv</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hleft</span><span class="o">,</span> <span class="n">hright</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">huniq</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">A</span><span class="bp">.</span><span class="n">property</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">huniq</span> <span class="o">(</span><span class="n">inv_mat</span> <span class="n">A</span><span class="o">),</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">hright</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">inv_mat</span> <span class="n">at</span> <span class="n">huniq</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">huniq</span><span class="o">,</span>
  <span class="c1">-- huniq : A.val.mul (classical.some _) = 1 →</span>
  <span class="c1">--         (classical.some _).mul A.val = 1 →</span>
  <span class="c1">--         classical.some _ = Ainv</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">huniq</span> <span class="n">hleft</span> <span class="n">hright</span><span class="o">],</span> <span class="c1">-- can&#39;t supply a specified value instead of classical.some</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201231980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201231980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201231980">(Jun 18 2020 at 06:31)</a>:</h4>
<p>I'm basically struggling to unify the <code>Ainv</code> I get from <code>A.property</code> in the latter lemma with how <code>inv_mat A</code> should be that <code>Ainv</code> due to the definition.</p>



<a name="201231988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201231988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201231988">(Jun 18 2020 at 06:31)</a>:</h4>
<p><code>units</code></p>



<a name="201232075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201232075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201232075">(Jun 18 2020 at 06:33)</a>:</h4>
<p>So, forgo subtypes and head directly to structures.</p>



<a name="201232187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201232187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201232187">(Jun 18 2020 at 06:35)</a>:</h4>
<p>what is the benefit of using subtype?</p>



<a name="201232244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201232244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201232244">(Jun 18 2020 at 06:36)</a>:</h4>
<p>don't use tactics in definitions</p>



<a name="201232271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201232271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201232271">(Jun 18 2020 at 06:37)</a>:</h4>
<p>Mathematicians are trained to think about subobjects because in set theory the map from the subobject to the object is completely transparent. This can't happen in lean so why bother with subtypes at all?</p>



<a name="201232371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201232371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201232371">(Jun 18 2020 at 06:38)</a>:</h4>
<p>The special_linear_group in mathlib is defined using a subtype, so I tried emulating that: <a href="https://github.com/leanprover-community/mathlib/blob/0736c95c61521f5040666d5832d808f71c537ab8/src/linear_algebra/special_linear_group.lean#L54">https://github.com/leanprover-community/mathlib/blob/0736c95c61521f5040666d5832d808f71c537ab8/src/linear_algebra/special_linear_group.lean#L54</a></p>



<a name="201232378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201232378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201232378">(Jun 18 2020 at 06:39)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">matrix</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span>

<span class="n">def</span> <span class="n">invertible_matrix</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">R</span> <span class="bp">//</span> <span class="bp">∃!</span> <span class="n">B</span><span class="o">,</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">}</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="n">R</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">inv_mat_unique</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">:</span> <span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">R</span><span class="o">}</span>
                     <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hC</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span><span class="n">one_mul</span> <span class="n">B</span><span class="o">,</span> <span class="bp">&lt;-</span><span class="n">hC</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">hB</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span>

<span class="kn">instance</span> <span class="n">coe_matrix</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">invertible_matrix</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">delta</span> <span class="n">invertible_matrix</span><span class="bp">;</span> <span class="n">apply_instance</span>

<span class="c1">-- ... proving an existence of an inverse is noncomputable</span>
<span class="c1">-- ... because we do not construct it</span>
<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">inv_mat</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">invertible_matrix</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">A</span><span class="bp">.</span><span class="n">property</span>

<span class="kn">lemma</span> <span class="n">inv_mat_cancel_self</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">invertible_matrix</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">inv_mat</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="n">A</span><span class="bp">.</span><span class="n">property</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span>
</code></pre></div>



<a name="201232578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201232578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201232578">(Jun 18 2020 at 06:42)</a>:</h4>
<p><code>units</code> has an API and is perfect for general linear groups</p>



<a name="201232709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201232709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201232709">(Jun 18 2020 at 06:44)</a>:</h4>
<p><code>units</code> looks pretty slick to use. What's the reason why SL_n would be in the library as a subtype?</p>



<a name="201232742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201232742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201232742">(Jun 18 2020 at 06:45)</a>:</h4>
<p>because the inverse can be explicitly given I assume</p>



<a name="201232846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201232846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201232846">(Jun 18 2020 at 06:47)</a>:</h4>
<p>Because it's not the units of something :-)</p>



<a name="201232861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201232861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201232861">(Jun 18 2020 at 06:47)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/b91909e77e219098a2f8cc031f89d595fe274bd2/src/linear_algebra/special_linear_group.lean#L83-L84">https://github.com/leanprover-community/mathlib/blob/b91909e77e219098a2f8cc031f89d595fe274bd2/src/linear_algebra/special_linear_group.lean#L83-L84</a></p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">has_inv</span> <span class="o">:</span> <span class="n">has_inv</span> <span class="o">(</span><span class="n">special_linear_group</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">A</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">adjugate</span> <span class="n">A</span><span class="o">,</span> <span class="n">det_adjugate_eq_one</span> <span class="n">A</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩⟩</span>
</code></pre></div>



<a name="201235180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201235180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201235180">(Jun 18 2020 at 07:23)</a>:</h4>
<p>I see, and because the inverse is given explicitly, we don't need to rely on <code>noncomputable</code>, and the usage of subtype makes sense.</p>



<a name="201235310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201235310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201235310">(Jun 18 2020 at 07:24)</a>:</h4>
<p>Just as an exercise, I finished the <code>has_inv</code> instance without using tactics in the proof of the instance itself, and did the same for <code>has_mul</code>, <code>has_one</code>. But I'll follow your suggestions and rely on structure-based encoding instead.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">matrix</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span>

<span class="n">def</span> <span class="n">invertible_matrix</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span> <span class="bp">//</span> <span class="bp">∃!</span> <span class="n">B</span><span class="o">,</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">}</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">inv_mat_unique</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="o">)</span> <span class="n">R</span><span class="o">}</span>
                     <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hC</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span><span class="n">one_mul</span> <span class="n">B</span><span class="o">,</span> <span class="bp">&lt;-</span><span class="n">hC</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">hB</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span>

<span class="kn">instance</span> <span class="n">coe_matrix</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">invertible_matrix</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="bp">.</span><span class="n">val</span><span class="bp">⟩</span>

<span class="c1">-- ... proving an existence of an inverse is noncomputable</span>
<span class="c1">-- ... because we do not construct it</span>
<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">inv_mat</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">invertible_matrix</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">A</span><span class="bp">.</span><span class="n">property</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">inv_mat_cancel_self</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">invertible_matrix</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">inv_mat</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="n">A</span><span class="bp">.</span><span class="n">property</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mat_cancel_inv_self</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">invertible_matrix</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="err">↑</span><span class="n">A</span> <span class="bp">*</span> <span class="n">inv_mat</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="n">A</span><span class="bp">.</span><span class="n">property</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">1</span>

<span class="kn">lemma</span> <span class="n">inv_mat_has_inv</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">invertible_matrix</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃!</span> <span class="n">B</span><span class="o">,</span> <span class="n">inv_mat</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">inv_mat</span> <span class="n">A</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">use</span> <span class="n">A</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">inv_mat_cancel_self</span> <span class="bp">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">mat_cancel_inv_self</span> <span class="bp">_</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">a&#39;</span> <span class="bp">⟨</span><span class="n">hleft&#39;</span><span class="o">,</span> <span class="n">hright&#39;</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">inv_mat_unique</span> <span class="n">hleft&#39;</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">mat_cancel_inv_self</span> <span class="bp">_</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="n">inv_mat_inv</span> <span class="o">:</span> <span class="n">has_inv</span> <span class="o">(</span><span class="n">invertible_matrix</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">A</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">inv_mat</span> <span class="n">A</span><span class="o">,</span> <span class="n">inv_mat_has_inv</span> <span class="bp">_⟩⟩</span>
</code></pre></div>



<a name="201235916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201235916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201235916">(Jun 18 2020 at 07:32)</a>:</h4>
<p>You can use tactics for proofs -- you should just be clear about whether you're defining a term of type <code>P : Prop</code> or of type <code>T : Type</code>. For example a term of type <code>fin n</code> is a pair consisting of a natural (data, which should be defined without tactics) and a proof (for which tactics are fine)</p>



<a name="201236379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201236379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201236379">(Jun 18 2020 at 07:38)</a>:</h4>
<p>Got it. Can you clarify what you mean by "ask for a B such at BA = 1"? And how does <code>delta</code> work?</p>



<a name="201236413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201236413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201236413">(Jun 18 2020 at 07:38)</a>:</h4>
<p>Do you mean that the lemmas (and possibly definitions) should require a <code>Prop</code> term of <code>h : BA = 1</code>?</p>



<a name="201237339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201237339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201237339">(Jun 18 2020 at 07:51)</a>:</h4>
<p>I really appreciate all the help and insight -- formalizing is difficult for me because of how ingrained some assumptions about conversions between mathematical definitions are for me. Like what was highlighted earlier about mapping from subobject to object.</p>



<a name="201238530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201238530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201238530">(Jun 18 2020 at 08:05)</a>:</h4>
<p>I just meant: instead of saying that A is invertible if there exists a unique B such that AB=BA=1, you could just ask for a B with AB=BA=1, or even, in your specific situation, for a B with AB=1</p>



<a name="201238588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201238588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201238588">(Jun 18 2020 at 08:05)</a>:</h4>
<p>They all give the same answer, but my gut feeling is that asking for uniqueness in your definition is just going to make it harder to use it</p>



<a name="201239778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201239778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201239778">(Jun 18 2020 at 08:19)</a>:</h4>
<p>Asking for uniqueness requires maybe 3 or 4 additional lines in the proofs portions of instance definitions. Having the uniqueness lemma and the cancellation lemmas make that portion of the proof pretty straightforward. The example above was </p>
<div class="codehilite"><pre><span></span><code>  <span class="o">{</span> <span class="n">rintros</span> <span class="n">a&#39;</span> <span class="bp">⟨</span><span class="n">hleft&#39;</span><span class="o">,</span> <span class="n">hright&#39;</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">inv_mat_unique</span> <span class="n">hleft&#39;</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">mat_cancel_inv_self</span> <span class="bp">_</span> <span class="o">}</span>
</code></pre></div>


<p>or from the <code>has_mul</code> proof:</p>
<div class="codehilite"><pre><span></span><code>  <span class="o">{</span> <span class="n">intros</span> <span class="n">C</span> <span class="n">hC</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">inv_mat_unique</span> <span class="n">hC</span><span class="bp">.</span><span class="n">left</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">&lt;-</span><span class="n">mul_assoc</span> <span class="n">Ainv</span><span class="o">,</span> <span class="n">hA</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">hB</span><span class="bp">.</span><span class="mi">2</span><span class="o">]}</span>
</code></pre></div>



<a name="201239861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201239861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201239861">(Jun 18 2020 at 08:20)</a>:</h4>
<p>I'll take your word for it that the uniqueness in the definition can cause issues later on -- I've stripped it out.</p>



<a name="201240128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201240128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201240128">(Jun 18 2020 at 08:23)</a>:</h4>
<p>I'm not claiming a theorem, I'm just making an observation based on a gut instinct. I guess that actually it doesn't really matter what your definition it, because you can make constructors for the type given any of the other proofs, e.g. you can just construct a function which given B such that BA=1 produces a term of your type. I'm not very good at definitions in Lean -- mathematicians understand specifications well, but this is an implementation issue.</p>



<a name="201257247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201257247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201257247">(Jun 18 2020 at 11:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype/near/201238530">said</a>:</p>
<blockquote>
<p>can just construct a function which given B such that BA=1 produces a term of your type</p>
</blockquote>
<p>For general matrices it is a slightly non-trivial theorem that having a left inverse gives you a right inverse for free, a while ago I proved some bits for this, <a href="https://github.com/leanprover-community/mathlib/pull/1822/files">https://github.com/leanprover-community/mathlib/pull/1822/files</a> .<br>
One advantage of the subtype approach is that lean knows how to iterate over a subtype if the original type is finite and the condition is decidable as there is no new data. I think with this branch I got lean to <code>#eval fintype.card (general_linear 3 (zmod 5))</code> in this way, as lean already knows this set is finite and can just run over all matrices checking if they have a right inverse. Of course this is a bit silly but I found forcing lean to calculate the size of this group by hand oddly fun.</p>



<a name="201257558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201257558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201257558">(Jun 18 2020 at 11:57)</a>:</h4>
<p>There's no reason this couldn't also be easy for structures with a little <code>derive</code> handler magic.</p>



<a name="201279923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201279923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201279923">(Jun 18 2020 at 15:02)</a>:</h4>
<p>Since we're on the topic of defintions, and invertible matrices, I have this other way of defining them, using <code>Prop</code> instead of <code>Type</code>. I thought<code>unfold</code> was usually not necessary. Why is it necessary here?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">matrix</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">mat_invertible</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="mi">1</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">mat_invertible</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">=</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- rewrite tactic failed, lemma is not an equality nor a iff</span>
  <span class="n">rw</span> <span class="n">one_mul</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mat_inv_left_cancel</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">mat_invertible</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">=</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">mat_invertible</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">]</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201280091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201280091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201280091">(Jun 18 2020 at 15:02)</a>:</h4>
<p><code>simp [h]</code> also only works after an <code>unfold</code>.</p>



<a name="201280464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201280464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201280464">(Jun 18 2020 at 15:04)</a>:</h4>
<p><code>rw</code> and <code>simp</code> work up to syntactic equality, as opposed to things like <code>exact</code> and <code>apply</code> which work up to definitional equality.</p>



<a name="201280790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201280790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201280790">(Jun 18 2020 at 15:06)</a>:</h4>
<p>You could add a <code>simp</code> lemma <code>@[simp] lemma mat_invertible_def  : mat_invertible A B \iff A * B = 1 := iff.rfl</code> and then maybe <code>simp [h]</code> would work. I'm not a <code>simp</code> expert though</p>



<a name="201288121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201288121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201288121">(Jun 18 2020 at 15:56)</a>:</h4>
<p>I tried that, but that still doesn't make <code>simp</code> happy. At least using the lemma you provided directly in <code>rw</code> will work:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">matrix</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">mat_invertible</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="mi">1</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mat_invertible_def</span> <span class="o">:</span> <span class="n">mat_invertible</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">↔</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">iff</span><span class="bp">.</span><span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mat_inv_left_cancel</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">mat_invertible</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">=</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">],</span> <span class="c1">-- does not prove</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mat_inv_left_cancel&#39;</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">mat_invertible</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">=</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">(</span><span class="n">mat_invertible_def</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201288812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Carrying%20inverse%20in%20subtype/near/201288812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Carrying.20inverse.20in.20subtype.html#201288812">(Jun 18 2020 at 16:01)</a>:</h4>
<p>I guess I don't understand something about simp, because I thought now this would work, but it doesn't.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">matrix</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">mat_invertible</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="mi">1</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mat_invertible_def</span> <span class="o">:</span> <span class="n">mat_invertible</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">↔</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">iff</span><span class="bp">.</span><span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mat_inv_left_cancel</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">mat_invertible</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">=</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">(</span><span class="n">mat_invertible_def</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">mat_invertible</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">=</span> <span class="n">C</span> <span class="o">:=</span>
<span class="n">mat_inv_left_cancel</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">h</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">mat_invertible</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">=</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="c1">-- fails</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
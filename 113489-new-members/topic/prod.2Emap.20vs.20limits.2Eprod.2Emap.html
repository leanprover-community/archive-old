---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html">prod.map vs limits.prod.map</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="291745502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291745502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291745502">(Aug 02 2022 at 18:01)</a>:</h4>
<p>Hello, I am yet again working on the thing discussed in <a class="stream-topic" data-stream-id="116395" href="/#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules">#maths &gt; Definition of presheaf of modules</a>, and I believe I have reduced (a chunk of) the problem to showing a statement like the following:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>MWE Lemma statement</p>
</div><div class="spoiler-content" aria-hidden="true">
<p>import category_theory.closed.cartesian<br>
import category_theory.limits.types<br>
import category_theory.limits.shapes.types<br>
import category_theory.types</p>
<p>noncomputable theory</p>
<p>universes u v</p>
<p>open category_theory<br>
-- open category_theory.limits<br>
open category_theory.limits.types<br>
open category_theory.concrete_category</p>
<p>instance : monoidal_category (Type u) :=<br>
  monoidal_of_has_finite_products (Type u)</p>
<p>lemma prod_map_bpo_commutes (A B C D : Type u) (f : A ⟶ C) (g : B ⟶ D) :<br>
as_hom (<a href="http://prod.map">prod.map</a> f g) ≫<br>
(binary_product_iso C D).inv =<br>
(binary_product_iso A B).inv ≫<br>
<a href="http://limits.prod.map">limits.prod.map</a> f g :=<br>
sorry</p>
</div></div>
<p>I don't really know how one would go about comparing <code>prod.map</code> and <code>limits.prod.map</code>, does anyone know how to prove such at thing?</p>



<a name="291746322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291746322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291746322">(Aug 02 2022 at 18:07)</a>:</h4>
<p>Hmm, it seems I could also use advice on how to get code to properly highlight in a spoiler, if anyone knows.</p>



<a name="291746344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291746344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291746344">(Aug 02 2022 at 18:07)</a>:</h4>
<p>I think <code>ext1</code> could help? Or maybe <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.prod.hom_ext">docs#category_theory.limits.prod.hom_ext</a> if <code>ext</code> found the wrong lemma.</p>



<a name="291746548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291746548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291746548">(Aug 02 2022 at 18:09)</a>:</h4>
<p>It should be </p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Spoiler</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="n">foo</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
</div></div>
<p>You can click the view source on the top right to see how I wrote it.</p>



<a name="291756684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291756684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291756684">(Aug 02 2022 at 19:25)</a>:</h4>
<p>Ok, I ended up proving the lemma! Thanks!</p>



<a name="291757517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291757517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291757517">(Aug 02 2022 at 19:32)</a>:</h4>
<p>I suspect <code>by {ext1, simp}</code> should close the goal. If not, then there are some simp lemmas missing.</p>



<a name="291951041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291951041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291951041">(Aug 04 2022 at 01:09)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> turns out, <code>by {ext1, simp}</code> does not close it. I don't quite know how <code>ext1</code> works, but it seems to focus on the first, goal, and since there are two (one for each projection), it doesn't seem to work. There also seem to be some lemmas missing, <code>simp</code> doesn't even close the first goal.</p>



<a name="291951116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291951116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291951116">(Aug 04 2022 at 01:11)</a>:</h4>
<p>By using the strategy of "write a bunch of have statements that can be cleared by simp, and then use <code>simp?</code> to turn them into things of the form <code>conv_lhs { simp only [...] }</code>, I was able to come up with the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">prod_map_bpo_commutes</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">⟶</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">⟶</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span>
<span class="n">as_hom</span> <span class="o">(</span><span class="n">prod.map</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="bp">≫</span>
<span class="o">(</span><span class="n">binary_product_iso</span> <span class="n">C</span> <span class="n">D</span><span class="o">)</span><span class="bp">.</span><span class="n">inv</span> <span class="bp">=</span>
<span class="o">(</span><span class="n">binary_product_iso</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">inv</span> <span class="bp">≫</span>
<span class="n">limits.prod.map</span> <span class="n">f</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">category_theory.limits.prod.hom_ext</span><span class="o">,</span>
  <span class="c1">-- prod.fst, goal 1</span>
  <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span> <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">conv_lhs</span> <span class="o">{</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">category_theory.types_comp_apply</span><span class="o">,</span>
               <span class="n">category_theory.limits.types.binary_product_iso_inv_comp_fst_apply</span><span class="o">],</span>
  <span class="o">},</span>
  <span class="n">conv_rhs</span> <span class="o">{</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">category_theory.limits.prod.map_fst</span><span class="o">,</span>
                         <span class="n">category_theory.iso.cancel_iso_inv_left</span><span class="o">,</span>
                         <span class="n">eq_self_iff_true</span><span class="o">,</span>
                         <span class="n">category_theory.category.assoc</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">category_theory.types_comp_apply</span><span class="o">,</span>
                 <span class="n">eq_self_iff_true</span><span class="o">,</span>
                 <span class="n">category_theory.limits.types.binary_product_iso_inv_comp_fst_apply</span><span class="o">]</span>
  <span class="o">},</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="c1">-- prod.snd, goal 2</span>
  <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span> <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">conv_lhs</span> <span class="o">{</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">category_theory.types_comp_apply</span><span class="o">,</span>
               <span class="n">category_theory.limits.types.binary_product_iso_inv_comp_snd_apply</span><span class="o">],</span>
  <span class="o">},</span>
  <span class="n">conv_rhs</span> <span class="o">{</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">category_theory.limits.prod.map_snd</span><span class="o">,</span>
                         <span class="n">category_theory.iso.cancel_iso_inv_left</span><span class="o">,</span>
                         <span class="n">eq_self_iff_true</span><span class="o">,</span>
                         <span class="n">category_theory.category.assoc</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">category_theory.types_comp_apply</span><span class="o">,</span>
                 <span class="n">eq_self_iff_true</span><span class="o">,</span>
                 <span class="n">category_theory.limits.types.binary_product_iso_inv_comp_snd_apply</span><span class="o">]</span>
  <span class="o">},</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="291951355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291951355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291951355">(Aug 04 2022 at 01:16)</a>:</h4>
<p>you should use braces to delimit subgoals instead of comments</p>



<a name="291952998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291952998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291952998">(Aug 04 2022 at 01:46)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.closed.cartesian</span>
<span class="kn">import</span> <span class="n">category_theory.limits.types</span>
<span class="kn">import</span> <span class="n">category_theory.limits.shapes.types</span>
<span class="kn">import</span> <span class="n">category_theory.types</span>

<span class="kd">noncomputable theory</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">open</span> <span class="n">category_theory</span>
<span class="c1">-- open category_theory.limits</span>
<span class="kn">open</span> <span class="n">category_theory.limits.types</span>
<span class="kn">open</span> <span class="n">category_theory.concrete_category</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">monoidal_category</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">monoidal_of_has_finite_products</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>

<span class="kd">@[simp, reassoc]</span>
<span class="kd">lemma</span> <span class="n">fst_foo</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">binary_product_iso</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">inv</span> <span class="bp">≫</span> <span class="n">limits.prod.fst</span> <span class="bp">=</span> <span class="n">prod.fst</span> <span class="o">:=</span>
<span class="n">limits.prod.lift_fst</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">@[simp, reassoc]</span>
<span class="kd">lemma</span> <span class="n">snd_foo</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">binary_product_iso</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">inv</span> <span class="bp">≫</span> <span class="n">limits.prod.snd</span> <span class="bp">=</span> <span class="n">prod.snd</span> <span class="o">:=</span>
<span class="n">limits.prod.lift_snd</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">lemma</span> <span class="n">prod_map_bpo_commutes</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">⟶</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">⟶</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span>
<span class="n">as_hom</span> <span class="o">(</span><span class="n">prod.map</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="bp">≫</span>
<span class="o">(</span><span class="n">binary_product_iso</span> <span class="n">C</span> <span class="n">D</span><span class="o">)</span><span class="bp">.</span><span class="n">inv</span> <span class="bp">=</span>
<span class="o">(</span><span class="n">binary_product_iso</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">inv</span> <span class="bp">≫</span>
<span class="n">limits.prod.map</span> <span class="n">f</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext1</span><span class="bp">;</span> <span class="n">simpa</span> <span class="o">}</span>
</code></pre></div>



<a name="291953006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291953006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291953006">(Aug 04 2022 at 01:46)</a>:</h4>
<p>not quite <code>ext1, simp</code>, but close ;)</p>



<a name="291964343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291964343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291964343">(Aug 04 2022 at 04:53)</a>:</h4>
<p>When I change the final semicolon to a comma, Lean complains because there are two goals and only the first one gets solved. Can you explain why simp works when there is a semicolon, but if I change that to a comma it complains?</p>



<a name="291964837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/prod.map%20vs%20limits.prod.map/near/291964837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/prod.2Emap.20vs.20limits.2Eprod.2Emap.html#291964837">(Aug 04 2022 at 05:03)</a>:</h4>
<p>A semicolon means: apply the next tactic to <em>all</em> the goals. So, in your case, the tactic after the semicolon solves both goals, but when you change it to a comma, that last tactic only acts on the 1st goal (it solves it, but there's still one leftover).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
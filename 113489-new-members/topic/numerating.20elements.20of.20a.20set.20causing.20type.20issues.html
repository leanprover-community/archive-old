---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html">numerating elements of a set causing type issues</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="321618475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321618475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321618475">(Jan 16 2023 at 11:34)</a>:</h4>
<p>Hello everyone,</p>
<p>I defined a directed walk in a directed graph with start and ending points in V. However, I would like to have a path which starting and ending points are in A and B, respectively. Additionally, as I want to define n different path, I want to numerate the elements in A.verts and B.verts by making them a list. But then the nth member of that list hast the wrong type to be plugged in the direct walk. Here a MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universes</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">directed_simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">):=</span> <span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">directed_simple_graph</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">directed_simple_graph</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">directed_walk</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">directed_walk</span> <span class="n">u</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span><span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">directed_walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">directed_walk</span> <span class="n">u</span> <span class="n">w</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">vertex_subset_n</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">verts</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">card</span> <span class="o">:</span> <span class="n">verts.card</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">vertex_subset_n</span> <span class="n">n</span> <span class="n">V</span><span class="o">}</span>
<span class="kn">namespace</span> <span class="n">directed_walk</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">start</span> <span class="o">:</span> <span class="n">A.verts</span><span class="o">}</span> <span class="o">{</span><span class="n">finish</span> <span class="o">:</span> <span class="n">B.verts</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.directed_walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">p2</span> <span class="o">:</span> <span class="n">G.directed_walk</span> <span class="n">start</span> <span class="n">finish</span><span class="o">}</span> <span class="c1">--works but start and end point are not numerated</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">(</span><span class="n">A.verts</span><span class="o">)</span><span class="bp">.</span><span class="n">to_list.nth</span> <span class="mi">1</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">p3</span> <span class="o">:</span> <span class="n">directed_walk</span> <span class="n">t</span> <span class="n">v</span><span class="o">}</span> <span class="c1">-- does not work</span>

<span class="kd">end</span> <span class="n">directed_walk</span>
<span class="kd">end</span> <span class="n">directed_simple_graph</span>
</code></pre></div>
<p>The knowledge that <code>.nth 0</code> up to <code>.nth (n-1)</code> is a member of the list :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">A_verts_list_length_eq_n</span> <span class="o">:</span> <span class="n">A.verts.to_list.length</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>  <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.length_to_list</span><span class="o">],</span> <span class="n">exact</span> <span class="n">A.card</span><span class="o">}</span>
</code></pre></div>
<p>How can I combine those such that I can numerate my start and end points, as it is important to differentiate between different ones ?<br>
Any help is appreciated.</p>



<a name="321618750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321618750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321618750">(Jan 16 2023 at 11:35)</a>:</h4>
<p>I didn't read your code so my answer is possibly OT, but I wanna say that <code>list.nth</code> and <code>list.nth_le</code> indexes elements from zero.</p>



<a name="321619226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321619226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321619226">(Jan 16 2023 at 11:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321618750">schrieb</a>:</p>
<blockquote>
<p>I didn't read your code so my answer is possibly OT, but I wanna say that <code>list.nth</code> and <code>list.nth_le</code> indexes elements from zero.</p>
</blockquote>
<p>Thats true, but unfortunately not helpful. Nevertheless, edited the last part, should be correct now.</p>



<a name="321620031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321620031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321620031">(Jan 16 2023 at 11:41)</a>:</h4>
<p>Can we <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> this? What is the main theorem you're wanting to prove? You're getting into territory where it's helpful to know the goal.</p>



<a name="321620883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321620883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321620883">(Jan 16 2023 at 11:45)</a>:</h4>
<p>Also, having a universe <code>u</code> and a "graph vertex <code>u</code>" is probably not a good idea.</p>



<a name="321621222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321621222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321621222">(Jan 16 2023 at 11:47)</a>:</h4>
<p>Is there a way to make the compiler complain about these name collisions?</p>



<a name="321621638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321621638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321621638">(Jan 16 2023 at 11:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321620031">schrieb</a>:</p>
<blockquote>
<p>Can we <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> this? What is the main theorem you're wanting to prove? You're getting into territory where it's helpful to know the goal.</p>
</blockquote>
<p>Fair enough.<br>
Well I am trying to formalize the Lindström Gessel Viennot Lemma as a bachelor thesis (therefore all the directed stuff). So I am working on establishing all the necessary objects which are weights, weight of a walk, path system, weight of path system, path matrix.</p>
<p>The current goal is to define the structure of a (vertex disjoint) path system which needs </p>
<ul>
<li>a permutation s and its sign</li>
<li>n paths p_i : A_i \to B_s(i), whereas A and B are subsets of the vertices of cardinality n<br>
(- vertex disjointness of the paths)</li>
</ul>
<p>Therefor the effort to numerate A.verts and B.verts and get the correct elements as an input for direct walks.</p>



<a name="321644888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321644888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321644888">(Jan 16 2023 at 13:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321620883">said</a>:</p>
<blockquote>
<p>Also, having a universe <code>u</code> and a "graph vertex <code>u</code>" is probably not a good idea.</p>
</blockquote>
<p>Maybe not, but for better or for worse we've been doing this in mathlib code throughout the graph library and its seems to work out fine</p>



<a name="321645574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321645574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321645574">(Jan 16 2023 at 13:51)</a>:</h4>
<p><span class="user-mention" data-user-id="573061">@Christopher Schmidt</span> I'm not sure I understand exactly what you're trying to do yet (what does it mean to <em>numerate</em> a set?), but maybe it's helpful to know that the way we talk about ordered finite lists of elements is either <code>f : fin n -&gt; V</code> or the combination <code>[fintype α]</code> with <code>f : α -&gt; V</code>. Sometimes we use a coercion, where <code>s : finset α</code> and then use <code>f : s -&gt; V</code>.</p>



<a name="321646478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321646478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321646478">(Jan 16 2023 at 13:56)</a>:</h4>
<p>Then when you have a pair of such a family of elements (for example <code>[fintype α]</code> with <code>f g : α -&gt; V</code>), you can work with <code>Π (i : α), G.directed_walk (f i) (g i)</code>, which is an <code>α</code>-indexed family of walks.</p>



<a name="321646864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321646864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321646864">(Jan 16 2023 at 13:58)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span> I see your <span aria-label="prohibited" class="emoji emoji-1f6ab" role="img" title="prohibited">:prohibited:</span>, but universe level variables and normal variables are in different namespaces, so it can't cause problems for Lean at least.</p>



<a name="321647292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321647292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321647292">(Jan 16 2023 at 14:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="573061">Christopher Schmidt</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321621638">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321620031">schrieb</a>:</p>
<blockquote>
<p>Can we <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> this? What is the main theorem you're wanting to prove? You're getting into territory where it's helpful to know the goal.</p>
</blockquote>
<p>Fair enough.<br>
Well I am trying to formalize the Lindström Gessel Viennot Lemma as a bachelor thesis (therefore all the directed stuff). So I am working on establishing all the necessary objects which are weights, weight of a walk, path system, weight of path system, path matrix.</p>
<p>The current goal is to define the structure of a (vertex disjoint) path system which needs </p>
<ul>
<li>a permutation s and its sign</li>
<li>n paths p_i : A_i \to B_s(i), whereas A and B are subsets of the vertices of cardinality n<br>
(- vertex disjointness of the paths)</li>
</ul>
<p>Therefor the effort to numerate A.verts and B.verts and get the correct elements as an input for direct walks.</p>
</blockquote>
<p>Let's rather focus on the question.</p>



<a name="321652264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321652264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321652264">(Jan 16 2023 at 14:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321645574">schrieb</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="573061">Christopher Schmidt</span> I'm not sure I understand exactly what you're trying to do yet (what does it mean to <em>numerate</em> a set?), but maybe it's helpful to know that the way we talk about ordered finite lists of elements is either <code>f : fin n -&gt; V</code> or the combination <code>[fintype α]</code> with <code>f : α -&gt; V</code>. Sometimes we use a coercion, where <code>s : finset α</code> and then use <code>f : s -&gt; V</code>.</p>
</blockquote>
<p>Maybe, what I have got by now, illustrates my issue more clearly.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">path_system</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">vertex_subset_n</span> <span class="n">n</span> <span class="n">V</span><span class="o">}</span>
<span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">finset.range</span> <span class="n">n</span><span class="o">)}</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">start_pts</span> <span class="o">:=</span> <span class="n">A.verts</span><span class="o">)</span>
<span class="o">(</span><span class="n">finish_pts</span> <span class="o">:</span> <span class="n">B.verts</span><span class="o">)</span>
<span class="o">(</span><span class="n">start</span>  <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">A.verts</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">)</span> <span class="c1">-- λ i, A.verts.to_list.nth i</span>
<span class="o">(</span><span class="n">finish</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">B.verts</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">)</span> <span class="c1">-- λ i, B.verts_to_list.nth σ(i)</span>
<span class="o">(</span><span class="n">n_walks</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="o">(</span><span class="n">G.directed_walk</span> <span class="n">start_pt</span> <span class="n">finish_pt</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="o">(</span><span class="n">G.directed_walk</span> <span class="n">start_pt</span> <span class="n">finish_pt</span><span class="o">)</span> <span class="bp">|</span> <span class="n">start_pt</span> <span class="bp">=</span> <span class="n">start</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">finish_pt</span> <span class="bp">=</span> <span class="n">finish</span><span class="o">(</span><span class="n">i</span><span class="o">)})</span>
<span class="o">(</span><span class="n">sgn</span> <span class="o">:=</span> <span class="n">σ.sign</span><span class="o">)</span>
</code></pre></div>
<p>I somehow want to manage that the starting and ending point of a walk are precisely the corresponding ones in the following sense:<br>
n_walk (i) goes from i to \sigma(i).<br>
Therefore, I need to be able to numerate the elements of A and B. But a list as suggested in the comments cuases type issues. Is there a way out of this arising type issue ?</p>
<p>I also thought about leaving away the \sigma and just claim that any starting and ending point of A and B is only used once. However, I need the concrete bijection as I need the sign.</p>



<a name="321653671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321653671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321653671">(Jan 16 2023 at 14:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321646478">said</a>:</p>
<blockquote>
<p>Then when you have a pair of such a family of elements (for example <code>[fintype α]</code> with <code>f g : α -&gt; V</code>), you can work with <code>Π (i : α), G.directed_walk (f i) (g i)</code>, which is an <code>α</code>-indexed family of walks.</p>
</blockquote>
<p>Let me mention this again, since this is how you can have a system of walks that go between corresponding vertices.</p>



<a name="321653754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321653754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321653754">(Jan 16 2023 at 14:25)</a>:</h4>
<p>There are a few formulations of this, but this is the general idea.</p>



<a name="321654149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321654149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321654149">(Jan 16 2023 at 14:27)</a>:</h4>
<p>In Lean, you usually have to translate things from set theory to type theory. Oftentimes, if you see "a finite set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a_1,\dots,a_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>" it's better to translate it to "a function <code>f : fin n -&gt; A</code>" rather than speak of sets at all.</p>



<a name="321654413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321654413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321654413">(Jan 16 2023 at 14:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321653754">schrieb</a>:</p>
<blockquote>
<p>There are a few formulations of this, but this is the general idea.</p>
</blockquote>
<p>Ok thank you. I thought its just shifting the problem to defining the sign, but I will try.</p>



<a name="321654487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321654487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321654487">(Jan 16 2023 at 14:28)</a>:</h4>
<p>The sign of a permutation should already exist somewhere in mathlib.</p>



<a name="321654637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321654637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321654637">(Jan 16 2023 at 14:29)</a>:</h4>
<p>Unless you're talking about defining a new concept, like a sign of a path system or something.</p>



<a name="321654837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321654837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321654837">(Jan 16 2023 at 14:30)</a>:</h4>
<p>Oh, I see, you already found <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.sign">docs#equiv.perm.sign</a></p>



<a name="321656255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321656255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321656255">(Jan 16 2023 at 14:35)</a>:</h4>
<p>Yes. Well, I better try to use your suggested approach with f and g and hoepfully get the points and sign right. <br>
Thanks again.<br>
I apologize if I have not stated the problem properly and/or wasted your time.</p>



<a name="321657875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321657875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321657875">(Jan 16 2023 at 14:42)</a>:</h4>
<p>Getting right type definitions at the beginning is a difficult part of formalization.</p>
<p>If you haven't done it already, you should try to very carefully specify as formally as possible what it is you're trying to enter into Lean. This will likely help you with what you're doing, but also as you get stuck you can point to a part of this "blueprint" to get more precise help.</p>



<a name="321658213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321658213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321658213">(Jan 16 2023 at 14:44)</a>:</h4>
<p>Combinatorics is already more difficult to formalize than abstract math since it tends to be done more informally on paper since the objects are more intuitive. You have to do the paper formalization yourself here before it's as amenable to formalization.</p>



<a name="321658504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321658504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321658504">(Jan 16 2023 at 14:45)</a>:</h4>
<p>This takes some thinking (or more likely, experimentation) with how this will interact with how the definitions will be used in your theorems. That can be hard to think about though if you haven't gotten to thinking carefully about the theorems because you don't have formalized definitions, which points toward why definitions can be hard.</p>



<a name="321659803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321659803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321659803">(Jan 16 2023 at 14:51)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> <br>
I have noticed that and could not agree more. As it is my first Lean project, it takes a lot of nerve. <br>
I largely appreciate your consistent help.</p>



<a name="321662556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321662556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321662556">(Jan 16 2023 at 15:05)</a>:</h4>
<p><span class="user-mention" data-user-id="573061">@Christopher Schmidt</span> Here's a start:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">logic.equiv.fintype</span>
<span class="kn">import</span> <span class="n">group_theory.perm.sign</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">universes</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">directed_simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">):=</span> <span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">directed_simple_graph</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">directed_simple_graph</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">directed_walk</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">directed_walk</span> <span class="n">u</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">directed_walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">directed_walk</span> <span class="n">u</span> <span class="n">w</span>

<span class="kd">def</span> <span class="n">directed_walk.support</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">directed_simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="n">G.directed_walk</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">V</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">v</span> <span class="n">directed_walk.nil</span> <span class="o">:=</span> <span class="o">[</span><span class="n">v</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">u</span> <span class="n">_</span> <span class="o">(</span><span class="n">directed_walk.cons</span> <span class="n">h</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">u</span> <span class="o">::</span> <span class="n">p.support</span>

<span class="kd">structure</span> <span class="n">path_system</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">B'</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">range_B'</span> <span class="o">:</span> <span class="n">set.range</span> <span class="n">B'</span> <span class="bp">=</span> <span class="n">set.range</span> <span class="n">B</span><span class="o">)</span>
<span class="o">(</span><span class="n">walk</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">G.directed_walk</span> <span class="o">(</span><span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">B'</span> <span class="n">i</span><span class="o">))</span>
<span class="o">(</span><span class="n">walk_disj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">list.disjoint</span> <span class="o">(</span><span class="n">walk</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="o">(</span><span class="n">walk</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">path_system.σ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">G.path_system</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">equiv.of_injective</span> <span class="n">s.B'</span> <span class="n">s.B'.inj'</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span>
  <span class="o">((</span><span class="n">equiv.set.of_eq</span> <span class="n">s.range_B'</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">equiv.of_injective</span> <span class="n">B</span> <span class="n">B.inj'</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">path_system.sign</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">G.path_system</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">equiv.perm.sign</span> <span class="n">s.σ</span>
</code></pre></div>



<a name="321662992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321662992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321662992">(Jan 16 2023 at 15:07)</a>:</h4>
<p>Another design for <code>path_system</code> could have been to include sigma as a permutation on <code>α</code> or as a permutation on <code>set.range B</code>.</p>



<a name="321663122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321663122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321663122">(Jan 16 2023 at 15:07)</a>:</h4>
<p>But you don't need anything saying it's a <em>finite</em> system of paths in any case. That only comes in for <code>sign</code>.</p>



<a name="321663753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321663753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321663753">(Jan 16 2023 at 15:10)</a>:</h4>
<p>For another example of this idea of generalizing indices so that you take an arbitrary index type rather than just the set of 1,...,n, take a look at <a href="https://github.com/leanprover-community/mathlib/blob/9003f28797c0664a49e4179487267c494477d853/src/data/matrix/basic.lean#L54">matrix</a>. Matrices are indexed by arbitrary types, not numbers.</p>



<a name="321664474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321664474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321664474">(Jan 16 2023 at 15:13)</a>:</h4>
<p>(Also, quick disclaimer, I just read the wikipedia page for the theorem and wrote up these definitions. They might be wrong or unoptimal for any number of reasons, but hopefully it's in the right direction.)</p>



<a name="321665950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321665950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321665950">(Jan 16 2023 at 15:19)</a>:</h4>
<p>Just for illustration, an option using sigma. I can't tell immediately whether this is better or worse than the previous definition.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">path_system</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">walk</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">G.directed_walk</span> <span class="o">(</span><span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">(</span><span class="n">σ</span> <span class="n">i</span><span class="o">)))</span>
<span class="o">(</span><span class="n">walk_disj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">list.disjoint</span> <span class="o">(</span><span class="n">walk</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="o">(</span><span class="n">walk</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span>

<span class="c1">-- This definition is not actually necessary since one can write `s.σ.sign` just as easily as `s.sign`.</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">path_system.sign</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">G.path_system</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">s.σ.sign</span>
</code></pre></div>



<a name="321682611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321682611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321682611">(Jan 16 2023 at 16:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321644888">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321620883">said</a>:</p>
<blockquote>
<p>Also, having a universe <code>u</code> and a "graph vertex <code>u</code>" is probably not a good idea.</p>
</blockquote>
<p>Maybe not, but for better or for worse we've been doing this in mathlib code throughout the graph library and its seems to work out fine</p>
</blockquote>
<p>Living on the directed edge!  <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="321696556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321696556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321696556">(Jan 16 2023 at 18:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321658213">said</a>:</p>
<blockquote>
<p>Combinatorics is already more difficult to formalize than abstract math since it tends to be done more informally on paper since the objects are more intuitive. You have to do the paper formalization yourself here before it's as amenable to formalization.</p>
</blockquote>
<p>I would even phrase it as "Combinatorics is harder to formalise than other subjects until you understand why it is easy"</p>



<a name="321696738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321696738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321696738">(Jan 16 2023 at 18:20)</a>:</h4>
<p>I am having a lot of success formalising combinatorics now, but this took two years of trying.</p>



<a name="321696826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321696826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321696826">(Jan 16 2023 at 18:21)</a>:</h4>
<p>I would be very interested in writing a chapter of the new Mathematics in Lean book on how to formalise combinatorics.</p>



<a name="321707606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321707606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321707606">(Jan 16 2023 at 19:37)</a>:</h4>
<p>You could use <a href="https://leanprover-community.github.io/mathlib_docs/find/pairwise">docs#pairwise</a> for <code>walk_disj</code>.</p>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321646864">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> I see your <span aria-label="prohibited" class="emoji emoji-1f6ab" role="img" title="prohibited">:prohibited:</span>, but universe level variables and normal variables are in different namespaces, so it can't cause problems for Lean at least.</p>
</blockquote>
<p>If universe variables clash with declaration names you get trouble though. Last time I changed <code>v'</code> to <code>w</code> in <a href="https://github.com/leanprover-community/mathlib/blob/9003f28797c0664a49e4179487267c494477d853/src/topology/sheaves/sheaf_condition/equalizer_products.lean#L23">this file</a> I got weird errors when Lean got to line 76 (<code>lemma w</code>).</p>



<a name="321708999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321708999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321708999">(Jan 16 2023 at 19:49)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> I tried two things:</p>
<ol>
<li>I changed that lemma to <code>lemma w'</code>, and there was no error.</li>
<li>I renamed the universe variable from <code>v'</code> to <code>w</code>, and then both <code>res_π</code> and <code>w</code> had a universe variable error. Removing the <code>@[elementwise]</code> attribute, though, removes the error.</li>
</ol>
<p>It seems more likely to me that there is some subtle bug in that attribute.</p>



<a name="321709281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321709281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321709281">(Jan 16 2023 at 19:51)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/9003f28797c0664a49e4179487267c494477d853/src/tactic/elementwise.lean#L100">This line</a> might be why having a universe variable that's a <code>w</code> is a problem.</p>



<a name="321709618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321709618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321709618">(Jan 16 2023 at 19:54)</a>:</h4>
<p>Universes are in a different namespace, so <code>get_unused_name_reserved</code> doesn't seem like the right way to get a fresh universe variable name.</p>



<a name="321709658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321709658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321709658">(Jan 16 2023 at 19:54)</a>:</h4>
<p>Oh! So it's just a red herring that the lemma is named <code>w</code>.</p>



<a name="321709701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321709701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321709701">(Jan 16 2023 at 19:55)</a>:</h4>
<p>Thanks for the diagnosis!</p>



<a name="321711866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321711866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321711866">(Jan 16 2023 at 20:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321696738">said</a>:</p>
<blockquote>
<p>I am having a lot of success formalising combinatorics now, but this took two years of trying.</p>
</blockquote>
<p>I suspect that if I now redid my <a href="https://github.com/jsm28/bmo2-2020-lean/blob/master/src/p3.lean">formalization of British MO 2020 round 2 problem 3</a> it would be rather less than 3000 lines of Lean for a not-very-hard combinatorics problem (that was the third Lean formalization I ever did after NNG).</p>



<a name="321712892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321712892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321712892">(Jan 16 2023 at 20:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321665950">schrieb</a>:</p>
<blockquote>
<p>Just for illustration, an option using sigma. I can't tell immediately whether this is better or worse than the previous definition.</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">path_system</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">walk</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">G.directed_walk</span> <span class="o">(</span><span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">(</span><span class="n">σ</span> <span class="n">i</span><span class="o">)))</span>
<span class="o">(</span><span class="n">walk_disj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">list.disjoint</span> <span class="o">(</span><span class="n">walk</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="o">(</span><span class="n">walk</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span>

<span class="c1">-- This definition is not actually necessary since one can write `s.σ.sign` just as easily as `s.sign`.</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">path_system.sign</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">G.path_system</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">s.σ.sign</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Thanks for the effort! Thats more than one could as for. I will implement both versions and see which is more practical.</p>



<a name="321782132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321782132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321782132">(Jan 17 2023 at 09:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321696826">said</a>:</p>
<blockquote>
<p>I would be very interested in writing a chapter of the new Mathematics in Lean book on how to formalise combinatorics.</p>
</blockquote>
<p>This could be nice if it fits with the style of other parts. You can write something anyway, and then decide what to do with it.</p>



<a name="321782384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321782384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321782384">(Jan 17 2023 at 09:06)</a>:</h4>
<p>Where can I see the current progress on the book?</p>



<a name="321782513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321782513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321782513">(Jan 17 2023 at 09:07)</a>:</h4>
<p>I'm not sure I understand the question, but the source is at <a href="https://github.com/avigad/mathematics_in_lean_source/">https://github.com/avigad/mathematics_in_lean_source/</a></p>



<a name="321782825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321782825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321782825">(Jan 17 2023 at 09:09)</a>:</h4>
<p>I am simply trying to get a sense of what "the style of other parts" is</p>



<a name="321783552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321783552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321783552">(Jan 17 2023 at 09:13)</a>:</h4>
<p>I just Google for mathematics in lean to find it</p>



<a name="321785238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321785238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321785238">(Jan 17 2023 at 09:22)</a>:</h4>
<p>Ah! I understand the confusion now. I thought there was some Mathematics in Lean 4 whose writing was underway.</p>



<a name="321805706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321805706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321805706">(Jan 17 2023 at 11:15)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>  I have added the following to your first approach :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">directed_simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">partial_order.lift</span> <span class="n">adj</span> <span class="n">ext</span>

<span class="kd">def</span> <span class="n">edge_set</span> <span class="o">:</span> <span class="n">directed_simple_graph</span> <span class="n">V</span> <span class="bp">↪</span><span class="n">o</span> <span class="n">set</span> <span class="o">(</span><span class="n">V</span> <span class="bp">×</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">order_embedding.of_map_le_iff</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">directed_simple_graph</span> <span class="n">V</span><span class="o">),</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">V</span> <span class="bp">|</span> <span class="n">G.adj</span> <span class="n">p.1</span> <span class="n">p.2</span><span class="o">})</span> <span class="bp">$</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">G</span> <span class="n">G'</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">set.le_eq_subset</span><span class="o">,</span> <span class="n">set.set_of_subset_set_of</span><span class="o">,</span> <span class="n">prod.forall</span><span class="o">],</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kn">namespace</span> <span class="n">directed_walk</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">}</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">weight</span> <span class="o">:</span> <span class="n">G.edge_set</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">walk_weight</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">directed_simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">weight</span> <span class="o">:</span> <span class="n">G.edge_set</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span>
<span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="n">G.directed_walk</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="n">u</span> <span class="n">v</span> <span class="n">nil</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">u</span> <span class="n">v</span> <span class="o">(</span><span class="n">cons</span> <span class="n">h</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">weight</span> <span class="o">⟨(</span><span class="n">u</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">*</span> <span class="n">walk_weight</span> <span class="n">p</span>

<span class="kd">def</span> <span class="n">path_system_weight</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">directed_simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">weight</span> <span class="o">:</span> <span class="n">G.edge_set</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span>
<span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">G.path_system</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="bp">∏</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">walk_weight</span> <span class="o">(</span><span class="n">s.walk</span> <span class="n">i</span><span class="o">)</span> <span class="c1">-- not working</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">G.path_system</span> <span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
<span class="k">#check</span> <span class="n">walk_weight</span> <span class="o">(</span><span class="n">s.walk</span> <span class="n">i</span><span class="o">)</span> <span class="c1">-- works</span>

<span class="kd">end</span> <span class="n">directed_walk</span>
</code></pre></div>
<p>I do not understand, why it is not working in the first but working in the second case. What have I messed up again?</p>



<a name="321805814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321805814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321805814">(Jan 17 2023 at 11:16)</a>:</h4>
<p>The opening statement being at the begining of the file after imports.</p>



<a name="321806557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321806557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321806557">(Jan 17 2023 at 11:20)</a>:</h4>
<p>What's the error?</p>



<a name="321806659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321806659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321806659">(Jan 17 2023 at 11:21)</a>:</h4>
<p>(Without running any code, I'm guessing it's that you don't have <code>[fintype α]</code>, which you need to take a product like that.)</p>



<a name="321806773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321806773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321806773">(Jan 17 2023 at 11:22)</a>:</h4>
<p>Design suggestion: make <code>weight</code> an explicit variable since it can't be inferred from the other arguments.</p>



<a name="321807651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/321807651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#321807651">(Jan 17 2023 at 11:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321806773">schrieb</a>:</p>
<blockquote>
<p>Design suggestion: make <code>weight</code> an explicit variable since it can't be inferred from the other arguments.</p>
</blockquote>
<p>Had the fintype, but this solved the issue. I do not get how but now it seems to work. Thanks !</p>



<a name="322031423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/322031423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#322031423">(Jan 18 2023 at 11:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="573061">Christopher Schmidt</span> has marked this topic as resolved.</p>



<a name="322058017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/322058017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#322058017">(Jan 18 2023 at 13:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="573061">Christopher Schmidt</span> has marked this topic as unresolved.</p>



<a name="322060059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/322060059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#322060059">(Jan 18 2023 at 14:04)</a>:</h4>
<p>Hello everyone I am running into a type issue again,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">directed_walk</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">new_weight</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">directed_simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">weight</span> <span class="o">:</span> <span class="n">G.edge_set</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
<span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">R</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">path_matrix</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">weight</span> <span class="o">:</span> <span class="n">G.edge_set</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
<span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">new_weight</span> <span class="n">weight</span> <span class="o">(</span><span class="n">G.directed_path</span> <span class="o">(</span><span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="n">j</span><span class="o">))</span> <span class="c1">-- error : failed to synthesize class instance for ... ⊢ field R</span>


<span class="kd">variables</span> <span class="o">{</span><span class="n">weight</span> <span class="o">:</span> <span class="n">G.edge_set</span> <span class="bp">→</span> <span class="n">R</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
<span class="k">#check</span> <span class="n">G.directed_path</span> <span class="o">(</span><span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="n">j</span><span class="o">)</span> <span class="c1">-- Type u</span>
<span class="k">#check</span> <span class="n">new_weight</span> <span class="n">weight</span> <span class="o">(</span><span class="n">G.directed_path</span> <span class="o">(</span><span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="n">j</span><span class="o">))</span> <span class="c1">-- type R</span>
<span class="kd">end</span> <span class="n">directed_walk</span>
</code></pre></div>
<p>the <code>new_weight weight (G.directed_path (A i) (B j))</code> is type R as shown below but the def of "path matrix" does not work. I do not understand how this is possible. Anyone got an idea?</p>



<a name="322077964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/322077964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#322077964">(Jan 18 2023 at 15:18)</a>:</h4>
<p>You have <code>variable {R : Type} [field R]</code> so that R is a field, but you have <code>def path_matrix... {R : Type}...</code> and this means "use a new R which isn't a field".</p>



<a name="322087859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/numerating%20elements%20of%20a%20set%20causing%20type%20issues/near/322087859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Schmidt <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues.html#322087859">(Jan 18 2023 at 15:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/322077964">schrieb</a>:</p>
<blockquote>
<p>You have <code>variable {R : Type} [field R]</code> so that R is a field, but you have <code>def path_matrix... {R : Type}...</code> and this means "use a new R which isn't a field".</p>
</blockquote>
<p>Thank you.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html">Formalizing basic linear algebra</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="313877679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/313877679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#313877679">(Dec 05 2022 at 02:27)</a>:</h4>
<p>Thanks all for your answers.</p>
<p>How do you perform induction on a term which is not part of the context? I am trying to prove this lemma, which says "finite sums of vectors can be done coordinate-by-coodinate" . I'm trying to employ induction on the size of  the fintype α. This is my best try so far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span> <span class="n">data.real.sqrt</span> <span class="n">data.nat.basic</span> <span class="n">data.fin.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">def</span> <span class="n">R</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">ℝ</span>

<span class="c1">-- I've show (add_comm_monoid (R n))</span>

<span class="kd">lemma</span> <span class="n">vec_sum_by_coordinate</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">R</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∑</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sizeof</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I used <code>let n := sizeof α</code> when <code>induction (sizeof  α)</code> failed to work on its own. But now I don't know how to work with the resulting target term:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="k">let</span> <span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">sizeof</span> <span class="n">α</span> <span class="k">in</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span> <span class="n">i</span><span class="o">)</span> <span class="mi">0</span>
</code></pre></div>
<p>What's the standard way forward here? Btw, I am trying to prove this first without <code>finset.sum_induction</code>,  just as an exercise.</p>



<a name="313903541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/313903541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#313903541">(Dec 05 2022 at 07:35)</a>:</h4>
<p>You should use <code>finset.sum_induction</code> and then specialise to <code>finset.univ</code> to get your result.</p>



<a name="313911885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/313911885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#313911885">(Dec 05 2022 at 08:35)</a>:</h4>
<p>I'm pretty sure you want <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.card">docs#fintype.card</a> not <a href="https://leanprover-community.github.io/mathlib_docs/find/sizeof">docs#sizeof</a></p>



<a name="313912275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/313912275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#313912275">(Dec 05 2022 at 08:37)</a>:</h4>
<p><code>induction h : fintype.card α</code> might be what you're asking for</p>



<a name="313923829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/313923829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#313923829">(Dec 05 2022 at 09:47)</a>:</h4>
<p>I'm not sure that encouraging the use of induction on the type is a good idea here. It's much easier to prove the more general statement about a finset because then you don't need to move the underlying type.</p>



<a name="313930603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/313930603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#313930603">(Dec 05 2022 at 10:25)</a>:</h4>
<p>Just to give a mathlib example of how to do induction on the cardinality of a type (which is like what Eric brought up), there's this part of the proof of Hall's marriage theorem: <a href="https://github.com/leanprover-community/mathlib/blob/f1a2caaf51ef593799107fe9a8d5e411599f3996/src/combinatorics/hall/finite.lean#L229">https://github.com/leanprover-community/mathlib/blob/f1a2caaf51ef593799107fe9a8d5e411599f3996/src/combinatorics/hall/finite.lean#L229</a></p>
<p>There's a Lean technicality where you have to use <code>unfreezingI</code> since the <code>fintype</code> instance is "frozen".</p>



<a name="313937607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/313937607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#313937607">(Dec 05 2022 at 11:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra/near/313923829">said</a>:</p>
<blockquote>
<p>I'm not sure that encouraging the use of induction on the type is a good idea here.</p>
</blockquote>
<p>Indeed; but it does directly answer the "How do you perform induction on a term which is not part of the context?". It just happens that in this particular case that's not actually a helpful thing to do!</p>



<a name="314382089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/314382089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#314382089">(Dec 07 2022 at 05:53)</a>:</h4>
<p>Hello all,</p>
<p>Thank you again for your helpful answers.</p>
<p>I am still stuck on proving the below lemma. <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> thank you for your suggestion to use <code>finset.sum_induction</code>. Upon further study of that theorem, I am struggling to apply it to my case (though I do not doubt it may apply). Specifically, I am struggling to formulate a predicate <code>p: R n -&gt; Prop</code> to use in my case. I believe I want to show a property of summing in <code>R n</code>.</p>
<p>Having temporarily hit a wall with the recommended approach, I have decided to continue playing with the ill-advised induction on <code>fintype.card α</code>, in hopes to learn why it breaks down. It did break down, but in an unexpected way. Here is my current state (using the induction pointed out by <span class="user-mention" data-user-id="310045">@Eric Wieser</span>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span> <span class="n">data.fin.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">R</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">ℝ</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">}</span>

<span class="c1">-- In my file, I have shown</span>
<span class="kd">instance</span> <span class="n">vec_add_comm_monoid</span><span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">R</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>  <span class="gr">sorry</span>

<span class="c1">-- the lemma in question</span>
<span class="kd">lemma</span> <span class="n">vec_sum_pointwise</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">R</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∑</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">:</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="k">with</span> <span class="n">n'</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="c1">-- constructing this instance as I don't know how to help Lean find/infer it</span>
    <span class="k">have</span> <span class="n">α_is_empty</span> <span class="o">:</span> <span class="n">is_empty</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">fintype.card_eq_zero_iff.mp</span> <span class="n">h</span><span class="o">,</span>
    <span class="c1">-- error on this line</span>
    <span class="n">rw</span> <span class="bp">@</span><span class="n">fintype.sum_empty</span> <span class="n">α</span> <span class="o">(</span><span class="n">R</span> <span class="n">n</span><span class="o">)</span> <span class="n">vec_add_comm_monoid</span> <span class="n">α_is_empty</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>Giving the following state/error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kd">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span> <span class="n">n</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">α_is_empty</span> <span class="o">:</span> <span class="n">is_empty</span> <span class="n">α</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span> <span class="n">i</span>
</code></pre></div>
<p>I am quite stumped, as I expect Lean to find the pattern in the target as <code>∑ (a : α), f a</code>. I believe this pattern is <code>finset.univ.sum f</code>. Does it perhaps have to do with Type universes?</p>
<p>Any help on either of these fronts would be greatly appreciated.</p>



<a name="314422552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/314422552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#314422552">(Dec 07 2022 at 10:26)</a>:</h4>
<p>I <em>think</em> what's being suggested here is to begin with something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">vec_sum_pointwise</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∑</span> <span class="n">a</span> <span class="k">in</span> <span class="n">A</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">a</span> <span class="k">in</span> <span class="n">A</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">A</span> <span class="n">using</span> <span class="n">finset.cons_induction</span> <span class="k">with</span> <span class="n">b</span> <span class="n">A</span> <span class="n">hb</span> <span class="n">ih</span><span class="o">,</span>
<span class="bp">...</span>
</code></pre></div>
<p>and only then proceed to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">vec_sum_pointwise'</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∑</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">i</span> <span class="o">:=</span>
<span class="n">vec_sum_pointwise</span> <span class="n">finset.univ</span> <span class="n">f</span>
</code></pre></div>



<a name="314443573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/314443573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#314443573">(Dec 07 2022 at 12:28)</a>:</h4>
<p>FWIW, this more general lemma exists already as <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_apply">docs#finset.sum_apply</a></p>



<a name="318027898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318027898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318027898">(Dec 27 2022 at 02:42)</a>:</h4>
<p>Thanks to those who have helped me thus far.</p>
<p>This time I'm not stuck, I just want to know the most idiomatic way of doing something. I have the following lemmas</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">dot_prod_right_distrib</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⟪</span><span class="o">(</span><span class="n">α</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">β</span> <span class="bp">•</span> <span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">=</span> <span class="n">α</span> <span class="bp">*</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">+</span> <span class="n">β</span> <span class="bp">*</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">vec_smul_one</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>Later on, I want to show that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⟪</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">y</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="bp">⟫</span><span class="n">_ℝ</span>
</code></pre></div>
<p>However, I find that I cannot <code>rw</code> or <code>apply</code> dot_prod_right_distrib directly. The problem is that the lemma does not know that <code>α</code> and <code>β</code> can be taken to be 1.  Thus, my proof of the latter statements starts like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⟪</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">y</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="bp">⟫</span><span class="n">_ℝ</span>  <span class="o">:=</span>
<span class="kd">begin</span>
      <span class="c1">-- insert "1 •" on every vector</span>
      <span class="n">rw</span> <span class="bp">←</span> <span class="n">vec_smul_one</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span> <span class="n">vec_smul_one</span> <span class="n">y</span><span class="o">,</span>
      <span class="c1">-- apply the lemma with α = β = 1</span>
      <span class="n">rw</span> <span class="n">dot_prod_distrib</span> <span class="mi">1</span> <span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="o">((</span><span class="mi">1</span><span class="o">:</span><span class="n">ℝ</span><span class="o">)</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">ℝ</span><span class="o">)</span> <span class="bp">•</span> <span class="n">y</span><span class="o">),</span>
      <span class="c1">-- remove the "1 •"</span>
      <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">vec_smul_one</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>My question is, is there a better way to do this? I suspect many theorems/lemmas will appear in these generalized forms. Can I tell LEAN how to guess <code>α = β = 1</code> automatically? Alternatively, I could just write multiple versions of the same lemma, e.g.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">dot_prod_right_distrib</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⟪</span><span class="o">(</span><span class="n">α</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">β</span> <span class="bp">•</span> <span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">=</span> <span class="n">α</span> <span class="bp">*</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">+</span> <span class="n">β</span> <span class="bp">*</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">dot_prod_right_distrib'</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⟪</span><span class="o">(</span><span class="n">α</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">=</span> <span class="n">α</span> <span class="bp">*</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">dot_prod_right_distrib''</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⟪</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">β</span> <span class="bp">•</span> <span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">+</span> <span class="n">β</span> <span class="bp">*</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">dot_prod_right_distrib'''</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⟪</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>but this seems rather tedious.</p>
<p>Thanks for the help!</p>



<a name="318039481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318039481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318039481">(Dec 27 2022 at 05:58)</a>:</h4>
<p><code>1 bub x</code> is neither syntactically nor definitely equal to <code>x</code>. The problem is not that lean isn't guessing alpha = 1, it's that even if you set alpha = 1 the lemma doesn't match. It might be what you see in the textbooks but the lemma isn't a good one for rewriting because it's doing too many jobs at once, and <code>rw</code> works up to syntactic equality. Why not prove additivity and linearity as two separate lemmas? <code>(x+y,z) and </code>(c \bub x,z), and also have lemmas for (x,y+z) etc.</p>



<a name="318039671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318039671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318039671">(Dec 27 2022 at 06:01)</a>:</h4>
<p>You don't want the more complex lemmas, you should tell the simplifier about the basic lemmas and then it will prove the more complex ones by itself.</p>



<a name="318040060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318040060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318040060">(Dec 27 2022 at 06:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Thanks for the insight. I see what you mean about this lemma being overloaded. I'll prove the two lemmas separately and show the textbook's lemma as an example.</p>



<a name="318060279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318060279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318060279">(Dec 27 2022 at 09:38)</a>:</h4>
<p>The proof of the textbook lemma should be <code>simp</code></p>



<a name="318121303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318121303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318121303">(Dec 27 2022 at 16:04)</a>:</h4>
<p>Isn't your <code>vec_smul_one</code> just <a href="https://leanprover-community.github.io/mathlib_docs/find/one_smul">docs#one_smul</a>?</p>



<a name="318517174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318517174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318517174">(Dec 30 2022 at 02:14)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span>. Thanks for the pointer. I had not seen this theorem. I have since removed my <code>vec_smul_one</code> lemma as I don't need it.</p>
<p>What I'm trying to do is formalize a basic linalg book, replicating any definitions/theorems from the book, while using mathlib as much as possible to help with any definitions/theorems that the book assumes or uses without proof.</p>



<a name="318517595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318517595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mitchell  Douglass <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318517595">(Dec 30 2022 at 02:19)</a>:</h4>
<p>I had a followup question about the simplifier.</p>
<p>I am working on a theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">vec_norm_sum</span> <span class="o">:</span>  <span class="bp">∥</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">∥</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">x</span><span class="bp">∥</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">+</span> <span class="bp">∥</span><span class="n">y</span><span class="bp">∥</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="bp">⟫</span><span class="n">_ℝ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">dot_prod_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">dot_prod_comm</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">ring</span><span class="o">,</span>
</code></pre></div>
<p>After the first <code>simp</code>,  the tactic state becomes:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">1</span> <span class="n">goal</span>
<span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">xy</span><span class="o">:</span> <span class="n">R</span> <span class="n">n</span>
<span class="bp">⊢</span> <span class="n">inner</span> <span class="n">x</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="n">inner</span> <span class="n">y</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">inner</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">inner</span> <span class="n">y</span> <span class="n">y</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">inner</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div>
<p>However, I have a theorem <code>dot_prod_comm</code> marked with <code>@[simp]</code> with the following type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- #check dot_prod_comm</span>
<span class="n">dot_prod_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">?</span><span class="n">M_1</span><span class="o">),</span> <span class="n">inner</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">inner</span> <span class="n">y</span> <span class="n">x</span>
</code></pre></div>
<p>My question is, why doesn't the simplifier use this lemma to further simplify the state? As shown above, I can manually apply <code>dot_prod_comm</code> twice with another <code>simp</code> and <code>ring</code> to complete the proof.</p>



<a name="318532329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318532329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318532329">(Dec 30 2022 at 06:53)</a>:</h4>
<p><code>simp</code> detects commutativity (such as your <code>dot_prod_comm</code> and only uses them if the rewrite results in smaller variable indices when taken lexicographically, or something along those lines. The details don't matter, but the point is that you don't want to rewrite <code>a + b</code> into <code>b + a</code> into <code>a + b</code> into... so <code>simp</code> has some secret preferred ordering of the variables, and in your case it just happens that the variables are in its preferred order.</p>



<a name="318532433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318532433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318532433">(Dec 30 2022 at 06:55)</a>:</h4>
<p>Here I would suggest adding <code>dot_prod_comm x</code> (or <code>dot_prod_comm x, dot_prod_comm y</code>) to your <code>simp</code> call because it suddenly isn't a commutativity lemma either (it won't rewrite back).</p>



<a name="318539509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318539509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318539509">(Dec 30 2022 at 08:20)</a>:</h4>
<p>In this case I think a better approach would be: you seem to have a simp lemma that says that <code>inner</code> is linear in the first argument, but not one for the second argument; you should add it.</p>



<a name="318539679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318539679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318539679">(Dec 30 2022 at 08:22)</a>:</h4>
<p>That's more sensible than relying on <code>dot_prod_comm</code> in this proof (which isn't "simplification" at all, it just happens to <em>allow</em> further simplification).</p>



<a name="318541169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalizing%20basic%20linear%20algebra/near/318541169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra.html#318541169">(Dec 30 2022 at 08:37)</a>:</h4>
<p>Are you aware of the lemmas <a href="https://leanprover-community.github.io/mathlib_docs/find/inner_add_right">docs#inner_add_right</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/inner_add_left">docs#inner_add_left</a>?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>